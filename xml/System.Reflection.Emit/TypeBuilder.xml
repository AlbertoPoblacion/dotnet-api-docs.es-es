<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea8c2e4359e8a9dc956ea6766b3b8d38ed283a88" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39985103" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <TypeSignature Language="F#" Value="type TypeBuilder = class&#xA;    inherit TypeInfo&#xA;    interface _TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f640b-101">Define y crea nuevas instancias de clases en tiempo de ejecución.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f640b-101">Defines and creates new instances of classes during run time.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-102"><xref:System.Reflection.Emit.TypeBuilder> se utiliza la clase raíz para controlar la creación de clases dinámicas en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="f640b-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="f640b-103">Proporciona un conjunto de rutinas que se usan para definir clases, agregue los campos y métodos y crear la clase dentro de un módulo.</span><span class="sxs-lookup"><span data-stu-id="f640b-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="f640b-104">Un nuevo <xref:System.Reflection.Emit.TypeBuilder> pueden crearse desde un módulo dinámico mediante una llamada a la <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> método, que devuelve un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="f640b-105">Emisión de la reflexión proporciona las siguientes opciones para definir los tipos:</span><span class="sxs-lookup"><span data-stu-id="f640b-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="f640b-106">Definir una clase o interfaz con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="f640b-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="f640b-107">Definir una clase o interfaz con el nombre especificado y atributos.</span><span class="sxs-lookup"><span data-stu-id="f640b-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="f640b-108">Definir una clase con el nombre especificado, atributos y clases base.</span><span class="sxs-lookup"><span data-stu-id="f640b-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="f640b-109">Definir una clase con el nombre especificado, atributos, clase base y el conjunto de interfaces que implementa la clase.</span><span class="sxs-lookup"><span data-stu-id="f640b-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="f640b-110">Definir una clase con el nombre especificado, los atributos, la clase base y tamaño de empaquetado.</span><span class="sxs-lookup"><span data-stu-id="f640b-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="f640b-111">Definir una clase con el nombre especificado, atributos, clase base y el tamaño de la clase como un todo.</span><span class="sxs-lookup"><span data-stu-id="f640b-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="f640b-112">Definir una clase con el nombre especificado, atributos, clase base, tamaño de empaquetado y el tamaño de la clase como un todo.</span><span class="sxs-lookup"><span data-stu-id="f640b-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="f640b-113">Para crear un tipo de matriz, tipo de puntero o tipo byref para un tipo incompleto representado por un <xref:System.Reflection.Emit.TypeBuilder> de objeto, utilice el <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método, o <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="f640b-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="f640b-114">Antes de utilizar un tipo, el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> debe llamarse al método.</span><span class="sxs-lookup"><span data-stu-id="f640b-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="f640b-115">**CreateType** llevar a cabo la creación del tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="f640b-116">Después de llamar a **CreateType**, el llamador puede crear instancias del tipo mediante el uso de la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e invocar miembros del tipo mediante el <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-117">Es un error al invocar los métodos que cambian la implementación de un tipo después **CreateType** se ha llamado.</span><span class="sxs-lookup"><span data-stu-id="f640b-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="f640b-118">Por ejemplo, common language runtime produce una excepción si el llamador intenta agregar a nuevos miembros a un tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="f640b-119">Un inicializador de clase se crea mediante el <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-120">**DefineTypeInitializer** devuelve un <xref:System.Reflection.Emit.ConstructorBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="f640b-121">Los tipos anidados se definen mediante una llamada a uno de los <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="f640b-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="f640b-122">Atributos</span><span class="sxs-lookup"><span data-stu-id="f640b-122">Attributes</span></span>  
 <span data-ttu-id="f640b-123">El <xref:System.Reflection.Emit.TypeBuilder> clase utiliza la <xref:System.Reflection.TypeAttributes> enumeración para especificar aún más las características del tipo que se crearán:</span><span class="sxs-lookup"><span data-stu-id="f640b-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="f640b-124">Las interfaces se especifican utilizando el <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> y <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> atributos.</span><span class="sxs-lookup"><span data-stu-id="f640b-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="f640b-125">Las clases concretas (clases que no se puede extender) se especifican utilizando el <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> atributo.</span><span class="sxs-lookup"><span data-stu-id="f640b-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="f640b-126">Varios atributos determinan la visibilidad de tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="f640b-127">Vea la descripción de la <xref:System.Reflection.TypeAttributes> enumeración.</span><span class="sxs-lookup"><span data-stu-id="f640b-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="f640b-128">Si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> se especifica, el cargador de clases dispone los campos en el orden en que se leen desde los metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="f640b-129">El cargador de clases tiene en cuenta el tamaño de empaquetado especificado, pero omite los desplazamientos de campo especificado.</span><span class="sxs-lookup"><span data-stu-id="f640b-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="f640b-130">Los metadatos conservan el orden en que se emiten las definiciones de campo.</span><span class="sxs-lookup"><span data-stu-id="f640b-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="f640b-131">Incluso a través de una combinación, los metadatos no reordenará las definiciones de campo.</span><span class="sxs-lookup"><span data-stu-id="f640b-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="f640b-132">El cargador admitirá los desplazamientos de campo especificado sólo si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> se especifica.</span><span class="sxs-lookup"><span data-stu-id="f640b-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="f640b-133">Problemas conocidos</span><span class="sxs-lookup"><span data-stu-id="f640b-133">Known Issues</span></span>  
  
-   <span data-ttu-id="f640b-134">Emisión de reflexión no comprueba si una clase no abstracta que implementa una interfaz ha implementado todos los métodos declarados en la interfaz.</span><span class="sxs-lookup"><span data-stu-id="f640b-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="f640b-135">Sin embargo, si la clase no implementa todos los métodos declarados en una interfaz, el tiempo de ejecución no carga la clase.</span><span class="sxs-lookup"><span data-stu-id="f640b-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="f640b-136">Aunque <xref:System.Reflection.Emit.TypeBuilder> se deriva de <xref:System.Type>, algunos de los métodos abstractos definidos en el <xref:System.Type> clase no están completamente implementados en el <xref:System.Reflection.Emit.TypeBuilder> clase.</span><span class="sxs-lookup"><span data-stu-id="f640b-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="f640b-137">Llamadas a estas <xref:System.Reflection.Emit.TypeBuilder> métodos inician una <xref:System.NotSupportedException> excepción.</span><span class="sxs-lookup"><span data-stu-id="f640b-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="f640b-138">La funcionalidad deseada puede obtenerse mediante la recuperación del tipo creado mediante el <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y reflejar en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-139">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="f640b-139">This section contains two code examples.</span></span> <span data-ttu-id="f640b-140">El primer ejemplo muestra cómo crear un tipo dinámico con un campo, constructor, propiedad y método.</span><span class="sxs-lookup"><span data-stu-id="f640b-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="f640b-141">El segundo ejemplo crea un método dinámicamente por el usuario.</span><span class="sxs-lookup"><span data-stu-id="f640b-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="f640b-142">**Ejemplo uno**</span><span class="sxs-lookup"><span data-stu-id="f640b-142">**Example one**</span></span>  
  
 <span data-ttu-id="f640b-143">El ejemplo de código siguiente muestra cómo definir un ensamblado dinámico con un módulo.</span><span class="sxs-lookup"><span data-stu-id="f640b-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="f640b-144">El módulo en el ensamblado de ejemplo contiene un solo tipo, `MyDynamicType`, que tiene un campo privado, una propiedad que obtiene y establece el campo privado, los constructores que inicializan el campo privado y un método que multiplica un número proporcionado por el usuario mediante el campo privado valor y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="f640b-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="f640b-145">El <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> campo se especifica cuando se crea el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="f640b-146">El código de ensamblado se usa inmediatamente, y el ensamblado también se guarda en el disco para que éste puede examinarse con [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) o se usa en otro programa.</span><span class="sxs-lookup"><span data-stu-id="f640b-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="f640b-147">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="f640b-147">**Example two**</span></span>  
  
 <span data-ttu-id="f640b-148">Ejemplo de código siguiente muestra cómo crear un tipo dinámico mediante el uso de `TypeBuilder`.</span><span class="sxs-lookup"><span data-stu-id="f640b-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="typeBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">
          <span data-ttu-id="f640b-149">Acción de seguridad que se va a realizar, como Demand, Assert, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-149">The security action to be taken such as Demand, Assert, and so on.</span>
          </span>
        </param>
        <param name="pset">
          <span data-ttu-id="f640b-150">El conjunto de permisos al que se aplica la acción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-150">The set of permissions the action applies to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-151">Agrega seguridad declarativa a este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-151">Adds declarative security to this type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-152">`AddDeclarativeSecurity` puede llamarse varias veces con cada llamada especifica una acción de seguridad (como Demand, Assert o denegar) y un conjunto de permisos que se aplican a la acción.</span><span class="sxs-lookup"><span data-stu-id="f640b-152">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-153">En las versiones 1.0, 1.1 y 2.0 de .NET Framework, los atributos de seguridad declarativa aplicados a un tipo con este método se almacenan en el formato de metadatos XML antiguo.</span><span class="sxs-lookup"><span data-stu-id="f640b-153">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-154">En el ejemplo siguiente se muestra el uso de la `AddDeclarativeSecurity` método para agregar una demanda de seguridad para <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca a un tipo dinámico denominado `MyDynamicClass`, en un ensamblado denominado EmittedExample.dll.</span><span class="sxs-lookup"><span data-stu-id="f640b-154">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="f640b-155">En el ejemplo no se genera ningún resultado de la consola; Después de ejecutarlo, puede usar [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar EmittedExample.dll.</span><span class="sxs-lookup"><span data-stu-id="f640b-155">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="f640b-156">En `MyDynamicClass`, abra el `.class public auto ansi` instrucción para ver los permisos declarativos.</span><span class="sxs-lookup"><span data-stu-id="f640b-156">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f640b-157">El <paramref name="action" /> no es válido (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> y <see langword="RequestRefuse" /> no son válidos).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-157">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-158">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-158">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-159">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-159">-or-</span>
          </span>
          <span data-ttu-id="f640b-160">El conjunto de permisos <paramref name="pset" /> contiene una acción que <see langword="AddDeclarativeSecurity" /> agregó anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-160">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-161">
            <paramref name="pset" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-161">
              <paramref name="pset" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : Type -&gt; unit" Usage="typeBuilder.AddInterfaceImplementation interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="f640b-162">La interfaz que implementa este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-162">The interface that this type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-163">Agrega una interfaz que implementa este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-163">Adds an interface that this type implements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f640b-164">Ejemplo de código siguiente muestra la implementación de una interfaz en un tipo creado dinámicamente mediante `AddInterfaceImplementation`.</span><span class="sxs-lookup"><span data-stu-id="f640b-164">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-165">
            <paramref name="interfaceType" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-165">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-166">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-166">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-167">Recupera el ensamblado dinámico que contiene esta definición de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-167">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-168">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-168">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-169">Recupera el ensamblado dinámico que contiene esta definición de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-169">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-170">Devuelve el nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-170">Returns the full name of this type qualified by the display name of the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-171">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-171">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-172">Nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-172">The full name of this type qualified by the display name of the assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-173">El formato de la cadena devuelta es la concatenación del nombre completo del tipo (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) y el nombre para mostrar del ensamblado (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separados por una coma y un espacio.</span><span class="sxs-lookup"><span data-stu-id="f640b-173">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="f640b-174">Consulte <xref:System.Reflection.AssemblyName> para obtener una descripción del formato del nombre para mostrar de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-174">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f640b-175">Información de versión</span><span class="sxs-lookup"><span data-stu-id="f640b-175">Version Information</span></span>  
 <span data-ttu-id="f640b-176">En las versiones 1.0 y 1.1 de .NET Framework, el valor de esta propiedad no incluye la referencia cultural o la clave pública.</span><span class="sxs-lookup"><span data-stu-id="f640b-176">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-177">Recupera el tipo base de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-177">Retrieves the base type of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-178">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-178">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-179">Recupera el tipo base de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-179">Retrieves the base type of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberSignature Language="F#" Value="member this.CreateType : unit -&gt; Type" Usage="typeBuilder.CreateType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-180">Crea un objeto <see cref="T:System.Type" /> para esta clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-180">Creates a <see cref="T:System.Type" /> object for the class.</span>
          </span>
          <span data-ttu-id="f640b-181">Después de definir los campos y métodos en la clase, se llama a <see langword="CreateType" /> para cargar su objeto <see langword="Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-181">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-182">Devuelve el nuevo objeto <see cref="T:System.Type" /> para esta clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-182">Returns the new <see cref="T:System.Type" /> object for this class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-183">Si este tipo es un tipo anidado, el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método debe llamarse en el tipo envolvente antes de que se llama en el tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-183">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="f640b-184">Si el tipo actual se deriva de un tipo incompleto o implementa interfaces incompletas, llame a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método en el tipo de elemento primario y los tipos de interfaz antes de llamarlo en el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="f640b-184">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="f640b-185">Si el tipo envolvente contiene un campo que es un tipo de valor definido como un tipo anidado (por ejemplo, un campo que es una enumeración que se define como un tipo anidado), una llamada a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método en el tipo envolvente generará un <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="f640b-185">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f640b-186">Esto es porque el cargador no puede determinar el tamaño del tipo envolvente hasta que se ha completado el tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-186">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="f640b-187">El llamador debe definir un controlador para el <xref:System.AppDomain.TypeResolve> eventos para completar la definición del tipo anidado mediante una llamada a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> en el <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-187">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="f640b-188">El ejemplo de código de este tema muestra cómo definir un controlador de eventos de este tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-188">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="f640b-189">Se crea un tipo de una sola vez, independientemente de cómo muchas veces los <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="f640b-189">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="f640b-190">Todas las llamadas devuelven el mismo <xref:System.Type> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-190">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-191">El ejemplo de código siguiente muestra cómo definir un controlador de eventos para el <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos, para poder llamar a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método en un tipo anidado durante un <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> llamar en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-191">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-192">No se ha creado el tipo envolvente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-192">The enclosing type has not been created.</span>
          </span>
          <span data-ttu-id="f640b-193">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-193">-or-</span>
          </span>
          <span data-ttu-id="f640b-194">Este tipo no es abstracto y contiene un método abstracto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-194">This type is non-abstract and contains an abstract method.</span>
          </span>
          <span data-ttu-id="f640b-195">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-195">-or-</span>
          </span>
          <span data-ttu-id="f640b-196">Este tipo no es una clase o interfaz abstracta y tiene un método sin cuerpo de método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-196">This type is not an abstract class or an interface and has a method without a method body.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-197">El tipo contiene código de Lenguaje Intermedio de Microsoft (MSIL) no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-197">The type contains invalid Microsoft intermediate language (MSIL) code.</span>
          </span>
          <span data-ttu-id="f640b-198">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-198">-or-</span>
          </span>
          <span data-ttu-id="f640b-199">El destino de bifurcación se especifica con un desplazamiento de 1 byte, pero el destino está a una distancia superior a 127 bytes de la bifurcación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-199">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f640b-200">No se puede cargar el tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-200">The type cannot be loaded.</span>
          </span>
          <span data-ttu-id="f640b-201">Por ejemplo, contiene un método <see langword="static" /> con la convención de llamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-201">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberSignature Language="F#" Value="member this.CreateTypeInfo : unit -&gt; System.Reflection.TypeInfo" Usage="typeBuilder.CreateTypeInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-202">Obtiene un objeto <see cref="T:System.Reflection.TypeInfo" /> que representa este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-202">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-203">Un objeto que representa este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-203">An object that represents this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-204">Obtiene el método que declaró el parámetro de tipo genérico actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-204">Gets the method that declared the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-205">Un <see cref="T:System.Reflection.MethodBase" /> que representa el método que declaró el tipo actual, si el tipo actual es un parámetro de tipo genérico; de lo contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-205">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="f640b-206">Cuando se emite el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de por un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-206">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-207">Devuelve el tipo que declaró este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-207">Returns the type that declared this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-208">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-208">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-209">Tipo que declaró este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-209">The type that declared this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-210">Agrega un constructor al tipo dinámico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-210">Adds a new constructor to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="f640b-211">Atributos del constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-211">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-212">Convención de llamada del constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-212">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-213">Tipos de parámetro del constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-213">The parameter types of the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-214">Agrega un nuevo constructor al tipo, con los atributos y firma especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-214">Adds a new constructor to the type, with the given attributes and signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-215">Constructor definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-215">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-216">Si no define un constructor para su tipo dinámico, se proporciona automáticamente un constructor predeterminado y llama al constructor predeterminado de la clase base.</span><span class="sxs-lookup"><span data-stu-id="f640b-216">If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</span></span>  
  
 <span data-ttu-id="f640b-217">Si define un constructor para su tipo dinámico, no se proporciona un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="f640b-217">If you define a constructor for your dynamic type, a default constructor is not provided.</span></span> <span data-ttu-id="f640b-218">Tiene las siguientes opciones para proporcionar un constructor predeterminado además del constructor definido:</span><span class="sxs-lookup"><span data-stu-id="f640b-218">You have the following options for providing a default constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="f640b-219">Si desea que un constructor predeterminado que llame simplemente al constructor predeterminado de la clase base, puede usar el <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> método para crear uno (y, opcionalmente, restringir el acceso a él).</span><span class="sxs-lookup"><span data-stu-id="f640b-219">If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="f640b-220">Proporciona una implementación para este constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="f640b-220">Do not provide an implementation for this default constructor.</span></span> <span data-ttu-id="f640b-221">Si lo hace, se produce una excepción al intentar usar el constructor.</span><span class="sxs-lookup"><span data-stu-id="f640b-221">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="f640b-222">Se produce ninguna excepción cuando la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="f640b-222">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="f640b-223">Si desea que un constructor predeterminado que haga algo más que simplemente llamar el constructor predeterminado de la clase base, o que llama a otro constructor de la clase base o que haga algo completamente distinto, debe usar el <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> método para crear uno, y proporcionar su propia implementación.</span><span class="sxs-lookup"><span data-stu-id="f640b-223">If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-224">Ejemplo de código siguiente muestra el uso de `DefineConstructor` para establecer los atributos y firma determinada de un constructor en un tipo dinámico y devolver el correspondiente <xref:System.Reflection.Emit.ConstructorBuilder> para rellenar el MSIL.</span><span class="sxs-lookup"><span data-stu-id="f640b-224">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-225">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-225">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes, requiredCustomModifiers, optionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="f640b-226">Atributos del constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-226">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-227">Convención de llamada del constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-227">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-228">Tipos de parámetro del constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-228">The parameter types of the constructor.</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="f640b-229">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-229">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-230">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-230">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-231">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-231">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-232">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-232">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="f640b-233">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-233">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-234">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-234">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-235">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-235">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-236">Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-236">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-237">Agrega un nuevo constructor al tipo, con los atributos, la firma y los modificadores personalizados especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-237">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-238">Constructor definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-238">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-239">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</span><span class="sxs-lookup"><span data-stu-id="f640b-239">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-240">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-240">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="f640b-241">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-241">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-242">El tamaño de <paramref name="requiredCustomModifiers" /> o <paramref name="optionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-242">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-243">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-243">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-244">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-244">-or-</span>
          </span>
          <span data-ttu-id="f640b-245">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-245">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDefaultConstructor : System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineDefaultConstructor attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="f640b-246">Un objeto <see langword="MethodAttributes" /> que representa los atributos que se aplicarán al constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-246">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-247">Define el constructor predeterminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-247">Defines the default constructor.</span>
          </span>
          <span data-ttu-id="f640b-248">El constructor definido aquí simplemente llamará al constructor predeterminado del elemento primario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-248">The constructor defined here will simply call the default constructor of the parent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-249">Devuelve el constructor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-249">Returns the constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-250">Dado que el constructor predeterminado se define automáticamente, es necesario llamar a este método solo en las situaciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="f640b-250">Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="f640b-251">Ha definido otro constructor y también desea un constructor predeterminado que simplemente llama al constructor de clase base.</span><span class="sxs-lookup"><span data-stu-id="f640b-251">You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="f640b-252">Desea establecer los atributos en el constructor predeterminado a algo distinto <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, y <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span><span class="sxs-lookup"><span data-stu-id="f640b-252">You want to set the attributes on the default constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-253">Ejemplo de código siguiente muestra el uso de `DefineConstructor` para establecer los atributos y firma determinada de un constructor en un tipo dinámico y devolver el correspondiente <xref:System.Reflection.Emit.ConstructorBuilder> para rellenar el MSIL.</span><span class="sxs-lookup"><span data-stu-id="f640b-253">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-254">El tipo de elemento primario (tipo base) no tiene un constructor predeterminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-254">The parent type (base type) does not have a default constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-255">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-255">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-256">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-256">-or-</span>
          </span>
          <span data-ttu-id="f640b-257">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-257">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberSignature Language="F#" Value="member this.DefineEvent : string * System.Reflection.EventAttributes * Type -&gt; System.Reflection.Emit.EventBuilder" Usage="typeBuilder.DefineEvent (name, attributes, eventtype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-258">Nombre del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-258">The name of the event.</span>
          </span>
          <span data-ttu-id="f640b-259">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-259">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-260">Atributos del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-260">The attributes of the event.</span>
          </span>
        </param>
        <param name="eventtype">
          <span data-ttu-id="f640b-261">Tipo del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-261">The type of the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-262">Agrega un nuevo evento al tipo, con el nombre, los atributos y el tipo de evento especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-262">Adds a new event to the type, with the given name, attributes and event type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-263">Evento definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-263">The defined event.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-264">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-264">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-265">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-265">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-266">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-266">-or-</span>
          </span>
          <span data-ttu-id="f640b-267">
            <paramref name="eventtype" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-267">
              <paramref name="eventtype" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-268">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-268">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-269">Agrega un campo al tipo dinámico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-269">Adds a new field to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="f640b-270">Nombre del campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-270">The name of the field.</span>
          </span>
          <span data-ttu-id="f640b-271">
            <c>fieldName</c> no puede contener valores null incrustados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-271">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f640b-272">Tipo del campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-272">The type of the field</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-273">Atributos del campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-273">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-274">Agrega un nuevo campo al tipo, con el nombre, los atributos y el tipo de campo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-274">Adds a new field to the type, with the given name, attributes, and field type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-275">Campo definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-275">The defined field.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-276">La longitud de <paramref name="fieldName" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-276">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-277">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-277">-or-</span>
          </span>
          <span data-ttu-id="f640b-278">
            <paramref name="type" /> es System.Void.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-278">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="f640b-279">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-279">-or-</span>
          </span>
          <span data-ttu-id="f640b-280">Se especificó un tamaño total de la clase primaria de este campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-280">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-281">
            <paramref name="fieldName" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-281">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-282">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-282">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * Type[] * Type[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="f640b-283">Nombre del campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-283">The name of the field.</span>
          </span>
          <span data-ttu-id="f640b-284">
            <c>fieldName</c> no puede contener valores null incrustados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-284">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f640b-285">Tipo del campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-285">The type of the field</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="f640b-286">Matriz de tipos que representan los modificadores personalizados necesarios para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-286">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="f640b-287">Matriz de tipos que representan los modificadores personalizados opcionales para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-287">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-288">Atributos del campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-288">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-289">Agrega un nuevo campo al tipo, con el nombre, los atributos, el tipo de campo y os modificadores personalizados especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-289">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-290">Campo definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-290">The defined field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-291">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</span><span class="sxs-lookup"><span data-stu-id="f640b-291">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-292">La longitud de <paramref name="fieldName" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-292">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-293">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-293">-or-</span>
          </span>
          <span data-ttu-id="f640b-294">
            <paramref name="type" /> es System.Void.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-294">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="f640b-295">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-295">-or-</span>
          </span>
          <span data-ttu-id="f640b-296">Se especificó un tamaño total de la clase primaria de este campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-296">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-297">
            <paramref name="fieldName" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-297">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-298">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-298">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="typeBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">
          <span data-ttu-id="f640b-299">Una matriz de nombres para los parámetros de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-299">An array of names for the generic type parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-300">Define los parámetros de tipo genérico para el tipo actual, especificando su número y sus nombres y devuelve una matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que pueden usarse para establecer sus restricciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-300">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-301">Una matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que pueden usarse para definir las restricciones de los parámetros de tipo genérico para el tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-301">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-302">Llamar a este método convierte al tipo actual en un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-302">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="f640b-303">Si se llama al método nuevo en el mismo tipo, un <xref:System.InvalidOperationException> se produce.</span><span class="sxs-lookup"><span data-stu-id="f640b-303">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-304">En el ejemplo de código siguiente se crea un tipo genérico con dos parámetros de tipo y los guarda en el ensamblado GenericEmitExample1.dll.</span><span class="sxs-lookup"><span data-stu-id="f640b-304">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="f640b-305">Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para ver los tipos generados.</span><span class="sxs-lookup"><span data-stu-id="f640b-305">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="f640b-306">Para obtener una explicación más detallada de los pasos implicados en la definición de un tipo genérico dinámico, vea [Cómo: definir un tipo genérico con emisión de reflexión](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-306">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-307">Los parámetros de tipo genérico ya se han definido para este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-307">Generic type parameters have already been defined for this type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-308">
            <paramref name="names" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-308">
              <paramref name="names" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-309">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-309">-or-</span>
          </span>
          <span data-ttu-id="f640b-310">Un elemento de <paramref name="names" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-310">An element of <paramref name="names" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-311">
            <paramref name="names" /> es una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-311">
              <paramref name="names" /> is an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-312">El nombre que se usa para hacer referencia a los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-312">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="f640b-313">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-313">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="f640b-314">El blob de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-314">The blob of data.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-315">Los atributos para este campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-315">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-316">Define el campo de datos inicializado en la sección .sdata del archivo ejecutable portable (PE).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-316">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-317">Campo para hacer referencia a los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-317">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-318">El campo que se crea con este método será `static`, incluso si no incluye `FieldAttributes.Static` en el `attributes` parámetro.</span><span class="sxs-lookup"><span data-stu-id="f640b-318">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-319">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-319">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-320">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-320">-or-</span>
          </span>
          <span data-ttu-id="f640b-321">El tamaño de los datos es menor o igual que cero, o mayor o igual que 0x3f0000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-321">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-322">El valor de <paramref name="name" /> o <paramref name="data" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-322">
              <paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-323">Se llamó anteriormente a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-323">
              <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-324">Agrega un método al tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-324">Adds a method to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-325">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-325">The name of the method.</span>
          </span>
          <span data-ttu-id="f640b-326">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-326">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-327">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-327">The attributes of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-328">Agrega un nuevo método al tipo, con el nombre especificado y los atributos de método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-328">Adds a new method to the type, with the specified name and method attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-329">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-329">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-330">Utilice esta sobrecarga del método cuando no conoce la firma del método en el momento de que definir el método.</span><span class="sxs-lookup"><span data-stu-id="f640b-330">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="f640b-331">Por ejemplo, los tipos de parámetro y el tipo de valor devuelto de un método genérico pueden especificarse mediante parámetros de tipo genérico del método, que se deben definir una vez que se ha agregado el método al tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-331">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="f640b-332">Los parámetros y el tipo de valor devuelto del método se pueden establecer más adelante mediante el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-332">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f640b-333">Esta sobrecarga del método define un método con <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f640b-333">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f640b-334">Si necesita definir un método sin una firma con otra convención de llamada, use la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="f640b-334">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-335">El ejemplo de código siguiente define un método genérico denominado `DemoMethod` cuyo tipo de parámetro y el tipo de valor devuelto se especifican mediante los parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-335">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="f640b-336">El método se define sin una firma, utilizando la convención de llamada estándar.</span><span class="sxs-lookup"><span data-stu-id="f640b-336">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="f640b-337">El <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método se utiliza para realizar `DemoMethod` un método genérico y los parámetros de tipo recién definidos a continuación, se usan para la firma y tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="f640b-337">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="f640b-338">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-338">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-339">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-339">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-340">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-340">-or-</span>
          </span>
          <span data-ttu-id="f640b-341">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-341">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-342">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-342">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-343">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-343">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-344">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-344">-or-</span>
          </span>
          <span data-ttu-id="f640b-345">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-345">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-346">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-346">The name of the method.</span>
          </span>
          <span data-ttu-id="f640b-347">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-347">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-348">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-348">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-349">Convención de llamada del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-349">The calling convention of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-350">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método y la convención de llamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-350">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-351">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-351">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-352">Utilice esta sobrecarga del método cuando no conoce la firma del método en el momento de que definir el método.</span><span class="sxs-lookup"><span data-stu-id="f640b-352">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="f640b-353">Por ejemplo, los tipos de parámetro y el tipo de valor devuelto de un método genérico pueden especificarse mediante parámetros de tipo genérico del método, que se deben definir una vez que se ha agregado el método al tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-353">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="f640b-354">Los parámetros y el tipo de valor devuelto del método se pueden establecer más adelante mediante el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-354">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-355">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-355">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-356">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-356">-or-</span>
          </span>
          <span data-ttu-id="f640b-357">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-357">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-358">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-358">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-359">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-359">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-360">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-360">-or-</span>
          </span>
          <span data-ttu-id="f640b-361">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-361">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-362">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-362">The name of the method.</span>
          </span>
          <span data-ttu-id="f640b-363">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-363">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-364">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-364">The attributes of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-365">Tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-365">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-366">Tipos de los parámetros del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-366">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-367">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método y la firma del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-367">Adds a new method to the type, with the specified name, method attributes, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-368">Método definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-368">The defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f640b-369">Ejemplo de código siguiente muestra el uso de `DefineMethod` para establecer los atributos y firma determinada de un constructor en un tipo dinámico y devolver el correspondiente <xref:System.Reflection.Emit.MethodBuilder> para rellenar el MSIL.</span><span class="sxs-lookup"><span data-stu-id="f640b-369">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-370">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-370">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-371">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-371">-or-</span>
          </span>
          <span data-ttu-id="f640b-372">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-372">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-373">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-373">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-374">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-374">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-375">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-375">-or-</span>
          </span>
          <span data-ttu-id="f640b-376">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-376">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-377">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-377">The name of the method.</span>
          </span>
          <span data-ttu-id="f640b-378">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-378">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-379">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-379">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-380">Convención de llamada del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-380">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-381">Tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-381">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-382">Tipos de los parámetros del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-382">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-383">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método, la convención de llamada y la firma del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-383">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-384">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-384">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f640b-385">Ejemplo de código siguiente muestra el uso de `DefineMethod` para establecer los atributos y firma determinada de un constructor en un tipo dinámico y devolver el correspondiente <xref:System.Reflection.Emit.MethodBuilder> para rellenar el MSIL.</span><span class="sxs-lookup"><span data-stu-id="f640b-385">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-386">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-386">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-387">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-387">-or-</span>
          </span>
          <span data-ttu-id="f640b-388">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-388">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-389">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-389">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-390">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-390">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-391">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-391">-or-</span>
          </span>
          <span data-ttu-id="f640b-392">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-392">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-393">Nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-393">The name of the method.</span>
          </span>
          <span data-ttu-id="f640b-394">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-394">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-395">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-395">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-396">Convención de llamada del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-396">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-397">Tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-397">The return type of the method.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-398">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-398">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="f640b-399">Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-399">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-400">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-400">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="f640b-401">Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-401">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-402">Tipos de los parámetros del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-402">The types of the parameters of the method.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-403">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-403">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-404">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-404">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-405">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-405">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-406">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-406">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-407">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-407">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-408">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-408">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-409">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-409">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-410">Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-410">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-411">Agrega un nuevo método al tipo, con el nombre especificado, los atributos de método, la convención de llamada, la firma del método y los modificadores personalizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-411">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-412">Un objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién agregado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-412">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-413">Utilice esta sobrecarga si necesita especificar los modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="f640b-413">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="f640b-414">Si tiene que especificar los modificadores personalizados una vez creado el método, como lo haría, por ejemplo, con un método genérico cuyos tipos de parámetro se especifican mediante los parámetros de tipo genérico, puede usar el <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecargas del método para definir el método y, después, use el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método para definir el parámetro y devolver tipos con los modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="f640b-414">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-415">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-415">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="f640b-416">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-417">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-417">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-418">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-418">-or-</span>
          </span>
          <span data-ttu-id="f640b-419">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-419">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
          <span data-ttu-id="f640b-420">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-420">-or-</span>
          </span>
          <span data-ttu-id="f640b-421">El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-421">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-422">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-422">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-423">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-423">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-424">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-424">-or-</span>
          </span>
          <span data-ttu-id="f640b-425">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-425">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberSignature Language="F#" Value="member this.DefineMethodOverride : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; unit" Usage="typeBuilder.DefineMethodOverride (methodInfoBody, methodInfoDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">
          <span data-ttu-id="f640b-426">Cuerpo del método que se va a usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-426">The method body to be used.</span>
          </span>
          <span data-ttu-id="f640b-427">Debería ser un objeto <see langword="MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-427">This should be a <see langword="MethodBuilder" /> object.</span>
          </span>
        </param>
        <param name="methodInfoDeclaration">
          <span data-ttu-id="f640b-428">Método cuya declaración se va a usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-428">The method whose declaration is to be used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-429">Especifica un cuerpo de método determinado que implementa una declaración de método concreta, posiblemente con otro nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-429">Specifies a given method body that implements a given method declaration, potentially with a different name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-430">No utilice este método para invalidar métodos o implementaciones de interfaz.</span><span class="sxs-lookup"><span data-stu-id="f640b-430">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="f640b-431">Para reemplazar un método de una clase base o implementar un método de una interfaz, simplemente emita un método con el mismo nombre y firma que el método se reemplaza o implementa, como se muestra en el ejemplo de código.</span><span class="sxs-lookup"><span data-stu-id="f640b-431">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="f640b-432">El <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método se utiliza cuando un cuerpo de método y una declaración de método tienen nombres diferentes.</span><span class="sxs-lookup"><span data-stu-id="f640b-432">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="f640b-433">Por ejemplo, una clase podría invalidar un método de clase base y también proporcionar una implementación independiente para un miembro de interfaz con el mismo nombre, como se muestra en el ejemplo de código.</span><span class="sxs-lookup"><span data-stu-id="f640b-433">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="f640b-434">`DefineMethodOverride` define un `methodimpl`, que consta de un par de tokens de metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-434">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="f640b-435">Un símbolo (token) apunta a una implementación y los demás puntos de token a una declaración que implementa el cuerpo.</span><span class="sxs-lookup"><span data-stu-id="f640b-435">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="f640b-436">El cuerpo debe definirse en el tipo definida en la implementación del método y el cuerpo debe ser virtual (`Overridable` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f640b-436">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="f640b-437">La declaración se puede realizar a un método definido en una interfaz implementada por el tipo, un método en una clase derivada o un método definido en el tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-437">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="f640b-438">Si la declaración está en una interfaz solo, se modifica la ranura definida por la interfaz.</span><span class="sxs-lookup"><span data-stu-id="f640b-438">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="f640b-439">Si la declaración se realiza a un método en un tipo base, se invalida la ranura para el método y también se reemplazan los duplicados para el método invalidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-439">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="f640b-440">El método invalidado no puede ser el método real que se declara.</span><span class="sxs-lookup"><span data-stu-id="f640b-440">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="f640b-441">Si el método está en el mismo tipo, se reemplaza la ranura y se invalidan los duplicados para los métodos reemplazados.</span><span class="sxs-lookup"><span data-stu-id="f640b-441">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-442">Para obtener más información acerca de las implementaciones de método, consulte `MethodImpl` en la documentación de ECMA Partition II metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-442">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="f640b-443">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-443">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f640b-444">Después de la <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> llama el método, algunas características de `methodInfoBody` no se puede cambiar.</span><span class="sxs-lookup"><span data-stu-id="f640b-444">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="f640b-445">Por ejemplo, no se puede aplicar un atributo a un parámetro de tipo genérico de `methodInfoBody` utilizando el <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-445">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="f640b-446">Si debe utilizar el <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método, hacerlo después de todas las características de `methodInfoBody` se han definido.</span><span class="sxs-lookup"><span data-stu-id="f640b-446">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-447">El ejemplo de código siguiente contiene una interfaz `I` con un método `M()`, una clase base `A` que implementa la interfaz y una clase derivada `C` que invalida la implementación de clase base `M()` y también Proporciona una implementación independiente explícita de `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="f640b-447">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="f640b-448">El `main()` método del ejemplo de código muestra cómo emitir la clase derivada `C`.</span><span class="sxs-lookup"><span data-stu-id="f640b-448">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="f640b-449">La invalidación de `A.M()` se logra simplemente mediante la emisión de un método `M()` con la misma firma.</span><span class="sxs-lookup"><span data-stu-id="f640b-449">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="f640b-450">Sin embargo, para proporcionar una implementación independiente de `I.M()`, debe definir un cuerpo de método y, a continuación, utilice el <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> para asociar dicho cuerpo de método con un <xref:System.Reflection.MethodInfo> que representa `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="f640b-450">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="f640b-451">El nombre del cuerpo del método no importa.</span><span class="sxs-lookup"><span data-stu-id="f640b-451">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="f640b-452">El ejemplo de código crea una instancia de la clase emitida.</span><span class="sxs-lookup"><span data-stu-id="f640b-452">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="f640b-453">Obtiene un <xref:System.Reflection.MethodInfo> objeto `I.M()`, y la implementación de la interfaz utiliza para invocar la clase emitida 's explícita.</span><span class="sxs-lookup"><span data-stu-id="f640b-453">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="f640b-454">A continuación, obtiene un <xref:System.Reflection.MethodInfo> objeto `A.M()`y se utiliza para invocar la invalidación de la clase emitida de ese método.</span><span class="sxs-lookup"><span data-stu-id="f640b-454">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-455">
            <paramref name="methodInfoBody" /> no pertenece a esta clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-455">
              <paramref name="methodInfoBody" /> does not belong to this class.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-456">El valor de <paramref name="methodInfoBody" /> o <paramref name="methodInfoDeclaration" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-456">
              <paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-457">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-457">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-458">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-458">-or-</span>
          </span>
          <span data-ttu-id="f640b-459">El tipo declarativo de <paramref name="methodInfoBody" /> no es del tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-459">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-460">Define un tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-460">Defines a nested type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-461">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-461">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-462">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-462">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-463">Define un tipo anidado, dado su nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-463">Defines a nested type, given its name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-464">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-464">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-465">Este método se puede usar para crear anidada tipos incluso después el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-465">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="f640b-466">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f640b-466">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="f640b-467">Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en que se deben completar los tipos anidados y los tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-467">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="f640b-468">Un nombre duplicado no es necesario crear si `name` es idéntico al nombre de un tipo definido previamente o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-468">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="f640b-469">Para ser duplicados, los nombres completos deben ser el mismo, incluido el espacio de nombres y todos los tipos de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="f640b-469">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-470">La longitud de <paramref name="name" /> es cero o mayor que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-470">Length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="f640b-471">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-471">-or-</span>
          </span>
          <span data-ttu-id="f640b-472">Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-472">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-473">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-473">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-474">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-474">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-475">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-475">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="f640b-476">Los atributos del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-476">The attributes of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-477">Define un tipo anidado, dado su nombre y atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-477">Defines a nested type, given its name and attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-478">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-478">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-479">Este método se puede usar para crear anidada tipos incluso después el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-479">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="f640b-480">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f640b-480">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="f640b-481">Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en que se deben completar los tipos anidados y los tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-481">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="f640b-482">Un nombre duplicado no es necesario crear si `name` es idéntico al nombre de un tipo definido previamente o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-482">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="f640b-483">Para ser duplicados, los nombres completos deben ser el mismo, incluido el espacio de nombres y todos los tipos de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="f640b-483">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-484">No se especificó el atributo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-484">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="f640b-485">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-485">-or-</span>
          </span>
          <span data-ttu-id="f640b-486">Este tipo está sellado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-486">This type is sealed.</span>
          </span>
          <span data-ttu-id="f640b-487">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-487">-or-</span>
          </span>
          <span data-ttu-id="f640b-488">Este tipo es una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-488">This type is an array.</span>
          </span>
          <span data-ttu-id="f640b-489">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-489">-or-</span>
          </span>
          <span data-ttu-id="f640b-490">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-490">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="f640b-491">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-491">-or-</span>
          </span>
          <span data-ttu-id="f640b-492">La longitud de <paramref name="name" /> es cero o mayor que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-492">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="f640b-493">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-493">-or-</span>
          </span>
          <span data-ttu-id="f640b-494">Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-494">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-495">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-495">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-496">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-496">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-497">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-497">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="f640b-498">Los atributos del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-498">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="f640b-499">Tipo que extiende el tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-499">The type that the nested type extends.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-500">Define un tipo anidado, dado su nombre, sus atributos y el tipo que extiende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-500">Defines a nested type, given its name, attributes, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-501">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-501">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-502">Este método se puede usar para crear anidada tipos incluso después el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-502">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="f640b-503">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f640b-503">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="f640b-504">Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en que se deben completar los tipos anidados y los tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-504">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="f640b-505">Un nombre duplicado no es necesario crear si `name` es idéntico al nombre de un tipo definido previamente o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-505">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="f640b-506">Para ser duplicados, los nombres completos deben ser el mismo, incluido el espacio de nombres y todos los tipos de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="f640b-506">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-507">No se especificó el atributo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-507">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="f640b-508">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-508">-or-</span>
          </span>
          <span data-ttu-id="f640b-509">Este tipo está sellado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-509">This type is sealed.</span>
          </span>
          <span data-ttu-id="f640b-510">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-510">-or-</span>
          </span>
          <span data-ttu-id="f640b-511">Este tipo es una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-511">This type is an array.</span>
          </span>
          <span data-ttu-id="f640b-512">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-512">-or-</span>
          </span>
          <span data-ttu-id="f640b-513">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-513">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="f640b-514">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-514">-or-</span>
          </span>
          <span data-ttu-id="f640b-515">La longitud de <paramref name="name" /> es cero o mayor que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-515">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="f640b-516">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-516">-or-</span>
          </span>
          <span data-ttu-id="f640b-517">Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-517">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-518">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-518">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-519">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-519">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-520">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-520">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="f640b-521">Los atributos del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-521">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="f640b-522">Tipo que extiende el tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-522">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="f640b-523">El tamaño total del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-523">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-524">Define un tipo anidado, dados su nombre, sus atributos, el tamaño total del tipo y el tipo que extiende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-524">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-525">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-525">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-526">Este método se puede usar para crear anidada tipos incluso después el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-526">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="f640b-527">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f640b-527">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="f640b-528">Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en que se deben completar los tipos anidados y los tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-528">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="f640b-529">Un nombre duplicado no es necesario crear si `name` es idéntico al nombre de un tipo definido previamente o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-529">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="f640b-530">Para ser duplicados, los nombres completos deben ser el mismo, incluido el espacio de nombres y todos los tipos de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="f640b-530">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-531">No se especificó el atributo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-531">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="f640b-532">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-532">-or-</span>
          </span>
          <span data-ttu-id="f640b-533">Este tipo está sellado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-533">This type is sealed.</span>
          </span>
          <span data-ttu-id="f640b-534">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-534">-or-</span>
          </span>
          <span data-ttu-id="f640b-535">Este tipo es una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-535">This type is an array.</span>
          </span>
          <span data-ttu-id="f640b-536">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-536">-or-</span>
          </span>
          <span data-ttu-id="f640b-537">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-537">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="f640b-538">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-538">-or-</span>
          </span>
          <span data-ttu-id="f640b-539">La longitud de <paramref name="name" /> es cero o mayor que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-539">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="f640b-540">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-540">-or-</span>
          </span>
          <span data-ttu-id="f640b-541">Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-541">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-542">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-542">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-543">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-543">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-544">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-544">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="f640b-545">Los atributos del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-545">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="f640b-546">Tipo que extiende el tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-546">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="f640b-547">Tamaño de empaquetado del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-547">The packing size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-548">Define un tipo anidado, dado su nombre, sus atributos, el tipo que extiende y el tamaño de empaquetado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-548">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-549">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-549">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-550">Este método se puede usar para crear anidada tipos incluso después el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-550">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="f640b-551">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f640b-551">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="f640b-552">Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en que se deben completar los tipos anidados y los tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-552">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="f640b-553">Un nombre duplicado no es necesario crear si `name` es idéntico al nombre de un tipo definido previamente o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-553">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="f640b-554">Para ser duplicados, los nombres completos deben ser el mismo, incluido el espacio de nombres y todos los tipos de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="f640b-554">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-555">No se especificó el atributo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-555">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="f640b-556">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-556">-or-</span>
          </span>
          <span data-ttu-id="f640b-557">Este tipo está sellado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-557">This type is sealed.</span>
          </span>
          <span data-ttu-id="f640b-558">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-558">-or-</span>
          </span>
          <span data-ttu-id="f640b-559">Este tipo es una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-559">This type is an array.</span>
          </span>
          <span data-ttu-id="f640b-560">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-560">-or-</span>
          </span>
          <span data-ttu-id="f640b-561">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-561">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="f640b-562">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-562">-or-</span>
          </span>
          <span data-ttu-id="f640b-563">La longitud de <paramref name="name" /> es cero o mayor que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-563">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="f640b-564">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-564">-or-</span>
          </span>
          <span data-ttu-id="f640b-565">Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-565">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-566">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-566">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-567">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-567">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-568">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-568">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="f640b-569">Los atributos del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-569">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="f640b-570">El tipo que extiende el tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-570">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="interfaces">
          <span data-ttu-id="f640b-571">Las interfaces que implementa el tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-571">The interfaces that the nested type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-572">Define un tipo anidado, dados su nombre, sus atributos, el tipo que extiende y las interfaces que implementa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-572">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-573">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-573">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-574">Este método se puede usar para crear anidada tipos incluso después el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método en el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="f640b-574">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="f640b-575">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="f640b-575">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="f640b-576">Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en que se deben completar los tipos anidados y los tipos.</span><span class="sxs-lookup"><span data-stu-id="f640b-576">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="f640b-577">Un nombre duplicado no es necesario crear si `name` es idéntico al nombre de un tipo definido previamente o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="f640b-577">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="f640b-578">Para ser duplicados, los nombres completos deben ser el mismo, incluido el espacio de nombres y todos los tipos de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="f640b-578">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-579">No se especificó el atributo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-579">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="f640b-580">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-580">-or-</span>
          </span>
          <span data-ttu-id="f640b-581">Este tipo está sellado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-581">This type is sealed.</span>
          </span>
          <span data-ttu-id="f640b-582">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-582">-or-</span>
          </span>
          <span data-ttu-id="f640b-583">Este tipo es una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-583">This type is an array.</span>
          </span>
          <span data-ttu-id="f640b-584">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-584">-or-</span>
          </span>
          <span data-ttu-id="f640b-585">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-585">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="f640b-586">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-586">-or-</span>
          </span>
          <span data-ttu-id="f640b-587">La longitud de <paramref name="name" /> es cero o mayor que 1023.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-587">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="f640b-588">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-588">-or-</span>
          </span>
          <span data-ttu-id="f640b-589">Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-589">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-590">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-590">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-591">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-591">-or-</span>
          </span>
          <span data-ttu-id="f640b-592">Un elemento de la matriz <paramref name="interfaces" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-592">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-593">El nombre corto del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-593">The short name of the type.</span>
          </span>
          <span data-ttu-id="f640b-594">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-594">
              <c>name</c> cannot contain embedded null values.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="f640b-595">Los atributos del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-595">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="f640b-596">Tipo que extiende el tipo anidado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-596">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="f640b-597">Tamaño de empaquetado del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-597">The packing size of the type.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="f640b-598">El tamaño total del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-598">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-599">Define un tipo anidado, dado su nombre, atributos, tamaño y el tipo que extiende.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-599">Defines a nested type, given its name, attributes, size, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-600">Tipo anidado definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-600">The defined nested type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-601">Define un método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-601">Defines a <see langword="PInvoke" /> method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-602">Nombre del método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-602">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="f640b-603">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-603">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="f640b-604">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-604">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-605">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-605">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-606">Convención de llamada del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-606">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-607">Tipo de valor devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-607">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-608">Tipos de los parámetros del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-608">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="f640b-609">Convención de llamada nativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-609">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="f640b-610">Juego de caracteres nativo del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-610">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-611">Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método y las marcas <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-611">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-612">Método <see langword="PInvoke" /> definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-612">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-613">Atributos de importación de algunas DLL (vea la descripción de <xref:System.Runtime.InteropServices.DllImportAttribute>) no se puede especificar como argumentos para este método.</span><span class="sxs-lookup"><span data-stu-id="f640b-613">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="f640b-614">Por ejemplo, el atributo de la importación de la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deben agregarse después de la `PInvoke` se crea el método, si el método devuelve un valor.</span><span class="sxs-lookup"><span data-stu-id="f640b-614">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="f640b-615">El ejemplo muestra cómo hacerlo.</span><span class="sxs-lookup"><span data-stu-id="f640b-615">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-616">En el ejemplo siguiente se muestra cómo usar el <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para crear un `PInvoke` método y cómo agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca para las marcas de implementación del método después de crear el <xref:System.Reflection.Emit.MethodBuilder>, mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> y <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>métodos.</span><span class="sxs-lookup"><span data-stu-id="f640b-616">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f640b-617">Para obtener un valor devuelto distinto de cero, debe agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="f640b-617">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="f640b-618">En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, `MyType`, que contiene el `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="f640b-618">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="f640b-619">El `PInvoke` método representa Win32 `GetTickCount` función.</span><span class="sxs-lookup"><span data-stu-id="f640b-619">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="f640b-620">Cuando se ejecuta el ejemplo, se ejecuta el `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="f640b-620">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="f640b-621">También se guarda el ensamblado dinámico como PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="f640b-621">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="f640b-622">Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el `MyType` clase y el `static` (`Shared` en Visual Basic) `PInvoke` contiene el método.</span><span class="sxs-lookup"><span data-stu-id="f640b-622">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="f640b-623">Puede compilar un programa de Visual Basic o C# que usa estático `MyType.GetTickCount` método mediante la inclusión de una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="f640b-623">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-624">El método no es estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-624">The method is not static.</span>
          </span>
          <span data-ttu-id="f640b-625">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-625">-or-</span>
          </span>
          <span data-ttu-id="f640b-626">El tipo principal es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-626">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="f640b-627">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-627">-or-</span>
          </span>
          <span data-ttu-id="f640b-628">Método abstracto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-628">The method is abstract.</span>
          </span>
          <span data-ttu-id="f640b-629">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-629">-or-</span>
          </span>
          <span data-ttu-id="f640b-630">El método se definió anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-630">The method was previously defined.</span>
          </span>
          <span data-ttu-id="f640b-631">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-631">-or-</span>
          </span>
          <span data-ttu-id="f640b-632">La longitud de <paramref name="name" /> o <paramref name="dllName" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-632">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-633">El valor de <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-633">
              <paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-634">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-634">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-635">Nombre del método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-635">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="f640b-636">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-636">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="f640b-637">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-637">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="f640b-638">El nombre del punto de entrada del archivo DLL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-638">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-639">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-639">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-640">Convención de llamada del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-640">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-641">Tipo de valor devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-641">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-642">Tipos de los parámetros del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-642">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="f640b-643">Convención de llamada nativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-643">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="f640b-644">Juego de caracteres nativo del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-644">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-645">Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método y las marcas <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-645">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-646">Método <see langword="PInvoke" /> definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-646">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-647">Atributos de importación de algunas DLL (vea la descripción de <xref:System.Runtime.InteropServices.DllImportAttribute>) no se puede especificar como argumentos para este método.</span><span class="sxs-lookup"><span data-stu-id="f640b-647">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="f640b-648">Por ejemplo, el atributo de la importación de la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deben agregarse después de la `PInvoke` se crea el método, si el método devuelve un valor.</span><span class="sxs-lookup"><span data-stu-id="f640b-648">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="f640b-649">El ejemplo muestra cómo hacerlo.</span><span class="sxs-lookup"><span data-stu-id="f640b-649">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-650">En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para crear un `PInvoke` método y cómo agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca para las marcas de implementación del método después de crear el <xref:System.Reflection.Emit.MethodBuilder>, mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> y <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="f640b-650">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f640b-651">Para obtener un valor devuelto distinto de cero, debe agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="f640b-651">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="f640b-652">En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, `MyType`, que contiene el `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="f640b-652">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="f640b-653">El `PInvoke` método representa Win32 `GetTickCount` función.</span><span class="sxs-lookup"><span data-stu-id="f640b-653">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="f640b-654">Cuando se ejecuta el ejemplo, se ejecuta el `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="f640b-654">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="f640b-655">También se guarda el ensamblado dinámico como PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="f640b-655">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="f640b-656">Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el `MyType` clase y el `static` (`Shared` en Visual Basic) `PInvoke` contiene el método.</span><span class="sxs-lookup"><span data-stu-id="f640b-656">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="f640b-657">Puede compilar un programa de Visual Basic o C# que usa estático `MyType.GetTickCount` método mediante la inclusión de una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="f640b-657">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-658">El método no es estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-658">The method is not static.</span>
          </span>
          <span data-ttu-id="f640b-659">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-659">-or-</span>
          </span>
          <span data-ttu-id="f640b-660">El tipo principal es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-660">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="f640b-661">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-661">-or-</span>
          </span>
          <span data-ttu-id="f640b-662">Método abstracto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-662">The method is abstract.</span>
          </span>
          <span data-ttu-id="f640b-663">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-663">-or-</span>
          </span>
          <span data-ttu-id="f640b-664">El método se definió anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-664">The method was previously defined.</span>
          </span>
          <span data-ttu-id="f640b-665">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-665">-or-</span>
          </span>
          <span data-ttu-id="f640b-666">La longitud de <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-666">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-667">
            <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-667">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-668">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-668">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-669">Nombre del método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-669">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="f640b-670">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-670">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="f640b-671">Nombre de la DLL en la que está definido el método <see langword="PInvoke" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-671">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="f640b-672">El nombre del punto de entrada del archivo DLL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-672">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-673">Los atributos del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-673">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-674">Convención de llamada del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-674">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-675">Tipo de valor devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-675">The method's return type.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-676">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-676">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="f640b-677">Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-677">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-678">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-678">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="f640b-679">Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-679">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-680">Tipos de los parámetros del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-680">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-681">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-681">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-682">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-682">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-683">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-683">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-684">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-684">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-685">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-685">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-686">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-686">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-687">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-687">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-688">Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-688">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="f640b-689">Convención de llamada nativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-689">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="f640b-690">Juego de caracteres nativo del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-690">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-691">Define un método <see langword="PInvoke" /> dado su nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamada del método, el tipo devuelto del método, los tipos de parámetros del método, las marcas <see langword="PInvoke" /> y los modificadores personalizados para los parámetros y el tipo de valor devuelto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-691">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-692">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método <see langword="PInvoke" /> definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-692">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-693">Atributos de importación de algunas DLL (vea la descripción de <xref:System.Runtime.InteropServices.DllImportAttribute>) no se puede especificar como argumentos para este método.</span><span class="sxs-lookup"><span data-stu-id="f640b-693">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="f640b-694">Por ejemplo, el atributo de la importación de la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deben agregarse después de la `PInvoke` se crea el método, si el método devuelve un valor.</span><span class="sxs-lookup"><span data-stu-id="f640b-694">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="f640b-695">El ejemplo muestra cómo hacerlo.</span><span class="sxs-lookup"><span data-stu-id="f640b-695">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-696">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-696">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="f640b-697">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-697">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-698">En el ejemplo de código siguiente se muestra cómo usar la [\], tipo\[\], tipo\[\], tipo\[\]\[\], tipo\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > método para crear un `PInvoke` método y cómo agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca para las marcas de implementación del método después de crear el <xref:System.Reflection.Emit.MethodBuilder>, mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> y <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="f640b-698">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="f640b-699">En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, `MyType`, que contiene el `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="f640b-699">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="f640b-700">El `PInvoke` método representa Win32 `GetTickCount` función.</span><span class="sxs-lookup"><span data-stu-id="f640b-700">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f640b-701">Para obtener un valor devuelto distinto de cero, debe agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="f640b-701">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-702">El ejemplo utiliza una sobrecarga que no especifica modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="f640b-702">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="f640b-703">Para especificar los modificadores personalizados, cambie el código de ejemplo para utilizar esta sobrecarga del método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="f640b-703">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="f640b-704">Cuando se ejecuta el ejemplo, se ejecuta el `PInvoke` método.</span><span class="sxs-lookup"><span data-stu-id="f640b-704">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="f640b-705">También se guarda el ensamblado dinámico como PInvokeTest.dll.</span><span class="sxs-lookup"><span data-stu-id="f640b-705">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="f640b-706">Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el `MyType` clase y el `static` (`Shared` en Visual Basic) `PInvoke` contiene el método.</span><span class="sxs-lookup"><span data-stu-id="f640b-706">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="f640b-707">Puede compilar un programa de Visual Basic o C# que usa estático `MyType.GetTickCount` método mediante la inclusión de una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="f640b-707">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-708">El método no es estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-708">The method is not static.</span>
          </span>
          <span data-ttu-id="f640b-709">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-709">-or-</span>
          </span>
          <span data-ttu-id="f640b-710">El tipo principal es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-710">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="f640b-711">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-711">-or-</span>
          </span>
          <span data-ttu-id="f640b-712">Método abstracto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-712">The method is abstract.</span>
          </span>
          <span data-ttu-id="f640b-713">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-713">-or-</span>
          </span>
          <span data-ttu-id="f640b-714">El método se definió anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-714">The method was previously defined.</span>
          </span>
          <span data-ttu-id="f640b-715">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-715">-or-</span>
          </span>
          <span data-ttu-id="f640b-716">La longitud de <paramref name="name" />, <paramref name="dllName" />o <paramref name="entryName" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-716">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-717">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-717">-or-</span>
          </span>
          <span data-ttu-id="f640b-718">El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-718">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-719">
            <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-719">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-720">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-720">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-721">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-721">-or-</span>
          </span>
          <span data-ttu-id="f640b-722">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-722">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-723">Agrega una propiedad al tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-723">Adds a new property to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-724">Nombre de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-724">The name of the property.</span>
          </span>
          <span data-ttu-id="f640b-725">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-725">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-726">Atributos de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-726">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-727">Tipo de valor devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-727">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-728">Tipos de los parámetros de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-728">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-729">Agrega una nueva propiedad al tipo, con el nombre proporcionado y la firma de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-729">Adds a new property to the type, with the given name and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-730">Propiedad definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-730">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f640b-731">Ejemplo de código siguiente muestra cómo definir una propiedad dinámica y obtener un <xref:System.Reflection.Emit.PropertyBuilder> para la especificación.</span><span class="sxs-lookup"><span data-stu-id="f640b-731">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="f640b-732">Tenga en cuenta que un `PropertyBuilder` también debe tener su correspondiente <xref:System.Reflection.Emit.MethodBuilder>, que hospedará la lógica de IL para la propiedad.</span><span class="sxs-lookup"><span data-stu-id="f640b-732">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-733">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-733">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-734">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-734">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-735">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-735">-or-</span>
          </span>
          <span data-ttu-id="f640b-736">Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-736">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-737">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-737">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-738">Nombre de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-738">The name of the property.</span>
          </span>
          <span data-ttu-id="f640b-739">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-739">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-740">Atributos de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-740">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-741">Convención de llamada de los descriptores de acceso de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-741">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-742">Tipo de valor devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-742">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-743">Tipos de los parámetros de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-743">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-744">Agrega una nueva propiedad al tipo, con el nombre, atributos, convención de llamada y firma de la propiedad especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-744">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-745">Propiedad definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-745">The defined property.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-746">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-746">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-747">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-747">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-748">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-748">-or-</span>
          </span>
          <span data-ttu-id="f640b-749">Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-749">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-750">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-750">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-751">Nombre de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-751">The name of the property.</span>
          </span>
          <span data-ttu-id="f640b-752">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-752">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-753">Atributos de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-753">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-754">Tipo de valor devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-754">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-755">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-755">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="f640b-756">Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-756">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-757">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-757">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="f640b-758">Si el tipo de valor devuelto no tiene ningún modificador personalizado opcional, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-758">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-759">Tipos de los parámetros de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-759">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-760">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-760">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-761">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-761">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-762">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-762">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-763">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-763">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-764">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-764">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-765">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-765">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-766">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-766">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-767">Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-767">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-768">Agrega una nueva propiedad al tipo, con el nombre proporcionado, la firma de la propiedad y los modificadores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-768">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-769">Propiedad definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-769">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-770">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</span><span class="sxs-lookup"><span data-stu-id="f640b-770">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-771">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-771">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="f640b-772">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-772">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-773">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-773">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-774">
            <paramref name="name" /> es <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-774">
              <paramref name="name" /> is <see langword="null" /></span>
          </span>
          <span data-ttu-id="f640b-775">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-775">-or-</span>
          </span>
          <span data-ttu-id="f640b-776">Alguno de los elementos de la matriz de <paramref name="parameterTypes" /> es <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-776">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-777">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-777">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-778">Nombre de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-778">The name of the property.</span>
          </span>
          <span data-ttu-id="f640b-779">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-779">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-780">Atributos de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-780">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="f640b-781">Convención de llamada de los descriptores de acceso de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-781">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f640b-782">Tipo de valor devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-782">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-783">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-783">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="f640b-784">Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-784">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-785">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-785">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="f640b-786">Si el tipo de valor devuelto no tiene ningún modificador personalizado opcional, especifique <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-786">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="f640b-787">Tipos de los parámetros de la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-787">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="f640b-788">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-788">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-789">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-789">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-790">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-790">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-791">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-791">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="f640b-792">Matriz de matrices de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-792">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="f640b-793">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-793">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="f640b-794">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-794">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="f640b-795">Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-795">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-796">Agrega una nueva propiedad al tipo, con el nombre proporcionado, la convención de llamada, la firma de la propiedad y los modificadores personalizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-796">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-797">Propiedad definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-797">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-798">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</span><span class="sxs-lookup"><span data-stu-id="f640b-798">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-799">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</span><span class="sxs-lookup"><span data-stu-id="f640b-799">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="f640b-800">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-800">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="f640b-801">Esta sobrecarga del método se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="f640b-801">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-802">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-802">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-803">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-803">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-804">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-804">-or-</span>
          </span>
          <span data-ttu-id="f640b-805">Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-805">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-806">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-806">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberSignature Language="F#" Value="member this.DefineTypeInitializer : unit -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineTypeInitializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-807">Define el inicializador para este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-807">Defines the initializer for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-808">Devuelve un inicializador de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-808">Returns a type initializer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-809">El inicializador creado siempre es público.</span><span class="sxs-lookup"><span data-stu-id="f640b-809">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-810">Ejemplo de código siguiente muestra cómo crear un constructor de inicialización mediante `DefineTypeInitializer`.</span><span class="sxs-lookup"><span data-stu-id="f640b-810">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-811">Tipo contenedor que se ha creado anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-811">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-812">El nombre que se usa para hacer referencia a los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-812">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="f640b-813">
            <c>name</c> no puede contener valores null insertados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-813">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="f640b-814">Tamaño del campo de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-814">The size of the data field.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="f640b-815">Los atributos para este campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-815">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-816">Define un campo de datos inicializado en la sección <see langword=".sdata" /> del archivo portable ejecutable (PE).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-816">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-817">Campo para hacer referencia a los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-817">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-818">El campo que se crea con este método será `static`, incluso si no incluye `FieldAttributes.Static` en el `attributes` parámetro.</span><span class="sxs-lookup"><span data-stu-id="f640b-818">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-819">Ejemplo de código siguiente muestra el uso de `DefineUninitializedData` para crear un campo de datos inicializado en un tipo dinámico:</span><span class="sxs-lookup"><span data-stu-id="f640b-819">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-820">La longitud de <paramref name="name" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-820">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="f640b-821">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-821">-or-</span>
          </span>
          <span data-ttu-id="f640b-822">
            <paramref name="size" /> es menor o igual que cero, o mayor o igual que 0x003f0000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-822">
              <paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-823">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-823">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-824">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-824">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-825">Recupera la ruta de acceso completa de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-825">Retrieves the full path of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-826">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-826">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-827">Recupera la ruta de acceso completa de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-827">Retrieves the full path of this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-828">El formato devuelto es "enclosingTypeFullName+nestedTypeName + en el caso" para los tipos anidados y "typeName" para tipos no anidados.</span><span class="sxs-lookup"><span data-stu-id="f640b-828">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-829">Obtiene un valor que indica la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-829">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-830">Combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-830">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="f640b-831">Cuando se emite el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de por un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-831">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-832">Obtiene la posición de un parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-832">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-833">Si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico, la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro; en otro caso, sin definir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-833">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="f640b-834">Cuando se emite el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de por un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-834">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="f640b-835">Si el actual <xref:System.Reflection.Emit.TypeBuilder> no representa un parámetro de tipo genérico, el valor de esta propiedad es indefinido.</span><span class="sxs-lookup"><span data-stu-id="f640b-835">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="f640b-836">Use la <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propiedad para determinar si el actual <xref:System.Reflection.Emit.TypeBuilder> representa un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-836">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberSignature Language="F#" Value="override this.GetArrayRank : unit -&gt; int" Usage="typeBuilder.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeBuilder.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member GetConstructor : Type * System.Reflection.ConstructorInfo -&gt; System.Reflection.ConstructorInfo" Usage="System.Reflection.Emit.TypeBuilder.GetConstructor (type, constructor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f640b-837">Tipo genérico construido cuyo constructor se devuelve.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-837">The constructed generic type whose constructor is returned.</span>
          </span>
        </param>
        <param name="constructor">
          <span data-ttu-id="f640b-838">Constructor de la definición de tipo genérico de <c>type</c>, que especifica qué constructor de <c>type</c> devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-838">A constructor on the generic type definition of <c>type</c>, which specifies which constructor of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-839">Devuelve el constructor del tipo genérico construido especificado que corresponde al constructor especificado de la definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-839">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-840">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor de <paramref name="type" /> correspondiente a <paramref name="constructor" />, que especifica un constructor perteneciente a la definición de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-840">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-841">El <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método proporciona una manera de obtener un <xref:System.Reflection.ConstructorInfo> objeto que representa un constructor de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-841">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="f640b-842">Por ejemplo, suponga que tiene un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo `G<T>` en sintaxis de C# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) y un <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa un constructor de `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="f640b-842">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="f640b-843">Suponga que `G<T>` tiene un método genérico con el parámetro de tipo `U` que crea una instancia del tipo construido `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="f640b-843">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="f640b-844">Para emitir el código para crear una instancia del tipo construido, se necesita un <xref:System.Reflection.ConstructorInfo> objeto que representa el constructor de este tipo construido, es decir, que crea una instancia de `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="f640b-844">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type — in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="f640b-845">Para ello, primero llame a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en el <xref:System.Reflection.Emit.TypeBuilder> objeto, especificando el <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-845">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="f640b-846">A continuación, llame a la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método con el valor devuelto de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parámetro `type` y el <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa el constructor de `G<U>` como parámetro `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f640b-846">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="f640b-847">El valor devuelto es el <xref:System.Reflection.ConstructorInfo> objeto deberá emitir la llamada de función.</span><span class="sxs-lookup"><span data-stu-id="f640b-847">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="f640b-848">El ejemplo de código muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="f640b-848">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-849">El siguiente ejemplo de código contiene código fuente para una clase genérica denominada `Sample` que tiene un parámetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-849">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="f640b-850">La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico denominado `GM` con su propio parámetro de tipo, denominado `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-850">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="f640b-851">Método `GM` crea una instancia de `Sample`, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de `Sample`y almacena su parámetro de entrada en `Field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-851">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="f640b-852">Este código fuente se compila, pero no se usa; puede verla en el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) y compararlo con el código emitido por la clase `Example`.</span><span class="sxs-lookup"><span data-stu-id="f640b-852">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="f640b-853">El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método para emitir código genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-853">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="f640b-854">El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample` y usa el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-854">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="f640b-855">Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-855">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="f640b-856">Un método `GM` se agregan y se convierte en un método genérico utilizando el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-856">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-857">El parámetro de tipo de `GM` se denomina `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-857">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="f640b-858">Una vez definido el parámetro de tipo, la firma de `GM` se agrega mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-858">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-859">No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`; `parameterTypes` establece el tipo de parámetro del método solo `U`, parámetro de tipo genérico del método.</span><span class="sxs-lookup"><span data-stu-id="f640b-859">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="f640b-860">El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-860">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="f640b-861">El <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método se usa para crear un <xref:System.Reflection.ConstructorInfo> que representa el constructor predeterminado del tipo genérico construido `Sample<U>` en el <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instrucción que crea la instancia.</span><span class="sxs-lookup"><span data-stu-id="f640b-861">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the default constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="f640b-862">Se define un tipo ficticio que contenga el método de punto de entrada `Main`.</span><span class="sxs-lookup"><span data-stu-id="f640b-862">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="f640b-863">En el cuerpo de `Main`, estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo <xref:System.String> sustituyen por `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-863">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="f640b-864">Cuando se ejecuta el ejemplo de código, guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="f640b-864">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="f640b-865">Puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.</span><span class="sxs-lookup"><span data-stu-id="f640b-865">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-866">
            <paramref name="type" /> no representa un tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-866">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="f640b-867">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-867">-or-</span>
          </span>
          <span data-ttu-id="f640b-868">
            <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-868">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="f640b-869">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-869">-or-</span>
          </span>
          <span data-ttu-id="f640b-870">El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-870">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="f640b-871">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-871">-or-</span>
          </span>
          <span data-ttu-id="f640b-872">El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-872">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeBuilder.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeBuilder.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-873">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo en <see langword="InvokeMethod" />, <see langword="NonPublic" />, entre otros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-873">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-874">Devuelve una matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa a los constructores públicos y no públicos definidos para esta clase, tal y como se especifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-874">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-875">Devuelve una matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa a los constructores especificados definidos para esta clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-875">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span>
          </span>
          <span data-ttu-id="f640b-876">Si no se definen constructores, se devuelve una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-876">If no constructors are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-877">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-877">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-878">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-878">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-879">Devuelve los atributos personalizados definidos para este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-879">Returns the custom attributes defined for this type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="f640b-880">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-880">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-881">Devuelve todos los atributos personalizados definidos para este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-881">Returns all the custom attributes defined for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-882">Devuelve una matriz de objetos que representan todos los atributos personalizados de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-882">Returns an array of objects representing all the custom attributes of this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-883">Este método no se admite actualmente para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-883">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="f640b-884">Recupere el tipo mediante el método <see cref="M:System.Type.GetType" /> y llame al método <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Type" /> devuelto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-884">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="f640b-885">El tipo de atributo que se va a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-885">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="f640b-886">Solo se devuelven los atributos que son asignables a este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-886">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="f640b-887">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-887">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-888">Devuelve todos los atributos personalizados del tipo actual que se pueden asignar a un tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-888">Returns all the custom attributes of the current type that are assignable to a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-889">Una matriz de atributos personalizados definidos en el tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-889">An array of custom attributes defined on the current type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-890">Este método no se admite actualmente para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-890">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="f640b-891">Recupere el tipo mediante el método <see cref="M:System.Type.GetType" /> y llame al método <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Type" /> devuelto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-891">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-892">
            <paramref name="attributeType" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-892">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-893">El tipo debe ser un tipo proporcionado por el sistema en tiempo de ejecución subyacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-893">The type must be a type provided by the underlying runtime system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeBuilder.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-894">Cuando se llama a este método, siempre se produce <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-894">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-895">No se admite este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-895">This method is not supported.</span>
          </span>
          <span data-ttu-id="f640b-896">No se devuelve ningún valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-896">No value is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-897">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-897">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-898">No se admite este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-898">This method is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeBuilder.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-899">Nombre del evento que se va a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-899">The name of the event to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-900">Combinación bit a bit de valores de <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-900">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-901">Devuelve el evento con el nombre especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-901">Returns the event with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-902">Un objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento declarado o heredado por este tipo con el nombre especificado, o <see langword="null" /> si no hay ninguna coincidencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-902">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-903">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-903">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-904">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-904">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-905">Devuelve los eventos definidos por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-905">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-906">Devuelve los eventos públicos declarados o heredados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-906">Returns the public events declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-907">Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa a los eventos públicos declarados o heredados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-907">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="f640b-908">Se devuelve una matriz vacía si no hay eventos públicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-908">An empty array is returned if there are no public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-909">Recupera el tipo mediante <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetType%2A> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-909">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-910">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-910">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-911">Combinación bit a bit de valores de <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-911">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-912">Devuelve los eventos públicos y no públicos declarados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-912">Returns the public and non-public events that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-913">Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos declarados o heredados por este tipo que coinciden con los marcadores de enlace especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-913">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span>
          </span>
          <span data-ttu-id="f640b-914">Se devuelve una matriz vacía si no hay eventos coincidentes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-914">An empty array is returned if there are no matching events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-915">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-915">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-916">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-916">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-917">Devuelve un campo definido por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-917">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-918">Nombre del campo que se va a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-918">The name of the field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-919">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo en <see langword="InvokeMethod" />, <see langword="NonPublic" />, entre otros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-919">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-920">Devuelve el campo especificado por el nombre facilitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-920">Returns the field specified by the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-921">Devuelve el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa al campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-921">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span>
          </span>
          <span data-ttu-id="f640b-922">Si no existen coincidencias, se devolverá <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-922">If there are no matches then <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-923">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-923">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-924">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-924">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member GetField : Type * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.Emit.TypeBuilder.GetField (type, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f640b-925">Tipo genérico construido cuyo campo se devuelve.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-925">The constructed generic type whose field is returned.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="f640b-926">Campo de la definición de tipo genérico de <c>type</c>, que especifica qué campo de <c>type</c> se va a devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-926">A field on the generic type definition of <c>type</c>, which specifies which field of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-927">Devuelve el campo del tipo genérico construido especificado que corresponde al campo especificado de la definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-927">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-928">Objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo de <paramref name="type" /> correspondiente a <paramref name="field" />, que especifica un campo perteneciente a la definición de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-928">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-929">El <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método proporciona una manera de obtener un <xref:System.Reflection.FieldInfo> objeto que representa un campo de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-929">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="f640b-930">Por ejemplo, suponga que tiene un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo `G<T>` en sintaxis de C# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) y un <xref:System.Reflection.Emit.FieldBuilder> objeto que representa un campo `public T F` en sintaxis de C# (`Public F As T`en Visual Basic, `public: T F` en C++) que se define mediante `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="f640b-930">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="f640b-931">Suponga que `G<T>` tiene un método genérico con el parámetro de tipo `U` que crea una instancia del tipo construido `G<U>` y campo llamadas `F` en esa instancia.</span><span class="sxs-lookup"><span data-stu-id="f640b-931">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="f640b-932">Para emitir la llamada de función, se necesita un <xref:System.Reflection.FieldInfo> objeto que representa `F` en el tipo construido, en otras palabras, que es de tipo `U` en lugar de tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-932">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type — in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="f640b-933">Para ello, primero llame a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en el <xref:System.Reflection.Emit.TypeBuilder> objeto, especificando el <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-933">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="f640b-934">A continuación, llame a la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método con el valor devuelto de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parámetro `type` y el <xref:System.Reflection.Emit.FieldBuilder> objeto que representa `F` como parámetro `field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-934">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="f640b-935">El valor devuelto es el <xref:System.Reflection.FieldInfo> objeto deberá emitir la llamada de función.</span><span class="sxs-lookup"><span data-stu-id="f640b-935">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="f640b-936">El ejemplo de código muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="f640b-936">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-937">El siguiente ejemplo de código contiene código fuente para una clase genérica denominada Sample que tiene un parámetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-937">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="f640b-938">La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico denominado `GM` con su propio parámetro de tipo, denominado `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-938">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="f640b-939">Método `GM` crea una instancia de `Sample`, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de `Sample`y almacena su parámetro de entrada en `Field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-939">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="f640b-940">Este código fuente se compila, pero no se usa; puede verla en el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) y compararlo con el código emitido por la clase `Example`.</span><span class="sxs-lookup"><span data-stu-id="f640b-940">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="f640b-941">El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método para emitir código genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-941">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="f640b-942">El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample`y usa el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-942">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="f640b-943">Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-943">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="f640b-944">Un método `GM` se agregan y se convierte en un método genérico utilizando el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-944">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-945">El parámetro de tipo de `GM` se denomina `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-945">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="f640b-946">Una vez definido el parámetro de tipo, la firma de `GM` se agrega mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-946">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-947">No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`; `parameterTypes` establece el tipo de parámetro del método solo `U`, parámetro de tipo genérico del método.</span><span class="sxs-lookup"><span data-stu-id="f640b-947">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="f640b-948">El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-948">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="f640b-949">El <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método se usa para crear un <xref:System.Reflection.FieldInfo> que representa el campo de tipo genérico construido `Sample<U>` en el <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> y <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instrucciones.</span><span class="sxs-lookup"><span data-stu-id="f640b-949">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="f640b-950">Se define un tipo ficticio que contenga el método de punto de entrada `Main`.</span><span class="sxs-lookup"><span data-stu-id="f640b-950">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="f640b-951">En el cuerpo de `Main`, estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo <xref:System.String> sustituyen por `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-951">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="f640b-952">Cuando se ejecuta el ejemplo de código, guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="f640b-952">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="f640b-953">Puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.</span><span class="sxs-lookup"><span data-stu-id="f640b-953">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-954">
            <paramref name="type" /> no representa un tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-954">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="f640b-955">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-955">-or-</span>
          </span>
          <span data-ttu-id="f640b-956">
            <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-956">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="f640b-957">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-957">-or-</span>
          </span>
          <span data-ttu-id="f640b-958">El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-958">The declaring type of <paramref name="field" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="f640b-959">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-959">-or-</span>
          </span>
          <span data-ttu-id="f640b-960">El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-960">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeBuilder.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-961">Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-961">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-962">Devuelve los campos públicos y no públicos declarados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-962">Returns the public and non-public fields that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-963">Devuelve una matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa a los campos públicos y no públicos declarados o heredados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-963">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="f640b-964">Se devuelve una matriz vacía si no hay ningún campo,  como se especifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-964">An empty array is returned if there are no fields, as specified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-965">El <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> método no devuelve los campos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="f640b-965">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="f640b-966">El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.</span><span class="sxs-lookup"><span data-stu-id="f640b-966">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="f640b-967">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-967">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-968">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-968">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="typeBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-969">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-969">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-970">Matriz de objetos <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-970">An array of <see cref="T:System.Type" /> objects.</span>
          </span>
          <span data-ttu-id="f640b-971">Los elementos de la matriz representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-971">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-972">Los elementos de la matriz devuelta están en el orden en que aparecen en la lista de parámetros de tipo para la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-972">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="f640b-973">Un <xref:System.Reflection.Emit.TypeBuilder> objeto representa una definición de tipo genérico si el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método se ha utilizado para darle parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-973">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="f640b-974">Este método recupera el <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objetos que representan los parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-974">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="f640b-975">Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="f640b-975">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="typeBuilder.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="typeBuilder.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-976">Devuelve un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-976">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-977">Objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-977">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-978">Si se llama a la <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> método en un <xref:System.Reflection.Emit.TypeBuilder> objeto para el que el <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propiedad devuelve `true`, el <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> propiedad devuelve la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="f640b-978">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="f640b-979">Un <xref:System.Reflection.Emit.TypeBuilder> siempre es una definición de tipo genérico que representa un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-979">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="f640b-980">Si ha usado el <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método para construir un tipo genérico a partir un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa una definición de tipo genérico utilizando el <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> vuelve el método en el tipo construido el <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo genérico definición.</span><span class="sxs-lookup"><span data-stu-id="f640b-980">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-981">El tipo actual no es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-981">The current type is not generic.</span>
          </span>
          <span data-ttu-id="f640b-982">Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> devuelve <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-982">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeBuilder.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-983">Nombre de la interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-983">The name of the interface.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f640b-984">Si es <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-984">If <see langword="true" />, the search is case-insensitive.</span>
          </span>
          <span data-ttu-id="f640b-985">Si es <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-985">If <see langword="false" />, the search is case-sensitive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-986">Devuelve la interfaz implementada por esta clase (directa o indirectamente) con el nombre completo que coincide con el nombre de la interfaz dada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-986">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-987">Devuelve un objeto <see cref="T:System.Type" /> que representa a la interfaz implementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-987">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span>
          </span>
          <span data-ttu-id="f640b-988">Devuelve null si no se encuentra ningún nombre de interfaz coincidente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-988">Returns null if no interface matching name is found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-989">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-989">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-990">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-990">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeBuilder.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="f640b-991">
            <see cref="T:System.Type" /> de la interfaz para el que se va a recuperar la asignación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-991">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-992">Devuelve una asignación de interfaz para la interfaz solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-992">Returns an interface mapping for the requested interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-993">Devuelve la asignación de interfaz solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-993">Returns the requested interface mapping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-994">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-994">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-995">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-995">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeBuilder.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-996">Devuelve una matriz de todas las interfaces implementadas en este tipo y sus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-996">Returns an array of all the interfaces implemented on this type and its base types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-997">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representa a las interfaces implementadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-997">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span>
          </span>
          <span data-ttu-id="f640b-998">Si no hay ninguna definida, se devuelve una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-998">If none are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-999">Nombre del miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-999">The name of the member.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f640b-1000">Tipo del miembro que se va a devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1000">The type of the member to return.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-1001">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en el caso de <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1001">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1002">Devuelve todos los miembros públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1002">Returns all the public and non-public members declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1003">Si se utiliza <paramref name="nonPublic" />, devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa a los miembros públicos y no públicos definidos en este tipo, en caso contrario, solo devuelve los miembros públicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1003">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1004">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1004">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1005">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1005">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-1006">Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo, <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1006">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1007">Devuelve los miembros para los miembros públicos y no públicos declarados o heredados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1007">Returns the members for the public and non-public members declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1008">Devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa a los miembros públicos y no públicos declarados o heredados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1008">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="f640b-1009">Se devuelve una matriz vacía si no hay miembros coincidentes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1009">An empty array is returned if there are no matching members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1010">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1010">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1011">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1011">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GetMethod : Type * System.Reflection.MethodInfo -&gt; System.Reflection.MethodInfo" Usage="System.Reflection.Emit.TypeBuilder.GetMethod (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f640b-1012">Tipo genérico construido cuyo método se devuelve.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1012">The constructed generic type whose method is returned.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f640b-1013">Método de la definición de tipo genérico de <c>type</c>, que especifica qué método de <c>type</c> se va a devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1013">A method on the generic type definition of <c>type</c>, which specifies which method of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1014">Devuelve el método del tipo genérico construido especificado que corresponde al método especificado de la definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1014">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1015">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de <paramref name="type" /> correspondiente a <paramref name="method" />, que especifica un método perteneciente a la definición de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1015">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1016">El <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método proporciona una manera de obtener un <xref:System.Reflection.MethodInfo> objeto que representa un método de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-1016">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="f640b-1017">Por ejemplo, suponga que tiene un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo `G<T>` en sintaxis de C# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) y un <xref:System.Reflection.Emit.MethodBuilder> objeto que representa un método `T M()` en sintaxis de C# (`Function M() As T`en Visual Basic, `T M()` en C++) que se define mediante `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1017">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="f640b-1018">Suponga que `G<T>` tiene un método genérico con el parámetro de tipo `U` que crea una instancia del tipo construido `G<U>` y llama al método `M` en esa instancia.</span><span class="sxs-lookup"><span data-stu-id="f640b-1018">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="f640b-1019">Para emitir la llamada de función, se necesita un <xref:System.Reflection.MethodInfo> objeto que representa `M` en el tipo construido, en otras palabras, que devuelve tipo `U` en lugar de tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1019">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type — in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="f640b-1020">Para ello, primero llame a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en el <xref:System.Reflection.Emit.TypeBuilder> objeto, especificando el <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-1020">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="f640b-1021">A continuación, llame a la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método con el valor devuelto de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parámetro `type` y el <xref:System.Reflection.Emit.MethodBuilder> objeto que representa `T M()` como parámetro `method`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1021">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="f640b-1022">El valor devuelto es el <xref:System.Reflection.MethodInfo> objeto deberá emitir la llamada de función.</span><span class="sxs-lookup"><span data-stu-id="f640b-1022">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="f640b-1023">El ejemplo de código muestra un escenario similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="f640b-1023">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-1024">El siguiente ejemplo de código contiene código fuente para una clase genérica denominada `Sample` que tiene un parámetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1024">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="f640b-1025">La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico denominado `GM` con su propio parámetro de tipo, denominado `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1025">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="f640b-1026">Método `GM` crea una instancia de `Sample`, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de `Sample`y almacena su parámetro de entrada en `Field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1026">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="f640b-1027">Este código fuente se compila, pero no se usa; puede verla en el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) y compararlo con el código emitido por la clase `Example`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1027">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="f640b-1028">El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método para emitir código genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1028">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="f640b-1029">El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample` y usa el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1029">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="f640b-1030">Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1030">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="f640b-1031">Un método `GM` se agregan y se convierte en un método genérico utilizando el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1031">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-1032">El parámetro de tipo de `GM` se denomina `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1032">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="f640b-1033">Una vez definido el parámetro de tipo, la firma de `GM` se agrega mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1033">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f640b-1034">No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`; `parameterTypes` establece el tipo de parámetro del método solo `U`, parámetro de tipo genérico del método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1034">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="f640b-1035">El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1035">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="f640b-1036">Se define un tipo ficticio que contenga el método de punto de entrada `Main`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1036">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="f640b-1037">En el cuerpo de `Main`, estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo <xref:System.String> sustituyen por `U`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1037">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="f640b-1038">El <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método se usa para crear un <xref:System.Reflection.MethodInfo> para estático `GM` método del tipo genérico construido `Sample<U>`y el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> , a continuación, se usa el método para crear un <xref:System.Reflection.MethodInfo> que pueden emitir una llamada al método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1038">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="f640b-1039">Cuando se ejecuta el ejemplo de código, guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="f640b-1039">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="f640b-1040">Puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.</span><span class="sxs-lookup"><span data-stu-id="f640b-1040">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-1041">
            <paramref name="method" /> es un método genérico que no es una definición de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1041">
              <paramref name="method" /> is a generic method that is not a generic method definition.</span>
          </span>
          <span data-ttu-id="f640b-1042">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1042">-or-</span>
          </span>
          <span data-ttu-id="f640b-1043">
            <paramref name="type" /> no representa un tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1043">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="f640b-1044">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1044">-or-</span>
          </span>
          <span data-ttu-id="f640b-1045">
            <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1045">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="f640b-1046">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1046">-or-</span>
          </span>
          <span data-ttu-id="f640b-1047">El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1047">The declaring type of <paramref name="method" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="f640b-1048">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1048">-or-</span>
          </span>
          <span data-ttu-id="f640b-1049">El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1049">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeBuilder.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-1050">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo en <see langword="InvokeMethod" />, <see langword="NonPublic" />, entre otros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1050">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1051">Devuelve todos los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1051">Returns all the public and non-public methods declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1052">Si se utiliza <paramref name="nonPublic" />, devuelve una matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representa los métodos públicos y no públicos definidos en este tipo, en caso contrario, solo devuelve los métodos públicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1052">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1053">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1053">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1054">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1054">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeBuilder.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-1055">
            <see cref="T:System.String" /> que contiene el nombre del tipo anidado que se va a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1055">The <see cref="T:System.String" /> containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-1056">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1056">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="f640b-1057">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1057">-or-</span>
          </span>
          <span data-ttu-id="f640b-1058">Cero, para realizar una búsqueda de los métodos públicos que distinga entre mayúsculas y minúsculas. </span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1058">Zero, to conduct a case-sensitive search for public methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1059">Devuelve los tipos anidados públicos y no públicos declarados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1059">Returns the public and non-public nested types that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1060">Objeto <see cref="T:System.Type" /> que representa el tipo anidado que coincide con los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1060">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1061">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1061">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="f640b-1062">Si este tipo es completo, por ejemplo, si `CreateType` se ha llamado en este tipo, pero hay tipos anidados que no están completos, a continuación, `GetNestedTypes` solo devolverá los tipos anidados que `CreateType` se ha llamado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1062">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1063">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1063">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeBuilder.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-1064">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en el caso de <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1064">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1065">Devuelve los tipos anidados públicos y no públicos declarados o heredados por este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1065">Returns the public and non-public nested types that are declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1066">Matriz de objetos <see cref="T:System.Type" /> que representa a todos los tipos anidados en el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1066">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="f640b-1067">Matriz vacía de tipo <see cref="T:System.Type" /> si no hay tipos anidados en el objeto <see cref="T:System.Type" /> actual o si ninguno de los tipos anidados coincide con las restricciones de enlace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1067">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1068">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1068">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="f640b-1069">Si este tipo es completo, por ejemplo, si `CreateType` se ha llamado en este tipo, pero hay tipos anidados que no están completos, a continuación, `GetNestedTypes` solo devolverá los tipos anidados que `CreateType` se ha llamado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1069">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1070">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1070">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeBuilder.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="f640b-1071">Este atributo de invocación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1071">This invocation attribute.</span>
          </span>
          <span data-ttu-id="f640b-1072">Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1072">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1073">Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, como se especifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1073">Returns all the public and non-public properties declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1074">Si se utiliza <paramref name="nonPublic" />, devuelve una matriz de objetos <see langword="PropertyInfo" /> que representa a las propiedades públicas y no públicas definidas en este tipo; en caso contrario, solo devuelve las propiedades públicas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1074">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1075">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1075">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1076">Este método no se implementa para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1076">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeBuilder.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1077">Recupera el GUID de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1077">Retrieves the GUID of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1078">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1078">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1079">Recupera el GUID de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1079">Retrieves the GUID of this type</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1080">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1080">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1081">Este método no se admite actualmente para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1081">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeBuilder.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeBuilder.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f640b-1082">Nombre del miembro que se va a invocar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1082">The name of the member to invoke.</span>
          </span>
          <span data-ttu-id="f640b-1083">Puede ser un constructor, un método, una propiedad o un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1083">This can be a constructor, method, property, or field.</span>
          </span>
          <span data-ttu-id="f640b-1084">Debe especificarse un atributo de invocación apropiado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1084">A suitable invocation attribute must be specified.</span>
          </span>
          <span data-ttu-id="f640b-1085">Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1085">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="f640b-1086">Atributo de invocación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1086">The invocation attribute.</span>
          </span>
          <span data-ttu-id="f640b-1087">Debe ser una marca de bits de <see langword="BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1087">This must be a bit flag from <see langword="BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f640b-1088">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1088">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="f640b-1089">Si el enlazador es <see langword="null" /> se utilizará el enlazador predeterminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1089">If binder is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="f640b-1090">Vea <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1090">See <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="f640b-1091">Objeto donde debe invocarse al miembro especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1091">The object on which to invoke the specified member.</span>
          </span>
          <span data-ttu-id="f640b-1092">Si el miembro es estático, se ignora este parámetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1092">If the member is static, this parameter is ignored.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f640b-1093">Lista de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1093">An argument list.</span>
          </span>
          <span data-ttu-id="f640b-1094">Se trata de una matriz de objetos que contiene el número, orden y tipo de los parámetros del miembro que se va a invocar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1094">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span>
          </span>
          <span data-ttu-id="f640b-1095">Si no hay ningún parámetro, este valor debe ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1095">If there are no parameters this should be null.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="f640b-1096">Matriz de la misma longitud que <c>args</c> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1096">An array of the same length as <c>args</c> with elements that represent the attributes associated with the arguments of the member to be invoked.</span>
          </span>
          <span data-ttu-id="f640b-1097">Un parámetro tiene atributos asociados a él en los metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1097">A parameter has attributes associated with it in the metadata.</span>
          </span>
          <span data-ttu-id="f640b-1098">Los usan varios servicios de interoperabilidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1098">They are used by various interoperability services.</span>
          </span>
          <span data-ttu-id="f640b-1099">Consulte las especificaciones de metadatos para obtener más detalles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1099">See the metadata specs for more details.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f640b-1100">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1100">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="f640b-1101">Si es null, se utiliza la clase <see langword="CultureInfo" /> para el subproceso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1101">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="f640b-1102">(Por ejemplo, esto es necesario para convertir un tipo String que representa 1000 en un valor Double, dado que 1000 se representa de manera diferente según la referencia cultural).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1102">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="f640b-1103">Cada parámetro de la matriz <c>namedParameters</c> obtiene el valor del elemento correspondiente de la matriz <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1103">Each parameter in the <c>namedParameters</c> array gets the value in the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="f640b-1104">Si la longitud de <c>args</c> es mayor que la longitud de <c>namedParameters</c>, los valores de argumento restantes se pasan en orden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1104">If the length of <c>args</c> is greater than the length of <c>namedParameters</c>, the remaining argument values are passed in order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1105">Invoca el miembro especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1105">Invokes the specified member.</span>
          </span>
          <span data-ttu-id="f640b-1106">El método que se va a invocar debe ser accesible y proporcionar la coincidencia más específica con la lista de argumentos dada, bajo las restricciones del enlazador y los atributos de invocación indicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1106">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1107">Devuelve el valor devuelto del miembro invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1107">Returns the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1108">Un método se invocará si el número de parámetros en la declaración del método es igual al número de argumentos de la lista de argumentos especificados, y se puede convertir el tipo de cada argumento por el enlazador para el tipo del parámetro.</span><span class="sxs-lookup"><span data-stu-id="f640b-1108">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="f640b-1109">El enlazador encontrará todos los métodos de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="f640b-1109">The binder will find all of the matching methods.</span></span> <span data-ttu-id="f640b-1110">Estos métodos se encuentran en función del tipo de enlace solicitado (BindingFlags.InvokeMethod, BindingFlags.GetProperties y así sucesivamente.).</span><span class="sxs-lookup"><span data-stu-id="f640b-1110">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="f640b-1111">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</span><span class="sxs-lookup"><span data-stu-id="f640b-1111">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="f640b-1112">Después de selecciona el método, se invocará.</span><span class="sxs-lookup"><span data-stu-id="f640b-1112">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="f640b-1113">En ese momento se comprueba la accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1113">Accessibility is checked at that point.</span></span> <span data-ttu-id="f640b-1114">La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1114">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="f640b-1115">El `IBinder.BindToMethod` método es responsable de seleccionar el método que se debe invocar.</span><span class="sxs-lookup"><span data-stu-id="f640b-1115">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="f640b-1116">El enlazador predeterminado, selecciona a la coincidencia más específica.</span><span class="sxs-lookup"><span data-stu-id="f640b-1116">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1117">Se omiten las restricciones de acceso para el código de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="f640b-1117">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="f640b-1118">Es decir, las propiedades, métodos, campos y constructores privados se pueden tener acceso e invocan mediante reflexión, siempre que el código es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="f640b-1118">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="f640b-1119">Este método no se admite actualmente.</span><span class="sxs-lookup"><span data-stu-id="f640b-1119">This method is not currently supported.</span></span> <span data-ttu-id="f640b-1120">Puede recuperar el tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1120">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1121">Este método no se admite actualmente para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1121">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeBuilder.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1122">Determina si se puede asignar un tipo especificado a este objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1122">Determines whether a specified type can be assigned to this object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeBuilder.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">
          <span data-ttu-id="f640b-1123">El objeto que se va a probar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1123">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1124">Obtiene un valor que indica si se puede asignar a este objeto un objeto <see cref="T:System.Reflection.TypeInfo" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1124">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1125">
            <see langword="true" /> si <paramref name="typeInfo" /> puede asignarse a este objeto; si no, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1125">
              <see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Type -&gt; bool" Usage="typeBuilder.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="f640b-1126">El objeto que se va a probar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1126">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1127">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> especificado puede asignarse a este objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1127">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1128">Es <see langword="true" /> si el parámetro <paramref name="c" /> y el tipo actual representan el mismo tipo, o si el tipo actual se encuentra en la jerarquía de herencia de <paramref name="c" />, o si el tipo actual es una interfaz compatible con <paramref name="c" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1128">
              <see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span>
          </span>
          <span data-ttu-id="f640b-1129">Es <see langword="false" /> si ninguna de estas condiciones son válidas o si <paramref name="c" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1129">
              <see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeBuilder.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeBuilder.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1130">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1130">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1131">
            <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1131">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberSignature Language="F#" Value="member this.IsCreated : unit -&gt; bool" Usage="typeBuilder.IsCreated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1132">Devuelve un valor que indica si se ha creado el tipo dinámico actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1132">Returns a value that indicates whether the current dynamic type has been created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1133">
            <see langword="true" /> si se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1133">
              <see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1134">Después de la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se ha llamado al método, el tipo representado por la <xref:System.Reflection.Emit.TypeBuilder> objeto completada.</span><span class="sxs-lookup"><span data-stu-id="f640b-1134">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="f640b-1135">Las excepciones se producen en los demás intentos de agregar a miembros o cambiar otras características del tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-1135">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="f640b-1136">El tipo de atributo que se va a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1136">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="f640b-1137">Solo se devuelven los atributos que son asignables a este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1137">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="f640b-1138">Especifica si se debe buscar la cadena de herencia de este miembro para encontrar los atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1138">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1139">Determina si un atributo personalizado se aplica al tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1139">Determines whether a custom attribute is applied to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1140">
            <see langword="true" /> si hay definidas una o más instancias de <paramref name="attributeType" />, o de un atributo derivado de <paramref name="attributeType" />, en este tipo; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1140">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1141">Este método no se admite para los parámetros de tipo genérico incompletos.</span><span class="sxs-lookup"><span data-stu-id="f640b-1141">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="f640b-1142">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1142">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1143">Este método no se admite actualmente para tipos incompletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1143">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="f640b-1144">Recupere el tipo mediante el método <see cref="M:System.Type.GetType" /> y llame al método <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el objeto <see cref="T:System.Type" /> devuelto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1144">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-1145">
            <paramref name="attributeType" /> no se ha definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1145">
              <paramref name="attributeType" /> is not defined.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-1146">
            <paramref name="attributeType" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1146">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1147">Obtiene un valor que indica si el tipo actual es un parámetro de tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1147">Gets a value indicating whether the current type is a generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1148">
            <see langword="true" /> si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1148">
              <see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1149">Cuando se emite el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de por un <xref:System.Reflection.Emit.TypeBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="f640b-1149">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1150">Obtiene un valor que indica si el tipo actual es genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1150">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1151">
            <see langword="true" /> si el tipo representado por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual es genérico; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1151">
              <see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1152">Un <xref:System.Reflection.Emit.TypeBuilder> objeto representa una definición de tipo genérico si el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método se ha utilizado para darle parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1152">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="f640b-1153">Una instancia de la <xref:System.Reflection.Emit.TypeBuilder> clase genérica siempre es una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1153">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="f640b-1154">Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1154">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1155">Obtiene un valor que indica si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa una definición de tipo genérico a partir de la cual se pueden construir otros tipos genéricos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1155">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1156">
            <see langword="true" /> si este objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> representa una definición de tipo genérico; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1156">
              <see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1157">Un <xref:System.Reflection.Emit.TypeBuilder> objeto representa una definición de tipo genérico si el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método se ha utilizado para darle parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1157">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="f640b-1158">Una instancia de la <xref:System.Reflection.Emit.TypeBuilder> clase genérica siempre es una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1158">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="f640b-1159">Un <xref:System.Reflection.Emit.TypeBuilder> puede usarse para crear definiciones de tipo genérico, pero no tipos genéricos construidos.</span><span class="sxs-lookup"><span data-stu-id="f640b-1159">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="f640b-1160">Para obtener un tipo genérico construido, llame a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en un <xref:System.Reflection.Emit.TypeBuilder> que representa una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1160">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="f640b-1161">Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1161">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeBuilder.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeBuilder.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1162">Obtiene un valor que indica si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente y, por tanto, puede realizar operaciones críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1162">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1163">
            <see langword="true" /> si el tipo actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1163">
              <see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1164">El <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="f640b-1164">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="f640b-1165">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="f640b-1165">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="f640b-1166">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="f640b-1166">Security level</span></span>|<span data-ttu-id="f640b-1167">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="f640b-1167">IsSecurityCritical</span></span>|<span data-ttu-id="f640b-1168">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="f640b-1168">IsSecuritySafeCritical</span></span>|<span data-ttu-id="f640b-1169">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="f640b-1169">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="f640b-1170">Crítico</span><span class="sxs-lookup"><span data-stu-id="f640b-1170">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="f640b-1171">Crítico para la seguridad</span><span class="sxs-lookup"><span data-stu-id="f640b-1171">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="f640b-1172">Transparente</span><span class="sxs-lookup"><span data-stu-id="f640b-1172">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="f640b-1173">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="f640b-1173">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="f640b-1174">El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1174">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="f640b-1175">Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1175">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="f640b-1176">De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite.</span><span class="sxs-lookup"><span data-stu-id="f640b-1176">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="f640b-1177">Puede invalidar este comportamiento predeterminado mediante el <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga del método y especificar los atributos de seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1177">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="f640b-1178">No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código-crítico para la seguridad o crítico para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1178">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="f640b-1179">Los atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1179">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1180">Herencia predeterminada se limita a la evaluación del tiempo de ejecución de transparencia.</span><span class="sxs-lookup"><span data-stu-id="f640b-1180">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="f640b-1181">No hay atributos se aplican al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1181">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="f640b-1182">Si desea agregar los atributos de seguridad, debe aplicarlos usted mismo.</span><span class="sxs-lookup"><span data-stu-id="f640b-1182">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="f640b-1183">Para obtener más información sobre la reflexión emite y la transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1183">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="f640b-1184">Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1184">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1185">El tipo dinámico actual no se ha creado llamando al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1185">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1186">Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1186">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1187">
            <see langword="true" /> si el tipo actual es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es crítico para la seguridad o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1187">
              <see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1188">El <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="f640b-1188">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="f640b-1189">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="f640b-1189">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="f640b-1190">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="f640b-1190">Security level</span></span>|<span data-ttu-id="f640b-1191">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="f640b-1191">IsSecurityCritical</span></span>|<span data-ttu-id="f640b-1192">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="f640b-1192">IsSecuritySafeCritical</span></span>|<span data-ttu-id="f640b-1193">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="f640b-1193">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="f640b-1194">Crítico</span><span class="sxs-lookup"><span data-stu-id="f640b-1194">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="f640b-1195">Crítico para la seguridad</span><span class="sxs-lookup"><span data-stu-id="f640b-1195">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="f640b-1196">Transparente</span><span class="sxs-lookup"><span data-stu-id="f640b-1196">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="f640b-1197">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="f640b-1197">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="f640b-1198">El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1198">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="f640b-1199">Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1199">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="f640b-1200">De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite.</span><span class="sxs-lookup"><span data-stu-id="f640b-1200">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="f640b-1201">Puede invalidar este comportamiento predeterminado mediante el <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga del método y especificar los atributos de seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1201">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="f640b-1202">No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código-crítico para la seguridad o crítico para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1202">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="f640b-1203">Los atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1203">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1204">Herencia predeterminada se limita a la evaluación del tiempo de ejecución de transparencia.</span><span class="sxs-lookup"><span data-stu-id="f640b-1204">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="f640b-1205">No hay atributos se aplican al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1205">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="f640b-1206">Si desea agregar los atributos de seguridad, debe aplicarlos usted mismo.</span><span class="sxs-lookup"><span data-stu-id="f640b-1206">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="f640b-1207">Para obtener más información sobre la reflexión emite y la transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1207">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="f640b-1208">Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1208">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1209">El tipo dinámico actual no se ha creado llamando al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1209">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1210">Obtiene un valor que indica si el tipo actual es transparente y, por tanto, no puede realizar operaciones críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1210">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1211">Es <see langword="true" /> si el tipo es transparente para la seguridad; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1211">
              <see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1212">El <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="f640b-1212">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="f640b-1213">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="f640b-1213">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="f640b-1214">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="f640b-1214">Security level</span></span>|<span data-ttu-id="f640b-1215">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="f640b-1215">IsSecurityCritical</span></span>|<span data-ttu-id="f640b-1216">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="f640b-1216">IsSecuritySafeCritical</span></span>|<span data-ttu-id="f640b-1217">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="f640b-1217">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="f640b-1218">Crítico</span><span class="sxs-lookup"><span data-stu-id="f640b-1218">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="f640b-1219">Crítico para la seguridad</span><span class="sxs-lookup"><span data-stu-id="f640b-1219">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="f640b-1220">Transparente</span><span class="sxs-lookup"><span data-stu-id="f640b-1220">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="f640b-1221">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="f640b-1221">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="f640b-1222">El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1222">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="f640b-1223">Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1223">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="f640b-1224">De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite.</span><span class="sxs-lookup"><span data-stu-id="f640b-1224">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="f640b-1225">Puede invalidar este comportamiento predeterminado mediante el <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga del método y especificar los atributos de seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1225">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="f640b-1226">No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código-crítico para la seguridad o crítico para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="f640b-1226">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="f640b-1227">Los atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1227">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1228">Herencia predeterminada se limita a la evaluación del tiempo de ejecución de transparencia.</span><span class="sxs-lookup"><span data-stu-id="f640b-1228">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="f640b-1229">No hay atributos se aplican al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1229">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="f640b-1230">Si desea agregar los atributos de seguridad, debe aplicarlos usted mismo.</span><span class="sxs-lookup"><span data-stu-id="f640b-1230">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="f640b-1231">Para obtener más información sobre la reflexión emite y la transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1231">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="f640b-1232">Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1232">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1233">El tipo dinámico actual no se ha creado llamando al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1233">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsSubclassOf : Type -&gt; bool" Usage="typeBuilder.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="f640b-1234">
            <see cref="T:System.Type" /> que se va a comprobar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1234">A <see cref="T:System.Type" /> that is to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1235">Determina si este tipo se deriva de un tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1235">Determines whether this type is derived from a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1236">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1236">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1237">Devuelve <see langword="true" /> si este tipo es igual que el tipo <paramref name="c" /> o si es un subtipo del tipo <paramref name="c" />; en caso contrario, devuelve <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1237">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeBuilder.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1238">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1238">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : unit -&gt; Type" Usage="typeBuilder.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1239">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1239">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1240">Un objeto <see cref="T:System.Type" /> que representa un tipo de matriz unidimensional cuyo tipo de elemento es el actual, con un límite inferior de cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1240">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1241">El <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método proporciona una manera de generar un tipo de matriz con cualquier tipo de elemento posible, incluidos los tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="f640b-1241">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-1242">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1242">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="f640b-1243">`TestMethod` toma un `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1243">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="f640b-1244">Devuelve una matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1244">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="f640b-1245">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1245">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : int -&gt; Type" Usage="typeBuilder.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="f640b-1246">Número de dimensiones de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1246">The number of dimensions for the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1247">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1247">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1248">Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1248">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1249">El <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método proporciona una manera de generar un tipo de matriz con cualquier tipo de elemento posible, incluidos los tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="f640b-1249">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-1250">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1250">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="f640b-1251">`TestMethod` toma un `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1251">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="f640b-1252">Devuelve una matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1252">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="f640b-1253">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1253">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="f640b-1254">
            <paramref name="rank" /> no es una dimensión de matriz válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1254">
              <paramref name="rank" /> is not a valid array dimension.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="override this.MakeByRefType : unit -&gt; Type" Usage="typeBuilder.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1255">Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1255">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1256">Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1256">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1257">El <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método proporciona una manera de generar `ref` tipos (`ByRef` en Visual Basic) para el parámetro contiene una lista.</span><span class="sxs-lookup"><span data-stu-id="f640b-1257">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1258">Utiliza la sintaxis de lenguaje intermedio (MSIL) de Microsoft, si el actual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, entonces el tipo devuelto por este método sería `MyType&`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1258">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-1259">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1259">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="f640b-1260">`TestMethod` toma un `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1260">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="f640b-1261">Devuelve una matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1261">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="f640b-1262">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1262">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericType : Type[] -&gt; Type" Usage="typeBuilder.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="f640b-1263">Matriz de tipos que se va a sustituir por los parámetros de la definición del tipo genérico actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1263">An array of types to be substituted for the type parameters of the current generic type definition.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1264">Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de tipo genérico actual y devuelve el tipo construido resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1264">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1265">Objeto <see cref="T:System.Type" /> que representa el tipo construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros del tipo genérico actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1265">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1266">Use este método cuando el código emitido requiere un tipo construido a partir de la definición de tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="f640b-1266">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="f640b-1267">No es necesario llamar a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método antes de llamar a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en un <xref:System.Reflection.Emit.TypeBuilder> que representa una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="f640b-1267">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="f640b-1268">Si el actual <xref:System.Reflection.Emit.TypeBuilder> no representa la definición de un tipo genérico, un <xref:System.InvalidOperationException> se produce.</span><span class="sxs-lookup"><span data-stu-id="f640b-1268">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="f640b-1269">El objeto devuelto por este método funciona como un marcador de posición para un tipo genérico construido en el código emitido.</span><span class="sxs-lookup"><span data-stu-id="f640b-1269">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="f640b-1270">Es una instancia de una clase derivada de <xref:System.Type> tiene capacidades limitadas.</span><span class="sxs-lookup"><span data-stu-id="f640b-1270">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="f640b-1271">En concreto:</span><span class="sxs-lookup"><span data-stu-id="f640b-1271">In particular:</span></span>  
  
-   <span data-ttu-id="f640b-1272">Para obtener los métodos, campos y constructores para estos tipos genéricos construyen, use el <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, y <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1272">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="f640b-1273">Dos instancias que representan el mismo tipo construido no comparen como iguales.</span><span class="sxs-lookup"><span data-stu-id="f640b-1273">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="f640b-1274">Por ejemplo, en el código siguiente `t1.Equals(t2)` devuelve `false`:</span><span class="sxs-lookup"><span data-stu-id="f640b-1274">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-1275">El tipo actual no representa la definición de un tipo genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1275">The current type does not represent the definition of a generic type.</span>
          </span>
          <span data-ttu-id="f640b-1276">Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> devuelve <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1276">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-1277">
            <paramref name="typeArguments" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1277">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-1278">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1278">-or-</span>
          </span>
          <span data-ttu-id="f640b-1279">Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1279">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-1280">La propiedad <see cref="P:System.Type.Module" /> de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1280">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f640b-1281">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1281">-or-</span>
          </span>
          <span data-ttu-id="f640b-1282">La propiedad <see cref="P:System.Reflection.Module.Assembly" /> del módulo de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1282">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="override this.MakePointerType : unit -&gt; Type" Usage="typeBuilder.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1283">Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo de puntero no administrado para el tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1283">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1284">Objeto <see cref="T:System.Type" /> que representa el tipo de puntero no administrado para el tipo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1284">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1285">El <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método proporciona una manera de generar los tipos de puntero para listas de parámetros.</span><span class="sxs-lookup"><span data-stu-id="f640b-1285">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1286">Utiliza la sintaxis de lenguaje intermedio (MSIL) de Microsoft, si el actual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, entonces el tipo devuelto por este método sería `MyType*`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1286">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f640b-1287">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1287">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="f640b-1288">`TestMethod` toma un `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1288">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="f640b-1289">Devuelve una matriz bidimensional de tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="f640b-1289">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="f640b-1290">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="f640b-1290">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1291">Recupera el módulo dinámico que contiene esta definición de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1291">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1292">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1292">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1293">Recupera el módulo dinámico que contiene esta definición de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1293">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1294">Recupera el nombre de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1294">Retrieves the name of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1295">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1295">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1296">Recupera el nombre <see cref="T:System.String" /> de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1296">Retrieves the <see cref="T:System.String" /> name of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1297">Recupera el espacio de nombres donde se define este <see langword="TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1297">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1298">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1298">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1299">Recupera el espacio de nombres donde se define este <see langword="TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1299">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberSignature Language="F#" Value="member this.PackingSize : System.Reflection.Emit.PackingSize" Usage="System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1300">Recupera el tamaño del empaquetado de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1300">Retrieves the packing size of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1301">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1301">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1302">Recupera el tamaño del empaquetado de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1302">Retrieves the packing size of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1303">Devuelve el tipo que se utilizó para obtener este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1303">Returns the type that was used to obtain this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1304">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1304">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1305">Tipo que se usó para obtener este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1305">The type that was used to obtain this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1306">Establece un atributo personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1306">Sets a custom attribute.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="typeBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">
          <span data-ttu-id="f640b-1307">Instancia de una clase auxiliar para definir el atributo personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1307">An instance of a helper class to define the custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1308">Establece un atributo personalizado mediante un generador de atributos personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1308">Set a custom attribute using a custom attribute builder.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1309">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="f640b-1309">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="f640b-1310">(Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="f640b-1310">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-1311">
            <paramref name="customBuilder" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1311">
              <paramref name="customBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-1312">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1312">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="typeBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">
          <span data-ttu-id="f640b-1313">Constructor para el atributo personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1313">The constructor for the custom attribute.</span>
          </span>
        </param>
        <param name="binaryAttribute">
          <span data-ttu-id="f640b-1314">Blob de bytes que representa los atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1314">A byte blob representing the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1315">Establece un atributo personalizado mediante un blob de atributo personalizado especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1315">Sets a custom attribute using a specified custom attribute blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1316">Para obtener más información sobre cómo dar formato a `binaryAttribute`, consulte la documentación de Common Language Infrastructure (CLI), especialmente en "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="f640b-1316">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="f640b-1317">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="f640b-1317">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f640b-1318">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="f640b-1318">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="f640b-1319">(Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="f640b-1319">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f640b-1320">El valor de <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1320">
              <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-1321">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1321">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.SetParent : Type -&gt; unit" Usage="typeBuilder.SetParent parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">
          <span data-ttu-id="f640b-1322">Nuevo tipo base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1322">The new base type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1323">Establece el tipo base del tipo actualmente en construcción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1323">Sets the base type of the type currently under construction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1324">Si `parent` es `null`, <xref:System.Object> se usa como el tipo base.</span><span class="sxs-lookup"><span data-stu-id="f640b-1324">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="f640b-1325">En las versiones 1.0 y 1.1 de .NET Framework, se produce ninguna excepción si `parent` es un tipo de interfaz, pero un <xref:System.TypeLoadException> se produce cuando el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1325">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="f640b-1326">El <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> método no comprueba la mayoría de los tipos de elemento primario no válido.</span><span class="sxs-lookup"><span data-stu-id="f640b-1326">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="f640b-1327">Por ejemplo, no rechaza un tipo de elemento primario que no tiene ningún constructor predeterminado cuando el tipo actual tiene un constructor predeterminado, no rechaza los tipos sellados y no rechaza el <xref:System.Delegate> tipo.</span><span class="sxs-lookup"><span data-stu-id="f640b-1327">For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="f640b-1328">En todos estos casos, se producen excepciones por el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f640b-1328">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-1329">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1329">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="f640b-1330">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1330">-or-</span>
          </span>
          <span data-ttu-id="f640b-1331">
            <paramref name="parent" /> es <see langword="null" /> y la instancia actual representa una interfaz cuyos atributos no incluyen <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1331">
              <paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          </span>
          <span data-ttu-id="f640b-1332">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1332">-or-</span>
          </span>
          <span data-ttu-id="f640b-1333">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1333">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f640b-1334">
            <paramref name="parent" /> es una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1334">
              <paramref name="parent" /> is an interface.</span>
          </span>
          <span data-ttu-id="f640b-1335">Esta condición de excepción es nueva en la versión 2.0 de .NET Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1335">This exception condition is new in the .NET Framework version 2.0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1336">Recupera el tamaño total de un tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1336">Retrieves the total size of a type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1337">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1337">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1338">Recupera el tamaño total de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1338">Retrieves this type’s total size.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="f640b-1339">Reservado para un uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1339">Reserved for future use.</span>
          </span>
          <span data-ttu-id="f640b-1340">Debe ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1340">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="f640b-1341">Matriz que se pasa con los nombres que se van a asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1341">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="f640b-1342">Número de nombres que se van a asignar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1342">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="f640b-1343">Contexto de configuración regional en el que se van a interpretar los nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1343">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="f640b-1344">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1344">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1345">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1345">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1346">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1346">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f640b-1347">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="f640b-1347">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f640b-1348">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1348">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="f640b-1349">Información de tipos que se va a devolver.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1349">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="f640b-1350">Identificador de la configuración regional de la información de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1350">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="f640b-1351">Recibe un puntero al objeto de información de tipo solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1351">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1352">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1352">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1353">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1353">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f640b-1354">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="f640b-1354">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f640b-1355">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1355">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="f640b-1356">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1356">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1357">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1357">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1358">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1358">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f640b-1359">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="f640b-1359">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f640b-1360">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1360">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="f640b-1361">Identifica el miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1361">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="f640b-1362">Reservado para un uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1362">Reserved for future use.</span>
          </span>
          <span data-ttu-id="f640b-1363">Debe ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1363">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="f640b-1364">Contexto de la configuración regional en que se interpretan los argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1364">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="f640b-1365">Marcas que describen el contexto de la llamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1365">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="f640b-1366">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1366">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="f640b-1367">Puntero a la ubicación donde se va a almacenar el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1367">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="f640b-1368">Puntero a una estructura que contiene información de excepciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1368">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="f640b-1369">Índice del primer argumento que tiene un error.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1369">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f640b-1370">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1370">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1371">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1371">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f640b-1372">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="f640b-1372">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f640b-1373">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1373">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="typeBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1374">Devuelve el nombre del tipo, excluido el espacio de nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1374">Returns the name of the type excluding the namespace.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f640b-1375">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1375">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1376">Nombre del tipo, excluido el espacio de nombres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1376">The name of the type excluding the namespace.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1377">No se admite en módulos dinámicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1377">Not supported in dynamic modules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1378">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1378">Read-only.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f640b-1379">Recupera el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y usar la reflexión en el tipo recuperado.</span><span class="sxs-lookup"><span data-stu-id="f640b-1379">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f640b-1380">No se admite en módulos dinámicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1380">Not supported in dynamic modules.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeToken : System.Reflection.Emit.TypeToken" Usage="System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1381">Devuelve el token de tipo de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1381">Returns the type token of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1382">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1382">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1383">Devuelve el <see langword="TypeToken" /> de este tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1383">Returns the <see langword="TypeToken" /> of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-1384">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1384">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1385">Devuelve el tipo de sistema subyacente para este <see langword="TypeBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1385">Returns the underlying system type for this <see langword="TypeBuilder" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f640b-1386">Sólo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1386">Read-only.</span>
          </span>
          <span data-ttu-id="f640b-1387">Devuelve el tipo de sistema subyacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1387">Returns the underlying system type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f640b-1388">Este tipo es una enumeración, pero no hay ningún tipo de sistema subyacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1388">This type is an enumeration, but there is no underlying system type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="F#" Value="val mutable UnspecifiedTypeSize : int" Usage="System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="f640b-1389">Representa que no se especifica el tamaño total del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f640b-1389">Represents that total size for the type is not specified.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>