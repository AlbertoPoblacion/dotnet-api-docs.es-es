<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeBuilder.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines and creates new instances of classes during run time.</source>
          <target state="translated">Define y crea nuevas instancias de clases en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is the root class used to control the creation of dynamic classes in the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> es la clase raíz que se utiliza para controlar la creación de clases dinámicas en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</source>
          <target state="translated">Proporciona un conjunto de rutinas que se utilizan para definir clases, agregar métodos y campos y crear la clase dentro de un módulo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A new <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be created from a dynamic module by calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Un nuevo <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> pueden crearse desde un módulo dinámico mediante una llamada a la <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> método, que devuelve un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit provides the following options for defining types:</source>
          <target state="translated">La emisión de reflexión proporciona las siguientes opciones para definir los tipos:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name.</source>
          <target state="translated">Definir una clase o interfaz con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name and attributes.</source>
          <target state="translated">Definir una clase o interfaz con el nombre especificado y los atributos.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, and base class.</source>
          <target state="translated">Defina una clase con el nombre especificado, atributos y clases base.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</source>
          <target state="translated">Defina una clase con el nombre especificado, atributos, clase base y el conjunto de interfaces que implementa la clase.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and packing size.</source>
          <target state="translated">Defina una clase con el nombre especificado, el atributos, la clase base y el tamaño de empaquetado.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the class size as a whole.</source>
          <target state="translated">Defina una clase con el nombre especificado, atributos, clase base y el tamaño de clase como un todo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</source>
          <target state="translated">Defina una clase con el nombre especificado, atributos, clase base, tamaño de empaquetado y el tamaño de clase como un todo.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Para crear un tipo de matriz, tipo de puntero o tipo byref para un tipo incompleto representado por un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto, utilice la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> método <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> método, o <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Before a type is used, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method must be called.</source>
          <target state="translated">Antes de que se utiliza un tipo, el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> debe llamar al método.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completes the creation of the type.</source>
          <target state="translated"><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completa la creación del tipo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Following the call to <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, the caller can instantiate the type by using the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and invoke members of the type by using the <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Después de llamar a <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, el llamador puede crear instancias del tipo mediante el uso de la <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> método e invocar los miembros del tipo mediante el <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It is an error to invoke methods that change the implementation of a type after <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> has been called.</source>
          <target state="translated">Es un error para invocar métodos que cambian la implementación de un tipo después <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> se ha llamado.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>For example, the common language runtime throws an exception if the caller tries to add new members to a type.</source>
          <target state="translated">Por ejemplo, common language runtime produce una excepción si el llamador intenta agregar a nuevos miembros a un tipo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A class initializer is created by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un inicializador de clase se crea mediante la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> returns a <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> devuelve un <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Nested types are defined by calling one of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Los tipos anidados se definen mediante una llamada a uno de los <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Attributes</source>
          <target state="translated">Atributos</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class uses the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration to further specify the characteristics of the type to be created:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> clase utiliza el <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeración para especificar aún más las características del tipo que se creará:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Interfaces are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attributes.</source>
          <target state="translated">Las interfaces se especifican mediante el <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> atributos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Concrete classes (classes that cannot be extended) are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Las clases concretas (clases que no se pueden extender) se especifican utilizando el <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Several attributes determine type visibility.</source>
          <target state="translated">Varios atributos determinan la visibilidad de tipos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration.</source>
          <target state="translated">Vea la descripción de la <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>If <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is specified, the class loader lays out fields in the order they are read from metadata.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> se especifica, el cargador de clases dispone los campos en el orden en que se leen de los metadatos.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The class loader considers the specified packing size but ignores any specified field offsets.</source>
          <target state="translated">El cargador de clases tiene en cuenta el tamaño de empaquetado especificado, pero omite los desplazamientos de campo especificado.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The metadata preserves the order in which the field definitions are emitted.</source>
          <target state="translated">Los metadatos conservan el orden en que se emiten las definiciones de campo.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Even across a merge, the metadata will not reorder the field definitions.</source>
          <target state="translated">Incluso a través de una combinación, los metadatos no reordenará las definiciones de campo.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The loader will honor the specified field offsets only if <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is specified.</source>
          <target state="translated">El cargador admitirá los desplazamientos de campo especificado sólo si <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> se especifica.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Known Issues</source>
          <target state="translated">Problemas conocidos</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</source>
          <target state="translated">La emisión de reflexión no comprueba si una clase no abstracta que implementa una interfaz ha implementado todos los métodos declarados en la interfaz.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</source>
          <target state="translated">Sin embargo, si la clase no implementa todos los métodos declarados en una interfaz, el tiempo de ejecución no carga la clase.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Type&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Type&gt;</ph> class are not fully implemented in the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class.</source>
          <target state="translated">Aunque <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> se deriva de <ph id="ph2">&lt;xref:System.Type&gt;</ph>, algunos de los métodos abstractos definidos en la <ph id="ph3">&lt;xref:System.Type&gt;</ph> clase no se implementan totalmente en el <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Calls to these <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> methods throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Llamadas a estas <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> métodos lanzan una <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The desired functionality can be obtained by retrieving the created type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and reflecting on the retrieved type.</source>
          <target state="translated">Obtener la funcionalidad deseada, se puede recuperar el tipo creado mediante el <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y reflejar en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The first example shows how to create a dynamic type with a field, constructor, property, and method.</source>
          <target state="translated">El primer ejemplo muestra cómo crear un tipo dinámico con un campo, el constructor, la propiedad y el método.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The second example builds a method dynamically from user input.</source>
          <target state="translated">El segundo ejemplo crea un método de forma dinámica desde proporcionados por el usuario.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example one<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Ejemplo uno<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code example shows how to define a dynamic assembly with one module.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo definir un ensamblado dinámico con un módulo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The module in the example assembly contains one type, <ph id="ph1">`MyDynamicType`</ph>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</source>
          <target state="translated">El módulo en el ensamblado de ejemplo contiene un solo tipo, <ph id="ph1">`MyDynamicType`</ph>, que tiene un campo privado, una propiedad que obtiene y establece el campo privado, constructores que inicializan el campo privado y un método que multiplica un número proporcionado por el usuario en el campo privado valor y devuelve el resultado.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> field is specified when the assembly is created.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> campo se especifica cuando se crea el ensamblado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> or used in another program.</source>
          <target state="translated">El código de ensamblado se usa inmediatamente y el ensamblado también se guarda en el disco para que se pueden examinar con <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> o se usa en otro programa.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example two<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>El segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code sample demonstrates how to build a dynamic type by using <ph id="ph1">`TypeBuilder`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente muestra cómo crear un tipo dinámico mediante <ph id="ph1">`TypeBuilder`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken such as Demand, Assert, and so on.</source>
          <target state="translated">Acción de seguridad que se va a realizar, por ejemplo, Demand, Assert, etc.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">Conjunto de permisos a los que se aplica la acción.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this type.</source>
          <target state="translated">Agrega seguridad declarativa a este tipo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">`AddDeclarativeSecurity`</ph> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</source>
          <target state="translated"><ph id="ph1">`AddDeclarativeSecurity`</ph> puede llamarse varias veces con cada llamada especifica una acción de seguridad (como Demand, Assert o Deny) y un conjunto de permisos que se aplican a la acción.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</source>
          <target state="translated">En las versiones 1.0, 1.1 y 2.0 de .NET Framework, los atributos de seguridad declarativa aplicados a un tipo mediante este método se almacenan en el formato de metadatos XML antiguo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The following example demonstrates the use of the <ph id="ph1">`AddDeclarativeSecurity`</ph> method to add a security demand for <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag to a dynamic type named <ph id="ph4">`MyDynamicClass`</ph>, in an assembly named EmittedExample.dll.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">`AddDeclarativeSecurity`</ph> método para agregar una demanda de seguridad para <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> marca a un tipo dinámico denominado <ph id="ph4">`MyDynamicClass`</ph>, en un ensamblado denominado EmittedExample.dll.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The example produces no console output; after you run it, you can use <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine EmittedExample.dll.</source>
          <target state="translated">En el ejemplo no se genera ninguna salida de la consola; Después de ejecutarlo, puede usar <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para examinar EmittedExample.dll.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In <ph id="ph1">`MyDynamicClass`</ph>, open the <ph id="ph2">`.class public auto ansi`</ph> statement to see the declarative permission.</source>
          <target state="translated">En <ph id="ph1">`MyDynamicClass`</ph>, abra el <ph id="ph2">`.class public auto ansi`</ph> instrucción para ver el permiso declarativo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> no es válido (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> y <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> no son válidos).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Tipo contenedor que se ha creado mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</source>
          <target state="translated">El conjunto de permisos <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contiene una acción que <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph> agregó anteriormente.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The interface that this type implements.</source>
          <target state="translated">Interfaz que implementa este tipo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>Adds an interface that this type implements.</source>
          <target state="translated">Agrega una interfaz que implementa este tipo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The following code sample demonstrates the implementation of an interface on a dynamically created type using <ph id="ph1">`AddInterfaceImplementation`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente muestra la implementación de una interfaz en un tipo creado dinámicamente mediante <ph id="ph1">`AddInterfaceImplementation`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Recupera el ensamblado dinámico que contiene la definición de este tipo.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Recupera el ensamblado dinámico que contiene la definición de este tipo.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Returns the full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Devuelve el nombre completo de este tipo calificado por el nombre de presentación del ensamblado.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Nombre completo de este tipo calificado por el nombre de presentación del ensamblado.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The format of the returned string is the concatenation of the full name of the type (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) and the display name of the assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separated by a comma and a space.</source>
          <target state="translated">El formato de la cadena devuelta es la concatenación del nombre completo del tipo (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) y el nombre para mostrar del ensamblado (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separados por una coma y un espacio.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> para obtener una descripción del formato del nombre para mostrar de un ensamblado.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Version Information</source>
          <target state="translated">Información de versión</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</source>
          <target state="translated">En las versiones 1.0 y 1.1 de .NET Framework, el valor de esta propiedad no incluye la referencia cultural o la clave pública.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Recupera el tipo base de este tipo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Recupera el tipo base de este tipo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the class.</source>
          <target state="translated">Crea un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> para la clase.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>After defining fields and methods on the class, <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> is called in order to load its <ph id="ph2">&lt;see langword="Type" /&gt;</ph> object.</source>
          <target state="translated">Después de definir los campos y métodos en la clase, se llama a <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> para cargar su objeto <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Returns the new <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for this class.</source>
          <target state="translated">Devuelve el nuevo objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> para esta instancia.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If this type is a nested type, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method must be called on the enclosing type before it is called on the nested type.</source>
          <target state="translated">Si este tipo es un tipo anidado, el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> se debe llamar el método en el tipo envolvente antes de que se llama en el tipo anidado.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the current type derives from an incomplete type or implements incomplete interfaces, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the parent type and the interface types before calling it on the current type.</source>
          <target state="translated">Si el tipo actual se deriva de un tipo incompleto o implementa interfaces incompletas, llame a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método dependen del tipo de elemento primario y los tipos de interfaz antes de llamarlo en el tipo actual.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the enclosing type will generate a <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Si el tipo envolvente contiene un campo que es un tipo de valor definido como un tipo anidado (por ejemplo, un campo que sea una enumeración definida como tipo anidado), al llamar a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método en el tipo envolvente generará un <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</source>
          <target state="translated">Esto es porque el cargador no puede determinar el tamaño del tipo envolvente hasta que se ha completado el tipo anidado.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The caller should define a handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event to complete the definition of the nested type by calling <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the nested type.</source>
          <target state="translated">El llamador debe definir un controlador para el <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> eventos para completar la definición del tipo anidado mediante una llamada a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> en la <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto que representa el tipo anidado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The code example for this topic shows how to define such an event handler.</source>
          <target state="translated">El ejemplo de código de este tema muestra cómo definir un controlador de eventos de este tipo.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>A type is created only once, no matter how many times the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Se crea un tipo solo una vez, con independencia de cómo muchas veces el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> se llama al método.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>All calls return the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Todas las llamadas devuelven el mismo <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The following code example shows how to define an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event, in order to call the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on a nested type during a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> call on the enclosing type.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo definir un controlador de eventos para el <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> eventos, para poder llamar a la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método en un tipo anidado durante un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> llame en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The enclosing type has not been created.</source>
          <target state="translated">No se ha creado el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is non-abstract and contains an abstract method.</source>
          <target state="translated">Este tipo no es abstracto y contiene un método abstracto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is not an abstract class or an interface and has a method without a method body.</source>
          <target state="translated">Este tipo no es una clase o interfaz abstracta y tiene un método sin cuerpo de método.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type contains invalid Microsoft intermediate language (MSIL) code.</source>
          <target state="translated">El tipo contiene código del Lenguaje intermedio de Microsoft (MSIL) no válido.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</source>
          <target state="translated">El destino de bifurcación se especifica con un desplazamiento de 1 byte, pero el destino está a una distancia superior a 127 bytes de la bifurcación.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type cannot be loaded.</source>
          <target state="translated">No se puede cargar el tipo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>For example, it contains a <ph id="ph1">&lt;see langword="static" /&gt;</ph> method that has the calling convention <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</source>
          <target state="translated">Por ejemplo, contiene un método <ph id="ph1">&lt;see langword="static" /&gt;</ph> con la convención de llamada <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object that represents this type.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> que representa este tipo.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>An object that represents this type.</source>
          <target state="translated">Objeto que representa este tipo.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>Gets the method that declared the current generic type parameter.</source>
          <target state="translated">Obtiene el método que declaró el parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa el método que declaró el tipo actual, si el tipo actual es un parámetro de tipo genérico; en caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Al emitir el código, un parámetro de tipo genérico se representa mediante un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto en lugar de un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Returns the type that declared this type.</source>
          <target state="translated">Devuelve el tipo que declara este tipo.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>The type that declared this type.</source>
          <target state="translated">Tipo que declara este tipo.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new constructor to the dynamic type.</source>
          <target state="translated">Agrega un nuevo constructor al tipo dinámico.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Atributos del constructor.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Convención de llamada del constructor.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Tipos de parámetro del constructor.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Adds a new constructor to the type, with the given attributes and signature.</source>
          <target state="translated">Agrega un nuevo constructor al tipo, con los atributos y signatura especificados.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The defined constructor.</source>
          <target state="translated">El constructor definido.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
          <target state="translated">Si no define un constructor para su tipo dinámico, se proporciona automáticamente un constructor predeterminado y llama al constructor predeterminado de la clase base.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you define a constructor for your dynamic type, a default constructor is not provided.</source>
          <target state="translated">Si define un constructor para su tipo dinámico, no se proporciona un constructor predeterminado.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
          <target state="translated">Tiene las siguientes opciones para proporcionar un constructor predeterminado además del constructor definido:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> method to create one (and optionally restrict access to it).</source>
          <target state="translated">Si desea un constructor predeterminado que llame simplemente al constructor predeterminado de la clase base, puede utilizar el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> método para crear uno (y opcionalmente restringir el acceso a él).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Do not provide an implementation for this default constructor.</source>
          <target state="translated">Proporciona una implementación para este constructor predeterminado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
          <target state="translated">Si lo hace, se produce una excepción al intentar usar el constructor.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Ninguna excepción se produce cuando el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> se llama al método.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create one, and provide your own implementation.</source>
          <target state="translated">Si desea un constructor predeterminado que haga algo más que simplemente llamar el constructor predeterminado de la clase base o que llame a otro constructor de la clase base o que haga algo completamente distinto, debe utilizar el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> método para crear uno y proporcionar su propia implementación.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">El ejemplo de código siguiente muestra el uso de <ph id="ph1">`DefineConstructor`</ph> para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> de población de MSIL.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Atributos del constructor.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Convención de llamada del constructor.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Tipos de parámetro del constructor.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ningún parámetro tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</source>
          <target state="translated">Agrega un nuevo constructor al tipo, con los atributos, la signatura y los modificadores personalizados especificados.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The defined constructor.</source>
          <target state="translated">El constructor definido.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">El tamaño de <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> o <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> no es igual al tamaño de <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se creó previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> object representing the attributes to be applied to the constructor.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> que representa los atributos que se van a aplicar al constructor.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Defines the default constructor.</source>
          <target state="translated">Define el constructor predeterminado.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The constructor defined here will simply call the default constructor of the parent.</source>
          <target state="translated">El constructor definido aquí simplemente llamará al constructor predeterminado del elemento principal.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Returns the constructor.</source>
          <target state="translated">Devuelve el constructor.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</source>
          <target state="translated">Dado que el constructor predeterminado se define automáticamente, es necesario llamar a este método solo en las situaciones siguientes:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</source>
          <target state="translated">Ha definido otro constructor y también desea un constructor predeterminado que simplemente llama al constructor de clase base.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You want to set the attributes on the default constructor to something other than <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</source>
          <target state="translated">Desea establecer los atributos en el constructor predeterminado en un valor distinto de <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, y <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">El ejemplo de código siguiente muestra el uso de <ph id="ph1">`DefineConstructor`</ph> para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> de población de MSIL.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The parent type (base type) does not have a default constructor.</source>
          <target state="translated">El tipo primario (tipo base) no tiene un constructor predeterminado.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The name of the event.</source>
          <target state="translated">Nombre del evento.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The attributes of the event.</source>
          <target state="translated">Atributos del evento.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type of the event.</source>
          <target state="translated">Tipo del evento.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>Adds a new event to the type, with the given name, attributes and event type.</source>
          <target state="translated">Agrega un nuevo evento al tipo, con el nombre, los atributos y el tipo de evento especificados.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The defined event.</source>
          <target state="translated">El evento definido.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new field to the dynamic type.</source>
          <target state="translated">Agrega un nuevo campo al tipo dinámico.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Nombre del campo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null incrustados.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Tipo del campo.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Atributos del campo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, and field type.</source>
          <target state="translated">Agrega un nuevo campo al tipo, con el nombre, los atributos y el tipo de campo especificados.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">El campo definido.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> es System.Void.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">Se especificó un tamaño total de la clase primaria de este campo.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Nombre del campo.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null incrustados.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Tipo del campo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the required custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Matriz de tipos que representan los modificadores personalizados necesarios para el campo, como <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the optional custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Matriz de tipos que representan los modificadores personalizados opcionales para el campo, como <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Atributos del campo.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</source>
          <target state="translated">Agrega un nuevo campo al tipo, con el nombre, los atributos, el tipo de campo y los modificadores personalizados especificados.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">El campo definido.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> es System.Void.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">Se especificó un tamaño total de la clase primaria de este campo.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of names for the generic type parameters.</source>
          <target state="translated">Matriz de nombres para los parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to set their constraints.</source>
          <target state="translated">Define los parámetros de tipo genérico para el tipo actual, especificando su número y sus nombres, y devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> que se pueden utilizar para establecer sus restricciones.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define the constraints of the generic type parameters for the current type.</source>
          <target state="translated">Una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> que se pueden utilizar para definir las restricciones de los parámetros de tipo genérico para el tipo actual.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method makes the current type a generic type.</source>
          <target state="translated">Llamar a este método convierte al tipo actual en un tipo genérico.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>If the method is called again on the same type, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Si el método se llama de nuevo en el mismo tipo, un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> se produce.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un tipo genérico con dos parámetros de tipo y los guarda en el ensamblado GenericEmitExample1.dll.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the generated types.</source>
          <target state="translated">Puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para ver los tipos generados.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>For a more detailed explanation of the steps involved in defining a dynamic generic type, see <bpt id="p1">[</bpt>How to: Define a Generic Type with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Para obtener una explicación más detallada de los pasos necesarios para definir un tipo genérico dinámico, vea <bpt id="p1">[</bpt>Cómo: definir un tipo genérico con emisión de reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this type.</source>
          <target state="translated">Los parámetros de tipo genérico ya se han definido para este tipo.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento de <ph id="ph1">&lt;paramref name="names" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> es una matriz vacía.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Nombre utilizado para hacer referencia a los datos.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The blob of data.</source>
          <target state="translated">Objeto binario de datos.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Atributos para el campo.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Define un campo de datos inicializado en la sección .sdata del archivo ejecutable portable (PE).</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Campo para hacer referencia a los datos.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">El campo que se cree con este método será <ph id="ph1">`static`</ph>, incluso si no incluye <ph id="ph2">`FieldAttributes.Static`</ph> en el <ph id="ph3">`attributes`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</source>
          <target state="translated">El tamaño de los datos es menor o igual que cero, o mayor o igual que 0x3f0000.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> o <ph id="ph2">&lt;paramref name="data" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has been previously called.</source>
          <target state="translated">Se ha llamado previamente a <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a method to the type.</source>
          <target state="translated">Agrega un método al tipo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The name of the method.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Adds a new method to the type, with the specified name and method attributes.</source>
          <target state="translated">Agrega un nuevo método al tipo, con el nombre y los atributos de método especificados.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> que representa el método recién definido.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Utilice esta sobrecarga del método cuando no conozca la firma del método en el momento en que se define el método.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Por ejemplo, los tipos de parámetro y el tipo de valor devuelto de un método genérico pueden especificarse mediante los parámetros de tipo genérico del método, que se deben definir una vez se ha agregado el método al tipo.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Los parámetros y el tipo de valor devuelto del método se pueden establecer más adelante mediante la <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This method overload defines a method with <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esta sobrecarga del método define un método con <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>If you need to define a method without a signature, with a different calling convention, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overload.</source>
          <target state="translated">Si necesita definir un método sin una firma con otra convención de llamada, use la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The following code example defines a generic method named <ph id="ph1">`DemoMethod`</ph> whose parameter type and return type are specified by its generic type parameters.</source>
          <target state="translated">En el ejemplo de código siguiente se define un método genérico denominado <ph id="ph1">`DemoMethod`</ph> cuyo tipo de parámetro y el tipo de valor devuelto se especifican mediante los parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The method is defined without a signature, using the standard calling convention.</source>
          <target state="translated">El método se define sin una firma, utilizando la convención de llamada estándar.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method is used to make <ph id="ph2">`DemoMethod`</ph> a generic method, and the newly defined type parameters are then used for the signature and return type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> método se usa para realizar <ph id="ph2">`DemoMethod`</ph> un método genérico y los parámetros de tipo recién definidos, a continuación, se usan para la firma y tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The name of the method.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The calling convention of the method.</source>
          <target state="translated">Convención de llamada del método.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Adds a new method to the type, with the specified name, method attributes, and calling convention.</source>
          <target state="translated">Agrega un nuevo método al tipo, con la convención de llamada, el nombre y los atributos de método especificados.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> que representa el método recién definido.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Utilice esta sobrecarga del método cuando no conozca la firma del método en el momento en que se define el método.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Por ejemplo, los tipos de parámetro y el tipo de valor devuelto de un método genérico pueden especificarse mediante los parámetros de tipo genérico del método, que se deben definir una vez se ha agregado el método al tipo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Los parámetros y el tipo de valor devuelto del método se pueden establecer más adelante mediante la <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type of the parent of this method is an interface and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, and method signature.</source>
          <target state="translated">Agrega un nuevo método al tipo, con la signatura de método, el nombre y los atributos de método especificados.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined method.</source>
          <target state="translated">El método definido.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">El ejemplo de código siguiente muestra el uso de <ph id="ph1">`DefineMethod`</ph> para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> de población de MSIL.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the method.</source>
          <target state="translated">Convención de llamada del método.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</source>
          <target state="translated">Agrega un nuevo método al tipo, con la signatura de método, la convención de llamada, el nombre y los atributos de método especificados.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> que representa el método recién definido.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">El ejemplo de código siguiente muestra el uso de <ph id="ph1">`DefineMethod`</ph> para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> de población de MSIL.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">El tipo del elemento principal de este método es una interfaz y este método no es virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">Nombre del método.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the method.</source>
          <target state="translated">Convención de llamada del método.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matriz de tipos que representa los modificadores personalizados obligatorios, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matriz de los tipos que representan los modificadores personalizados opcionales, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto del método.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ningún parámetro tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</source>
          <target state="translated">Agrega un nuevo método al tipo, con el nombre, los atributos de método, la convención de llamada, la signatura de método, y los modificadores personalizados especificados.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object representing the newly added method.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> que representa el método recién agregado.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this overload if you need to specify custom modifiers.</source>
          <target state="translated">Utilice esta sobrecarga si necesita especificar modificadores personalizados.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overloads to define the method and then use the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method to define the parameter and return types with custom modifiers.</source>
          <target state="translated">Si necesita especificar modificadores personalizados una vez creado el método, como lo haría, por ejemplo, con un método genérico cuyos tipos de parámetro se especifican mediante sus parámetros de tipo genérico, puede usar el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> sobrecargas del método para definir el método y, a continuación, usar el <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> método para definir el parámetro y devolver tipos con modificadores personalizados.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">El tipo del elemento primario de este método es una interfaz y este método no es virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">El tamaño de <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> o <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> no es igual al tamaño de <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method body to be used.</source>
          <target state="translated">Cuerpo del método que se va a utilizar.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>This should be a <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Debería ser un objeto <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method whose declaration is to be used.</source>
          <target state="translated">Método cuya declaración se va a utilizar.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Specifies a given method body that implements a given method declaration, potentially with a different name.</source>
          <target state="translated">Especifica un cuerpo de método determinado que implementa una declaración de método específica, posiblemente con otro nombre.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Do not use this method to emit method overrides or interface implementations.</source>
          <target state="translated">No utilice este método para invalidar métodos o implementaciones de interfaz.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</source>
          <target state="translated">Para reemplazar un método de una clase base o implementar un método de una interfaz, simplemente emita un método con el mismo nombre y firma que el método se reemplaza o implementa, como se muestra en el ejemplo de código.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is used when a method body and a method declaration have different names.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> método se utiliza cuando un cuerpo de método y una declaración de método tienen nombres diferentes.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</source>
          <target state="translated">Por ejemplo, una clase puede reemplazar un método de clase base y también proporcionar una implementación independiente para un miembro de interfaz con el mismo nombre, como se muestra en el ejemplo de código.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`DefineMethodOverride`</ph> defines a <ph id="ph2">`methodimpl`</ph>, which consists of a pair of metadata tokens.</source>
          <target state="translated"><ph id="ph1">`DefineMethodOverride`</ph> define un <ph id="ph2">`methodimpl`</ph>, que consta de un par de tokens de metadatos.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>One token points to an implementation, and the other token points to a declaration that the body implements.</source>
          <target state="translated">Un símbolo (token) señala a una implementación y los demás puntos de símbolo (token) a una declaración que implementa el cuerpo.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The body must be defined on the type the method impl is defined on, and the body must be virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
          <target state="translated">El cuerpo debe definirse en el tipo de la implementación del método se define en, y el cuerpo debe ser virtual (<ph id="ph1">`Overridable`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</source>
          <target state="translated">La declaración puede realizarse a un método definido en una interfaz implementada por el tipo, un método en una clase derivada o un método definido en el tipo.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is on an interface only, the slot defined for the interface is altered.</source>
          <target state="translated">Si la declaración es sólo en una interfaz, se modifica la ranura definida por dicha interfaz.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</source>
          <target state="translated">Si la declaración se realiza a un método en un tipo base, la ranura para el método se reemplaza y los duplicados para el método reemplazado también se sustituyen.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The overridden method cannot be the actual method that is declared.</source>
          <target state="translated">El método invalidado no puede ser el método real que se declara.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</source>
          <target state="translated">Si el método está en el mismo tipo, la ranura se reemplaza y los duplicados para los métodos sustituidos se omiten.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For more information about method impls, see <ph id="ph1">`MethodImpl`</ph> in the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Para obtener más información acerca de implementaciones de métodos, consulte <ph id="ph1">`MethodImpl`</ph> en la documentación de ECMA Partition II metadatos.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is called, some features of <ph id="ph2">`methodInfoBody`</ph> cannot be changed.</source>
          <target state="translated">Después de la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> método se llama, algunas características de <ph id="ph2">`methodInfoBody`</ph> no se puede cambiar.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, you cannot apply an attribute to a generic type parameter of <ph id="ph1">`methodInfoBody`</ph> by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> method.</source>
          <target state="translated">Por ejemplo, no se puede aplicar un atributo a un parámetro de tipo genérico de <ph id="ph1">`methodInfoBody`</ph> utilizando el <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method, do so after all characteristics of <ph id="ph2">`methodInfoBody`</ph> have been defined.</source>
          <target state="translated">Si debe utilizar el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> método, hacerlo después de todas las características de <ph id="ph2">`methodInfoBody`</ph> se han definido.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The following code example contains an interface <ph id="ph1">`I`</ph> with a method <ph id="ph2">`M()`</ph>, a base class <ph id="ph3">`A`</ph> that implements the interface, and a derived class <ph id="ph4">`C`</ph> that overrides the base class implementation of <ph id="ph5">`M()`</ph> and also provides a separate explicit implementation of <ph id="ph6">`I.M()`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente contiene una interfaz <ph id="ph1">`I`</ph> con un método <ph id="ph2">`M()`</ph>, una clase base <ph id="ph3">`A`</ph> que implementa la interfaz y una clase derivada <ph id="ph4">`C`</ph> que invalida la implementación de clase base <ph id="ph5">`M()`</ph> y también Proporciona una implementación independiente y explícita de <ph id="ph6">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`main()`</ph> method of the code example shows how to emit the derived class <ph id="ph2">`C`</ph>.</source>
          <target state="translated">El <ph id="ph1">`main()`</ph> método del ejemplo de código muestra cómo emitir la clase derivada <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The override of <ph id="ph1">`A.M()`</ph> is accomplished simply by emitting a method <ph id="ph2">`M()`</ph> with the same signature.</source>
          <target state="translated">La invalidación de <ph id="ph1">`A.M()`</ph> se logra simplemente mediante la emisión de un método <ph id="ph2">`M()`</ph> con la misma firma.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>However, to provide a separate implementation of <ph id="ph1">`I.M()`</ph>, you must define a method body and then use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method to associate that method body with a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing <ph id="ph4">`I.M()`</ph>.</source>
          <target state="translated">Sin embargo, para proporcionar una implementación independiente de <ph id="ph1">`I.M()`</ph>, debe definir un cuerpo de método y, a continuación, usar el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> método para asociar dicho cuerpo de método con un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa <ph id="ph4">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The name of the method body does not matter.</source>
          <target state="translated">El nombre del cuerpo del método no importa.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The code example creates an instance of the emitted class.</source>
          <target state="translated">El ejemplo de código crea una instancia de la clase emitida.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`I.M()`</ph>, and uses it to invoke the emitted class's explicit interface implementation.</source>
          <target state="translated">Obtiene un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto <ph id="ph2">`I.M()`</ph>, y se utiliza para invocar la clase emitida 's explícito de implementación de interfaces.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It then obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`A.M()`</ph>, and uses it to invoke the emitted class's override of that method.</source>
          <target state="translated">A continuación, obtiene un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto <ph id="ph2">`A.M()`</ph>y lo utiliza para invocar la invalidación de la clase emitida de ese método.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> does not belong to this class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> no pertenece a esta clase.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> o <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> is not the type represented by this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> no es el tipo representado por este <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a nested type.</source>
          <target state="translated">Define un tipo anidado.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Defines a nested type, given its name.</source>
          <target state="translated">Define un tipo anidado a partir de su nombre.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Este método puede utilizarse para crear anidada tipos incluso después del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vea la descripción de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> para el orden en el que se deben completar los tipos anidados y los tipos.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">No se crea necesariamente un nombre duplicado si <ph id="ph1">`name`</ph> es idéntico al nombre de un tipo anidado o un tipo definido previamente.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero o mayor que 1023.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Esta operación crearía un tipo con un valor de <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicado en el ensamblado actual.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the type.</source>
          <target state="translated">Atributos del tipo.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>Defines a nested type, given its name and attributes.</source>
          <target state="translated">Define un tipo anidado a partir del nombre y los atributos.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Este método puede utilizarse para crear anidada tipos incluso después del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vea la descripción de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> para el orden en el que se deben completar los tipos anidados y los tipos.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">No se crea necesariamente un nombre duplicado si <ph id="ph1">`name`</ph> es idéntico al nombre de un tipo anidado o un tipo definido previamente.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">El atributo anidado no está especificado.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is sealed.</source>
          <target state="translated">Este tipo está sellado.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an array.</source>
          <target state="translated">Este tipo es una matriz.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero o mayor que 1023.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Esta operación crearía un tipo con un valor de <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicado en el ensamblado actual.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes of the type.</source>
          <target state="translated">Atributos del tipo.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo que extiende el tipo anidado.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines a nested type, given its name, attributes, and the type that it extends.</source>
          <target state="translated">Define un tipo anidado a partir del nombre, los atributos y el tipo que extiende.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Este método puede utilizarse para crear anidada tipos incluso después del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vea la descripción de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> para el orden en el que se deben completar los tipos anidados y los tipos.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">No se crea necesariamente un nombre duplicado si <ph id="ph1">`name`</ph> es idéntico al nombre de un tipo anidado o un tipo definido previamente.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">El atributo anidado no está especificado.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is sealed.</source>
          <target state="translated">Este tipo está sellado.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an array.</source>
          <target state="translated">Este tipo es una matriz.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero o mayor que 1023.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Esta operación crearía un tipo con un valor de <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicado en el ensamblado actual.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Atributos del tipo.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo que extiende el tipo anidado.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Tamaño total del tipo.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</source>
          <target state="translated">Define un tipo anidado a partir del nombre, los atributos, el tamaño total del tipo y el tipo que extiende.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Este método puede utilizarse para crear anidada tipos incluso después del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vea la descripción de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> para el orden en el que se deben completar los tipos anidados y los tipos.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">No se crea necesariamente un nombre duplicado si <ph id="ph1">`name`</ph> es idéntico al nombre de un tipo anidado o un tipo definido previamente.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">El atributo anidado no está especificado.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is sealed.</source>
          <target state="translated">Este tipo está sellado.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an array.</source>
          <target state="translated">Este tipo es una matriz.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero o mayor que 1023.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Esta operación crearía un tipo con un valor de <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicado en el ensamblado actual.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the type.</source>
          <target state="translated">Atributos del tipo.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo que extiende el tipo anidado.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">Tamaño de empaquetado del tipo.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</source>
          <target state="translated">Define un tipo anidado a partir del nombre, los atributos, el tipo que extiende y el tamaño de empaquetado.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Este método puede utilizarse para crear anidada tipos incluso después del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vea la descripción de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> para el orden en el que se deben completar los tipos anidados y los tipos.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">No se crea necesariamente un nombre duplicado si <ph id="ph1">`name`</ph> es idéntico al nombre de un tipo anidado o un tipo definido previamente.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">El atributo anidado no está especificado.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is sealed.</source>
          <target state="translated">Este tipo está sellado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an array.</source>
          <target state="translated">Este tipo es una matriz.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero o mayor que 1023.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Esta operación crearía un tipo con un valor de <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicado en el ensamblado actual.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes of the type.</source>
          <target state="translated">Atributos del tipo.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the nested type extends.</source>
          <target state="translated">El tipo que extiende el tipo anidado.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The interfaces that the nested type implements.</source>
          <target state="translated">Interfaz que implementa el tipo anidado.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</source>
          <target state="translated">Define un tipo anidado a partir del nombre, los atributos, el tipo que extiende y las interfaces que implementa.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Este método puede utilizarse para crear anidada tipos incluso después del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado en el tipo envolvente.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">El tipo anidado debe estar completo antes de poder reflejarse en él mediante <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vea la descripción de <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> para el orden en el que se deben completar los tipos anidados y los tipos.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">No se crea necesariamente un nombre duplicado si <ph id="ph1">`name`</ph> es idéntico al nombre de un tipo anidado o un tipo definido previamente.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested attribute is not specified.</source>
          <target state="translated">El atributo anidado no está especificado.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is sealed.</source>
          <target state="translated">Este tipo está sellado.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an array.</source>
          <target state="translated">Este tipo es una matriz.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Este tipo es una interfaz, pero el tipo anidado no es una interfaz.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero o mayor que 1023.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Esta operación crearía un tipo con un valor de <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicado en el ensamblado actual.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>An element of the <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento de la matriz <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Nombre corto del tipo.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null values.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Atributos del tipo.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo que extiende el tipo anidado.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">Tamaño de empaquetado del tipo.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Tamaño total del tipo.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Defines a nested type, given its name, attributes, size, and the type that it extends.</source>
          <target state="translated">Define un tipo anidado a partir del nombre, los atributos, el tamaño y el tipo que extiende.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">El tipo anidado definido.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Define un método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nombre del método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nombre del archivo DLL en que está definido el método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convención de llamadas del método.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convención nativa de llamadas.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Juego nativo de caracteres del método.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Define un método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> a partir del nombre, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamadas del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> que se ha definido.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Atributos de importación de algunas DLL (vea la descripción de <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) no se pueden especificar como argumentos para este método.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Por ejemplo, el atributo de la importación de la DLL <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> debe agregarse después de la <ph id="ph2">`PInvoke`</ph> se crea el método si el método devuelve un valor.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">En el ejemplo se muestra cómo hacerlo.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> método para crear un <ph id="ph2">`PInvoke`</ph> método y cómo agregar la <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> marca a los marcadores de implementación del método después de crear el <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mediante el uso de la <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>métodos.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Para obtener un valor devuelto distinto de cero, debe agregar el <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> marca.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, <ph id="ph1">`MyType`</ph>, que contiene el <ph id="ph2">`PInvoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">El <ph id="ph1">`PInvoke`</ph> método representa Win32 <ph id="ph2">`GetTickCount`</ph> función.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Cuando se ejecuta el ejemplo, se ejecuta el <ph id="ph1">`PInvoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">También se guarda el ensamblado dinámico como PInvokeTest.dll.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para examinar el <ph id="ph1">`MyType`</ph> clase y la <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) <ph id="ph4">`PInvoke`</ph> contiene el método.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Puede compilar un programa de Visual Basic o C# que utiliza el método estático <ph id="ph1">`MyType.GetTickCount`</ph> método incluye una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Método no estático.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">El tipo principal es una interfaz.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Método abstracto.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">El método se definió anteriormente.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> o <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> o <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo contenedor se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nombre del método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nombre del archivo DLL en que está definido el método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">El nombre del punto de entrada del archivo DLL.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convención de llamadas del método.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convención nativa de llamadas.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Juego nativo de caracteres del método.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Define un método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> a partir del nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamadas del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> que se ha definido.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Atributos de importación de algunas DLL (vea la descripción de <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) no se pueden especificar como argumentos para este método.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Por ejemplo, el atributo de la importación de la DLL <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> debe agregarse después de la <ph id="ph2">`PInvoke`</ph> se crea el método si el método devuelve un valor.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">En el ejemplo se muestra cómo hacerlo.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> método para crear un <ph id="ph2">`PInvoke`</ph> método y cómo agregar la <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> marca a los marcadores de implementación del método después de crear el <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mediante el uso de la <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Para obtener un valor devuelto distinto de cero, debe agregar el <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> marca.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, <ph id="ph1">`MyType`</ph>, que contiene el <ph id="ph2">`PInvoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">El <ph id="ph1">`PInvoke`</ph> método representa Win32 <ph id="ph2">`GetTickCount`</ph> función.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Cuando se ejecuta el ejemplo, se ejecuta el <ph id="ph1">`PInvoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">También se guarda el ensamblado dinámico como PInvokeTest.dll.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para examinar el <ph id="ph1">`MyType`</ph> clase y la <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) <ph id="ph4">`PInvoke`</ph> contiene el método.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Puede compilar un programa de Visual Basic o C# que utiliza el método estático <ph id="ph1">`MyType.GetTickCount`</ph> método incluye una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Método no estático.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">El tipo principal es una interfaz.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Método abstracto.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">El método se definió anteriormente.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo contenedor se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nombre del método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nombre del archivo DLL en que está definido el método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">El nombre del punto de entrada del archivo DLL.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Atributos del método.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convención de llamadas del método.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Tipo de valor devuelto del método.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matriz de los tipos que representan los modificadores personalizados necesarios, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto del método.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matriz de los tipos que representan los modificadores personalizados opcionales, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto del método.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Tipos de los parámetros del método.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convención nativa de llamadas.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Juego nativo de caracteres del método.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags, and custom modifiers for the parameters and return type.</source>
          <target state="translated">Define un método <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> a partir del nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamadas del método, el tipo de valor devuelto del método, los tipos de los parámetros del método, las marcas de <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> y los modificadores personalizados de los parámetros y del tipo de valor devuelto.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the defined <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> que representa el método <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> definido.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Atributos de importación de algunas DLL (vea la descripción de <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) no se pueden especificar como argumentos para este método.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Por ejemplo, el atributo de la importación de la DLL <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> debe agregarse después de la <ph id="ph2">`PInvoke`</ph> se crea el método si el método devuelve un valor.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">En el ejemplo se muestra cómo hacerlo.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the [<ph id="ph1">\]</ph>, Type<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, Type<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, Type<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, Type<ph id="ph10">\[</ph><ph id="ph11">\]</ph><ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt; method to create a <ph id="ph13">`PInvoke`</ph> method, and how to add the <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar el [<ph id="ph1">\]</ph>, tipo<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, tipo<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, tipo<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, tipo<ph id="ph10">\[</ph> <ph id="ph11">\]</ph> <ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A &gt; método para crear un <ph id="ph13">`PInvoke`</ph> método y cómo agregar el <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> marca a los marcadores de implementación del método después de crear el <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mediante el uso de la <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, <ph id="ph1">`MyType`</ph>, que contiene el <ph id="ph2">`PInvoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">El <ph id="ph1">`PInvoke`</ph> método representa Win32 <ph id="ph2">`GetTickCount`</ph> función.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Para obtener un valor devuelto distinto de cero, debe agregar el <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> marca.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example uses an overload that does not specify custom modifiers.</source>
          <target state="translated">En el ejemplo se usa una sobrecarga que no especifica modificadores personalizados.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To specify custom modifiers, change the example code to use this method overload instead.</source>
          <target state="translated">Para especificar los modificadores personalizados, cambie el código de ejemplo para utilizar esta sobrecarga del método en su lugar.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Cuando se ejecuta el ejemplo, se ejecuta el <ph id="ph1">`PInvoke`</ph> método.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">También se guarda el ensamblado dinámico como PInvokeTest.dll.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para examinar el <ph id="ph1">`MyType`</ph> clase y la <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) <ph id="ph4">`PInvoke`</ph> contiene el método.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Puede compilar un programa de Visual Basic o C# que utiliza el método estático <ph id="ph1">`MyType.GetTickCount`</ph> método incluye una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Método no estático.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">El tipo principal es una interfaz.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Método abstracto.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">El método se definió anteriormente.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">El tamaño de <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> o <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> no es igual al tamaño de <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> es <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new property to the type.</source>
          <target state="translated">Agrega una nueva propiedad al tipo.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">El nombre de la propiedad.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Atributos de la propiedad.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipos de los parámetros de la propiedad.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name and property signature.</source>
          <target state="translated">Agrega una nueva propiedad al tipo, con el nombre y la signatura de propiedad especificados.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">La propiedad definida.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates how to define a dynamic property and obtain a <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> for specification.</source>
          <target state="translated">El ejemplo de código siguiente muestra cómo definir una propiedad dinámica y obtener un <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> para la especificación.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Note that a <ph id="ph1">`PropertyBuilder`</ph> must also have a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, which will house the IL logic for the property.</source>
          <target state="translated">Tenga en cuenta que un <ph id="ph1">`PropertyBuilder`</ph> también debe tener su correspondiente <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, que hospedará la lógica de IL para la propiedad.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cualquiera de los elementos de la matriz <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">El nombre de la propiedad.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Atributos de la propiedad.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Convención de llamada de los descriptores de acceso de la propiedad.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipos de los parámetros de la propiedad.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</source>
          <target state="translated">Agrega una nueva propiedad al tipo, con el nombre, los atributos, la convención de llamada y la firma de propiedad especificados.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">La propiedad definida.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cualquiera de los elementos de la matriz <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">El nombre de la propiedad.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Atributos de la propiedad.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matriz de tipos que representan los modificadores personalizados necesarios, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene modificadores personalizados obligatorios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matriz de los tipos que representan los modificadores personalizados opcionales, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene ningún modificador personalizado opcional, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipos de los parámetros de la propiedad.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ningún parámetro tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, property signature, and custom modifiers.</source>
          <target state="translated">Agrega una nueva propiedad al tipo, con el nombre, la signatura de propiedad y los modificadores personalizados especificados.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">La propiedad definida.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated">Alguno de los elementos de la matriz de <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">El nombre de la propiedad.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Atributos de la propiedad.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Convención de llamada de los descriptores de acceso de la propiedad.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">tipo de valor devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matriz de tipos que representan los modificadores personalizados necesarios, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene modificadores personalizados obligatorios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matriz de los tipos que representan los modificadores personalizados opcionales, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, para el tipo devuelto de la propiedad.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el tipo de valor devuelto no tiene ningún modificador personalizado opcional, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipos de los parámetros de la propiedad.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matriz de matrices de tipos.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de tipos.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Si ningún parámetro tiene modificadores personalizados opcionales, especifique <ph id="ph1">&lt;see langword="null" /&gt;</ph> en lugar de una matriz de matrices.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</source>
          <target state="translated">Agrega una nueva propiedad al tipo, con el nombre, la convención de llamada, la firma de propiedad y los modificadores personalizados especificados.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">La propiedad definida.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Esta sobrecarga del método se introdujo en la <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o una versión posterior.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cualquiera de los elementos de la matriz <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Defines the initializer for this type.</source>
          <target state="translated">Define el inicializador para este tipo.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Returns a type initializer.</source>
          <target state="translated">Devuelve un inicializador de tipo.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The initializer created is always public.</source>
          <target state="translated">El inicializador creado siempre es público.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The following code sample demonstrates how to create an initialization constructor using <ph id="ph1">`DefineTypeInitializer`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente muestra cómo crear un constructor de inicialización mediante <ph id="ph1">`DefineTypeInitializer`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo contenedor se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Nombre utilizado para hacer referencia a los datos.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> no puede contener valores null insertados.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">Tamaño del campo de datos.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Atributos para el campo.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> section of the portable executable (PE) file.</source>
          <target state="translated">Define un campo de datos sin inicializar en la sección <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> del archivo portable ejecutable (PE).</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Campo para hacer referencia a los datos.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">El campo que se cree con este método será <ph id="ph1">`static`</ph>, incluso si no incluye <ph id="ph2">`FieldAttributes.Static`</ph> en el <ph id="ph3">`attributes`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineUninitializedData`</ph> to create an uninitialized data field in a dynamic type:</source>
          <target state="translated">El ejemplo de código siguiente muestra el uso de <ph id="ph1">`DefineUninitializedData`</ph> para crear un campo de datos sin inicializar en un tipo dinámico:</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="name" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> es menor o igual que cero, o mayor o igual que 0x003f0000.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Recupera la ruta de acceso completa de este tipo.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Recupera la ruta de acceso completa de este tipo.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</source>
          <target state="translated">El formato devuelto es "enclosingTypeFullName+nestedTypeName + en el caso" para los tipos anidados y "typeName" para tipos no anidados.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>Gets a value that indicates the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Obtiene un valor que indica la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Combinación bit a bit de valores de <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Al emitir el código, un parámetro de tipo genérico se representa mediante un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto en lugar de un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</source>
          <target state="translated">Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</source>
          <target state="translated">Si el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> actual representa un parámetro de tipo genérico, la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro; de lo contrario, no se define.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Al emitir el código, un parámetro de tipo genérico se representa mediante un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto en lugar de un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent a generic type parameter, the value of this property is undefined.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no representa un parámetro de tipo genérico, el valor de esta propiedad es indefinido.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents a generic type parameter.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> propiedad para determinar si la actual <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> representa un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The constructed generic type whose constructor is returned.</source>
          <target state="translated">Tipo genérico construido cuyo constructor se devuelve.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A constructor on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which constructor of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Constructor de la definición de tipo genérico de <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, que especifica qué constructor de <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> devolver.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</source>
          <target state="translated">Devuelve el constructor del tipo genérico construido especificado que corresponde al constructor especificado de la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object that represents the constructor of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, which specifies a constructor belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representa el constructor de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> que corresponde a <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, y que especifica un constructor perteneciente a la definición de tipo genérico de <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> método proporciona una manera de obtener un <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto que representa un constructor de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents a constructor of <ph id="ph6">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, suponga que tiene un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto que representa el tipo <ph id="ph2">`G&lt;T&gt;`</ph> en sintaxis de C# (<ph id="ph3">`G(Of T)`</ph> en Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> en C++) y un <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> objeto que representa un constructor de <ph id="ph6">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Suponga que <ph id="ph1">`G&lt;T&gt;`</ph> tiene un método genérico con parámetros de tipo <ph id="ph2">`U`</ph> que crea una instancia del tipo construido <ph id="ph3">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In order to emit the code to create an instance of the constructed type, you need a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents the constructor of this constructed type — in other words, that creates an instance of <ph id="ph2">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Para emitir el código para crear una instancia del tipo construido, se necesita un <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto que representa el constructor de este tipo construido, es decir, que crea una instancia de <ph id="ph2">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Para ello, llame primero a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método en el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto, especificando la <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto que representa <ph id="ph4">`U`</ph> como el argumento de tipo.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents the constructor of <ph id="ph5">`G&lt;U&gt;`</ph> as parameter <ph id="ph6">`constructor`</ph>.</source>
          <target state="translated">A continuación, llame a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> método con el valor devuelto de la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método como parámetro <ph id="ph3">`type`</ph> y la <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> objeto que representa el constructor de <ph id="ph5">`G&lt;U&gt;`</ph> como parámetro <ph id="ph6">`constructor`</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">El valor devuelto es el <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objeto necesita para emitir la llamada de función.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">El ejemplo de código muestra este escenario.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada <ph id="ph1">`Sample`</ph> que tiene un parámetro de tipo denominado <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La clase tiene un campo denominado <ph id="ph1">`Field`</ph>, del tipo <ph id="ph2">`T`</ph>y un método genérico denominado <ph id="ph3">`GM`</ph> con su propio parámetro de tipo, denominado <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Método <ph id="ph1">`GM`</ph> crea una instancia de <ph id="ph2">`Sample`</ph>, sustituyendo su propio parámetro de tipo <ph id="ph3">`U`</ph> para el parámetro de tipo de <ph id="ph4">`Sample`</ph>y almacena su parámetro de entrada de <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Este código fuente se compila pero no se utiliza; puede ver con el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> y compárelo con el código emitido por la clase <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">El código de clase <ph id="ph1">`Example`</ph> muestra el uso de la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> método para emitir código genérico.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">El <ph id="ph1">`Main`</ph> método de clase <ph id="ph2">`Example`</ph> crea un ensamblado dinámico que contiene una clase denominada <ph id="ph3">`Sample`</ph> y usa el <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> método hacerla genérica mediante la adición de un parámetro de tipo denominado <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un constructor predeterminado y un campo denominado <ph id="ph1">`Field`</ph>, del tipo <ph id="ph2">`T`</ph>, se agregan a la clase <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un método <ph id="ph1">`GM`</ph> se agrega y se convierte en un método genérico mediante el uso de la <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">El parámetro de tipo de <ph id="ph1">`GM`</ph> se denomina <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Una vez definido el parámetro de tipo, la firma de <ph id="ph1">`GM`</ph> se agrega mediante la <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son <ph id="ph1">`null`</ph> excepto <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> establece el tipo del parámetro del método única para <ph id="ph4">`U`</ph>, parámetro de tipo genérico del método.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">El cuerpo del método crea una instancia del tipo construido <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> en Visual Basic), asigna el parámetro del método a <ph id="ph3">`Field`</ph>y, a continuación, imprime el valor de <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents the default constructor of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> instruction that creates the instance.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> método se utiliza para crear un <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> que representa el constructor predeterminado del tipo genérico construido <ph id="ph3">`Sample&lt;U&gt;`</ph> en el <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> instrucción que crea la instancia.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Se define un tipo ficticio para contener el método de punto de entrada <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">En el cuerpo de <ph id="ph1">`Main`</ph>, el método estático <ph id="ph2">`GM`</ph> método se invoca en el tipo genérico construido <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> en Visual Basic), con el tipo de <ph id="ph5">&lt;xref:System.String&gt;</ph> sustituye por <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para comparar el código emitido por el código para el <ph id="ph1">`Sample`</ph> clase que se compila en el ejemplo de código propio.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> no representa un tipo genérico.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> no es del tipo <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> no es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> no es la definición de tipo genérico de <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de un marcador de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, como por ejemplo en <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, entre otros.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the public and non-public constructors defined for this class, as specified.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representa a los constructores públicos y no públicos definidos para esta clase, tal y como se especifica.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the specified constructors defined for this class.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> que representa a los constructores especificados definidos para esta clase.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">Si no se ha definido ningún constructor, se devolverá una matriz vacía.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the custom attributes defined for this type.</source>
          <target state="translated">Devuelve los atributos personalizados definidos para este tipo.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Especifica si se debe buscar en la cadena de herencia de este miembro para encontrar los atributos.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">Devuelve todos los atributos personalizados definidos para este tipo.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this type.</source>
          <target state="translated">Devuelve una matriz de objetos que representa todos los atributos personalizados de este tipo.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Actualmente este método no es compatible para tipos incompletos.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Recupere el tipo mediante el método <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> y llame al método <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> en el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> devuelto.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Tipo de atributo que se va a buscar.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Solo se devuelven los atributos que son asignables a este tipo.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Especifica si se debe buscar en la cadena de herencia de este miembro para encontrar los atributos.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes of the current type that are assignable to a specified type.</source>
          <target state="translated">Devuelve todos los atributos personalizados del tipo actual que se pueden asignar a un tipo especificado.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes defined on the current type.</source>
          <target state="translated">Una matriz de atributos personalizados definida en el tipo actual.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Actualmente este método no es compatible para tipos incompletos.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Recupere el tipo mediante el método <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> y llame al método <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> en el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> devuelto.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type must be a type provided by the underlying runtime system.</source>
          <target state="translated">El tipo debe ser un tipo proporcionado por el sistema en tiempo de ejecución subyacente.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Calling this method always throws <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</source>
          <target state="translated">Cuando se llama a este método, siempre se produce <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">No se admite este método.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>No value is returned.</source>
          <target state="translated">No se devuelve ningún valor.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">No se admite este método.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to search for.</source>
          <target state="translated">Nombre del evento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Combinación bit a bit de valores de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que limita la búsqueda.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the event with the specified name.</source>
          <target state="translated">Devuelve el evento con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if there are no matches.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representa el evento declarado o heredado por este tipo con el nombre especificado, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si no hay ninguna coincidencia.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the events defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Devuelve los eventos definidos por el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns the public events declared or inherited by this type.</source>
          <target state="translated">Devuelve los eventos públicos declarados o heredados por este tipo.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the public events declared or inherited by this type.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representa a los eventos públicos declarados o heredados por este tipo.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>An empty array is returned if there are no public events.</source>
          <target state="translated">Si no hay eventos públicos, se devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Combinación bit a bit de valores de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que limita la búsqueda.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public events that are declared by this type.</source>
          <target state="translated">Devuelve los eventos públicos y no públicos declarados por este tipo.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the events declared or inherited by this type that match the specified binding flags.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> que representan los eventos declarados o heredados por este tipo que coinciden con los marcadores de enlace especificados.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching events.</source>
          <target state="translated">Si no hay eventos coincidentes, se devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a field defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Devuelve un campo definido por el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to get.</source>
          <target state="translated">Nombre del campo que se va a obtener.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de un marcador de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, como por ejemplo en <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, entre otros.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the field specified by the given name.</source>
          <target state="translated">Devuelve el campo especificado por el nombre dado.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</source>
          <target state="translated">Devuelve el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa al campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If there are no matches then <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Si no existen coincidencias, se devolverá <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The constructed generic type whose field is returned.</source>
          <target state="translated">Tipo genérico construido cuyo campo se devuelve.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A field on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which field of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Campo de la definición de tipo genérico de <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, que especifica qué campo de <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> se va a devolver.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</source>
          <target state="translated">Devuelve el campo del tipo genérico construido especificado que corresponde al campo especificado de la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object that represents the field of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, which specifies a field belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa el campo de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> que corresponde a <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, y que especifica un campo perteneciente a la definición de tipo genérico de <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents a field of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> método proporciona una manera de obtener un <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objeto que representa un campo de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents a field <ph id="ph6">`public T F`</ph> in C# syntax (<ph id="ph7">`Public F As T`</ph> in Visual Basic, <ph id="ph8">`public: T F`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, suponga que tiene un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto que representa el tipo <ph id="ph2">`G&lt;T&gt;`</ph> en sintaxis de C# (<ph id="ph3">`G(Of T)`</ph> en Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> en C++) y un <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> objeto que representa un campo <ph id="ph6">`public T F`</ph> en sintaxis de C# (<ph id="ph7">`Public F As T`</ph> en Visual Basic, <ph id="ph8">`public: T F`</ph> en C++) que se definen mediante <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls field <ph id="ph4">`F`</ph> on that instance.</source>
          <target state="translated">Suponga que <ph id="ph1">`G&lt;T&gt;`</ph> tiene un método genérico con parámetros de tipo <ph id="ph2">`U`</ph> que crea una instancia del tipo construido <ph id="ph3">`G&lt;U&gt;`</ph> y campo llamadas <ph id="ph4">`F`</ph> en esa instancia.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents <ph id="ph2">`F`</ph> on the constructed type — in other words, that is of type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Para emitir la llamada de función, se necesita un <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objeto que representa <ph id="ph2">`F`</ph> en el tipo construido, es decir, que es de tipo <ph id="ph3">`U`</ph> en lugar de tipo <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Para ello, llame primero a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método en el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto, especificando la <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto que representa <ph id="ph4">`U`</ph> como el argumento de tipo.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents <ph id="ph5">`F`</ph> as parameter <ph id="ph6">`field`</ph>.</source>
          <target state="translated">A continuación, llame a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> método con el valor devuelto de la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método como parámetro <ph id="ph3">`type`</ph> y la <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> objeto que representa <ph id="ph5">`F`</ph> como parámetro <ph id="ph6">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">El valor devuelto es el <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objeto necesita para emitir la llamada de función.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">El ejemplo de código muestra este escenario.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter named <ph id="ph1">`T`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada Sample que tiene un parámetro de tipo denominado <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La clase tiene un campo denominado <ph id="ph1">`Field`</ph>, del tipo <ph id="ph2">`T`</ph>y un método genérico denominado <ph id="ph3">`GM`</ph> con su propio parámetro de tipo, denominado <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Método <ph id="ph1">`GM`</ph> crea una instancia de <ph id="ph2">`Sample`</ph>, sustituyendo su propio parámetro de tipo <ph id="ph3">`U`</ph> para el parámetro de tipo de <ph id="ph4">`Sample`</ph>y almacena su parámetro de entrada de <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Este código fuente se compila pero no se utiliza; puede ver con el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> y compárelo con el código emitido por la clase <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">El código de clase <ph id="ph1">`Example`</ph> muestra el uso de la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> método para emitir código genérico.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">El <ph id="ph1">`Main`</ph> método de clase <ph id="ph2">`Example`</ph> crea un ensamblado dinámico que contiene una clase denominada <ph id="ph3">`Sample`</ph>y utiliza el <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> método hacerla genérica mediante la adición de un parámetro de tipo denominado <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un constructor predeterminado y un campo denominado <ph id="ph1">`Field`</ph>, del tipo <ph id="ph2">`T`</ph>, se agregan a la clase <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un método <ph id="ph1">`GM`</ph> se agrega y se convierte en un método genérico mediante el uso de la <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">El parámetro de tipo de <ph id="ph1">`GM`</ph> se denomina <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Una vez definido el parámetro de tipo, la firma de <ph id="ph1">`GM`</ph> se agrega mediante la <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son <ph id="ph1">`null`</ph> excepto <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> establece el tipo del parámetro del método única para <ph id="ph4">`U`</ph>, parámetro de tipo genérico del método.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">El cuerpo del método crea una instancia del tipo construido <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> en Visual Basic), asigna el parámetro del método a <ph id="ph3">`Field`</ph>y, a continuación, imprime el valor de <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> that represents the field of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> instructions.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> método se utiliza para crear un <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> que representa el campo de tipo genérico construido <ph id="ph3">`Sample&lt;U&gt;`</ph> en el <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> y <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> instrucciones.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Se define un tipo ficticio para contener el método de punto de entrada <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">En el cuerpo de <ph id="ph1">`Main`</ph>, el método estático <ph id="ph2">`GM`</ph> método se invoca en el tipo genérico construido <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> en Visual Basic), con el tipo de <ph id="ph5">&lt;xref:System.String&gt;</ph> sustituye por <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para comparar el código emitido por el código para el <ph id="ph1">`Sample`</ph> clase que se compila en el ejemplo de código propio.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> no representa un tipo genérico.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> no es del tipo <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="field" /&gt;</ph> no es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="field" /&gt;</ph> no es la definición de tipo genérico de <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de una marca de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public fields that are declared by this type.</source>
          <target state="translated">Devuelve los campos públicos y no públicos declarados por este tipo.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the public and non-public fields declared or inherited by this type.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> que representa a los campos públicos y no públicos declarados o heredados por este tipo.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no fields, as specified.</source>
          <target state="translated">Si no hay campos, devuelve una matriz vacía, tal como se especifica.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Los elementos de la matriz representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</source>
          <target state="translated">Los elementos de la matriz devuelta están en el orden en que aparecen en la lista de parámetros de tipo para la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto representa una definición de tipo genérico si el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> método se ha utilizado para darle parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>This method retrieves the <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objects that represent the generic type parameters.</source>
          <target state="translated">Este método recupera el <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objetos que representan los parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables de términos que se usan en la reflexión genérica, vea la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object for which the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> property returns the current instance.</source>
          <target state="translated">Si se llama a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto para el que el <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> propiedad devuelve <ph id="ph4">`true`</ph>, el <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> propiedad devuelve la instancia actual.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type is always a generic type definition.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> que representa un tipo genérico siempre es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you used the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method to construct a generic type from a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents a generic type definition, using the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> method on the constructed type gets back the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the generic type definition.</source>
          <target state="translated">Si ha usado la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método para construir un tipo genérico a partir un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto que representa una definición de tipo genérico, con el <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> método en el tipo construido vuelve el <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto que representa la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>The current type is not generic.</source>
          <target state="translated">El tipo actual no es genérico.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>The name of the interface.</source>
          <target state="translated">Nombre de la interfaz.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Si es <ph id="ph1">&lt;see langword="true" /&gt;</ph>, la búsqueda no distingue entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Si es <ph id="ph1">&lt;see langword="false" /&gt;</ph>, la búsqueda distingue entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</source>
          <target state="translated">Devuelve la interfaz implementada por esta clase (directa o indirectamente) con el nombre completo que coincide con el nombre de la interfaz dada.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the implemented interface.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa a la interfaz implementada.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns null if no interface matching name is found.</source>
          <target state="translated">Devuelve null si no encuentra una interfaz que coincida con el nombre dado.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface for which the mapping is to be retrieved.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de la interfaz para el que se va a recuperar la asignación.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the requested interface.</source>
          <target state="translated">Devuelve una asignación de interfaz para la interfaz solicitada.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns the requested interface mapping.</source>
          <target state="translated">Devuelve la asignación de interfaz solicitada.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of all the interfaces implemented on this type and its base types.</source>
          <target state="translated">Devuelve una matriz de todas las interfaces implementadas en este tipo y sus tipos base.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the implemented interfaces.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa a las interfaces implementadas.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">Si no se ha definido ninguna, se devolverá una matriz vacía.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member.</source>
          <target state="translated">Nombre del miembro.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of the member to return.</source>
          <target state="translated">Tipo del miembro que se va a devolver.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de un marcador de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, como en el caso de <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public members declared or inherited by this type, as specified.</source>
          <target state="translated">Devuelve todos los miembros públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public members are returned.</source>
          <target state="translated">Si se utiliza <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph>, devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa a los miembros públicos y no públicos definidos en este tipo, en caso contrario, solo devuelve los miembros públicos.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, such as <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de una marca de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, como por ejemplo, <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns the members for the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Devuelve los miembros para los miembros públicos y no públicos declarados o heredados por este tipo.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> que representa a los miembros públicos y no públicos declarados o heredados por este tipo.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching members.</source>
          <target state="translated">Si no coinciden los miembros, devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The constructed generic type whose method is returned.</source>
          <target state="translated">Tipo genérico construido cuyo método se devuelve.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which method of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Método de la definición de tipo genérico de <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, que especifica qué método de <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> se va a devolver.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</source>
          <target state="translated">Devuelve el método del tipo genérico construido especificado que corresponde al método especificado de la definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, which specifies a method belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa el método de <ph id="ph2">&lt;paramref name="type" /&gt;</ph> que corresponde a <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, y que especifica un método perteneciente a la definición de tipo genérico de <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a method of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> método proporciona una manera de obtener un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa un método de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents a method <ph id="ph6">`T M()`</ph> in C# syntax (<ph id="ph7">`Function M() As T`</ph> in Visual Basic, <ph id="ph8">`T M()`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Por ejemplo, suponga que tiene un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto que representa el tipo <ph id="ph2">`G&lt;T&gt;`</ph> en sintaxis de C# (<ph id="ph3">`G(Of T)`</ph> en Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> en C++) y un <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objeto que representa un método <ph id="ph6">`T M()`</ph> en sintaxis de C# (<ph id="ph7">`Function M() As T`</ph> en Visual Basic, <ph id="ph8">`T M()`</ph> en C++) que se definen mediante <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls method <ph id="ph4">`M`</ph> on that instance.</source>
          <target state="translated">Suponga que <ph id="ph1">`G&lt;T&gt;`</ph> tiene un método genérico con parámetros de tipo <ph id="ph2">`U`</ph> que crea una instancia del tipo construido <ph id="ph3">`G&lt;U&gt;`</ph> y llama a método <ph id="ph4">`M`</ph> en esa instancia.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph2">`M`</ph> on the constructed type — in other words, that returns type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Para emitir la llamada de función, se necesita un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa <ph id="ph2">`M`</ph> en el tipo construido, en otras palabras, que devuelve tipo <ph id="ph3">`U`</ph> en lugar de tipo <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Para ello, llame primero a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método en el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto, especificando la <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto que representa <ph id="ph4">`U`</ph> como el argumento de tipo.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents <ph id="ph5">`T M()`</ph> as parameter <ph id="ph6">`method`</ph>.</source>
          <target state="translated">A continuación, llame a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> método con el valor devuelto de la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método como parámetro <ph id="ph3">`type`</ph> y la <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objeto que representa <ph id="ph5">`T M()`</ph> como parámetro <ph id="ph6">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">El valor devuelto es el <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto necesita para emitir la llamada de función.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates a scenario similar to this.</source>
          <target state="translated">El ejemplo de código muestra un escenario similar al siguiente.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada <ph id="ph1">`Sample`</ph> que tiene un parámetro de tipo denominado <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La clase tiene un campo denominado <ph id="ph1">`Field`</ph>, del tipo <ph id="ph2">`T`</ph>y un método genérico denominado <ph id="ph3">`GM`</ph> con su propio parámetro de tipo, denominado <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Método <ph id="ph1">`GM`</ph> crea una instancia de <ph id="ph2">`Sample`</ph>, sustituyendo su propio parámetro de tipo <ph id="ph3">`U`</ph> para el parámetro de tipo de <ph id="ph4">`Sample`</ph>y almacena su parámetro de entrada de <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Este código fuente se compila pero no se utiliza; puede ver con el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> y compárelo con el código emitido por la clase <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">El código de clase <ph id="ph1">`Example`</ph> muestra el uso de la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> método para emitir código genérico.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">El <ph id="ph1">`Main`</ph> método de clase <ph id="ph2">`Example`</ph> crea un ensamblado dinámico que contiene una clase denominada <ph id="ph3">`Sample`</ph> y usa el <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> método hacerla genérica mediante la adición de un parámetro de tipo denominado <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un constructor predeterminado y un campo denominado <ph id="ph1">`Field`</ph>, del tipo <ph id="ph2">`T`</ph>, se agregan a la clase <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un método <ph id="ph1">`GM`</ph> se agrega y se convierte en un método genérico mediante el uso de la <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">El parámetro de tipo de <ph id="ph1">`GM`</ph> se denomina <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Una vez definido el parámetro de tipo, la firma de <ph id="ph1">`GM`</ph> se agrega mediante la <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son <ph id="ph1">`null`</ph> excepto <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> establece el tipo del parámetro del método única para <ph id="ph4">`U`</ph>, parámetro de tipo genérico del método.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">El cuerpo del método crea una instancia del tipo construido <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> en Visual Basic), asigna el parámetro del método a <ph id="ph3">`Field`</ph>y, a continuación, imprime el valor de <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Se define un tipo ficticio para contener el método de punto de entrada <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">En el cuerpo de <ph id="ph1">`Main`</ph>, el método estático <ph id="ph2">`GM`</ph> método se invoca en el tipo genérico construido <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> en Visual Basic), con el tipo de <ph id="ph5">&lt;xref:System.String&gt;</ph> sustituye por <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> método se utiliza para crear un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para el método estático <ph id="ph3">`GM`</ph> método del tipo genérico construido <ph id="ph4">`Sample&lt;U&gt;`</ph>y el <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> , a continuación, se utiliza el método para crear un <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que pueden emitir en una llamada al método.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> para comparar el código emitido por el código para el <ph id="ph1">`Sample`</ph> clase que se compila en el ejemplo de código propio.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is a generic method that is not a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> es un método genérico que no es una definición de método genérico.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> no representa un tipo genérico.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> no es del tipo <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="method" /&gt;</ph> no es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">El tipo declarativo de <ph id="ph1">&lt;paramref name="method" /&gt;</ph> no es la definición de tipo genérico de <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de un marcador de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, como por ejemplo en <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, entre otros.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public methods declared or inherited by this type, as specified.</source>
          <target state="translated">Devuelve los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing the public and non-public methods defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public methods are returned.</source>
          <target state="translated">Si se utiliza <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph>, devuelve una matriz de objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa los métodos públicos y no públicos definidos en este tipo, en caso contrario, solo devuelve los métodos públicos.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name of the nested type to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene el nombre del tipo anidado que se va a obtener.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Máscara de bits formada por una o varias enumeraciones <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> que especifican la forma en que se realiza la búsqueda.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to conduct a case-sensitive search for public methods.</source>
          <target state="translated">Cero, para realizar una búsqueda de métodos públicos que distinga entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared by this type.</source>
          <target state="translated">Devuelve los campos públicos y no públicos anidados, declarados por este tipo.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo anidado que coincide con los requisitos especificados, si se encuentra; en caso contrario, es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Si este tipo es completo, por ejemplo, si <ph id="ph1">`CreateType`</ph> se ha llamado en este tipo, pero hay tipos anidados que no están completos, a continuación, <ph id="ph2">`GetNestedTypes`</ph> solo devolverá los tipos anidados para los que <ph id="ph3">`CreateType`</ph> se ha llamado.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de un marcador de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, como en el caso de <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared or inherited by this type.</source>
          <target state="translated">Devuelve los tipos públicos y no públicos anidados, declarados o heredados por este tipo.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa a todos los tipos anidados en el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual que coincidan con las restricciones de enlace especificadas.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no types are nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the nested types match the binding constraints.</source>
          <target state="translated">Matriz vacía de tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> si no hay tipos anidados en el objeto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> actual o si ninguno de los tipos anidados coincide con las restricciones de enlace.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Si este tipo es completo, por ejemplo, si <ph id="ph1">`CreateType`</ph> se ha llamado en este tipo, pero hay tipos anidados que no están completos, a continuación, <ph id="ph2">`GetNestedTypes`</ph> solo devolverá los tipos anidados para los que <ph id="ph3">`CreateType`</ph> se ha llamado.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This invocation attribute.</source>
          <target state="translated">Atributo de invocación.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Debe tratarse de una marca de bits de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, etc.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public properties declared or inherited by this type, as specified.</source>
          <target state="translated">Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, tal como se especifica.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing the public and non-public properties defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public properties are returned.</source>
          <target state="translated">Si se utiliza <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph>, devuelve una matriz de objetos <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> que representa a las propiedades públicas y no públicas definidas en este tipo; en caso contrario, solo devuelve las propiedades públicas.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Este método no se implementa en el caso de tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type.</source>
          <target state="translated">Recupera el GUID de este tipo.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type</source>
          <target state="translated">Recupera el GUID de este tipo.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Actualmente este método no es compatible para tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">Nombre del miembro al que se va a invocar.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This can be a constructor, method, property, or field.</source>
          <target state="translated">Puede ser un constructor, un método, una propiedad o un campo.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">Debe especificarse un atributo de invocación apropiado.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</source>
          <target state="translated">Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">Atributo de invocación.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be a bit flag from <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Debe ser una marca de bits de <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> mediante la reflexión.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Si el enlazador es <ph id="ph1">&lt;see langword="null" /&gt;</ph> se utilizará el enlazador predeterminado.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Objeto donde debe invocarse al miembro especificado.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member is static, this parameter is ignored.</source>
          <target state="translated">Si el miembro es estático, se ignora este parámetro.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An argument list.</source>
          <target state="translated">Lista de argumentos.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">Se trata de una matriz de objetos que contiene el número, orden y tipo de los parámetros del miembro que se va a invocar.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If there are no parameters this should be null.</source>
          <target state="translated">Si no hay ningún parámetro, este debería ser null.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">Matriz de la misma longitud que <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the metadata.</source>
          <target state="translated">Parámetro con los atributos asociados a él en los metadatos.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>They are used by various interoperability services.</source>
          <target state="translated">Los usan varios servicios de interoperabilidad.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See the metadata specs for more details.</source>
          <target state="translated">Consulte las especificaciones de metadatos para obtener más detalles.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Instancia de <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> por la que se rige la conversión de tipos.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If this is null, the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Si es null, se utiliza la clase <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> para el subproceso actual.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Observe que esto es necesario, por ejemplo, para convertir una cadena que representa 1000 en un valor doble, ya que 1000 se representa de forma diferente en distintas referencias culturales).</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> array gets the value in the corresponding element in the <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Cada parámetro de la matriz <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> obtiene el valor del elemento correspondiente de la matriz <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> is greater than the length of <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, the remaining argument values are passed in order.</source>
          <target state="translated">Si la longitud de <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> es mayor que la longitud de <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, los valores de argumento restantes se pasan en orden.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">Invoca al miembro especificado.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">El método al que se va a invocar debe estar accesible y proporcionar la coincidencia más específica con la lista de argumentos especificada, teniendo en cuenta las restricciones del enlazador predeterminado y los atributos de invocación indicados.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Returns the return value of the invoked member.</source>
          <target state="translated">Devuelve el valor devuelto del miembro invocado.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Un método se invocará si el número de parámetros en la declaración del método es igual al número de argumentos en la lista de argumentos especificados, y el tipo de cada argumento se puede convertir por el enlazador al tipo del parámetro.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">El enlazador encontrará todos los métodos de búsqueda de coincidencias.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</source>
          <target state="translated">Estos métodos se encuentran en función del tipo de enlace solicitado (BindingFlags.InvokeMethod, BindingFlags.GetProperties etc.).</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">Después de selecciona el método, se invocará.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">En ese momento se comprueba la accesibilidad.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">La búsqueda puede controlar qué conjunto de métodos que se buscan basándose en el atributo de accesibilidad asociado al método.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`IBinder.BindToMethod`</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated">El <ph id="ph1">`IBinder.BindToMethod`</ph> método es responsable de seleccionar el método que se debe invocar.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">El enlazador predeterminado selecciona a la coincidencia más específica.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Se omiten las restricciones de acceso de código de plena confianza.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">Es decir, propiedades, métodos, campos y constructores privados son accesibles y se invocan mediante la reflexión siempre que el código es de plena confianza.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported.</source>
          <target state="translated">Actualmente este método no es compatible.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Puede recuperar el tipo usando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Actualmente este método no es compatible para tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Determines whether a specified type can be assigned to this object.</source>
          <target state="translated">Determina si se puede asignar un tipo especificado a este objeto.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The object to test.</source>
          <target state="translated">Objeto que se va a probar.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object can be assigned to this object.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> especificado puede asignarse a este objeto.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> can be assigned to this object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> se puede asignar este objeto; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>The object to test.</source>
          <target state="translated">Objeto que se va a probar.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be assigned to this object.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> especificado puede asignarse a este objeto.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="c" /&gt;</ph> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, or if the current type is an interface that <ph id="ph4">&lt;paramref name="c" /&gt;</ph> supports.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el parámetro <ph id="ph2">&lt;paramref name="c" /&gt;</ph> y el tipo actual representan el mismo tipo, o si el tipo actual se encuentra en la jerarquía de herencia de <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, o si el tipo actual es una interfaz compatible con <ph id="ph4">&lt;paramref name="c" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are valid, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="false" /&gt;</ph> si ninguna de estas condiciones son válidas o si <ph id="ph2">&lt;paramref name="c" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este objeto representa una definición de tipo genérico construido; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Returns a value that indicates whether the current dynamic type has been created.</source>
          <target state="translated">Devuelve un valor que indica si se ha creado el tipo dinámico actual.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has been called; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se ha llamado al método <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called, the type represented by the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object is complete.</source>
          <target state="translated">Después de la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método se ha llamado, el tipo representado por la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto está completa.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</source>
          <target state="translated">Las excepciones se producen en cualquier intento posterior de agregar a miembros o cambiar otras características del tipo.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Tipo de atributo que se va a buscar.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Solo se devuelven los atributos que son asignables a este tipo.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Especifica si se debe buscar en la cadena de herencia de este miembro para encontrar los atributos.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Determines whether a custom attribute is applied to the current type.</source>
          <target state="translated">Determina si un atributo personalizado se aplica al tipo actual.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, or an attribute derived from <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, is defined on this type; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si hay definidas una o más instancias de <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, o de un atributo derivado de <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, en este tipo; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not supported for incomplete generic type parameters.</source>
          <target state="translated">Este método no se admite para los parámetros de tipo genérico incompletos.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Actualmente este método no es compatible para tipos incompletos.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Recupere el tipo mediante el método <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> y llame al método <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> en el objeto <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> devuelto.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> no se ha definido.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>Gets a value indicating whether the current type is a generic type parameter.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es un parámetro de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> actual representa un parámetro de tipo genérico; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Al emitir el código, un parámetro de tipo genérico se representa mediante un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objeto en lugar de un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es genérico.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object is generic; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo representado por el objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> actual es genérico; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto representa una definición de tipo genérico si el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> método se ha utilizado para darle parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Una instancia de la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> clase genérica siempre es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables de términos que se usan en la reflexión genérica, vea la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> represents a generic type definition from which other generic types can be constructed.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> actual representa una definición de tipo genérico, a partir de la cual se pueden construir otros tipos genéricos.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este objeto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> representa una definición de tipo genérico; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objeto representa una definición de tipo genérico si el <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> método se ha utilizado para darle parámetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Una instancia de la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> clase genérica siempre es una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be used to build generic type definitions, but not constructed generic types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> puede usarse para crear definiciones de tipo genérico, pero no tipos genéricos construidos.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>To get a constructed generic type, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Para obtener un tipo genérico construido, llame a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> que representa una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables de términos que se usan en la reflexión genérica, vea la <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente y, por tanto, puede realizar operaciones críticas.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si es transparente.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">Crítico para la seguridad</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Puede invalidar este comportamiento predeterminado mediante el uso de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método y especificando los atributos de seguridad.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código crítico para la seguridad o bien crítico para la seguridad.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Herencia predeterminada se limita a la evaluación del runtime de transparencia.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">No hay atributos se aplican al ensamblado dinámico.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Si desea agregar atributos de seguridad, debe aplicarlos usted mismo.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de la reflexión emitir y transparencia, consulte <bpt id="p1">[</bpt>problemas de seguridad en la emisión de reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">El tipo dinámico actual no se ha creado llamando al método <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo actual es crítico para la seguridad y disponible desde código transparente; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si es crítico para la seguridad o transparente.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">Crítico para la seguridad</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Puede invalidar este comportamiento predeterminado mediante el uso de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método y especificando los atributos de seguridad.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código crítico para la seguridad o bien crítico para la seguridad.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Herencia predeterminada se limita a la evaluación del runtime de transparencia.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">No hay atributos se aplican al ensamblado dinámico.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Si desea agregar atributos de seguridad, debe aplicarlos usted mismo.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de la reflexión emitir y transparencia, consulte <bpt id="p1">[</bpt>problemas de seguridad en la emisión de reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">El tipo dinámico actual no se ha creado llamando al método <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</source>
          <target state="translated">Obtiene un valor que indica si el tipo actual es transparente y, por tanto, no puede realizar operaciones críticas.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el tipo es transparente para la seguridad; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> propiedades notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">Nivel de seguridad</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">Crítico para la seguridad</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Puede invalidar este comportamiento predeterminado mediante el uso de la <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método y especificando los atributos de seguridad.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código crítico para la seguridad o bien crítico para la seguridad.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Herencia predeterminada se limita a la evaluación del runtime de transparencia.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">No hay atributos se aplican al ensamblado dinámico.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Si desea agregar atributos de seguridad, debe aplicarlos usted mismo.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de la reflexión emitir y transparencia, consulte <bpt id="p1">[</bpt>problemas de seguridad en la emisión de reflexión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obtener información acerca de las transparencias, consulte <bpt id="p1">[</bpt>cambios de seguridad<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">El tipo dinámico actual no se ha creado llamando al método <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that is to be checked.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que se va a comprobar.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Determines whether this type is derived from a specified type.</source>
          <target state="translated">Determina si este tipo se deriva de un tipo especificado.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if this type is the same as the type <ph id="ph2">&lt;paramref name="c" /&gt;</ph>, or is a subtype of type <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Devuelve <ph id="ph1">&lt;see langword="true" /&gt;</ph> si este tipo es igual que el tipo <ph id="ph2">&lt;paramref name="c" /&gt;</ph> o si es un subtipo del tipo <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; en caso contrario, devuelve <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz del tipo actual.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz unidimensional cuyo tipo de elemento es el tipo actual, con un límite inferior de cero.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> método proporciona una manera de generar un tipo de matriz con cualquier tipo de elemento posible, incluidos los tipos genéricos.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado <ph id="ph1">`Sample`</ph>y un método abstracto denominado <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> toma una <ph id="ph2">`ref`</ph> parámetro (<ph id="ph3">`ByRef`</ph> en Visual Basic) de tipo <ph id="ph4">`Sample`</ph>, un puntero al tipo <ph id="ph5">`Sample`</ph>y una matriz de tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Devuelve una matriz bidimensional de tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Número de dimensiones de la matriz.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz del tipo actual, con el número de dimensiones especificado.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa una matriz unidimensional del tipo actual.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> método proporciona una manera de generar un tipo de matriz con cualquier tipo de elemento posible, incluidos los tipos genéricos.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado <ph id="ph1">`Sample`</ph>y un método abstracto denominado <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> toma una <ph id="ph2">`ref`</ph> parámetro (<ph id="ph3">`ByRef`</ph> en Visual Basic) de tipo <ph id="ph4">`Sample`</ph>, un puntero al tipo <ph id="ph5">`Sample`</ph>y una matriz de tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Devuelve una matriz bidimensional de tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is not a valid array dimension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> no es una dimensión de matriz válida.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo actual cuando se pasa como un parámetro <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo actual cuando se pasa como un parámetro <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> método proporciona una manera de generar <ph id="ph2">`ref`</ph> tipos (<ph id="ph3">`ByRef`</ph> en Visual Basic) para el parámetro se enumeran.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType&amp;`</ph>.</source>
          <target state="translated">Utiliza la sintaxis de lenguaje intermedio (MSIL) de Microsoft, si la actual <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> representa <ph id="ph2">`MyType`</ph>, entonces el tipo devuelto por este método se <ph id="ph3">`MyType&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado <ph id="ph1">`Sample`</ph>y un método abstracto denominado <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> toma una <ph id="ph2">`ref`</ph> parámetro (<ph id="ph3">`ByRef`</ph> en Visual Basic) de tipo <ph id="ph4">`Sample`</ph>, un puntero al tipo <ph id="ph5">`Sample`</ph>y una matriz de tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Devuelve una matriz bidimensional de tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type definition.</source>
          <target state="translated">Matriz de tipos que se van a sustituir por los parámetros de tipo de la definición de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</source>
          <target state="translated">Sustituye los elementos de una matriz de tipos por los parámetros de la definición de tipo genérico actual y devuelve el tipo construido resultante.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo construido formado al sustituir los elementos de <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> por los parámetros del tipo genérico actual. </target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Use this method when your emitted code requires a type constructed from the current generic type definition.</source>
          <target state="translated">Use este método cuando el código emitido requiere un tipo construido a partir de la definición de tipo genérico actual.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is not necessary to call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">No es necesario llamar a la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método antes de llamar a la <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> método en un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> que representa una definición de tipo genérico.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent the definition of a generic type, an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> no representa la definición de un tipo genérico, un <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> se produce.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</source>
          <target state="translated">El objeto devuelto por este método funciona como un marcador de posición para un tipo genérico construido en el código emitido.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is an instance of a class derived from <ph id="ph1">&lt;xref:System.Type&gt;</ph> that has limited capabilities.</source>
          <target state="translated">Es una instancia de una clase derivada de <ph id="ph1">&lt;xref:System.Type&gt;</ph> que tiene capacidades limitadas.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>In particular:</source>
          <target state="translated">En concreto:</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>To get methods, fields, and constructors for these constructed generic types, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> method overloads.</source>
          <target state="translated">Para obtener los métodos, campos y constructores para estos tipos genéricos construyen, use la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, y <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> sobrecargas del método.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Two instances that represent the same constructed type do not compare as equal.</source>
          <target state="translated">Dos instancias que representan el mismo tipo construido no comparables a igual.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>For example, in the following code <ph id="ph1">`t1.Equals(t2)`</ph> returns <ph id="ph2">`false`</ph>:</source>
          <target state="translated">Por ejemplo, en el código siguiente <ph id="ph1">`t1.Equals(t2)`</ph> devuelve <ph id="ph2">`false`</ph>:</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The current type does not represent the definition of a generic type.</source>
          <target state="translated">El tipo actual no representa la definición de un tipo genérico.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es decir, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cualquier elemento de <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> property of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> de cualquier elemento de <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> property of the module of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> del módulo de cualquier elemento de <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo de un puntero no administrado al tipo actual.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa el tipo de un puntero no administrado al tipo actual.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> método proporciona un medio para generar tipos de puntero para listas de parámetros.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType*`</ph>.</source>
          <target state="translated">Utiliza la sintaxis de lenguaje intermedio (MSIL) de Microsoft, si la actual <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> representa <ph id="ph2">`MyType`</ph>, entonces el tipo devuelto por este método se <ph id="ph3">`MyType*`</ph>.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado <ph id="ph1">`Sample`</ph>y un método abstracto denominado <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> toma una <ph id="ph2">`ref`</ph> parámetro (<ph id="ph3">`ByRef`</ph> en Visual Basic) de tipo <ph id="ph4">`Sample`</ph>, un puntero al tipo <ph id="ph5">`Sample`</ph>y una matriz de tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Devuelve una matriz bidimensional de tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Recupera el módulo dinámico que contiene la definición de este tipo.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Recupera el módulo dinámico que contiene la definición de este tipo.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the name of this type.</source>
          <target state="translated">Recupera el nombre de este tipo.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> name of this type.</source>
          <target state="translated">Recupera el nombre <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> de este tipo.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Recupera el espacio de nombres en el que está definido este <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Recupera el espacio de nombres en el que está definido este <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Recupera el tamaño de paquete de este tipo.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Recupera el tamaño de paquete de este tipo.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Returns the type that was used to obtain this type.</source>
          <target state="translated">Devuelve el tipo utilizado para obtener este tipo.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>The type that was used to obtain this type.</source>
          <target state="translated">Tipo utilizado para obtener este tipo.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Establece un atributo personalizado.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">Instancia de una clase de ayuda utilizada para definir el atributo personalizado.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute using a custom attribute builder.</source>
          <target state="translated">Establece un atributo personalizado utilizando un generador de atributos personalizados.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este miembro ya no requiere <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> marca.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de seguridad en la reflexión emisión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Constructor para el atributo personalizado.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">Objeto binario de bytes que representa los atributos.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Establece un atributo personalizado mediante un objeto binario de atributo especificado y personalizado.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Para obtener más información sobre cómo dar formato a <ph id="ph1">`binaryAttribute`</ph>, consulte la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos".</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentación está disponible en línea; vea <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este miembro ya no requiere <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con el <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> marca.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>problemas de seguridad en la reflexión emisión<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Para utilizar esta funcionalidad, la aplicación debe utilizar <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o posterior como destino.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> o <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> es <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The new base type.</source>
          <target state="translated">Nuevo tipo base.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>Sets the base type of the type currently under construction.</source>
          <target state="translated">Establece el tipo base del tipo actualmente en construcción.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>If <ph id="ph1">`parent`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> is used as the base type.</source>
          <target state="translated">Si <ph id="ph1">`parent`</ph> es <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> se utiliza como el tipo base.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <ph id="ph1">`parent`</ph> is an interface type, but a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> is thrown when the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">En las versiones 1.0 y 1.1 de .NET Framework, se inicia ninguna excepción si <ph id="ph1">`parent`</ph> es un tipo de interfaz, pero un <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> se produce cuando el <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> se llama al método.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> method does not check for most invalid parent types.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> método no comprueba la mayoría de los tipos de elemento primario no válido.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> type.</source>
          <target state="translated">Por ejemplo, no rechaza un tipo primario que no tiene ningún constructor predeterminado cuando el tipo actual tiene un constructor predeterminado, no rechaza los tipos sellados y no rechaza el <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In all these cases, exceptions are thrown by the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
          <target state="translated">En todos estos casos, las excepciones se inician mediante el <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the current instance represents an interface whose attributes do not include <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y la instancia actual representa una interfaz cuyos atributos no incluyen <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Para el tipo dinámico actual, la propiedad <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>, pero la propiedad <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> es <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> es una interfaz.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>This exception condition is new in the .NET Framework version 2.0.</source>
          <target state="translated">Esta condición de excepción es nueva en la versión 2.0 de .NET Framework.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves the total size of a type.</source>
          <target state="translated">Recupera el tamaño total de un tipo.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves this type’s total size.</source>
          <target state="translated">Recupera el tamaño total de este tipo.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz que se pasa con los nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Número de nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexto de configuración regional en el que se van a interpretar los nombres.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz asignada por quien realiza la llamada que recibe los id. que corresponden a los nombres.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Información de tipos que se va a devolver.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificador de la configuración regional de la información de tipo.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recibe un puntero al objeto de información de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera la información de tipo de un objeto, que se puede utilizar después para obtener la información de tipo de una interfaz.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica el miembro.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexto de la configuración regional en que se interpretan los argumentos.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Marcas que describen el contexto de la llamada.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntero a la ubicación donde se va a almacenar el resultado.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntero a una estructura que contiene información de excepciones.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Índice del primer argumento que tiene un error.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::Invoke`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Returns the name of the type excluding the namespace.</source>
          <target state="translated">Devuelve el nombre del tipo sin incluir el espacio de nombres.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>The name of the type excluding the namespace.</source>
          <target state="translated">Nombre del tipo sin incluir el espacio de nombres.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">No es compatible en módulos dinámicos.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recupere el tipo mediante <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> y utilizar la reflexión en el tipo recuperado.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">No es compatible en módulos dinámicos.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the type token of this type.</source>
          <target state="translated">Devuelve el símbolo (token) de tipo de este tipo.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> of this type.</source>
          <target state="translated">Devuelve el <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> de este tipo.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">El tipo se ha creado previamente mediante <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type for this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Devuelve el tipo de sistema subyacente para este <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Read-only.</source>
          <target state="translated">Es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type.</source>
          <target state="translated">Devuelve el tipo de sistema subyacente.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>This type is an enumeration, but there is no underlying system type.</source>
          <target state="translated">Este tipo es una enumeración pero no hay ningún tipo de sistema subyacente.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
          <source>Represents that total size for the type is not specified.</source>
          <target state="translated">Indica que el tamaño total del tipo no está especificado.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>