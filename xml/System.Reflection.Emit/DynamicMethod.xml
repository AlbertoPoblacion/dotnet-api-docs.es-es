<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="27f229b19693e5f93b88f14817c1ac384a6931af" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48701192" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define y representa un método dinámico que se puede compilar, ejecutar y descartar. Los métodos descartados están disponibles para la recolección de elementos no utilizados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Reflection.Emit.DynamicMethod> clase para generar y ejecutar un método en tiempo de ejecución sin tener que generar un ensamblado dinámico y un tipo dinámico para que contenga el método. Se recupera el código ejecutable creado por el compilador just-in-time (JIT) cuando el <xref:System.Reflection.Emit.DynamicMethod> reclame el objeto. Los métodos dinámicos son la forma más eficaz para generar y ejecutar pequeñas cantidades de código.  
  
 Un método dinámico puede hospedarse de forma anónima, o puede ser lógicamente asociado a un módulo o a un tipo.  
  
-   Si el método dinámico es hospedado de forma anónima, se encuentra en un ensamblado proporcionado por el sistema y, por tanto, está aislado del resto del código. De forma predeterminada, no tiene acceso a datos no públicos. Un método dinámico hospedado de forma anónima puede restringir la capacidad de omitir las comprobaciones de visibilidad del compilador JIT, si se ha concedido <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca. El nivel de confianza del ensamblado cuyos miembros no públicos se tiene acceso el método dinámico debe ser igual a, o un subconjunto de, el nivel de confianza de la pila de llamadas que emite el método dinámico. Para obtener más información sobre los métodos dinámicos hospedados de forma anónima, vea [Tutorial: emitir código en escenarios de confianza parcial](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Si el método dinámico está asociado con un módulo que se especifica, el método dinámico es efectivamente global para ese módulo. Puede tener acceso a todos los tipos del módulo y todos `internal` (`Friend` en Visual Basic) los miembros de los tipos. Puede asociar una dinámica proporciona el método a cualquier módulo, independientemente de si ha creado el módulo, que una petición para <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> marca se puede satisfacer mediante la pila de llamadas que incluye el código. Si el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca se incluye en la concesión, el método dinámico puede omitir las comprobaciones de visibilidad del compilador JIT y obtener acceso a los datos privados de todos los tipos declarados en el módulo o en cualquier otro módulo de cualquier ensamblado.  
  
    > [!NOTE]
    >  Cuando se especifica el módulo que está asociado un método dinámico, dicho módulo no debe estar en el ensamblado proporcionado por el sistema que se usa para el hospedaje anónimo.  
  
-   Si el método dinámico está asociado con un tipo que especifique, tiene acceso a todos los miembros del tipo, independientemente del nivel de acceso. Además, se pueden omitir las comprobaciones de visibilidad JIT. Esto proporciona el método dinámico obtiene acceso a los datos privados de otros tipos declarados en el mismo módulo o en cualquier otro módulo de cualquier ensamblado. Puede asociar un método dinámico con cualquier tipo, pero el código debe tener concedido <xref:System.Security.Permissions.ReflectionPermission> con ambos el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> y <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> marcas.  
  
 La siguiente tabla muestra qué tipos y miembros son accesibles a un método dinámico hospedado de forma anónima, con y sin comprobaciones de visibilidad JIT, dependiendo de si <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> se concede la marca.  
  
||Sin <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Con <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Sin omitir las comprobaciones de visibilidad JIT|Miembros públicos de tipos públicos de cualquier ensamblado.|Miembros públicos de tipos públicos de cualquier ensamblado.|  
|JIT de omitir las comprobaciones de visibilidad, con restricciones|Miembros públicos de tipos públicos de cualquier ensamblado.|Todos los miembros de todos los tipos, solo en los ensamblados cuyos niveles de confianza son iguales o menores que el nivel de confianza del ensamblado que emite el método dinámico.|  
  
> [!NOTE]
>  Anteriores a la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], emisión de código requerido <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. Este permiso se incluye de forma predeterminada en denominado conjuntos de permisos de LocalIntranet y FullTrust, pero no en la Internet conjunto de permisos. Por lo tanto, en versiones anteriores de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] se puede usar una biblioteca con permisos de Internet sólo si tiene la <xref:System.Security.SecurityCriticalAttribute> atributo y también ejecuta un <xref:System.Security.PermissionSet.Assert%2A> para <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Estas bibliotecas requieren una revisión cuidadosa de la seguridad porque los errores de codificación pueden provocar vulnerabilidades de seguridad. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] permite emitir código en escenarios de confianza parcial sin emitir ninguna petición de seguridad, porque la generación de código no es en sí una operación que requiera privilegios. Es decir, el código generado no tiene más permisos que el ensamblado que lo emite. Esto permite que las bibliotecas que emiten código sean transparentes en seguridad y elimina la necesidad de declarar <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, lo que simplifica la tarea de escribir una biblioteca segura. Para usar esta característica, la aplicación debe tener como destino el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o una versión posterior.  
  
 La siguiente tabla muestra qué tipos y miembros son accesibles a un método dinámico que está asociado con un módulo o a un tipo de un módulo.  
  
||Asociado con el módulo|Asociado con tipo|  
|-|-|-|  
|Sin omitir las comprobaciones de visibilidad JIT|Miembros públicos e internos de tipos públicos, internos y privados en el módulo.<br /><br /> Miembros públicos de tipos públicos de cualquier ensamblado.|Todos los miembros del tipo asociado. Miembros públicos e internos de todos los demás tipos del módulo.<br /><br /> Miembros públicos de tipos públicos de cualquier ensamblado.|  
|Omitiendo las comprobaciones de visibilidad JIT|Todos los miembros de todos los tipos en cualquier ensamblado.|Todos los miembros de todos los tipos en cualquier ensamblado.|  
  
 Un método dinámico que está asociado a un módulo tiene los permisos de ese módulo. Un método dinámico que está asociado a un tipo tiene los permisos del módulo que contiene ese tipo.  
  
 Métodos dinámicos y sus parámetros no es necesario que el nombre, pero puede especificar nombres para ayudar en la depuración. Los atributos personalizados no se admiten en los métodos dinámicos o sus parámetros.  
  
 Aunque los métodos dinámicos son `static` métodos (`Shared` métodos en Visual Basic), el más flexible de las reglas de enlace a delegados introducidas en la [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] permitir que un método dinámico al enlazarse a un objeto, para que actúe como un método de instancia cuando se llama con esa instancia de delegado. Se proporciona un ejemplo que muestra esto para el <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga del método.  
  
> [!NOTE]
>  En el [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], los métodos dinámicos no admiten la información de símbolos, es decir, nombres de variables locales y asignación de número de línea. Esta limitación podría quitarse en una versión futura. Puede usar <xref:System.Reflection.Emit.AssemblyBuilder> durante el desarrollo para simplificar la depuración del lenguaje intermedio de Microsoft (MSIL) generado y, a continuación, pasar a métodos dinámicos durante la implementación final, ya que el <xref:System.Reflection.Emit.ILGenerator> llamadas son los mismos en ambos casos.  
  
## <a name="verification"></a>para complementos  
 En la lista siguiente se resume las condiciones en las que los métodos dinámicos pueden contener código no comprobable. (Por ejemplo, un método dinámico es no se puede comprobar si su <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> propiedad está establecida en `false`.)  
  
-   Un método dinámico que está asociado a un ensamblado crítico para la seguridad también es crítico para la seguridad y puede omitir la comprobación. Por ejemplo, un ensamblado sin atributos de seguridad que se ejecuta como una aplicación de escritorio se trata como crítico para la seguridad por el tiempo de ejecución. Si asocia un método dinámico con el ensamblado, el método dinámico puede contener código no comprobable.  
  
-   Si un método dinámico que contiene código no comprobable está asociado a un ensamblado que tiene la transparencia de nivel 1, el compilador de just-in-time (JIT) inserta una petición de seguridad. La demanda se realiza correctamente sólo si el método dinámico se ejecuta código de plena confianza. Consulte [código transparente en seguridad, nivel 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Si un método dinámico que contiene código no comprobable está asociado a un ensamblado que tiene la transparencia de nivel 2 (como mscorlib.dll), produce una excepción (insertada por el compilador JIT) en lugar de realizar una petición de seguridad. Consulte [código transparente en seguridad, nivel 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Un método dinámico hospedado de forma anónima que contiene código no comprobable siempre produce una excepción. Nunca puede omitir la comprobación, incluso si se crea y ejecuta código de plena confianza.  
  
 La excepción que se produce en código no comprobable varía según la manera en que se invoca el método dinámico. Si invoca un método dinámico mediante el uso de un delegado devuelto por la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método, un <xref:System.Security.VerificationException> se produce. Si se invoca el método dinámico utilizando la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, un <xref:System.Reflection.TargetInvocationException> se produce con interior <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un método dinámico que toma dos parámetros. El ejemplo emite un cuerpo de función sencilla que imprime el primer parámetro en la consola y, en el ejemplo se usa el segundo parámetro como el valor devuelto del método. En el ejemplo se finaliza el método mediante la creación de un delegado, invoca el delegado con parámetros diferentes y, por último, se invoca el método dinámico usando el <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Tutorial: Emitir código en escenarios que no son de plena confianza</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un método dinámico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico o <see langword="null" /> si el método no tiene parámetros.</param>
        <summary>Inicializa un método dinámico hospedado de forma anónima, especificando el nombre del método, el tipo de valor devuelto y los tipos de parámetros.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método dinámico creado por este constructor está asociado con un ensamblado anónimo en lugar de un tipo o módulo existente. El ensamblado anónimo existe solo para proporcionar un entorno de recinto de seguridad para los métodos dinámicos, es decir, para aislarlos de otro código. Este entorno resulta seguro para el método dinámico se genera y ejecuta código de confianza parcial.  
  
 Este constructor especifica que just-in-time (JIT) las comprobaciones de visibilidad, se exige el lenguaje intermedio de Microsoft (MSIL) del método dinámico. Es decir, el código del método dinámico tiene acceso a los métodos públicos de las clases públicas. Se producen excepciones si el método intenta obtener acceso a tipos o miembros que son `private`, `protected`, o `internal` (`Friend` en Visual Basic). Para crear un método dinámico que se ha restringido la capacidad de omitir las comprobaciones de visibilidad JIT, utilice el <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor.  
  
 Cuando se crea un método dinámico hospedado de forma anónima, se incluye la pila de llamadas del ensamblado emisor. Cuando se invoca el método, los permisos del ensamblado emisor se usan en lugar de los permisos del llamador real. Por lo tanto, el método dinámico no se puede ejecutar en un nivel de privilegios superior del ensamblado que genera, incluso si se pasa a y se ejecuta un ensamblado que tiene un mayor nivel de confianza.  
  
 Este constructor especifica los atributos del método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> y <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>y la convención de llamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Este constructor se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o una versión posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Tutorial: Emitir código en escenarios que no son de plena confianza</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="restrictedSkipVisibility">
          <see langword="true" /> para omitir las comprobaciones de visibilidad de JIT en tipos y miembros a los que se tiene acceso por el MSIL del método dinámico, con esta restricción: el nivel de confianza de los ensamblados que contienen esos tipos y miembros debe ser igual o menor que el nivel de confianza de la pila de llamadas que emite el método dinámico; de lo contrario, <see langword="false" />.</param>
        <summary>Inicializa un método dinámico hospedado de forma anónima, especificando el nombre del método, el tipo de valor devuelto, los tipos de parámetros y si se deben omitir comprobaciones de visibilidad Just-In-Time (JIT) para tipos y miembros a los que se tiene acceso por el lenguaje intermedio de Microsoft (MSIL) del método dinámico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método dinámico creado por este constructor está asociado con un ensamblado anónimo en lugar de un tipo o módulo existente. El ensamblado anónimo existe solo para proporcionar un entorno de recinto de seguridad para los métodos dinámicos, es decir, para aislarlos de otro código. Este entorno resulta seguro para el método dinámico se genera y ejecuta código de confianza parcial.  
  
 Métodos dinámicos hospedados de forma anónima no tienen acceso automático a los tipos o miembros que son `private`, `protected`, o `internal` (`Friend` en Visual Basic). Esto es diferente de métodos dinámicos asociados con un tipo existente o un módulo, que tienen acceso a los miembros ocultos en su ámbito asociado.  
  
 Especificar `true` para `restrictedSkipVisibility` si el método dinámico tiene que tener acceso a tipos o miembros que son `private`, `protected`, o `internal`. Esto proporciona el método dinámico acceso restringido a estos miembros. Es decir, se pueden tener acceso a los miembros solo si se cumplen las condiciones siguientes:  
  
-   Los miembros de destino pertenecen a un ensamblado que tiene un nivel de confianza igual o menor que la pila de llamadas que emite el método dinámico.  
  
-   Se concede la pila de llamadas que emite el método dinámico <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca. Siempre es true cuando el código se ejecuta con plena confianza. Para código de confianza parcial, es true solo si el host concede explícitamente el permiso.  
  
    > [!IMPORTANT]
    >  Si no se ha concedido el permiso, se produce una excepción de seguridad cuando <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> se denomina o cuando se invoca el método dinámico, no cuando se llama a este constructor. No se requiere ningún permiso especial para emitir el método dinámico.  
  
 Por ejemplo, un método dinámico que se crea con `restrictedSkipVisibility` establecido en `true` puede tener acceso a un miembro privado de cualquier ensamblado de la pila de llamadas si la pila de llamadas se ha concedido acceso a miembros restringidos. Si el método dinámico se crea con el código de confianza parcial en la pila de llamadas, no se puede obtener acceso a un miembro privado de un tipo en un [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] ensamblado, porque esos ensamblados son de plena confianza.  
  
 Si `restrictedSkipVisibility` es `false`, se aplican las comprobaciones de visibilidad JIT. El código del método dinámico tiene acceso a los métodos públicos de las clases públicas y se producen excepciones si intenta tener acceso a tipos o miembros que son `private`, `protected`, o `internal`.  
  
 Cuando se crea un método dinámico hospedado de forma anónima, se incluye la pila de llamadas del ensamblado emisor. Cuando se invoca el método, se utilizan los permisos de la pila de llamadas emisora en lugar de los permisos del llamador real. Por lo tanto, el método dinámico no se puede ejecutar en un nivel de privilegios superior del ensamblado que genera, incluso si se pasa a y se ejecuta un ensamblado que tiene un mayor nivel de confianza.  
  
 Este constructor especifica los atributos del método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> y <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>y la convención de llamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Este constructor se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o una versión posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Tutorial: Emitir código en escenarios que no son de plena confianza</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="m">
          <see cref="T:System.Reflection.Module" /> que representa el módulo con el que se va a asociar de manera lógica al método dinámico.</param>
        <summary>Crea un método dinámico que es global para un módulo, especificando el nombre del método, el tipo de devolución, los tipos de parámetros y el módulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor especifica los atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> y <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, convención de llamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>y no omite las comprobaciones de visibilidad just-in-time (JIT).  
  
 El método dinámico creado con este constructor tiene acceso público y `internal` (`Friend` en Visual Basic) los miembros de todos los tipos contenidos en el módulo `m`.  
  
> [!NOTE]
>  Por compatibilidad con versiones anteriores, este constructor exige <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca si las siguientes condiciones son true: `m` es un módulo que no sea el módulo que realiza la llamada y la demanda de <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca error. Si la demanda de <xref:System.Security.Permissions.SecurityPermission> se realiza correctamente, se permite la operación.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un método dinámico que toma dos parámetros. El ejemplo emite un cuerpo de función sencilla que imprime el primer parámetro en la consola y, en el ejemplo se usa el segundo parámetro como el valor devuelto del método. En el ejemplo se finaliza el método mediante la creación de un delegado, invoca el delegado con parámetros diferentes y, por último, se invoca el método dinámico usando el <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> método.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="m" /> es un módulo que proporciona hospedaje anónimo para los métodos dinámicos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="m" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para asociar el método dinámico con un módulo distinto del módulo que realiza la llamada. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico, o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="owner">
          <see cref="T:System.Type" /> con el que está asociado lógicamente el método dinámico. El método dinámico tiene acceso a todos los miembros del tipo.</param>
        <summary>Crea un método dinámico, especificando el nombre del método, tipo de valor devuelto, los tipos de parámetro y el tipo al que está asociado lógicamente el método dinámico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método dinámico creado con este constructor tiene acceso a todos los miembros del tipo `owner`y al público y `internal` (`Friend` en Visual Basic) los miembros de todos los tipos en el módulo que contiene `owner`.  
  
 Este constructor especifica los atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> y <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, convención de llamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>y no omite las comprobaciones de visibilidad just-in-time (JIT).  
  
> [!NOTE]
>  Por compatibilidad con versiones anteriores, este constructor exige <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca si las siguientes condiciones son true: `owner` está en un módulo distinto del módulo de llamada y la demanda de <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Error de indicador. Si la demanda de <xref:System.Security.Permissions.SecurityPermission> se realiza correctamente, se permite la operación.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Reflection.Emit.DynamicMethod> que está asociado lógicamente con un tipo. Esta asociación le permite acceder a los miembros privados de ese tipo.  
  
 El ejemplo de código define una clase denominada `Example` con un campo privado, una clase denominada `DerivedFromxample` que se deriva de la primera clase, un tipo de delegado denominado `UseLikeStatic` que devuelve <xref:System.Int32> y tiene los parámetros de tipo `Example` y <xref:System.Int32>y un tipo de delegado denominado `UseLikeInstance` que devuelve <xref:System.Int32> y tiene un parámetro de tipo <xref:System.Int32>.  
  
 El código de ejemplo, a continuación, crea un <xref:System.Reflection.Emit.DynamicMethod> que cambia el campo privado de una instancia de `Example` y devuelve el valor anterior.  
  
> [!NOTE]
>  En general, cambiar los campos internos de clases no es buena práctica de programación orientada a objetos.  
  
 El código de ejemplo crea una instancia de `Example` y, a continuación, se crean dos delegados. El primero es de tipo `UseLikeStatic`, que tiene los mismos parámetros que el método dinámico. El segundo es de tipo `UseLikeInstance`, que no tiene el primer parámetro (de tipo `Example`). Este delegado se crea mediante la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga del método; el segundo parámetro de esa sobrecarga del método es una instancia de `Example`, en este caso la instancia recién creada, que está enlazada al delegado recién creado. Cada vez que se invoca ese delegado, el método dinámico actúa en la instancia enlazada de `Example`.  
  
> [!NOTE]
>  Este es un ejemplo de las reglas relajadas enlace a delegados introducidas en la [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], junto con las nuevas sobrecargas de los <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> método. Para obtener más información, vea la clase <xref:System.Delegate>.  
  
 El `UseLikeStatic` se invoca al delegado, pasando la instancia de `Example` que está enlazado a la `UseLikeInstance` delegar. El `UseLikeInstance` delegado se invoca, para que ambos delegados que actúan en la misma instancia de `Example`. Los cambios en los valores del campo interno se muestran después de cada llamada. Por último, un `UseLikeInstance` delegado está enlazado a una instancia de `DerivedFromxample`, y se repiten las llamadas de delegado.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="owner" /> es una interfaz, una matriz, un tipo genérico abierto o un parámetro de tipo de un tipo o método genérico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="owner" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> es <see langword="null" /> o es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para asociar el método dinámico con un tipo en un módulo distinto del módulo que realiza la llamada. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="m">
          <see cref="T:System.Reflection.Module" /> que representa el módulo con el que se va a asociar de manera lógica al método dinámico.</param>
        <param name="skipVisibility">
          <see langword="true" /> para omitir las comprobaciones de visibilidad JIT en tipos y miembros a los que accede el MSIL del método dinámico.</param>
        <summary>Crea un método dinámico que es global para un módulo, especificando el nombre del método, el tipo de valor devuelto, los tipos de parámetros, el módulo y si se deben omitir comprobaciones de visibilidad Just-In-Time (JIT) para tipos y miembros a los que se tiene acceso por el lenguaje intermedio de Microsoft (MSIL) del método dinámico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor especifica los atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> y <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>y la convención de llamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 El método dinámico creado con este constructor tiene acceso público y `internal` (`Friend` en Visual Basic) los miembros de todos los tipos incluidos en el módulo `m`. Omitiendo el compilador JIT las comprobaciones de visibilidad del compilador permite que el método dinámico obtiene acceso a miembros privados y protegidos de todos los demás tipos. Esto es útil, por ejemplo, al escribir código para serializar objetos.  
  
> [!NOTE]
>  Por compatibilidad con versiones anteriores, este constructor exige <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca si las siguientes condiciones son true: `m` es un módulo que no sea el módulo que realiza la llamada y la demanda de <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca error. Si la demanda de <xref:System.Security.Permissions.SecurityPermission> se realiza correctamente, se permite la operación.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="m" /> es un módulo que proporciona hospedaje anónimo para los métodos dinámicos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="m" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para asociar el método dinámico con un módulo distinto del módulo que realiza la llamada. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico, o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="owner">
          <see cref="T:System.Type" /> con el que está asociado lógicamente el método dinámico. El método dinámico tiene acceso a todos los miembros del tipo.</param>
        <param name="skipVisibility">
          <see langword="true" /> para omitir las comprobaciones de visibilidad JIT en tipos y miembros a los que obtiene acceso el MSIL del método dinámico; en otro caso, <see langword="false" />.</param>
        <summary>Crea un método dinámico que especifica el nombre del método, el tipo de valor de devolución, los tipos de parámetros, el tipo con el que está asociado lógicamente el método dinámico y si se deben omitir comprobaciones de visibilidad Just-In-Time (JIT) para los tipos y miembros a los que se tiene acceso mediante el lenguaje intermedio de Microsoft (MSIL) del método dinámico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método dinámico creado con este constructor tiene acceso a todos los miembros del tipo `owner`y al público y `internal` (`Friend` en Visual Basic) los miembros de todos los tipos en el módulo que contiene `owner`. Omitiendo el compilador JIT las comprobaciones de visibilidad del compilador permite que el método dinámico obtiene acceso a miembros privados y protegidos de todos los demás tipos. Esto es útil, por ejemplo, al escribir código para serializar objetos.  
  
 Este constructor especifica los atributos de método <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> y <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>y la convención de llamada <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Por compatibilidad con versiones anteriores, este constructor exige <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca si las siguientes condiciones son true: `owner` está en un módulo distinto del módulo de llamada y la demanda de <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Error de indicador. Si la demanda de <xref:System.Security.Permissions.SecurityPermission> se realiza correctamente, se permite la operación.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="owner" /> es una interfaz, una matriz, un tipo genérico abierto o un parámetro de tipo de un tipo o método genérico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="owner" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> es <see langword="null" /> o es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para asociar el método dinámico con un tipo en un módulo distinto del módulo que realiza la llamada. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Esto puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="attributes">Combinación bit a bit de valores <see cref="T:System.Reflection.MethodAttributes" /> que especifica los atributos del método dinámico. La única combinación permitida es <see cref="F:System.Reflection.MethodAttributes.Public" /> y <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">La convención de llamada para el método dinámico. Debe ser <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Un objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">
          <see langword="true" /> para omitir las comprobaciones de visibilidad JIT en tipos y miembros a los que obtiene acceso el MSIL del método dinámico; en otro caso, <see langword="false" />.</param>
        <summary>Crea un método dinámico que es global para un módulo, especificando el nombre del método, los atributos, la convención de nomenclatura, el tipo de valor devuelto, los tipos de parámetros, el módulo y si se deben omitir comprobaciones de visibilidad Just-In-Time (JIT) para tipos y miembros a los que se tiene acceso por el lenguaje intermedio de Microsoft (MSIL) del método dinámico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método dinámico creado con este constructor tiene acceso público y `internal` (`Friend` en Visual Basic) los miembros de todos los tipos públicos e internos contenidos en el módulo `m`.  
  
 Omitiendo el compilador JIT las comprobaciones de visibilidad del compilador permite que el método dinámico obtiene acceso a miembros privados y protegidos de todos los demás tipos del módulo y en todos los demás ensamblados. Esto es útil, por ejemplo, al escribir código para serializar objetos.  
  
> [!NOTE]
>  Por compatibilidad con versiones anteriores, este constructor exige <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca si las siguientes condiciones son true: `m` es un módulo que no sea el módulo que realiza la llamada y la demanda de <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca error. Si la demanda de <xref:System.Security.Permissions.SecurityPermission> se realiza correctamente, se permite la operación.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="m" /> es un módulo que proporciona hospedaje anónimo para los métodos dinámicos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="m" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> es una combinación de indicadores distinta de <see cref="F:System.Reflection.MethodAttributes.Public" /> y <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
O bien 
 <paramref name="callingConvention" /> no es <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
O bien 
 <paramref name="returnType" /> es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para asociar el método dinámico con un módulo distinto del módulo que realiza la llamada. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método dinámico. Esto puede ser una cadena de longitud cero, pero no puede ser <see langword="null" />.</param>
        <param name="attributes">Combinación bit a bit de valores <see cref="T:System.Reflection.MethodAttributes" /> que especifica los atributos del método dinámico. La única combinación permitida es <see cref="F:System.Reflection.MethodAttributes.Public" /> y <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">La convención de llamada para el método dinámico. Debe ser <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Un objeto <see cref="T:System.Type" /> que especifica el tipo de valor devuelto del método dinámico o <see langword="null" /> si el método no tiene ningún tipo de valor devuelto.</param>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que especifican los tipos de los parámetros del método dinámico, o <see langword="null" /> si el método no tiene parámetros.</param>
        <param name="owner">
          <see cref="T:System.Type" /> con el que está asociado lógicamente el método dinámico. El método dinámico tiene acceso a todos los miembros del tipo.</param>
        <param name="skipVisibility">
          <see langword="true" /> para omitir las comprobaciones de visibilidad JIT en tipos y miembros a los que obtiene acceso el MSIL del método dinámico; en otro caso, <see langword="false" />.</param>
        <summary>Crea un método dinámico que especifica el nombre del método, los atributos, la convención de llamada, el tipo de valor de devolución, los tipos de parámetros, el tipo con el que está asociado lógicamente el método dinámico y si se deben omitir comprobaciones de visibilidad Just-In-Time (JIT) para los tipos y miembros a los que se tiene acceso mediante el lenguaje intermedio de Microsoft (MSIL) del método dinámico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método dinámico es global para el módulo que contiene el tipo `owner`. Tiene acceso a todos los miembros del tipo `owner`.  
  
 El método dinámico creado con este constructor tiene acceso a todos los miembros del tipo `owner`y al público y `internal` (`Friend` en Visual Basic) los miembros de todos los tipos contenidos en el módulo que contiene `owner`. Omitiendo el compilador JIT las comprobaciones de visibilidad del compilador permite que el método dinámico obtiene acceso a miembros privados y protegidos de todos los demás tipos. Esto es útil, por ejemplo, al escribir código para serializar objetos.  
  
> [!NOTE]
>  Por compatibilidad con versiones anteriores, este constructor exige <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca si las siguientes condiciones son true: `owner` está en un módulo distinto del módulo de llamada y la demanda de <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Error de indicador. Si la demanda de <xref:System.Security.Permissions.SecurityPermission> se realiza correctamente, se permite la operación.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ya no requiere este miembro <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en Reflection emiten](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un elemento de <paramref name="parameterTypes" /> es <see langword="null" /> o <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="owner" /> es una interfaz, una matriz, un tipo genérico abierto o un parámetro de tipo de un tipo o método genérico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
O bien 
 <paramref name="owner" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> es una combinación de indicadores distinta de <see cref="F:System.Reflection.MethodAttributes.Public" /> y <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
O bien 
 <paramref name="callingConvention" /> no es <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
O bien 
 <paramref name="returnType" /> es un tipo para el que <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Para asociar el método dinámico con un tipo en un módulo distinto del módulo que realiza la llamada. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los atributos especificados cuando se creó el método dinámico.</summary>
        <value>Una combinación bit a bit de los valores <see cref="T:System.Reflection.MethodAttributes" /> que representan los atributos del método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actualmente, los atributos de método para un método dinámico siempre son <xref:System.Reflection.MethodAttributes.Public> y <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los atributos de método de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la convención de llamada especificada cuando se creó el método dinámico.</summary>
        <value>Uno de los valores de <see cref="T:System.Reflection.CallingConventions" /> que indica la convención de llamada del método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actualmente, la convención de llamada para un método dinámico es siempre <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la convención de llamada de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finaliza el método dinámico y crea a un delegado que se puede usar para ejecutarlo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Tipo de delegado cuya firma coincide con la del método dinámico.</param>
        <summary>Finaliza el método dinámico y crea a un delegado que se puede usar para ejecutarlo.</summary>
        <returns>Un delegado del tipo especificado, que se puede usar para ejecutar el método dinámico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método o la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método completa el método dinámico. Cualquiera aún más si intenta modificar el método dinámico, como modificar las definiciones de parámetro o emitir más lenguaje intermedio de Microsoft (MSIL), se omite; se produce ninguna excepción.  
  
 Para crear un cuerpo de método para un método dinámico cuando tenga su propio generador de MSIL, llame a la <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> método para obtener un <xref:System.Reflection.Emit.DynamicILInfo> objeto. Si no tiene su propio generador de MSIL, llame a la <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> método para obtener un <xref:System.Reflection.Emit.ILGenerator> objeto que puede usarse para generar el cuerpo del método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un método dinámico que toma dos parámetros. El ejemplo emite un cuerpo de función sencilla que imprime el primer parámetro en la consola y, en el ejemplo se usa el segundo parámetro como el valor devuelto del método. En el ejemplo se finaliza el método mediante la creación de un delegado, invoca el delegado con parámetros diferentes y, por último, se invoca el método dinámico usando el <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método dinámico no tiene ningún cuerpo de método.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> tiene el número incorrecto de parámetros o los tipos de parámetro incorrectos.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Tipo de delegado cuya firma coincide con la del método dinámico menos el primer parámetro.</param>
        <param name="target">Objeto al que está enlazado el delegado. Debe ser del mismo tipo que el primer parámetro del método dinámico.</param>
        <summary>Completa el método dinámico y crea un delegado que puede utilizarse para ejecutarlo, especificando el tipo de delegado y un objeto que se enlaza al delegado.</summary>
        <returns>Delegado del tipo especificado, que se puede usar para ejecutar el método dinámico con el objeto de destino especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método crea un delegado que se enlaza a un objeto determinado. Se dice que un delegado se cerrados a lo largo de su primer argumento. Aunque el método es estático, que actúa como si fuera un método de instancia; la instancia es `target`.  
  
 Esta sobrecarga del método requiere `target` para que sean del mismo tipo como el primer parámetro del método dinámico, o se pueda asignar a ese tipo (por ejemplo, una clase derivada).  La firma de `delegateType` tiene todos los parámetros del método dinámico excepto el primero. Por ejemplo, si el método dinámico tiene los parámetros <xref:System.String>, <xref:System.Int32>, y <xref:System.Byte>, a continuación, `delegateType` tiene los parámetros <xref:System.Int32> y <xref:System.Byte>; `target` es de tipo <xref:System.String>.  
  
 Una llamada a la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método o la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método completa el método dinámico. Cualquiera aún más si intenta modificar el método dinámico, como modificar las definiciones de parámetro o emitir más lenguaje intermedio de Microsoft (MSIL), se omite; se produce ninguna excepción.  
  
 Para crear un cuerpo de método para un método dinámico cuando tenga su propio generador de MSIL, llame a la <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> método para obtener un <xref:System.Reflection.Emit.DynamicILInfo> objeto. Si no tiene su propio generador de MSIL, llame a la <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> método para obtener un <xref:System.Reflection.Emit.ILGenerator> objeto que puede usarse para generar el cuerpo del método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea el delegado que se enlaza un <xref:System.Reflection.Emit.DynamicMethod> a una instancia de un tipo, por lo que el método actúa en la misma instancia cada vez que se invoca.  
  
 El ejemplo de código define una clase denominada `Example` con un campo privado, una clase denominada `DerivedFromxample` que se deriva de la primera clase, un tipo de delegado denominado `UseLikeStatic` que devuelve <xref:System.Int32> y tiene los parámetros de tipo `Example` y <xref:System.Int32>y un tipo de delegado denominado `UseLikeInstance` que devuelve <xref:System.Int32> y tiene un parámetro de tipo <xref:System.Int32>.  
  
 El código de ejemplo, a continuación, crea un <xref:System.Reflection.Emit.DynamicMethod> que cambia el campo privado de una instancia de `Example` y devuelve el valor anterior.  
  
> [!NOTE]
>  En general, cambiar los campos internos de clases no es buena práctica de programación orientada a objetos.  
  
 El código de ejemplo crea una instancia de `Example` y, a continuación, se crean dos delegados. El primero es de tipo `UseLikeStatic`, que tiene los mismos parámetros que el método dinámico. El segundo es de tipo `UseLikeInstance`, que no tiene el primer parámetro (de tipo `Example`). Este delegado se crea mediante la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga del método; el segundo parámetro de esa sobrecarga del método es una instancia de `Example`, en este caso la instancia recién creada, que está enlazada al delegado recién creado. Cada vez que se invoca ese delegado, el método dinámico actúa en la instancia enlazada de `Example`.  
  
> [!NOTE]
>  Este es un ejemplo de las reglas relajadas enlace a delegados introducidas en la [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], junto con las nuevas sobrecargas de los <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> método. Para obtener más información, vea la clase <xref:System.Delegate>.  
  
 El `UseLikeStatic` se invoca al delegado, pasando la instancia de `Example` que está enlazado a la `UseLikeInstance` delegar. El `UseLikeInstance` delegado se invoca, para que ambos delegados que actúan en la misma instancia de `Example`. Los cambios en los valores del campo interno se muestran después de cada llamada. Por último, un `UseLikeInstance` delegado está enlazado a una instancia de `DerivedFromxample`, y se repiten las llamadas de delegado.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método dinámico no tiene ningún cuerpo de método.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> no es del mismo tipo que el primer parámetro del método dinámico y no se puede asignar a ese tipo.  
  
O bien 
 <paramref name="delegateType" /> tiene el número incorrecto de parámetros o los tipos de parámetro incorrectos.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que declara el método, que es siempre <see langword="null" /> para los métodos dinámicos.</summary>
        <value>Siempre es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad siempre devuelve `null` para los métodos dinámicos. Incluso cuando un método dinámico está asociado lógicamente con un tipo, no se declaró el tipo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el tipo declarativo de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Posición del parámetro en la lista de parámetros. Los parámetros se indizan empezando por el número 1 para el primer parámetro.</param>
        <param name="attributes">Combinación bit a bit de valores <see cref="T:System.Reflection.ParameterAttributes" /> que especifica los atributos del parámetro.</param>
        <param name="parameterName">Nombre del parámetro. El nombre puede ser una cadena de longitud cero.</param>
        <summary>Define un parámetro del método dinámico.</summary>
        <returns>Siempre devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `position` es 0, el <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> método hace referencia al valor devuelto. Establecer información de parámetro no tiene ningún efecto en el valor devuelto.  
  
 Si el método dinámico se ya se ha completado, mediante una llamada a la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, el <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> método no tiene ningún efecto. No se inicia ninguna excepción.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo definir la información de parámetros para un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El método no tiene parámetros.  
  
O bien 
 <paramref name="position" /> es menor que 0.  
  
O bien 
 <paramref name="position" /> es mayor que el número de los parámetros del método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la implementación para el método.</summary>
        <returns>La implementación base del método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método siempre devuelve el valor actual `DynamicMethod` objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los atributos personalizados aplicados al método.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" /> para buscar la cadena de herencia del método con el fin de encontrar los atributos personalizados; <see langword="false" /> para comprobar solo el método actual.</param>
        <summary>Devuelve todos los atributos personalizados definidos para el método.</summary>
        <returns>Matriz de objetos que representa todos los atributos personalizados del método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los métodos dinámicos, especificar `true` para `inherit` no tiene ningún efecto, porque no se declara el método en un tipo.  
  
> [!NOTE]
>  Los atributos personalizados no se admiten actualmente en los métodos dinámicos. El único atributo devuelto es <xref:System.Runtime.CompilerServices.MethodImplAttribute>; puede obtener el método marcas de implementación más fácilmente mediante el <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see cref="T:System.Type" /> que representa el tipo de atributo personalizado que se va a devolver.</param>
        <param name="inherit">
          <see langword="true" /> para buscar la cadena de herencia del método con el fin de encontrar los atributos personalizados; <see langword="false" /> para comprobar solo el método actual.</param>
        <summary>Devuelve los atributos personalizados del tipo especificado que se han aplicado al método.</summary>
        <returns>Una matriz de objetos que representan los atributos del método que son de tipo <paramref name="attributeType" /> o derivan del tipo <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los métodos dinámicos, especificar `true` para `inherit` no tiene ningún efecto, porque no se declara el método en un tipo.  
  
> [!NOTE]
>  Los atributos personalizados no se admiten actualmente en los métodos dinámicos. El único atributo devuelto es <xref:System.Runtime.CompilerServices.MethodImplAttribute>; puede obtener el método marcas de implementación más fácilmente mediante el <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> que se puede utilizar para generar un cuerpo de método a partir de los símbolos (token) de metadatos, los ámbitos y las secuencias de Lenguaje intermedio de Microsoft (MSIL).</summary>
        <returns>Un objeto <see cref="T:System.Reflection.Emit.DynamicILInfo" /> que se puede utilizar para generar un cuerpo de método a partir de los símbolos (token) de metadatos, los ámbitos, y las secuencias de MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Reflection.Emit.DynamicILInfo> clase se proporciona para admitir la generación de código no administrado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para ejecutar código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un generador de MSIL que se puede usar para emitir un cuerpo para el método dinámico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un generador de Lenguaje Intermedio de Microsoft (MSIL) para el método con un tamaño de secuencia de MSIL predeterminado de 64 bytes.</summary>
        <returns>Objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para el método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez completado un método dinámico, mediante una llamada a la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, cualquier intento posterior de agregar MSIL se omite. No se inicia ninguna excepción.  
  
> [!NOTE]
>  Hay restricciones en el código no comprobable en métodos dinámicos, incluso en algunos escenarios de plena confianza. Vea la sección "Comprobación" en Comentarios para <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un método dinámico que toma dos parámetros. El ejemplo emite un cuerpo de función sencilla que imprime el primer parámetro en la consola y, en el ejemplo se usa el segundo parámetro como el valor devuelto del método. En el ejemplo se finaliza el método mediante la creación de un delegado, invoca el delegado con parámetros diferentes y, por último, se invoca el método dinámico usando el <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Tamaño de la secuencia MSIL, en bytes.</param>
        <summary>Devuelve un generador de Lenguaje intermedio de Microsoft (MSIL) para el método con el tamaño de secuencia de MSIL especificado.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.Emit.ILGenerator" /> para el método, con el tamaño de secuencia de MSIL especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez completado un método dinámico, mediante una llamada a la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> o <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método, cualquier intento posterior de agregar MSIL se omite. No se inicia ninguna excepción.  
  
> [!NOTE]
>  Hay restricciones en el código no comprobable en métodos dinámicos, incluso en algunos escenarios de plena confianza. Vea la sección "Comprobación" en Comentarios para <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra esta sobrecarga del método. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Cómo: Definir y ejecutar métodos dinámicos</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve las marcas de implementación para el método.</summary>
        <returns>Una combinación bit a bit de valores de <see cref="T:System.Reflection.MethodImplAttributes" /> que representan las marcas de implementación para el método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actualmente, los atributos de la implementación de método para los métodos dinámicos siempre son <xref:System.Reflection.MethodImplAttributes.IL> y <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los parámetros del método dinámico.</summary>
        <returns>Una matriz de objetos <see cref="T:System.Reflection.ParameterInfo" /> que representan los parámetros del método dinámico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.ParameterInfo> los objetos devueltos por este método son meramente informativos. Use el <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> método para establecer o cambiar las características de los parámetros.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los parámetros de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si las variables locales del método se inicializan a cero.</summary>
        <value>
          <see langword="true" /> si las variables locales del método se inicializan a cero; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta propiedad se establece en `true`, el lenguaje intermedio de Microsoft (MSIL) emitido incluye la inicialización de variables locales. Si se establece en `false`, no se inicializan las variables locales y el código generado es no comprobable.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> propiedad de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Este parámetro se omite para los métodos dinámicos porque son estáticos. Especifique <see langword="null" />.</param>
        <param name="invokeAttr">Combinación bit a bit de los valores de <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Objeto <see cref="T:System.Reflection.Binder" /> que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <c>binder</c> es <see langword="null" />, se usará el enlazador predeterminado. Para obtener más información, vea <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Lista de argumentos. Esta es una matriz de argumentos con el mismo número, orden y tipo que los parámetros del método al que se va a invocar. Si no hay parámetros, este parámetro debe ser <see langword="null" />.</param>
        <param name="culture">Instancia de <see cref="T:System.Globalization.CultureInfo" /> usada para regir la conversión de tipos. Si es <see langword="null" />, se utiliza <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual. Por ejemplo, esta información es necesaria para convertir correctamente un objeto <see cref="T:System.String" /> que representa 1000 en un valor <see cref="T:System.Double" />, ya que 1000 se representa de manera diferente en referencias culturales diferentes.</param>
        <summary>Invoca el método dinámico usando los parámetros especificados, bajo las restricciones del enlazador especificado, con la información de la referencia cultural especificada.</summary>
        <returns>
          <see cref="T:System.Object" /> que contiene el valor devuelto del método invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de las excepciones enumeradas, el código de llamada debe estar preparado para detectar cualquier excepción producida por el método dinámico.  
  
 Ejecutar un método dinámico con un delegado creado por el <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método es más eficaz que si se ejecuta con la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método.  
  
 Una llamada a la <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> método o la <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> método completa el método dinámico. Cualquiera aún más si intenta modificar el método dinámico, como modificar las definiciones de parámetro o emitir más lenguaje intermedio de Microsoft (MSIL), se omite; se produce ninguna excepción.  
  
 Todos los métodos dinámicos son estáticos, por lo que el `obj` siempre se omite el parámetro. Para tratar un método dinámico como si fuera un método de instancia, utilice el <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> sobrecarga que toma una instancia de objeto.  
  
 Si el método dinámico no tiene parámetros, el valor de `parameters` debe ser `null`. En caso contrario, el número, tipo y orden de los elementos de la matriz de parámetros deben ser idénticos al número, tipo y orden de los parámetros del método dinámico.  
  
> [!NOTE]
>  Esta sobrecarga del método es llamada el <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> sobrecarga del método se hereda de la <xref:System.Reflection.MethodBase> clase, de manera que los comentarios anteriores se aplican a ambas sobrecargas.  
  
 Este método no exige permisos directamente, pero al invocar el método dinámico puede dar lugar a las peticiones de seguridad, en función del método. Por ejemplo, no se realizan peticiones para los métodos dinámicos hospedados de forma anónima que se crean con el `restrictedSkipVisibility` parámetro establecido en `false`. Por otro lado, si crea un método con `restrictedSkipVisibility` establecido en `true` por lo que puede tener acceso a un miembro oculto de un ensamblado de destino, el método generará una solicitud para los permisos del ensamblado de destino más <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca.  
  
> [!NOTE]
>  Anteriores a la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método requerido <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> marca.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se invoca un método dinámico con enlace exacto, utilizando la referencia cultural de inglés de Estados Unidos. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">No se admite la convención de llamada <see cref="F:System.Reflection.CallingConventions.VarArgs" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">El número de elementos de <paramref name="parameters" /> no coincide con el número de parámetros del método dinámico.</exception>
        <exception cref="T:System.ArgumentException">El tipo de uno o más elementos de <paramref name="parameters" /> no coincide con el tipo del parámetro correspondiente del método dinámico.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El método dinámico está asociado con un módulo, no está hospedado de forma anónima y se construyó con el parámetro <paramref name="skipVisibility" /> establecido en <see langword="false" />, pero tiene acceso a los miembros que no son <see langword="public" /> o <see langword="internal" /> (<see langword="Friend" /> en Visual Basic).  
  
O bien 
El método dinámico está hospedado de forma anónima y se construyó con el parámetro <paramref name="skipVisibility" /> establecido en <see langword="false" />, pero tiene acceso a miembros que no son <see langword="public" />.  
  
O bien 
El método dinámico contiene código no comprobable. Vea la sección "Comprobación" en Comentarios para <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see cref="T:System.Type" /> que representa el tipo de atributo personalizado que se va a buscar.</param>
        <param name="inherit">
          <see langword="true" /> para buscar la cadena de herencia del método con el fin de encontrar los atributos personalizados; <see langword="false" /> para comprobar solo el método actual.</param>
        <summary>Indica si se ha definido el tipo de atributo personalizado especificado.</summary>
        <returns>
          <see langword="true" /> si está definido el tipo de atributo personalizado especificado, en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los métodos dinámicos, especificar `true` para `inherit` no tiene ningún efecto. Los métodos dinámicos no tengan ninguna cadena de herencia.  
  
> [!NOTE]
>  Los atributos personalizados no se admiten actualmente en los métodos dinámicos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el método dinámico actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente y, por tanto, puede realizar operaciones críticas.</summary>
        <value>
          <see langword="true" /> si el método dinámico actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> notifican el nivel de transparencia del método dinámico conforme a common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico seguro|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
 La transparencia de un método dinámico depende del módulo que está asociado. Si el método dinámico está asociado con un tipo en lugar de un módulo, su transparencia depende del módulo que contiene el tipo. Los métodos dinámicos no tienen anotaciones de seguridad, por lo que se les asigna la transparencia predeterminada para el módulo asociado.  
  
-   Métodos dinámicos hospedados de forma anónima siempre son transparentes, porque el módulo proporcionado por el sistema que las contiene es transparente.  
  
-   La transparencia de un método dinámico que está asociado a un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) se describe en la tabla siguiente.  
  
    |Anotación de ensamblado|Transparencia de nivel 1|Transparencia de nivel 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Totalmente transparente|Transparente|Transparente|  
    |Totalmente crítico|Crítico|Crítico|  
    |Transparencia mixta|Transparente|Transparente|  
    |Independiente de la seguridad|Crítico para la seguridad|Crítico|  
  
     Por ejemplo, si asocia un método dinámico con un tipo que está en mscorlib.dll, que tiene el nivel 2 transparencia mixta, el método dinámico es transparente y no puede ejecutar el código crítico. Para obtener información acerca de los niveles de transparencia, consulte [código transparente en seguridad, nivel 1](~/docs/framework/misc/security-transparent-code-level-1.md) y [código transparente en seguridad, nivel 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Asociar un método dinámico con un módulo en un ensamblado de confianza de nivel 1 que es independiente de la seguridad, como System.dll, no permite la elevación de confianza. Si el conjunto de permisos del código que llama al método dinámico no incluye el conjunto de permisos concedidos de System.dll (es decir, de plena confianza), <xref:System.Security.SecurityException> se produce cuando se llama al método dinámico.  
  
-   La transparencia de un método dinámico que está asociado a un ensamblado de confianza parcial depende de cómo se carga el ensamblado. Si el ensamblado se carga con confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el tiempo de ejecución omite las anotaciones de seguridad del ensamblado. El ensamblado y todos sus tipos y miembros, incluidos los métodos dinámicos, se tratan como transparentes. El tiempo de ejecución presta atención a las anotaciones de seguridad solo si el ensamblado de confianza parcial se carga con plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio). En ese caso, el tiempo de ejecución asigna el método dinámico la transparencia predeterminada para los métodos según las anotaciones del ensamblado.  
  
 Para obtener más información sobre la reflexión emite y la transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método dinámico no tiene un cuerpo de método.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Consideraciones de seguridad sobre la reflexión</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Cambios de seguridad en .NET Framework versión 4.0</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Código transparente en seguridad, nivel 1</related>
        <related type="Article" href="http://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Código transparente en seguridad, nivel 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el método dinámico actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</summary>
        <value>
          <see langword="true" /> si el método dinámico es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es crítico para la seguridad o transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> notifican el nivel de transparencia del método dinámico conforme a common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico seguro|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
 La transparencia de un método dinámico depende del módulo que está asociado. Si el método dinámico está asociado con un tipo en lugar de un módulo, su transparencia depende del módulo que contiene el tipo. Los métodos dinámicos no tienen anotaciones de seguridad, por lo que se les asigna la transparencia predeterminada para el módulo asociado.  
  
-   Métodos dinámicos hospedados de forma anónima siempre son transparentes, porque el módulo proporcionado por el sistema que las contiene es transparente.  
  
-   La transparencia de un método dinámico que está asociado a un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) se describe en la tabla siguiente.  
  
    |Anotación de ensamblado|Transparencia de nivel 1|Transparencia de nivel 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Totalmente transparente|Transparente|Transparente|  
    |Totalmente crítico|Crítico|Crítico|  
    |Transparencia mixta|Transparente|Transparente|  
    |Independiente de la seguridad|Crítico para la seguridad|Crítico|  
  
     Por ejemplo, si asocia un método dinámico con un tipo que está en mscorlib.dll, que tiene el nivel 2 transparencia mixta, el método dinámico es transparente y no puede ejecutar el código crítico. Para obtener información acerca de los niveles de transparencia, consulte [código transparente en seguridad, nivel 1](~/docs/framework/misc/security-transparent-code-level-1.md) y [código transparente en seguridad, nivel 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Asociar un método dinámico con un módulo en un ensamblado de confianza de nivel 1 que es independiente de la seguridad, como System.dll, no permite la elevación de confianza. Si el conjunto de permisos del código que llama al método dinámico no incluye el conjunto de permisos concedidos de System.dll (es decir, de plena confianza), <xref:System.Security.SecurityException> se produce cuando se llama al método dinámico.  
  
-   La transparencia de un método dinámico que está asociado a un ensamblado de confianza parcial depende de cómo se carga el ensamblado. Si el ensamblado se carga con confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el tiempo de ejecución omite las anotaciones de seguridad del ensamblado. El ensamblado y todos sus tipos y miembros, incluidos los métodos dinámicos, se tratan como transparentes. El tiempo de ejecución presta atención a las anotaciones de seguridad solo si el ensamblado de confianza parcial se carga con plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio). En ese caso, el tiempo de ejecución asigna el método dinámico la transparencia predeterminada para los métodos según las anotaciones del ensamblado.  
  
 Para obtener más información sobre la reflexión emite y la transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método dinámico no tiene un cuerpo de método.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Consideraciones de seguridad sobre la reflexión</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Cambios de seguridad en .NET Framework versión 4.0</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Código transparente en seguridad, nivel 1</related>
        <related type="Article" href="http://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Código transparente en seguridad, nivel 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el método dinámico actual es transparente en el nivel de confianza actual y, por tanto, no puede realizar operaciones críticas.</summary>
        <value>Es <see langword="true" /> si el método dinámico es transparente para la seguridad en el nivel de confianza actual; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> notifican el nivel de transparencia del método dinámico conforme a common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico seguro|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
 La transparencia de un método dinámico depende del módulo que está asociado. Si el método dinámico está asociado con un tipo en lugar de un módulo, su transparencia depende del módulo que contiene el tipo. Los métodos dinámicos no tienen anotaciones de seguridad, por lo que se les asigna la transparencia predeterminada para el módulo asociado.  
  
-   Métodos dinámicos hospedados de forma anónima siempre son transparentes, porque el módulo proporcionado por el sistema que las contiene es transparente.  
  
-   La transparencia de un método dinámico que está asociado a un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) se describe en la tabla siguiente.  
  
    |Anotación de ensamblado|Transparencia de nivel 1|Transparencia de nivel 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Totalmente transparente|Transparente|Transparente|  
    |Totalmente crítico|Crítico|Crítico|  
    |Transparencia mixta|Transparente|Transparente|  
    |Independiente de la seguridad|Crítico para la seguridad|Crítico|  
  
     Por ejemplo, si asocia un método dinámico con un tipo que está en mscorlib.dll, que tiene el nivel 2 transparencia mixta, el método dinámico es transparente y no puede ejecutar el código crítico. Para obtener información acerca de los niveles de transparencia, consulte [código transparente en seguridad, nivel 1](~/docs/framework/misc/security-transparent-code-level-1.md) y [código transparente en seguridad, nivel 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Asociar un método dinámico con un módulo en un ensamblado de confianza de nivel 1 que es independiente de la seguridad, como System.dll, no permite la elevación de confianza. Si el conjunto de permisos del código que llama al método dinámico no incluye el conjunto de permisos concedidos de System.dll (es decir, de plena confianza), <xref:System.Security.SecurityException> se produce cuando se llama al método dinámico.  
  
-   La transparencia de un método dinámico que está asociado a un ensamblado de confianza parcial depende de cómo se carga el ensamblado. Si el ensamblado se carga con confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el tiempo de ejecución omite las anotaciones de seguridad del ensamblado. El ensamblado y todos sus tipos y miembros, incluidos los métodos dinámicos, se tratan como transparentes. El tiempo de ejecución presta atención a las anotaciones de seguridad solo si el ensamblado de confianza parcial se carga con plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio). En ese caso, el tiempo de ejecución asigna el método dinámico la transparencia predeterminada para los métodos según las anotaciones del ensamblado.  
  
 Para obtener más información sobre la reflexión emite y la transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método dinámico no tiene un cuerpo de método.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemas de seguridad en la emisión de la reflexión</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Consideraciones de seguridad sobre la reflexión</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Cambios de seguridad en .NET Framework versión 4.0</related>
        <related type="Article" href="http://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Código transparente en seguridad, nivel 1</related>
        <related type="Article" href="http://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Código transparente en seguridad, nivel 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>No se admite para los métodos dinámicos.</summary>
        <value>No se admite para los métodos dinámicos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No se permite para los métodos dinámicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el módulo con el que está asociado lógicamente el método dinámico.</summary>
        <value>
          <see cref="T:System.Reflection.Module" /> al que está asociado el método dinámico actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un módulo se especificó cuando creó el método dinámico, esta propiedad devuelve ese módulo. Si se especificó un tipo como propietario cuando se creó el método dinámico, esta propiedad devuelve el módulo que contiene ese tipo.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Reflection.Emit.DynamicMethod.Module%2A> propiedad de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del método dinámico.</summary>
        <value>Nombre simple del método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  No es necesario para los métodos dinámicos de nombre.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el nombre de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clase que se usó en la reflexión para obtener el método.</summary>
        <value>Siempre es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad siempre devuelve `null` para los métodos dinámicos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el tipo reflejado de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el parámetro devuelto del método dinámico.</summary>
        <value>Siempre es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad siempre devuelve `null` para los métodos dinámicos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de valor devuelto para el método dinámico.</summary>
        <value>
          <see cref="T:System.Type" /> que representa el tipo del valor devuelto del método actual; <see cref="T:System.Void" /> si el método no tiene ningún tipo de valor devuelto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `null` se especificó para el tipo de valor devuelto cuando se creó el método dinámico, esta propiedad devuelve <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el tipo de valor devuelto de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los atributos personalizados del tipo de valor devuelto para el método dinámico.</summary>
        <value>Un objeto <see cref="T:System.Reflection.ICustomAttributeProvider" /> que representa los atributos personalizados del tipo de valor devuelto para el método dinámico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los atributos personalizados no se admiten en el tipo de valor devuelto de un método dinámico, por lo que la matriz de atributos personalizados devuelta por la <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> método siempre está vacío.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo se muestran los atributos personalizados del tipo de valor devuelto de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la firma del método, representada como una cadena.</summary>
        <returns>Cadena que representa la firma del método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La firma incluye solo los tipos y el nombre del método, si existe. No se incluyen los nombres de parámetro.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> método de un método dinámico. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Emit.DynamicMethod> clase.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>