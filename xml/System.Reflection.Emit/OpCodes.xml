<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d83d76933977f09396d3785edac9c15d9fd4cf6" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52919051" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona representaciones de campo de las instrucciones del Lenguaje intermedio de Microsoft (MSIL) para su emisión por parte de los miembros de la clase <see cref="T:System.Reflection.Emit.ILGenerator" /> (como <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una descripción detallada de los códigos de operación de miembro, consulte la documentación de Common Language Infrastructure (CLI), especialmente "Partition III: CIL Instruction Set" y "Partition II: Metadata Definition and Semantics". La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la construcción de un método dinámico utilizando <xref:System.Reflection.Emit.ILGenerator> para emitir `OpCodes` en un <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Suma dos valores e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|58|agregar|Suma dos valores numéricos, devuelve un nuevo valor numérico.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se agrega a `value2`.  
  
4.  El resultado se inserta en la pila.  
  
 No se detecta el desbordamiento para operaciones con enteros (para controlar el desbordamiento adecuado, vea <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Adición de números enteros se ajusta, en lugar de saturarse. Por ejemplo, suponiendo que los enteros de 8 bits donde `value1` se establece en 255 y `value2` se establece en 1, el resultado ajustado es 0, en lugar de 256.  
  
 Desbordamiento de punto flotante devuelve `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).  
  
 En la tabla siguiente se enumeran los tipos de operandos aceptables y el tipo de datos de resultado correspondiente. Si no hay ninguna entrada para una combinación de tipo concreto (por ejemplo, `int32` y `float`; `int32` y `int64`), es una válido lenguaje intermedio de Microsoft (MSIL) y se genera un error.  
  
|Operando|tipo de value1|Tipo value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|agregar|`int32`|`int32`|`int32`|  
|agregar|`int32`|`native int`|`native int`|  
|agregar|`int32`|`&`|`&`|  
|agregar|`int32`|`*`|`*`|  
|agregar|`int64`|`int64`|`int64`|  
|agregar|`native int`|`int32`|`native int`|  
|agregar|`native int`|`native int`|`native int`|  
|agregar|`native int`|`&`|`&`|  
|agregar|`native int`|`*`|`*`|  
|agregar|`F`|`F`|`F`|  
|agregar|`&`|`int32`|`&`|  
|agregar|`&`|`native int`|`&`|  
|agregar|`*`|`int32`|`*`|  
|agregar|`*`|`native int`|`*`|  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `add` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Suma dos enteros, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D6|Add.ovf|Agrega dos valores enteros con signo con una comprobación de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se agrega a `value2` con una comprobación de desbordamiento.  
  
4.  El resultado se inserta en la pila.  
  
 <xref:System.OverflowException> se produce si el resultado no está representado en el tipo de resultado.  
  
 Puede realizar esta operación en enteros con signo. Para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 En la tabla siguiente se enumeran los tipos de operandos aceptables y el tipo de datos de resultado correspondiente. Si no hay ninguna entrada para una combinación de tipo concreto (por ejemplo, `int32` y `float`; `int32` y `int64`), es una instrucción de lenguaje intermedio de Microsoft (MSIL) válida y se genera un error.  
  
|Operando|tipo de value1|Tipo value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|agregar|`int32`|`int32`|`int32`|  
|agregar|`int32`|`native int`|`native int`|  
|agregar|`int32`|`&`|`&`|  
|agregar|`int32`|`*`|`*`|  
|agregar|`int64`|`int64`|`int64`|  
|agregar|`native int`|`int32`|`native int`|  
|agregar|`native int`|`native int`|`native int`|  
|agregar|`native int`|`&`|`&`|  
|agregar|`native int`|`*`|`*`|  
|agregar|`F`|`F`|`F`|  
|agregar|`&`|`int32`|`&`|  
|agregar|`&`|`native int`|`&`|  
|agregar|`*`|`int32`|`*`|  
|agregar|`*`|`native int`|`*`|  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `add.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Suma dos valores enteros sin signo, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D7|Add.ovf.un|Agrega dos valores enteros sin signo con una comprobación de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se agrega a `value2` con una comprobación de desbordamiento.  
  
4.  El resultado se inserta en la pila.  
  
 <xref:System.OverflowException> se produce si el resultado no está representado en el tipo de resultado.  
  
 Puede realizar esta operación en enteros con signo. Para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 En la tabla siguiente se enumeran los tipos de operandos aceptables y el tipo de datos de resultado correspondiente. Si no hay ninguna entrada para una combinación de tipo concreto (por ejemplo, `int32` y `float`; `int32` y `int64`), es una instrucción de lenguaje intermedio de Microsoft (MSIL) válida y se genera un error.  
  
|Operando|tipo de value1|Tipo value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|agregar|`int32`|`int32`|`int32`|  
|agregar|`int32`|`native int`|`native int`|  
|agregar|`int32`|`&`|`&`|  
|agregar|`int32`|`*`|`*`|  
|agregar|`int64`|`int64`|`int64`|  
|agregar|`native int`|`int32`|`native int`|  
|agregar|`native int`|`native int`|`native int`|  
|agregar|`native int`|`&`|`&`|  
|agregar|`native int`|`*`|`*`|  
|agregar|`F`|`F`|`F`|  
|agregar|`&`|`int32`|`&`|  
|agregar|`&`|`native int`|`&`|  
|agregar|`*`|`int32`|`*`|  
|agregar|`*`|`native int`|`*`|  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `add.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula la operación AND bit a bit de dos valores e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Instrucción|Descripción|  
|------------|-----------------|-----------------|  
|5F|y|Determina el AND bit a bit de dos valores enteros.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value1` y `value2` se extraen de la pila; se calcula el AND bit a bit de los dos valores.  
  
4.  El resultado se inserta en la pila.  
  
 El `and` instrucción calcula el AND bit a bit de los dos primeros valores de la pila y deja el resultado en la pila.  
  
 `And` es una operación específica de valores enteros.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `and` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve un puntero no administrado a la lista de argumentos del método actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Devuelve un identificador de la lista de argumentos del método actual.|  
  
 No hay comportamientos de la pila de evaluación se realizan mediante esta operación.  
  
 El `arglist` instrucción devuelve un identificador opaco (un puntero no administrado, de tipo `native int`) que representa la lista de argumentos del método actual. Este identificador es válido solo durante la vigencia del método actual. Sin embargo, puede pasar el identificador a otros métodos, siempre y cuando el método actual está en el subproceso de control. Sólo se puede ejecutar el `arglist` instrucción dentro de un método que toma un número variable de argumentos.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `arglist` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si dos valores son iguales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|3B &LT; `int32` >|beq `target`|Rama a la instrucción máquina de destino en el desplazamiento `target` si los dos valores son iguales.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es igual a `value2`, se realiza la operación de bifurcación.  
  
 El `beq` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es igual a `value2`. El efecto es similar a realizar un `ceq` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Los tipos de operandos aceptables se encapsulan a continuación:  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos.  
  
 Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción (dichas transferencias están muy limitadas y debe usar el <xref:System.Reflection.Emit.OpCodes.Leave> instrucción en su lugar).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `beq` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si dos valores son iguales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|2E &LT; `int8` >|beq.s `target`|Rama a la instrucción máquina de destino en el desplazamiento `target` si son iguales, forma corta|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es igual a `value2`, se realiza la operación de bifurcación.  
  
 El `beq.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es igual a `value2`. El efecto es similar a realizar un `ceq` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Los tipos de operandos aceptables se encapsulan a continuación:  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos.  
  
 Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción (dichas transferencias están muy limitadas y debe usar el <xref:System.Reflection.Emit.OpCodes.Leave> instrucción en su lugar).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `beq.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es mayor o igual que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `bge` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor o igual que `value2`. El efecto es idéntico a realizar un `clt.un` instrucción seguida de un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bge` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor o igual que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor, la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `bge.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor o igual que `value2`. El efecto es idéntico a realizar un `clt.un` instrucción seguida de un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bge.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `bge.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor o igual que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `clt` instrucción seguida de un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bge.un` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor (valores sin signo), la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `bge.un.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor o igual que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `clt` instrucción seguida de un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bge.un.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es mayor que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|3D &LT; `int32` >|bgt `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.  
  
 El `bgt` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor que `value2`. El efecto es idéntico a realizar un `cgt` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bgt` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor, la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.  
  
 El `bgt.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor que `value2`. El efecto es idéntico a realizar un `cgt` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bgt.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.  
  
 El `bgt.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `cgt.un` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bgt.un` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor (valores sin signo), la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.  
  
 El `bgt.un.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es mayor que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `cgt.un` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bgt.un.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es menor o igual que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `ble` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor o igual que `value2`. El efecto es idéntico a realizar un `cgt` instrucción (`cgt.un` para los elementos flotantes) seguido por un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ble` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor o igual que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor, la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `ble.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor o igual que `value2`. El efecto es idéntico a realizar un `cgt` instrucción (`cgt.un` para los elementos flotantes) instrucción seguida de un`brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ble.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es menor o igual que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `ble.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor o igual que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `cgt.un` instrucción (`cgt` para los elementos flotantes) seguido por un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ble.un` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor o igual que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor (valores sin signo), la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.  
  
 El `ble.un.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor o igual que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `cgt.un` instrucción (`cgt` para los elementos flotantes) seguido por un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ble.un.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es menor que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|3F &LT; `int32` >|blt `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.  
  
 El `blt` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor o igual que `value2`. El efecto es idéntico a realizar un `clt` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `blt` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor que el segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor, la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.  
  
 El `blt.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor que `value2`. El efecto es idéntico a realizar un `clt` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `blt.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si el primer valor es menor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.  
  
 El `blt.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `clt.un` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `blt.un` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor (valores sin signo), la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.  
  
 El `blt.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` es menor que `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `clt.un` instrucción seguida de un `brtrue` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `blt.un.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino cuando dos valores enteros sin signo o dos valores flotantes desordenados no son iguales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|Rama en el destino de instrucción en el desplazamiento especificado si dos valores enteros sin signo no son iguales (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` no es igual a `value2`, se realiza la operación de bifurcación.  
  
 El `bne.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` no es igual a `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `ceq` instrucción seguida de un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bne.un` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) cuando dos valores enteros sin signo o dos valores flotantes desordenados no son iguales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Rama para el destino de instrucción máquina en el desplazamiento especificado si dos valores enteros sin signo son no iguales (valores sin signo), la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; si `value1` no es igual a `value2`, se realiza la operación de bifurcación.  
  
 El `bne.un` instrucción transfiere el control a la instrucción máquina de destino especificada si `value1` no es igual a `value2`, cuando se comparan utilizando un entero sin signo o valores flotantes desordenados. El efecto es idéntico a realizar un `ceq` instrucción seguida de un `brfalse` rama a la instrucción máquina de destino específica. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `bne.un.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte un tipo de valor en una referencia a objeto (tipo <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|8C &LT; `T` >|cuadro `valTypeToken`|Convertir un tipo de valor (del tipo especificado en `valTypeToken`) a una referencia a objeto real.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un tipo de valor se inserta en la pila.  
  
2.  El tipo de valor se extrae de la pila; el `box` se realiza la operación.  
  
3.  Una referencia de objeto para el tipo de valor "empaquetado" resultante se inserta en la pila.  
  
 Un tipo de valor tiene dos representaciones distintas dentro de Common Language Infrastructure (CLI):  
  
-   Una forma "sin procesar" que se utiliza cuando un tipo de valor se incrusta dentro de otro objeto o en la pila.  
  
-   Una forma de 'conversión boxing', donde los datos en el tipo de valor se empaquetan (boxed) en un objeto de modo que puede existir como una entidad independiente.  
  
 El `box` instrucción convierte el tipo de valor (con conversión unboxing) "sin procesar" en una referencia de objeto (tipo `O`). Esto se consigue creando un nuevo objeto y copiando los datos del tipo de valor en el objeto recién asignado. `valTypeToken` es un token de metadatos que indica el tipo del tipo de valor en la pila.  
  
 <xref:System.OutOfMemoryException> se produce si no hay memoria suficiente para satisfacer la solicitud.  
  
 <xref:System.TypeLoadException> se produce si no se encuentra la clase. Normalmente, esto se detecta cuando el lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo, en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `box` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control incondicionalmente a una instrucción de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Ramas a una instrucción máquina de destino en el desplazamiento especificado.|  
  
 No hay comportamientos de la pila de evaluación se realizan mediante esta operación.  
  
 El `br` instrucción transfiere el control incondicionalmente a una instrucción máquina de destino. La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `br` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control incondicionalmente a una instrucción máquina de destino (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|2B &LT; `int8` >|br.s `target`|Ramas a una instrucción máquina de destino en el desplazamiento especificado, la forma abreviada.|  
  
 No hay comportamientos de la pila de evaluación se realizan mediante esta operación.  
  
 El `br.s` instrucción transfiere el control incondicionalmente a una instrucción máquina de destino. La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `br.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica a Common Language Infrastructure (CLI) que informe al depurador de que se ha recorrido un punto de interrupción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|01|break|informa al depurador que se ha alcanzado un punto de interrupción.|  
  
 No hay comportamientos de la pila de evaluación se realizan mediante esta operación.  
  
 El `break` instrucción es para la compatibilidad con la depuración. Indica a la CLI que informe al depurador que se ha recorrido un punto de interrupción. No tiene ningún otro efecto en el estado del intérprete.  
  
 El `break` instrucción tiene el tamaño más pequeño posible instrucción habilitar código revisiones con un punto de interrupción y afecta mínimamente al código circundante.  
  
 El `break` instrucción puede interceptar un depurador, no hacer nada o producir una excepción de seguridad. El comportamiento exacto es definido por la implementación.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `break` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si <paramref name="value" /> es <see langword="false" />, una referencia nula (<see langword="Nothing" /> en Visual Basic) o cero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Las ramas a una instrucción máquina de destino en el desplazamiento especificado si `false`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila mediante una operación anterior.  
  
2.  `value` se extrae de la pila; Si `value` es `false`, bifurcar a `target`.  
  
 El `brfalse` instrucción (y sus alias `brnull` y `brzero`) transfiere el control a la instrucción de destino especificada si `value` (de tipo `int32`, `int64`, referencia de objeto `O`administrado puntero `&`, puntero transitorio `*`, `native int`) es cero (`false`). Si `value` es distinto de cero (`true`) la ejecución continúa en la siguiente instrucción.  
  
 La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `brfalse` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si <paramref name="value" /> es <see langword="false" />, una referencia nula o cero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|2C &LT;`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Las ramas a una instrucción máquina de destino en el desplazamiento especificado si `false`, forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila mediante una operación anterior.  
  
2.  `value` se extrae de la pila; Si `value` es `false`, bifurcar a `target`.  
  
 El `brfalse.s` instrucción (y sus alias `brnull` y `brzero`) transfiere el control a la instrucción de destino especificada si `value` (de tipo `int32`, `int64`, referencia de objeto `O`administrado puntero `&`, puntero transitorio `*`, `native int`) es cero (`false`). Si `value` es distinto de cero (`true`) la ejecución continúa en la siguiente instrucción.  
  
 La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `brfalse.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino si <paramref name="value" /> es <see langword="true" />, no es null o es distinto de cero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|3A &LT; `int32` >|brtrue `target`<br /><br /> brinst `target`|Rama a una instrucción máquina de destino en el desplazamiento especificado, si es distinto de cero (`true`).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila mediante una operación anterior.  
  
2.  `value` se extrae de la pila; Si `value` es `true`, bifurcar a `target`.  
  
 El `brtrue` instrucción transfiere el control a la instrucción máquina de destino especificada si `value` (tipo `native int`) es distinto de cero (`true`). Si `value` es cero (`false`) la ejecución continúa en la siguiente instrucción.  
  
 Si `value` es una referencia de objeto (tipo `O`), a continuación, `brinst` (un alias para `brtrue`) transfiere el control si representa una instancia de un objeto (por ejemplo, si no es la referencia de objeto nulo; vea <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `brtrue` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfiere el control a una instrucción máquina de destino (forma corta) si <paramref name="value" /> es <see langword="true" />, no es null o es distinto de cero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|2D &LT; `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Rama a una instrucción máquina de destino en el desplazamiento especificado, si es distinto de cero (`true`), forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila mediante una operación anterior.  
  
2.  `value` se extrae de la pila; Si `value` es `true`, bifurcar a `target`.  
  
 El `brtrue.s` instrucción transfiere el control a la instrucción máquina de destino especificada si `value` (tipo `native int`) es distinto de cero (`true`). Si `value` es cero (`false`) la ejecución continúa en la siguiente instrucción.  
  
 Si `value` es una referencia de objeto (tipo `O`), a continuación, `brinst` (un alias para `brtrue`) transfiere el control si representa una instancia de un objeto (por ejemplo, si no es la referencia de objeto nulo; vea <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos. Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `brtrue.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Llama al método indicado por el descriptor del método que se ha pasado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|28 < `T` >|Llamar a `methodDesc`|Llame al método descrito por `methodDesc`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Argumentos del método `arg1` a través de `argN` se insertan en la pila.  
  
2.  Argumentos del método `arg1` a través de `argN` se extraen de la pila; la llamada al método se realiza con estos argumentos y el control se transfiere al método que hace referencia el descriptor del método. Cuando haya finalizado, un valor devuelto es generado por el método de destinatario y envía al llamador.  
  
3.  El valor devuelto se inserta en la pila.  
  
 El `call` instrucción llama al método indicado por el descriptor del método pasado con la instrucción. El descriptor del método es un token de metadatos que indica el método de llamada y el número, tipo y orden de los argumentos que se han colocado en la pila que se pasarán a ese método, así como la convención de llamada que se usará. El `call` instrucción puede ir precedida inmediatamente por un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) instrucción para especificar que el estado del método actual debe liberarse antes de transferir el control con el prefijo. Si la llamada transfiere el control a un método de mayor confianza que el método de origen, no se libera el marco de pila. En su lugar, la ejecución continúa en modo silencioso como si el `tail` no se ha suministrado. El token de metadatos incluye información suficiente para determinar si la llamada a un método estático, un método de instancia, un método virtual o una función global. En todos estos casos, la dirección de destino se determina por completo desde el descriptor del método (Compare esto con el <xref:System.Reflection.Emit.OpCodes.Callvirt> instrucciones para llamar a métodos virtuales, donde la dirección de destino también depende del tipo en tiempo de ejecución de la instancia referencia que se inserta antes del <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Los argumentos se colocan en la pila en orden de izquierda a derecha. Es decir, el primer argumento se calcula y se coloca en la pila, el segundo argumento y, luego, el tercero, hasta que todos los argumentos necesarios son la parte superior de la pila en orden descendente. Existen tres casos especiales importantes:  
  
 1. Las llamadas a una instancia (o virtual) método debe insertar esa referencia a la instancia antes de cualquiera de los argumentos visible para el usuario. La referencia de instancia no debe ser una referencia nula. La firma que se incluyen en los metadatos no contiene una entrada en la lista de parámetros para el `this` puntero; en su lugar, utiliza un bit para indicar si el método requiere que se pase el `this` puntero.  
  
 2. Es válido llamar a un método virtual mediante `call` (en lugar de `callvirt`); Esto indica que se puede resolver mediante la clase especificada por el método en lugar de como se especifica dinámicamente desde el objeto que se invoca el método.  
  
 3. Tenga en cuenta que un delegado `Invoke` método puede llamarse con cualquiera el `call` o `callvirt` instrucción.  
  
 <xref:System.Security.SecurityException> se puede producir si la seguridad del sistema no concede al llamador acceso al método llamado. La comprobación de seguridad puede producirse cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.  
  
> [!NOTE]
>  Al llamar a métodos de System.Object en tipos de valor, considere el uso de la `constrained` con el prefijo del `callvirt` instrucción en lugar de emitir un `call` instrucción. Esto elimina la necesidad para emitir IL diferente dependiendo de si el tipo de valor invalida el método, evitar un posible problema de control de versiones. Considere el uso de la `constrained` prefijo al invocar los métodos de interfaz en tipos de valor, ya que el método de tipo de valor implementa el método de interfaz se puede cambiar mediante una `MethodImpl`. Estos problemas se describen con más detalle en la <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `call` opcode:  
  
-   ILGenerator.Emit (código de operación, MethodInfo)  
  
-   ILGenerator.EmitCall (código de operación, MethodInfo, Type[])  
  
> [!NOTE]
>  El <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> se proporciona para el método `varargs` llamadas. Use el <xref:System.Reflection.Emit.ILGenerator.Emit%2A> método para las llamadas normales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Llama al método indicado en la pila de evaluación (como puntero a un punto de entrada) con los argumentos descritos mediante una convención de llamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Llama al método que se señala con los argumentos descritos mediante la convención de llamada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Argumentos del método `arg1` a través de `argN` se insertan en la pila.  
  
2.  El puntero de entrada del método se inserta en la pila.  
  
3.  Argumentos del método `arg1` a través de `argN` y el puntero de entrada del método se extraen de la pila; se realiza la llamada al método. Cuando haya finalizado, un valor devuelto es generado por el método de destinatario y envía al llamador.  
  
4.  El valor devuelto se inserta en la pila.  
  
 El `calli` instrucción llama el puntero de entrada del método con los argumentos `arg1` a través de `argN`. Los tipos de estos argumentos se describen mediante la convención de llamada específica (`callSiteDesc`). El `calli` instrucción puede estar precedida inmediatamente por un `tail` prefijo (<xref:System.Reflection.Emit.OpCodes.Tailcall>) para especificar que el estado del método actual debe liberarse antes de transferir el control. Si la llamada transfiere el control a un método de mayor confianza que el método de origen del marco de pila no se liberará; en su lugar, la ejecución continúa en modo silencioso como si el `tail` no se ha suministrado.  
  
 El puntero de entrada del método se supone que un puntero específico a código nativo (del equipo de destino) que se puede llamar legítimamente con los argumentos descritos mediante la convención de llamada (un token de metadatos para una firma independiente). Un puntero puede crearse mediante el <xref:System.Reflection.Emit.OpCodes.Ldftn> o <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instrucciones, o pasar desde código nativo.  
  
 La convención de llamada no está activada de forma dinámica, por lo que el código que utiliza un `calli` instrucción no funciona correctamente si el destino no utiliza realmente la convención de llamada especificada.  
  
 Los argumentos se colocan en la pila en orden de izquierda a derecha. Es decir, el primer argumento se calcula y se coloca en la pila, el segundo argumento y, luego, el tercero, hasta que todos los argumentos necesarios son la parte superior de la pila en orden descendente. La secuencia de código de compilación de argumento para una instancia o un método virtual debe insertar esa referencia a la instancia (que no debe ser una referencia nula) antes de cualquiera de los argumentos visible para el usuario.  
  
 <xref:System.Security.SecurityException> se puede producir si la seguridad del sistema no concede al llamador acceso al método llamado. La comprobación de seguridad puede producirse cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> métodos pueden usarse para realizar un `calli` instrucciones acerca de la pila. Tenga en cuenta que `calli` debe llamarse a través de los siguientes métodos en lugar de usar el <xref:System.Reflection.Emit.ILGenerator.Emit%2A> clase para colocar la instrucción directamente en la pila.  
  
-   ILGenerator.EmitCalli (Opcode, CallingConventions, Type, Type [], Type[]) para llamadas con una convención de llamada administrada.  
  
-   ILGenerator.EmitCalli (Opcode, Type[]) CallingConvention, Type, para las llamadas con una convención de llamada no administrada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Llama a un método enlazado tardíamente en un objeto e inserta el valor devuelto en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|6F &LT; `T` >|callvirt `method`|Llama a un método específico asociado con `obj`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `obj` se inserta en la pila.  
  
2.  Argumentos del método `arg1` a través de `argN` se insertan en la pila.  
  
3.  Argumentos del método `arg1` a través de `argN` y la referencia de objeto `obj` se extraen de la pila; la llamada al método se realiza con estos argumentos y el control se transfiere al método en `obj` que hace referencia el método token de metadatos. Cuando haya finalizado, un valor devuelto es generado por el método de destinatario y envía al llamador.  
  
4.  El valor devuelto se inserta en la pila.  
  
 El `callvirt` instrucción llama a un método enlazado tardíamente en un objeto. Es decir, el método se elige en función del tipo en tiempo de ejecución de `obj` en lugar de la clase en tiempo de compilación visible en el puntero del método. `Callvirt` puede usarse para llamar a las virtual y métodos de instancia. El `callvirt` instrucción puede estar precedida inmediatamente por un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) para especificar que el marco de pila actual debe liberarse antes de transferir el control. Si la llamada transfiere el control a un método de mayor confianza que el método original en el marco de pila no se liberará.  
  
 El token de metadatos del método proporciona el nombre, la clase y la firma del método para llamar a. La clase asociada `obj` es la clase de los cuales es una instancia. Si la clase define un método no estático que coincide con el nombre del método indicado y la firma, se llama a este método. En caso contrario, todas las clases de la cadena de la clase base de esta clase se comprueban en orden. Es un error si se encuentra ningún método.  
  
 `Callvirt` extrae el objeto y los argumentos asociados de la pila de evaluación antes de llamar al método. Si el método tiene un valor devuelto, se inserta en la pila tras la finalización del método. En el lado del destinatario, el `obj` se obtiene acceso al parámetro como argumento 0, `arg1` como argumento 1 y así sucesivamente.  
  
 Los argumentos se colocan en la pila en orden de izquierda a derecha. Es decir, el primer argumento se calcula y se coloca en la pila, el segundo argumento y, luego, el tercero, hasta que todos los argumentos necesarios son la parte superior de la pila en orden descendente. La referencia de instancia `obj` (siempre se requiere para `callvirt`) se deben insertar antes que cualquiera de los argumentos visible para el usuario. La firma (incluida en el token de metadatos) no debe contener una entrada en la lista de parámetros para este puntero.  
  
 Tenga en cuenta que un método virtual también se puede llamar mediante el <xref:System.Reflection.Emit.OpCodes.Call> instrucción.  
  
 <xref:System.MissingMethodException> se produce si no se encontró en la clase asociada a un método no estático con el nombre indicado y firma `obj` o cualquiera de sus clases base. Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, en lugar de en tiempo de ejecución.  
  
 <xref:System.NullReferenceException> se produce si obj es null.  
  
 <xref:System.Security.SecurityException> se produce si la seguridad del sistema no concede al llamador acceso al método llamado. La comprobación de seguridad puede producirse cuando se convierte el archivo de CIL a código nativo en lugar de en tiempo de ejecución.  
  
> [!NOTE]
>  Al llamar a métodos de System.Object en tipos de valor, considere el uso de la `constrained` con el prefijo del `callvirt` instrucción. Esto elimina la necesidad para emitir IL diferente dependiendo de si el tipo de valor invalida el método, evitar un posible problema de control de versiones. Considere el uso de la `constrained` prefijo al invocar los métodos de interfaz en tipos de valor, ya que el método de tipo de valor implementa el método de interfaz se puede cambiar mediante una `MethodImpl`. Estos problemas se describen con más detalle en la <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `callvirt` opcode:  
  
-   ILGenerator.Emit (código de operación, MethodInfo)  
  
-   ILGenerator.EmitCall (código de operación, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Intenta convertir un objeto pasado por referencia en la clase especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Convierte el objeto a un nuevo objeto de tipo `class`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto se inserta en la pila.  
  
2.  La referencia de objeto se extrae de la pila; se convierte el objeto de referencia especificado `class`.  
  
3.  Si se realiza correctamente, se inserta una nueva referencia de objeto en la pila.  
  
 El `castclass` instrucción intenta convertir la referencia de objeto (tipo `O`) encima de la pila en una clase especificada. La nueva clase se especifica mediante un token de metadatos que indica la clase deseada. Si la clase del objeto en la parte superior de la pila no implementa la nueva clase (suponiendo que la nueva clase es una interfaz) y no es una clase derivada de la nueva clase una <xref:System.InvalidCastException> se produce. Si la referencia de objeto es una referencia nula, `castclass` se realiza correctamente y devuelve el nuevo objeto como una referencia nula.  
  
 <xref:System.InvalidCastException> se produce si obj no se puede convertir a clase.  
  
 <xref:System.TypeLoadException> se produce si no se encuentra la clase. Normalmente, esto se detecta cuando una instrucción de lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `castclass` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dos valores. Si son iguales, el valor entero 1 <see langword="(int32" />) se inserta en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Inserta 1 si `value1` es igual a `value2`; de lo contrario, inserta 0.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se compara con `value2`.  
  
4.  Si `value1` es igual a `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.  
  
 El `ceq` instrucción compara `value1` y `value2`. Si `value1` es igual a `value2`, a continuación, 1 (de tipo `int32`) se inserta en la pila. En caso contrario, 0 (de tipo `int32`) se inserta en la pila.  
  
 Para el número de punto flotante, `ceq` devolverá 0 si los números están desordenados (uno o ambos son NaN). Los valores infinitos son iguales a sí mismos.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ceq` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dos valores. Si el primer valor es mayor que el segundo, se inserta el valor entero 1 <see langword="(int32" />) en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Inserta 1 si `value1` es mayor que `value2`; de lo contrario, inserta 0.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `cgt` comprueba si `value1` es mayor que `value2`.  
  
4.  Si `value1` es mayor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.  
  
 El `cgt` instrucción compara `value1` y `value2`. Si `value1` es estrictamente mayor que `value2`, una `int32` se inserta el valor 1 en la pila. En caso contrario, un `int32` se inserta el valor 0 en la pila.  
  
-   Números de punto flotante, `cgt` devuelve 0 si los números están desordenados (es decir, si uno o ambos argumentos son NaN).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `cgt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dos valores sin signo o desordenados. Si el primer valor es mayor que el segundo, se inserta el valor entero 1 <see langword="(int32" />) en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Inserta 1 si `value1` es mayor que `value2`; de lo contrario, inserta 0 (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `cgt.un` comprueba si `value1` es mayor que `value2`.  
  
4.  Si `value1` es mayor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.  
  
 Un `int32` se inserta el valor 1 en la pila si se cumple alguna de las siguientes acciones `true` :  
  
 Números de punto flotante, `value1` no está ordenado con respecto a `value2`.  
  
 Para los valores enteros, `value1` es estrictamente mayor que `value2` cuando se consideran como números sin signo.  
  
 En caso contrario, un `int32` se inserta el valor 0 en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `cgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Produce <see cref="T:System.ArithmeticException" /> si el valor no es un número finito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|C3|ckfinite|producir <xref:System.ArithmeticException> si el valor no es un número finito.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila...  
  
2.  `value` se extrae de la pila y la `ckfinite` instrucción se ejecuta en él.  
  
3.  `value` se vuelve a insertar en la pila si se produce ninguna excepción.  
  
 El `ckfinite instruction` produce <xref:System.ArithmeticException> si `value` (un número de punto flotante) es un valor de "not a number" (NaN) o un `+-` valor infinito. `Ckfinite` deja el valor en la pila si se produce ninguna excepción. Si no se especifica ejecución `value` no es un número de punto flotante.  
  
 <xref:System.ArithmeticException> se produce si `value` no es un número 'normal'.  
  
 Tenga en cuenta que una excepción especial o una clase derivada de <xref:System.ArithmeticException> puede resultar más adecuado, pasando el valor incorrecto para el controlador de excepciones.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ckfinite` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dos valores. Si el primer valor es menor que el segundo, se inserta el valor entero 1 <see langword="(int32" />) en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 04|clt|Inserta 1 si `value1` es menor que `value2`; de lo contrario, inserta 0.|  
  
 El comportamiento de transición de pila, en orden secuencial, es: `value1` se inserta en la pila.  
  
1.  `value2` se inserta en la pila.  
  
2.  `value2` y `value1` se extraen de la pila; `clt` comprueba si `value1` es menor que `value2`.  
  
3.  Si `value1` es menor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.  
  
 El `clt` instrucción compara `value1` y `value2`. Si `value1` es estrictamente menor que `value2`, una `int32` se inserta el valor 1 en la pila. En caso contrario, un `int32` se inserta el valor 0 en la pila.  
  
-   Números de punto flotante, `clt` devuelve 0 si los números están desordenados (es decir, si uno o ambos argumentos son NaN).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `clt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara los valores sin signo o desordenados <paramref name="value1" /> y <paramref name="value2" />. Si <paramref name="value1" /> es menor que <paramref name="value2" />, se inserta en la pila de evaluación el valor entero 1 <see langword="(int32" />); en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|Inserta 1 si `value1` es menor que `value2`; de lo contrario, inserta 0 (valores sin signo).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `clt.un` comprueba si `value1` es menor que `value2`.  
  
4.  Si `value1` es menor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.  
  
 El `clt.un` instrucción compara `value1` y `value2`. Un `int32` se inserta el valor 1 en la pila si se cumple alguna de las siguientes acciones:  
  
-   `value1` es estrictamente menor que `value2` (como para `clt`).  
  
-   Números de punto flotante, `value1` no está ordenado con respecto a `value2`.  
  
-   Para los valores enteros, `value1` es estrictamente menor que `value2` cuando se consideran como números sin signo.  
  
 En caso contrario, un `int32` se inserta el valor 0 en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `clt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restringe el tipo en el que se realiza una llamada a método virtual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|restringida. `thisType`|Llamada a un método virtual en un tipo de restricción de tipo `T`.|  
  
 El `constrained` prefijo sólo se permite en un `callvirt` instrucción.  
  
 El estado de la pila MSIL en este punto debe ser como sigue:  
  
1.  Un puntero administrado, `ptr`, se inserta en la pila. El tipo de `ptr` debe ser un puntero administrado (`&`) a `thisType`. Tenga en cuenta que esto es diferente en el caso de una sin prefijo `callvirt` instrucción, que espera una referencia de `thisType`.  
  
2.  Argumentos del método `arg1` a través de `argN` se insertan en la pila, al igual que con una sin prefijo `callvirt` instrucción.  
  
 El `constrained` prefijo está diseñado para permitir `callvirt` instrucciones que se realiza en una uniforme de forma independiente de si `thisType` es un tipo de valor o un tipo de referencia.  
  
 Cuando un `callvirt` `method` ha prefijado instrucción `constrained` `thisType`, la instrucción se ejecuta como sigue:  
  
-   Si `thisType` es un tipo de referencia (en lugar de un tipo de valor), a continuación, `ptr` se desreferencia y se pasa como el puntero 'this' en el `callvirt` de `method`.  
  
-   Si `thisType` es un tipo de valor y `thisType` implementa `method` , a continuación, `ptr` se pasa sin modificaciones como el puntero 'this' en un `call` `method` instrucciones para la implementación de `method` por `thisType`.  
  
-   Si `thisType` es un tipo de valor y `thisType` no implementa `method` , a continuación, `ptr` se desreferencia, aplicar la conversión boxing y pasa como el puntero 'this' en el `callvirt` `method` instrucción.  
  
 Puede producirse este último caso solo cuando `method` se definió en <xref:System.Object>, <xref:System.ValueType>, o <xref:System.Enum> y no se reemplaza por `thisType`. En este caso, la conversión boxing hace una copia del objeto original que se realicen. Sin embargo, dado que ninguno de los métodos de <xref:System.Object>, <xref:System.ValueType>, y <xref:System.Enum> modificar el estado del objeto, no se puede detectar este hecho.  
  
 El `constrained` prefijo es compatible con los generadores de IL que crean código genérico. Normalmente el `callvirt` instrucción no es válido en tipos de valor. En su lugar, es necesario que los compiladores de lenguaje intermedio realizan eficazmente la transformación de 'this' descrita anteriormente en tiempo de compilación, según el tipo de `ptr` y se llame al método. Sin embargo, cuando `ptr` es un tipo genérico que se desconoce en tiempo de compilación, no es posible realizar esta transformación en tiempo de compilación.  
  
 El `constrained` opcode permite que los compiladores de IL realizar una llamada a una función virtual en una uniforme de forma independiente de si `ptr` es un tipo de valor o un tipo de referencia. Aunque está diseñado para el caso donde `thisType` es una variable de tipo genérico, la `constrained` prefijo también funciona para tipos no genéricos y puede reducir la complejidad de generar llamadas virtuales en lenguajes que ocultan la distinción entre los tipos de valor y tipos de referencia.  
  
 Mediante el `constrained` prefijo también evita posibles problemas de control de versiones con tipos de valor. Si el `constrained` no se usa el prefijo, se debe emitir IL diferente dependiendo de si un tipo de valor invalida un método de System.Object. Por ejemplo, si un tipo de valor `V` invalida el método Object.ToString (), un `call` `V.ToString()` se emite una instrucción; de lo contrario, un `box` instrucciones y un `callvirt` `Object.ToString()` se emite la instrucción. En el caso anterior, si se quita más tarde la invalidación y, en este caso puede surgir un problema de control de versiones si más adelante se agrega una invalidación.  
  
 El `constrained` prefijo también puede usarse para la invocación de métodos de interfaz en tipos de valor, porque se puede cambiar el método de tipo de valor implementa el método de interfaz mediante un `MethodImpl`. Si el `constrained` no se utiliza el prefijo, el compilador se obliga a elegir qué del valor de los métodos del tipo para enlazar en tiempo de compilación. Mediante el `constrained` prefijo permite que el código MSIL enlazar con el método que implementa el método de interfaz en tiempo de ejecución, en lugar de en tiempo de compilación.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `constrained` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D3|conv.i|Convertir en `native int`e inserta `native int` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.i` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="int8" /> y luego lo extiende (lo rellena) hasta <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|67|conv.i1|Convertir en `int8`e inserta `int32` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.i1` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="int16" /> y luego lo extiende (lo rellena) hasta <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|68|conv.i2|Convertir en `int16`e inserta `int32` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.i2` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|69|conv.i4|Convertir en `int32`e inserta `int32` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.i4` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|6A|conv.i8|Convertir en `int64`e inserta `int64` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.i8` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="native int" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Convertir en un `native int` (en la pila como `native int`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="native int" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Convierte un valor sin signo en un `native int` (en la pila como `native int`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en un <see langword="int8" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Convertir en un `int8` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i1` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en un <see langword="int8" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Convierte un valor sin signo en un `int8` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i1.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en un <see langword="int16" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Convertir en un `int16` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i2` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en un <see langword="int16" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Convierte un valor sin signo en un `int16` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i2.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Convertir en un `int32` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i4` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Convierte un valor sin signo en un `int32` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i4.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="int64" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Convertir en un `int64` (en la pila como `int64`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i8` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="int64" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Convierte un valor sin signo en un `int64` (en la pila como `int64`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.i8.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.i8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned native int" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Convertir en un `unsigned native int` (en la pila como `native int`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned native int" /> y produce <see cref="T:System.OverflowException" /> en caso de desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Convierte un valor sin signo en un `unsigned native int` (en la pila como `native int`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.uvf.u.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int8" />, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.U1|Convertir en un `unsigned int8` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u1` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int8" />, lo extiende hasta <see langword="int32" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Convierte un valor sin signo en un `unsigned int8` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u1.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int16" />, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Convertir en un `unsigned int16` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u2` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int16" />, lo extiende hasta <see langword="int32" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Convierte un valor sin signo en un `unsigned int16` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u2.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int32" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|Convertir en un `unsigned int32` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u4` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int32" /> y produce <see cref="T:System.OverflowException" /> en caso de desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Convierte un valor sin signo en un `unsigned int32` (en la pila como `int32`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u4.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int64" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Convertir en un `unsigned int64` (en la pila como `int64`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u8` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int64" /> y produce <see cref="T:System.OverflowException" /> en caso de desbordamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Convierte un valor sin signo en un `unsigned int64` (en la pila como `int64`) e inicia una excepción en caso de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación. Si se produce un desbordamiento, se produce una excepción.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.ovf.u8.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido. Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.  
  
 Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero. Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.ovf.u8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor entero sin signo situado en la parte superior de la pila de evaluación en <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Convert entero sin signo de punto flotante, insertar `F` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.r.un` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir un tipo de punto flotante a entero la `result` devuelto no se especifica. El `conv.r.un` operación toma un entero de la pila, lo interpreta como valor sin signo y lo reemplaza con un número de punto flotante para representar el entero: ya sea un `float32`, si esto es lo suficientemente ancha para representar el entero sin pérdida de precisión o else un `float64`.  
  
 Nunca se produce ninguna excepción cuando se usa este campo.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.r.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|6B|conv.r4|Convertir en `float32`e inserta `F` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.r4` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|6C|conv.r8|Convertir en `float64`e inserta `F` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.r8` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned native int" /> y lo extiende hasta <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|E0|conv.u|Convertir en `unsigned native int`e inserta `native int` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.u` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int8" /> y lo extiende hasta <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D2|conv.U1|Convertir en `int8`e inserta `int32` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.u1` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int16" /> y lo extiende hasta <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D1|conv.u2|Convertir en `int16`e inserta `int32` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.u2` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int32" /> y lo extiende hasta <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|6D|conv.u4|Convertir en `unsigned int32`e inserta `int32` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.u4` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int64" /> y lo extiende hasta <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Convertir en `int64`e inserta `int64` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y la conversión se intenta la operación.  
  
3.  Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.  
  
 El `conv.u8` opcode convierte el `value` encima de la pila para el tipo especificado en el código de operación y deja que convierte el valor en la parte superior de la pila. Valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`). Valores de punto flotante se convierten en el `F` tipo.  
  
 Conversión de números de punto flotante en valores enteros trunca el número en cero. Al convertir de un `float64` a un `float32`, se puede perder precisión. Si `value` es demasiado grande para caber un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve. Si produce el desbordamiento convertir tipo de entero de uno a otro, se truncan los bits de orden superior. Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.  
  
 Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero que devuelve el valor se especifica.  
  
 Nunca se produce ninguna excepción cuando se usa este campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obtener instrucciones equivalentes que se producen una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `conv.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia un número de bytes especificado de una dirección de origen en una dirección de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Copiar datos desde un bloque de memoria a otro.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección de destino se inserta en la pila.  
  
2.  La dirección de origen se inserta en la pila.  
  
3.  Se inserta el número de bytes que deben copiarse en la pila.  
  
4.  El número de bytes, la dirección de origen y la dirección de destino se extrae de la pila; el número especificado de bytes se copia de la dirección de origen a la dirección de destino.  
  
 El `cpblk` instrucción copia un número (tipo `unsigned int32`) de bytes a partir de una dirección de origen (de tipo `*`, `native int`, o `&`) a una dirección de destino (de tipo `*`, `native int`, o `&`). El comportamiento de `cpblk` no se especifica si las áreas de origen y destino se superponen.  
  
 `cpblk` se da por supuesto que el origen y el destino direccionado se alinean con el tamaño natural de la máquina. El `cpblk` instrucción puede ir precedida inmediatamente por la `unaligned.<prefix>` instrucción para indicar que el origen o el destino está sin alinear.  
  
 La operación de la `cpblk` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `cpblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia el tipo de valor situado en la dirección de un objeto (de tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" />) en la dirección del objeto de destino (de tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Copia un valor de un tipo de un objeto de origen a un objeto de destino.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La referencia de objeto de destino se inserta en la pila.  
  
2.  La referencia de objeto de origen se inserta en la pila.  
  
3.  Las referencias a dos objetos se extraen de la pila; el tipo de valor en la dirección del objeto de origen se copia en la dirección del objeto de destino.  
  
 El comportamiento de `cpobj` no se especifica si las referencias no son punteros a las instancias de la clase representada por el token de la clase de objeto de origen y destino `classTok` (un `typeref` o `typedef`), o si `classTok` no representa un tipo de valor.  
  
 <xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `cpobj` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dos valores e inserta el resultado como punto flotante (de tipo <see langword="F" />) o cociente (de tipo <see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|5B|div|Divide dos valores para devolver un resultado de punto flotante o cociente.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se divide por `value2`.  
  
4.  El resultado se inserta en la pila.  
  
 `result` = `value1` div value2 cumple las condiciones siguientes:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, y:  
  
 inicio de sesión (`result`) = +, if firmar (`value1`) = el inicio de sesión (`value2`), o-, si inicio de sesión (`value1`) ~ = inicio de sesión (`value2`)  
  
 El `div` instrucción calcula el resultado y lo inserta en la pila.  
  
 División de enteros trunca hacia cero.  
  
 División de un número finito por cero, genera el valor infinito firmado correctamente.  
  
 División entre cero por cero o infinito por infinito, se obtiene el valor NaN (no-un número). Cualquier número dividido entre infinito generará un valor de cero.  
  
 Las operaciones integrales inician <xref:System.ArithmeticException> si el resultado no se puede representar el tipo de resultado. Esto puede suceder si `value1` es el máximo valor negativo, y `value2` es -1.  
  
 Las operaciones integrales inician <xref:System.DivideByZeroException> si `value2` es cero.  
  
 Tenga en cuenta que en plataformas basadas en Intel en un <xref:System.OverflowException> se produce al calcular (minint div -1). Operaciones de punto flotante nunca producen una excepción (que generan valores NaN o infinitos en su lugar).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `div` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dos valores enteros sin signo e inserta el resultado (<see langword="int32" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|5C|div.un|Divide dos valores sin signo y devuelve un cociente.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se divide por `value2`.  
  
4.  El resultado se inserta en la pila.  
  
 El `div.un` instrucción calcula `value1` dividido por `value2`, ambos como enteros sin signo e inserta el `result` en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `div.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia el valor que se encuentra en la parte superior de la pila de evaluación e inserta la copia en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|25|dupl.|Duplica el valor en la parte superior de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila para la duplicación.  
  
3.  `value` se vuelve a insertar en la pila.  
  
4.  Un valor duplicado se inserta en la pila.  
  
 El `dup` instrucción duplica el elemento superior de la pila y deja dos valores idénticos encima.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `dup` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vuelve a transferir el control de la cláusula <see langword="filter" /> de una excepción al controlador de excepciones de Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|Cláusula de filtro de extremo de control de excepciones SEH.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila; `endfilter` se ejecuta y el control se transfiere al controlador de excepciones.  
  
 `Value` (que debe ser de tipo `int32` y es uno de un conjunto específico de valores) se devuelve de la cláusula de filtro. Debe ser uno de:  
  
-   `exception_continue_search` (`value` = 0) para continuar la búsqueda para un controlador de excepciones  
  
-   `exception_execute_handler` (`value` = 1) para iniciar la segunda fase del control de excepciones donde se ejecutan bloques finally hasta que el controlador asociado a esta cláusula de filtro se encuentra. Tras la detección, se ejecuta el controlador.  
  
 Otros valores enteros producirá resultados no especificados.  
  
 El punto de entrada de un filtro, como se muestra en la tabla de excepciones del método, debe ser la primera instrucción del bloque de código del filtro. El `endfilter` instrucción debe ser la última instrucción del bloque de filtro código (por lo tanto, solo puede haber uno `endfilter` para cada bloque filter). Después de ejecutar el `endfilter` instrucción de control lógicamente fluye al mecanismo de control de excepciones de CLI.  
  
 No se puede transferir el control en un bloque de filtros, excepto a través del mecanismo de excepción. No se puede transferir el control fuera de un bloque de filtro, excepto a través del uso de un `throw` instrucciones o mediante la ejecución de la última `endfilter` instrucción. No puede incrustar un `try` bloquear dentro de un `filter` bloque. Si se produce una excepción dentro de la `filter` bloque, se interceptan y un valor de 0 (`exception_continue_search`) se devuelve.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `endfilter` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vuelve a transferir el control de la cláusula <see langword="fault" /> o <see langword="finally" /> de un bloque de excepción al controlador de excepciones de Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|Finaliza el `finally` o `fault` cláusula de un bloque de excepción.|  
  
 No hay ninguna pila de comportamientos de transición de esta instrucción.  
  
 `Endfinally` y `endfault` indicar el final de la `finally` o `fault` cláusula para ese desenredo de pila pueda continuar hasta que se invoca el controlador de excepciones. El `endfinally` o `endfault` instrucción transfiere el control al mecanismo de excepciones de CLI. Después, este mecanismo busca la siguiente `finally` cláusula en la cadena si se salió del bloque protegido con una instrucción leave. Si se salió del bloque protegido con una excepción, la CLI buscará durante los próximos `finally` o `fault`, o especifique el controlador de excepciones elegido durante el primer paso del control de excepciones.  
  
 Un `endfinally` instrucción podría aparecer sólo léxicamente en un `finally` bloque. A diferencia de la `endfilter` instrucciones, no es necesario que el bloque terminan con un `endfinally` instrucción y puede haber tantos `endfinally` instrucciones dentro del bloque según sea necesario. Se aplican las mismas restricciones a la `endfault` instrucción y el `fault` bloque.  
  
 No se puede transferir el control a un `finally` (o `fault`) bloque excepto a través del mecanismo de excepción. No se puede transferir el control fuera de un `finally` (o `fault`) bloque excepto mediante el uso de un `throw` instrucciones o ejecutar el `endfinally` (o `endfault`) instrucción. En concreto, no se puede "salir" de un `finally` (o `fault`) bloque o para ejecutar un <xref:System.Reflection.Emit.OpCodes.Ret> o <xref:System.Reflection.Emit.OpCodes.Leave> instrucción dentro de un `finally` (o `fault`) bloque.  
  
 Tenga en cuenta que el `endfault` y `endfinally` instrucciones son alias, que se corresponden con el mismo código de operación.  
  
 Lo siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `endfinally` (`endfault`) código de operación, así como el `ILGenerator` método <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicializa un bloque de memoria especificado en una dirección específica con el tamaño y el valor inicial dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Establecer cada ubicación en un bloque de memoria con un valor determinado.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección de inicio se inserta en la pila.  
  
2.  Un valor de inicialización se inserta en la pila.  
  
3.  El número de bytes que se inicializarán se inserta en la pila.  
  
4.  El número de bytes, el valor de inicialización y la dirección inicial se extrae de la pila y se realiza la inicialización según sus valores.  
  
 El `initblk` el número de conjuntos de instrucciones (`unsigned int32`) de bytes a partir de la dirección especificada (de tipo `native int`, `&`, o `*`) en el valor de inicialización (de tipo `unsigned int8`). `initblk` se da por supuesto que la dirección inicial está alineada con el tamaño natural de la máquina.  
  
 La operación de la `initblk` instrucciones pueden ser modificadas por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `initblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicializa cada uno de los campos del tipo de valor en la dirección especificada en una referencia nula o en un valor 0 del tipo primitivo correspondiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|Inicializa un tipo de valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección del tipo de valor para inicializar se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el tipo de valor en la dirección especificada se inicializa como tipo `typeTok`.  
  
 El `initobj` instrucción inicializa cada campo del tipo de valor especificado por la dirección insertada (de tipo `native int`, `&`, o `*`) en una referencia null o un valor 0 del tipo primitivo correspondiente. Después de llamar a este método, la instancia está lista para un método constructor al que llamar. Si `typeTok` es un tipo de referencia, esta instrucción tiene el mismo efecto que `ldnull` seguido `stind.ref`.  
  
 A diferencia de <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` no llama al método de constructor. `Initobj` está diseñado para inicializar tipos de valor, mientras que `newobj` se usa para asignar e inicializar objetos.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `initobj` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comprueba si una referencia a objeto (de tipo <see langword="O" />) es una instancia de una clase determinada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Comprueba si una referencia de objeto es una instancia de `class`, que devuelve una referencia nula o una instancia de esa clase o interfaz.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto se inserta en la pila.  
  
2.  La referencia de objeto se extrae de la pila y probada para ver si es una instancia de la clase pasada en `class`.  
  
3.  El resultado (una referencia de objeto o una referencia nula) se inserta en la pila.  
  
 `Class` es un token de metadatos que indica la clase deseada. Si la clase del objeto en la parte superior de la pila implementa `class` (si `class` es una interfaz) o es una clase derivada de `class` (si `class` es una clase normal), a continuación, se convierte al tipo `class` y se inserta el resultado en la pila, exactamente como si <xref:System.Reflection.Emit.OpCodes.Castclass> hubiera llamado. En caso contrario, se inserta una referencia nula en la pila. Si la propia referencia de objeto es una referencia nula, a continuación, `isinst` del mismo modo, devuelve una referencia nula.  
  
 <xref:System.TypeLoadException> se produce si no se encuentra la clase. Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `isinst` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sale del método actual y salta al método especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|Sale del método actual y salta al método especificado.|  
  
 No hay ninguna pila de comportamientos de transición de esta instrucción.  
  
 El `jmp` instrucción (jump) transfiere el control al método especificado por `method`, que es un token de metadatos para una referencia de método. Los argumentos actuales se transfieren al método de destino.  
  
 La pila de evaluación debe estar vacía cuando se ejecuta esta instrucción. La convención de llamada, el número y el tipo de los argumentos de la dirección de destino deben coincidir con los del método actual.  
  
 El `jmp` instrucción no se puede usar para transferir el control fuera de un `try`, `filter`, `catch`, o `finally` bloque.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `jmp` opcode:  
  
-   ILGenerator.Emit (código de operación, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga un argumento (al que hace referencia un valor de índice especificado) en la pila.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 09 &LT; `unsigned int16` >|ldarg `index`|Carga el argumento en `index` en pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del argumento en `index` se inserta en la pila.  
  
 El `ldarg` instrucción inserta el argumento que se encuentra en el índice `index`, donde los argumentos están indizados comprendido entre 0 y versiones posteriores, en la pila de evaluación. El `ldarg` instrucción puede usarse para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada. El tipo del valor del argumento es el mismo que el tipo del argumento, tal como se especifica mediante la firma del método actual.  
  
 Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarg` instrucción puede usarse solo para los argumentos fijos iniciales, no los de la parte variable de la firma (vea la <xref:System.Reflection.Emit.OpCodes.Arglist> instrucciones para obtener más detalles).  
  
 Argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarg` opcode:  
  
-   ILGenerator.Emit (código de operación, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el argumento que se encuentra en el índice 0 en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Carga el argumento 0 en la pila|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del argumento en el índice 0 se inserta en la pila.  
  
 El `ldarg.0` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 0.  
  
 El `ldarg.0` instrucción inserta el argumento indizado en 0 en la pila de evaluación. El `ldarg.0` instrucción puede usarse para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada. El tipo del valor del argumento es el mismo que el tipo del argumento, tal como se especifica mediante la firma del método actual.  
  
 Argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarg.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el argumento que se encuentra en el índice 1 en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Carga el argumento 1 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del argumento en el índice 1 se inserta en la pila.  
  
 El `ldarg.1` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 1.  
  
 El `ldarg.1` instrucción inserta el argumento indizado en 1 en la pila de evaluación. El `ldarg.1` instrucción puede usarse para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada. El tipo del valor del argumento es el mismo que el tipo del argumento, tal como se especifica mediante la firma del método actual.  
  
 Argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarg.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el argumento que se encuentra en el índice 2 en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Carga el argumento 2 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del argumento en el índice 2 se inserta en la pila.  
  
 El `ldarg.2` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 2.  
  
 El `ldarg.2` instrucción inserta el argumento indizado en 2 en la pila de evaluación. El `ldarg.2` instrucción puede usarse para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada. El tipo del valor del argumento es el mismo que el tipo del argumento, tal como se especifica mediante la firma del método actual.  
  
 Argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarg.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el argumento que se encuentra en el índice 3 en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Carga el argumento 3 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del argumento en el índice 3 se inserta en la pila.  
  
 El `ldarg.3` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 3.  
  
 El `ldarg.3` instrucción inserta el argumento indizado en 3 en la pila de evaluación. El `ldarg.3` instrucción puede usarse para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada. El tipo del valor del argumento es el mismo que el tipo del argumento, tal como se especifica mediante la firma del método actual.  
  
 Argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarg.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el argumento (al que hace referencia un índice de forma corta especificado) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0E &LT; `unsigned int8` >|ldarg.s `index`|Carga el argumento en `index` en la pila de forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del argumento en `index` se inserta en la pila.  
  
 El `ldarg.s` instrucción es una codificación eficaz para cargar los argumentos que se indexa de 4 a 255.  
  
 El `ldarg.s` instrucción inserta el argumento que se encuentra en el índice `index`, donde los argumentos están indizados comprendido entre 0 y versiones posteriores, en la pila de evaluación. El `ldarg.s` instrucción puede usarse para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada. El tipo del valor del argumento es el mismo que el tipo del argumento, tal como se especifica mediante la firma del método actual.  
  
 Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarg.s` instrucción puede usarse solo para los argumentos fijos iniciales, no los de la parte variable de la firma (vea la <xref:System.Reflection.Emit.OpCodes.Arglist> instrucciones para obtener más detalles).  
  
 Argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarg.s` opcode:  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga la dirección de un argumento en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 0A &LT; `unsigned int16` >|ldarga `index`|Obtiene la dirección del argumento indizado en `index`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección `addr` del argumento indizado por `index` se inserta en la pila.  
  
 El `ldarga` instrucción obtiene la dirección (de tipo `*`) del argumento indizado por `index`, donde los argumentos están indizados comprendido entre 0 y versiones posteriores. La dirección `addr` siempre se alinea con un límite natural del equipo de destino.  
  
 Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarga` instrucción puede usarse solo para los argumentos fijos iniciales, no los de la parte variable de la firma.  
  
 `ldarga` se usa para pasar de parámetros por referencia. Para otros casos, <xref:System.Reflection.Emit.OpCodes.Ldarg> y <xref:System.Reflection.Emit.OpCodes.Starg> se debe usar.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarga` opcode:  
  
-   ILGenerator.Emit (código de operación, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga la dirección de un argumento (forma corta) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0F &LT; `unsigned int8` >|ldarga.s `index`|Obtiene la dirección del argumento indizado en `index`, forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección `addr` del argumento indizado por `index` se inserta en la pila.  
  
 `ldarga.s` (la forma abreviada de `ldarga`) se debe usar para los números de argumento 0 y 255, y es una codificación más eficaz.  
  
 El `ldarga.s` instrucción obtiene la dirección (de tipo`*`) del argumento indizado por `index`, donde los argumentos están indizados comprendido entre 0 y versiones posteriores. La dirección `addr` siempre se alinea con un límite natural del equipo de destino.  
  
 Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarga.s` instrucción puede usarse solo para los argumentos fijos iniciales, no los de la parte variable de la firma.  
  
 `ldarga.s` se usa para pasar de parámetros por referencia. Para otros casos, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> y <xref:System.Reflection.Emit.OpCodes.Starg_S> se debe usar.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldarga.s` opcode:  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación un valor suministrado de tipo <see langword="int32" /> como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Inserta el valor `num` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor `num` se inserta en la pila.  
  
 Tenga en cuenta que hay codificaciones especiales de corto (y por lo tanto, más eficaces) para los enteros -128 a 127 y codificaciones especialmente cortas de -1 a 8. Todas las codificaciones cortas insertan enteros de 4 bytes en la pila. Codificaciones más largas se usan para los enteros de 8 bytes y 4 y 8 números de punto flotante de byte, así como los valores de 4 bytes que no caben en la forma corta. Hay tres maneras de insertar una constante de entero de 8 bytes en la pila  
  
 1. Use el <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instrucciones para las constantes que se debe expresar en más de 32 bits.  
  
 2. Use la <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instrucción seguida de un <xref:System.Reflection.Emit.OpCodes.Conv_I8> para las constantes que requieran de 9 a 32 bits.  
  
 3. Utilice una instrucción de forma abreviada seguida por un <xref:System.Reflection.Emit.OpCodes.Conv_I8> para las constantes que se pueden expresar en 8 bits o menos.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4` opcode:  
  
-   ILGenerator.Emit (código de operación, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 0 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Inserta 0 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 0 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 1 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Inserta 1 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 1 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 2 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Inserta el 2 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 2 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 3 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Inserta 3 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 3 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 4 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Inserta 4 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 4 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 5 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Inserta 5 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 5 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.5` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 6 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Inserta 6 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 6 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.6` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 7 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Inserta 7 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 7 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.7` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero 8 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Inserta 8 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor 8 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor entero -1 como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|15|ldc.i4.M1|Inserta -1 en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor -1 se inserta en la pila.  
  
 Esto es una codificación corta especial para la inserción del valor entero de 0. Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.m1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor <see langword="int8" /> suministrado como <see langword="int32" /> (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1F &LT; `int8` >|ldc.i4.s `num`|Inserta `num` en la pila como `int32`, forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor `num` se inserta en la pila.  
  
 `ldc.i4.s` es una codificación más eficaz para insertar los enteros entre -128 a 127 en la pila de evaluación.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i4.s` opcode:  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación un valor suministrado de tipo <see langword="int64" /> como <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|Inserta `num` en la pila como `int64`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor `num` se inserta en la pila.  
  
 Esta codificación inserta un `int64` valor en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.i8` opcode:  
  
-   ILGenerator.Emit (código de operación, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación un valor suministrado de tipo <see langword="float32" /> como tipo <see langword="F" /> (flotante).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|Inserta `num` en la pila como `F`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor `num` se inserta en la pila.  
  
 Esta codificación inserta un `float32` valor en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.r4` opcode:  
  
-   ILGenerator.Emit (código de operación, solo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación un valor suministrado de tipo <see langword="float64" /> como tipo <see langword="F" /> (flotante).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|Inserta `num` en la pila como `F`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor `num` se inserta en la pila.  
  
 Esta codificación inserta un `float64` valor en la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldc.r8` opcode:  
  
-   ILGenerator.Emit (código de operación, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como el tipo definido en la instrucción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|A3 &LT; `T` >|ldelem `typeTok`|Carga el elemento en `index` en la parte superior de la pila como tipo `typeTok`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por lo tanto, representado por un valor de tipo `O`.  
  
 El tipo del valor devuelto se especifica el token `typeTok` en la instrucción.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite superior de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="native int" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Carga el elemento de tipo `native int` en `index` en la parte superior de la pila como un `native int`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.i` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.i` es `native int`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="int8" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Carga el elemento de tipo `int8` en `index` en la parte superior de la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.i1` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.i1` es `int8`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="int16" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|Carga el elemento de tipo `int16` en `index` en la parte superior de la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.i2` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.i2` es `int16`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="int32" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Carga el elemento de tipo `int32` en `index` en la parte superior de la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.i4` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.i4` es `int32`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="int64" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|Carga el elemento de tipo `int64` en `index` en la parte superior de la pila como un `int64`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.i8` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.i8` es `int64`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="float32" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como tipo <see langword="F" /> (flotante).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|Carga el elemento de tipo `float32` en `index` en la parte superior de la pila como un tipo `F`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.r4` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.r4` es `float32`.  
  
 Valores de punto flotante se convierten al tipo `F` cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="float64" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como tipo <see langword="F" /> (flotante).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|Carga el elemento de tipo `float64` en `index` en la parte superior de la pila como tipo `F`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.r8` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.r8` es `float64`.  
  
 Valores de punto flotante se convierten al tipo `F` cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento que contiene una referencia a objeto en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como tipo <see langword="O" /> (referencia a objeto).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Carga el elemento con una referencia a objeto en `index` en la parte superior de la pila como tipo `O`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.ref` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.ref` es de tipo `O` (referencia a objeto).  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="unsigned int8" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|91|ldelem.U1|Carga el elemento de tipo `unsigned int8` en `index` en la parte superior de la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.u1` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.u1` es `int8`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="unsigned int16" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|Carga el elemento de tipo `unsigned int16` en el índice en la parte superior de la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.u2` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.u2` es `int16`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga el elemento de tipo <see langword="unsigned int32" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|Carga el elemento de tipo `unsigned int32` en el índice en la parte superior de la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; el valor almacenado en la posición `index` en `array` se busca.  
  
4.  El valor se inserta en la pila.  
  
 El `ldelem.u4` instrucción carga el valor del elemento con índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`.  
  
 El valor devuelto para `ldelem.u4` es `int32`.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si la matriz no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelem.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga la dirección del elemento de la matriz que se encuentra en un índice de la matriz especificado en la parte superior de la pila de evaluación como tipo <see langword="&amp;" /> (puntero administrado).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|8F &LT; `T` >|ldelema `class`|Carga la dirección del elemento de matriz en `index` en la parte superior de la pila de evaluación como tipo `&` (puntero administrado).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `array` se inserta en la pila.  
  
2.  Un valor de índice `index` se inserta en la pila.  
  
3.  `index` y `array` se extraen de la pila; la dirección almacenada en la posición `index` en `array` se busca.  
  
4.  La dirección se inserta en la pila.  
  
 El `ldelema` se usa para recuperar la dirección de un objeto en un índice determinado en una matriz de objetos (de tipo `class`). El `ldelema` instrucción carga la dirección del valor en el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila. Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El valor debe ser de tipo `class` pasado con la instrucción.  
  
 El valor devuelto para `ldelema` es un puntero administrado (tipo `&`).  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldelema` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Encuentra el valor de un campo en el objeto cuya referencia se encuentra actualmente en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|7B &LT; `T` >|ldfld `field`|Inserta el valor de un campo en un objeto especificado en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto (o puntero) se inserta en la pila.  
  
2.  La referencia de objeto (o puntero) se extrae de la pila; el valor del campo especificado en el objeto se encuentra.  
  
3.  El valor almacenado en el campo se inserta en la pila.  
  
 El `ldfld` instrucción inserta el valor de un campo que se encuentra en un objeto en la pila. El objeto debe estar en la pila como una referencia de objeto (tipo `O`), un puntero administrado (tipo `&`), un puntero no administrado (tipo `native int`), un puntero transitorio (tipo `*`), o una instancia de un tipo de valor. No se permite el uso de un puntero no administrado en código comprobable. El campo del objeto especificado por un token de metadatos que debe hacer referencia a un miembro de campo. El tipo de valor devuelto es el mismo que el asociado con el campo. El campo puede ser un campo de instancia (en cuyo caso el objeto debe no ser una referencia nula) o un campo estático.  
  
 El `ldfld` instrucción puede ir precedida por uno o ambos de los <xref:System.Reflection.Emit.OpCodes.Unaligned> y <xref:System.Reflection.Emit.OpCodes.Volatile> prefijos.  
  
 <xref:System.NullReferenceException> se produce si el objeto es null y el campo no es estático.  
  
 <xref:System.MissingFieldException> se produce si el campo especificado no se encuentra en los metadatos. Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldfld` opcode:  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Busca la dirección de un campo en el objeto cuya referencia se encuentra actualmente en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|7C &LT; `T` >|ldflda `field`|Inserta la dirección de `field` en un objeto especificado en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto (o puntero) se inserta en la pila.  
  
2.  La referencia de objeto (o puntero) se extrae de la pila; la dirección del campo especificado en el objeto se encuentra.  
  
3.  La dirección del campo especificado se inserta en la pila.  
  
 El `ldflda` instrucción inserta la dirección de un campo que se encuentra en un objeto en la pila. El objeto debe estar en la pila como una referencia de objeto (tipo `O`), un puntero administrado (tipo `&`), un puntero no administrado (tipo `native int`), un puntero transitorio (tipo `*`), o una instancia de un tipo de valor. No se permite el uso de un puntero no administrado en código comprobable. El campo del objeto especificado por un token de metadatos que debe hacer referencia a un miembro de campo.  
  
 El valor devuelto por `ldflda` es un puntero administrado (tipo `&`) a menos que el objeto se inserta en la pila como un puntero no administrado, en cuyo caso la dirección de retorno es también un puntero no administrado (tipo `native int`).  
  
 El `ldflda` instrucción puede ir precedida por uno o ambos de los <xref:System.Reflection.Emit.OpCodes.Unaligned> y <xref:System.Reflection.Emit.OpCodes.Volatile> prefijos.  
  
 <xref:System.InvalidOperationException> se produce si el objeto no está dentro del dominio de aplicación desde el que se tiene acceso. No se puede cargar la dirección de un campo que no está dentro del acceso a dominio de aplicación.  
  
 <xref:System.NullReferenceException> se produce si el objeto es null y el campo no es estático.  
  
 <xref:System.MissingFieldException> se produce si el campo especificado no se encuentra en los metadatos. Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldflda` opcode:  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación un puntero no administrado (de tipo <see langword="native int" />) al código nativo que implementa un método específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 06 &LT; `T` >|ldftn `method`|Inserta un puntero a un método al que hace referencia `method` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El puntero no administrado a un método específico se inserta en la pila.  
  
 El método específico (`method`) se puede llamar mediante el <xref:System.Reflection.Emit.OpCodes.Calli> instrucción si hace referencia a un método administrado (o un código auxiliar que realiza la transición de administrado a código no administrado).  
  
 El valor devuelto hace referencia a código nativo utilizando la convención de llamada de CLR. Puntero a este método no debe pasarse a código nativo no administrado como una rutina de devolución de llamada.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldftn` opcode:  
  
-   ILGenerator.Emit (código de operación, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="native int" /> como <see langword="native int" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Carga el `native int` valor dirección `addr` en la pila como un `native int`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.i` instrucción carga indirectamente un `native int` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `native int`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="int8" /> como <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|46|ldind.i1|Carga el `int8` valor dirección `addr` en la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila...  
  
 El `ldind.i1` instrucción carga indirectamente un `int8` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `int32`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="int16" /> como <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|48|ldind.i2|Carga el `int16` valor dirección `addr` en la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.i2` instrucción carga indirectamente un `int16` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `int32`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="int32" /> como <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Carga el `int32` valor dirección `addr` en la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.i4` instrucción carga indirectamente un `int32` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `int32`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="int64" /> como <see langword="int64" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|Carga el `int64` valor dirección `addr` en la pila como un `int64`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.i8` instrucción carga indirectamente un `int64` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `int64`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="float32" /> como tipo <see langword="F" /> (flotante) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|Carga el `float32` valor dirección `addr` en la pila como un tipo `F`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.r4` instrucción carga indirectamente un `float32` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un tipo `F`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="float64" /> como tipo <see langword="F" /> (flotante) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|Carga el `float64` valor dirección `addr` en la pila como un tipo `F`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.r8` instrucción carga indirectamente un `float64` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `float64`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente una referencia a objeto como tipo <see langword="O" /> (referencia a objeto) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Carga de la referencia de objeto en la dirección `addr` en la pila como un tipo `O`|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; la referencia al objeto situada en la dirección se captura.  
  
3.  La referencia obtenida se inserta en la pila.  
  
 El `ldind.ref` instrucción carga indirectamente la referencia de objeto de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como tipo `O`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="unsigned int8" /> como <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|47|ldind.U1|Carga el `unsigned int8` valor dirección `addr` en la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.u1` instrucción carga indirectamente un `unsigned int8` valor de la dirección especificada (de tipo`native int`, `&`, o *) en la pila como un `int32`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="unsigned int16" /> como <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|49|ldind.u2|Carga el `unsigned int16` valor dirección `addr` en la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.u2` instrucción carga indirectamente un `unsigned int16` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `int32`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga indirectamente un valor de tipo <see langword="unsigned int32" /> como <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|Carga el `unsigned int32` valor dirección `addr` en la pila como un `int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  La dirección se extrae de la pila; el valor situado en la dirección se captura.  
  
3.  El valor capturado se inserta en la pila.  
  
 El `ldind.u4` instrucción carga indirectamente un `unsigned int32` valor de la dirección especificada (de tipo `native int`, `&`, o *) en la pila como un `int32`.  
  
 Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.  
  
 Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación. Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.  
  
 Con el formato correcto Microsoft Intermediate Language (MSIL) garantiza que el `ldind` instrucciones se usan de manera coherente con el tipo de puntero.  
  
 La dirección inicialmente se inserta en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> puede producirse (consulte la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo). Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados. Para los tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino. No puede ejecutar el código que depende el orden de bytes en todas las plataformas.  
  
 <xref:System.NullReferenceException> se puede iniciar si se detecta una dirección no válida.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldind.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el número de elementos de una matriz unidimensional de base cero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|8E|ldlen|Inserta la longitud (de tipo `natural unsigned int`) de una matriz en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto a una matriz se inserta en la pila.  
  
2.  La referencia de la matriz se extrae de la pila y se calcula la longitud.  
  
3.  La longitud se inserta en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. La longitud se devuelve como un `natural unsigned int`.  
  
 <xref:System.NullReferenceException> se produce si la referencia de la matriz es una referencia nula.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldlen` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la variable local que se encuentra en un índice específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 0C &LT; `unsigned int16` >|ldloc `index`|Carga la variable local en el índice `index` en pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor de la variable local en el índice especificado se inserta en la pila.  
  
 El `ldloc` instrucción inserta el contenido del número de variable local en el índice pasado en la pila de evaluación, donde las variables locales están numeradas del 0 en adelante. Antes de entrar en el método solo si el indicador de que el método de inicialización es true, las variables locales se inicializan en 0. Existen 65.535 (2 ^ 16 - 1) variables locales posibles (0-65534). Índice 65.535 no es válido ya que probablemente en las implementaciones utilizará un entero de 2 bytes para realizar un seguimiento del índice del local, junto con el número total de variables locales de un método determinado. Si se hubiera realizado un índice de 65535 válido, requeriría un entero más amplio realizar un seguimiento del número de variables locales de este método.  
  
 El `ldloc.0`, `ldloc.1`, `ldloc.2`, y `ldloc.3` instrucciones proporcionan una codificación eficaz para tener acceso a las cuatro primeras variables locales.  
  
 El tipo del valor es igual que el tipo de la variable local, que se especifica en el encabezado del método. Ver variables locales de I. de partición que sea menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `ldloc` opcode:  
  
-   ILGenerator.Emit (código de operación, LocalBuilder)  
  
-   ILGenerator.Emit (código de operación, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la variable local que se encuentra en el índice 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|06|ldloc.0|Carga en la pila de evaluación la variable local que se encuentra en el índice 0.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor de la variable local en el índice 0 se inserta en la pila.  
  
 `ldloc.0` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, que permite el acceso a la variable local en el índice 0.  
  
 El tipo del valor es igual que el tipo de la variable local, que se especifica en el encabezado del método. Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la variable local que se encuentra en el índice 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|07|ldloc.1|Carga en la pila de evaluación la variable local que se encuentra en el índice 1.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor de la variable local en el índice 1 se inserta en la pila.  
  
 `ldloc.1` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, que permite el acceso a la variable local en el índice 1.  
  
 El tipo del valor es igual que el tipo de la variable local, que se especifica en el encabezado del método. Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la variable local que se encuentra en el índice 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|08|ldloc.2|Carga en la pila de evaluación la variable local que se encuentra en el índice 2.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor de la variable local en el índice 2 se inserta en la pila.  
  
 `ldloc.2` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, que permite el acceso a la variable local en el índice 2.  
  
 El tipo del valor es igual que el tipo de la variable local, que se especifica en el encabezado del método. Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la variable local que se encuentra en el índice 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|09|ldloc.3|Carga en la pila de evaluación la variable local que se encuentra en el índice 3.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor de la variable local en el índice 3 se inserta en la pila.  
  
 `ldloc.3` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, que permite el acceso a la variable local en el índice 3.  
  
 El tipo del valor es igual que el tipo de la variable local, que se especifica en el encabezado del método. Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la variable local que se encuentra en un índice específico (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Carga la variable local en el índice `index` en la pila de forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor de la variable local en el índice especificado se inserta en la pila.  
  
 El `ldloc.s` instrucción inserta el contenido del número de variable local en el índice pasado en la pila de evaluación, donde las variables locales están numeradas del 0 en adelante. Antes de entrar en el método si el indicador de que el método de inicialización es true, las variables locales se inicializan en 0. Existen 256 (2 ^ 8) variables locales posibles (0-255) en la forma abreviada, que es una codificación más eficaz que `ldloc`.  
  
 El tipo del valor es igual que el tipo de la variable local, que se especifica en el encabezado del método. Ver variables locales de I. de partición que sea menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila. Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `ldloc.s` opcode:  
  
-   ILGenerator.Emit (código de operación, LocalBuilder)  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la dirección de la variable local que se encuentra en un índice específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|OD FE &LT; `unsigned int16` >|ldloca `index`|Carga la dirección de la variable local en `index` en la pila de evaluación.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección almacenada en la variable local en el índice especificado se inserta en la pila.  
  
 El `ldloca` instrucción inserta la dirección del número de variable local en el índice pasado en la pila, donde las variables locales están numeradas del 0 en adelante. El valor insertado en la pila ya está alineado correctamente para su uso con instrucciones como <xref:System.Reflection.Emit.OpCodes.Ldind_I> y <xref:System.Reflection.Emit.OpCodes.Stind_I>. El resultado es un puntero transitorio (tipo `*`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldloca` opcode:  
  
-   ILGenerator.Emit (código de operación, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carga en la pila de evaluación la dirección de la variable local que se encuentra en un índice específico (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Carga la dirección de la variable local en `index` en la pila de evaluación, la forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección almacenada en la variable local en el índice especificado se inserta en la pila.  
  
 El `ldloca.s` instrucción inserta la dirección del número de variable local en el índice pasado en la pila, donde las variables locales están numeradas del 0 en adelante. El valor insertado en la pila ya está alineado correctamente para su uso con instrucciones como <xref:System.Reflection.Emit.OpCodes.Ldind_I> y <xref:System.Reflection.Emit.OpCodes.Stind_I>. El resultado es un puntero transitorio (tipo `*`).  
  
 El `ldloca.s` instrucción proporciona una codificación eficaz para su uso con las variables locales 0 y 255.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldloca.s` opcode:  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación una referencia nula (de tipo <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|14|ldnull|Inserta una referencia nula en la pila|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia a objeto nula se inserta en la pila.  
  
 `ldnull` Inserta una referencia null (tipo `O`) en la pila. Esto se usa para inicializar ubicaciones antes de que se rellenan con datos, o cuando han quedado obsoletas.  
  
 `ldnull` Proporciona una referencia nula que no depende del tamaño.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldnull` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia en la parte superior de la pila de evaluación el objeto de tipo de valor al que señala una dirección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Copia una instancia de tipo de valor `class` a la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección de un objeto de tipo de valor se inserta en la pila.  
  
2.  La dirección se extrae de la pila y se busca la instancia en esa dirección particular.  
  
3.  El valor del objeto almacenado en esa dirección se inserta en la pila.  
  
 El `ldobj` instrucción se utiliza para pasar un tipo de valor como un parámetro.  
  
 El `ldobj` instrucción copia el valor señalado por `addrOfValObj` (de tipo `&`, `*`, o `native int`) a la parte superior de la pila. El número de bytes copiados depende del tamaño de la clase (según lo especificado por el `class` parámetro). El `class` parámetro es un token de metadatos que representa el tipo de valor.  
  
 La operación de la `ldobj` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.TypeLoadException> se produce si no se encuentra la clase. Normalmente, esto se detecta cuando la instrucción de lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldobj` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el valor de un campo estático.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|7E &LT; `T` >|ldsfld `field`|Inserta el valor de `field` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor del campo específico se inserta en la pila.  
  
 El `ldsfld` instrucción inserta el valor estático (compartido entre todas las instancias de una clase) en la pila. El tipo de valor devuelto está asociado con el token de metadatos pasado `field`.  
  
 El `ldsfld` instrucción puede tener un <xref:System.Reflection.Emit.OpCodes.Volatile> prefijo.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldsfld` opcode:  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación la dirección de un campo estático.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|7F &LT; `T` >|ldsflda `field`|Inserta la dirección de `field` en la pila|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  La dirección de un campo específico se inserta en la pila.  
  
 El `ldsflda` instrucción inserta la dirección de un estático (compartido entre todas las instancias de una clase) en la pila. La dirección puede representarse como un puntero transitorio (tipo `*`) si el token de metadatos `field` hace referencia a un tipo cuya memoria se administra. En caso contrario, se corresponde con un puntero no administrado (tipo `native int`). Tenga en cuenta que `field` puede ser estático global con una dirección virtual relativa asignada (el desplazamiento del campo de la dirección base en el que el archivo PE contenedor se carga en memoria) en la memoria no está administrada.  
  
 El `ldsflda` instrucción puede tener un <xref:System.Reflection.Emit.OpCodes.Volatile> prefijo.  
  
 <xref:System.MissingFieldException> se produce si no se encuentra el campo en los metadatos. Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldsflda` opcode:  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta una nueva referencia de objeto a un literal de cadena almacenado en los metadatos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Inserta un objeto de cadena para el token de cadena de metadatos `mdToken`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una cadena se inserta en la pila.  
  
 El `ldstr` instrucción inserta una referencia de objeto (tipo `O`) a un nuevo objeto de cadena que representa el literal de cadena específico almacenado en los metadatos. El `ldstr` instrucción asigna la cantidad de memoria y realiza las conversiones de formato necesaria para convertir el literal de cadena desde el formulario utilizado en el archivo de formato de cadena necesario en tiempo de ejecución.  
  
 Common Language Infrastructure (CLI) garantiza que el resultado de dos `ldstr` instrucciones que hacen referencia a dos tokens de metadatos que tienen la misma secuencia de caracteres devuelven exactamente el mismo objeto de cadena (un proceso conocido como "interning").  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldstr` opcode:  
  
-   ILGenerator.Emit (código de operación, cadena)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte un símbolo (token) de metadatos en su representación en tiempo de ejecución y lo inserta en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D0 &LT; `T` >|ldtoken `token`|Convierte un token de metadatos en su representación en tiempo de ejecución.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El token pasado se convierte en un `RuntimeHandle` y se inserta en la pila.  
  
 El `ldtoken` instrucción inserciones un `RuntimeHandle` para el token de metadatos especificado. Un `RuntimeHandle` puede ser un `fieldref/fielddef`, un `methodref/methoddef`, o un `typeref/typedef`.  
  
 El valor insertado en la pila puede usarse en las llamadas a `Reflection` métodos en la biblioteca de clases del sistema.  
  
 Para obtener información sobre identificadores en tiempo de ejecución, consulte las siguientes clases: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, y <xref:System.RuntimeMethodHandle>.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `ldtoken` opcode:  
  
-   ILGenerator.Emit (código de operación, MethodInfo)  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación un puntero no administrado (de tipo <see langword="native int" />) al código nativo que implementa un método virtual concreto que está asociado al objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 07 &LT; `T` >|ldvirtftn `method`|Inserta el puntero al método virtual de un objeto `method` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto se inserta en la pila.  
  
2.  La referencia de objeto se extrae de la pila y la dirección del punto de entrada al método (tal y como especifica el token de metadatos `method`) se busca.  
  
3.  El puntero a `method` se inserta en la pila.  
  
 El puntero no administrado resultante se inserta en la pila por la `ldvirtftn` instrucción se puede llamar mediante el <xref:System.Reflection.Emit.OpCodes.Calli> instrucción si hace referencia a un método administrado (o un código auxiliar que realiza la transición de administrado a código no administrado).  
  
 Señala el puntero no administrado a código nativo utilizando la convención de llamada de CLR. Puntero a este método no debe pasarse a código nativo no administrado como una rutina de devolución de llamada.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ldvirtftn` opcode:  
  
-   ILGenerator.Emit (código de operación, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sale de una región de código protegida y transfiere el control incondicionalmente a una instrucción máquina de destino específica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|DD &LT; `int32` >|deje `target`|Sale de una región de código protegida.|  
  
 No hay ningún comportamiento de transición de pila especificado para esta instrucción.  
  
 El `leave` instrucción transfiere incondicionalmente el control a la instrucción máquina de destino específica, representada como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.  
  
 El `leave` instrucción es similar a la `br` instrucción, pero puede utilizarse para salir de un `try`, `filter`, o `catch` bloquear mientras que las instrucciones de bifurcación normales sólo se pueden utilizar en estos bloques para transferir el control dentro de él. El `leave` instrucción vacía la pila de evaluación y garantiza que el correspondiente que rodea `finally` bloques se ejecutan.  
  
 No puede usar un `leave` instrucciones para salir de un `finally` bloque. Para facilitar la generación de código para controladores de excepciones es válido desde dentro de un bloque catch para usar un `leave` instrucción para transferir el control a cualquier instrucción dentro asociado `try` bloque.  
  
 Si una instrucción tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `leave` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sale de una región de código protegida y transfiere el control incondicionalmente a una instrucción máquina de destino (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|DE &LT; `int8` >|leave.s `target`|Salir de una región protegida de código, la forma abreviada.|  
  
 No hay ningún comportamiento de transición de pila especificado para esta instrucción.  
  
 El `leave.s` instrucción transfiere incondicionalmente el control a la instrucción de destino pasados, representada como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.  
  
 El `leave.s` instrucción es similar a la `br` instrucción, pero puede utilizarse para salir de un `try`, `filter`, o `catch` bloquear mientras que las instrucciones de bifurcación normales sólo se pueden utilizar en estos bloques para transferir el control dentro de él. El `leave.s` instrucción vacía la pila de evaluación y garantiza que el correspondiente que rodea `finally` bloques se ejecutan.  
  
 No puede usar un `leave.s` instrucciones para salir de un `finally` bloque. Para facilitar la generación de código para controladores de excepciones es válido desde dentro de un bloque catch para usar un `leave.s` instrucción para transferir el control a cualquier instrucción dentro asociado `try` bloque.  
  
 Si una instrucción tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `leave.s` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Asigna un número determinado de bytes del bloque de memoria dinámica local e inserta la dirección (un puntero transitorio de tipo <see langword="*" />) del primer byte asignado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0F FE|localloc|Asignar espacio en el montón local.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El número de bytes que se asignen se inserta en la pila.  
  
2.  El número de bytes se extrae de la pila; se asigna una cantidad de memoria correspondientes al tamaño del montón local.  
  
3.  Un puntero al primer byte de la memoria asignada se inserta en la pila.  
  
 El `localloc` instrucción asigna `size` (tipo `natural unsigned int`) grupo de bytes a partir de la memoria dinámica local y devuelve la dirección (un puntero transitorio, el tipo `*`) del primer byte asignado. El bloque de memoria devuelto se inicializa en 0 sólo si el indicador de inicialización en el método es `true`. Cuando se ejecuta el método actual un <xref:System.Reflection.Emit.OpCodes.Ret>, el bloque de memoria local está disponible para su reutilización.  
  
 La dirección resultante se alinea de manera que cualquier tipo de datos primitivo se puede almacenar allí mediante el `stind` instrucciones (como <xref:System.Reflection.Emit.OpCodes.Stind_I4>) y se cargan mediante el `ldind` instrucciones (como <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 El `localloc` instrucción no puede aparecer dentro de un `filter`, `catch`, `finally`, o `fault` bloque.  
  
 <xref:System.StackOverflowException> se produce si hay suficiente memoria para atender la solicitud.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `localloc` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación una referencia con tipo a una instancia de un tipo específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|C6 &LT; `T` >|mkrefany `class`|Inserta una referencia con tipo del tipo `class` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un puntero al elemento de datos se inserta en la pila.  
  
2.  El puntero se extrae y se convierte en una referencia con tipo del tipo `class`.  
  
3.  La referencia con tipo se inserta en la pila.  
  
 El `mkrefany` instrucción permite pasar referencias con tipos dinámicos. El puntero debe ser de tipo `&`, `*`, o `native int`, mantenga la dirección válida de un fragmento de datos. `Class` es el token de la clase que describe el tipo de datos al que hace referencia el puntero. `Mkrefany` Inserta una referencia con tipo en la pila, que proporciona un descriptor opaco del puntero y el tipo `class`.  
  
 La operación solo es válida, puede realizar con una referencia con tipo es pasarla a un método que requiere una referencia con tipo como parámetro. El destinatario, a continuación, puede usar el <xref:System.Reflection.Emit.OpCodes.Refanytype> y <xref:System.Reflection.Emit.OpCodes.Refanyval> instrucciones para recuperar el tipo (clase) y la dirección, respectivamente.  
  
 <xref:System.TypeLoadException> se produce si `class` no se encuentra. Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `mkrefany` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dos valores e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|5A|mul|Multiplica dos valores de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se multiplica por `value2`.  
  
4.  El resultado se inserta en la pila.  
  
 El `mul` instrucción multiplica `value1` por `value2` e inserta el resultado en la pila. Operaciones con enteros truncan sin notificación los bits superiores en caso de desbordamiento.  
  
 Consulte <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> para un número entero específico multiplicar la operación con un control de desbordamiento.  
  
 Para los tipos de punto flotante, 0 * infinito = NaN.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `mul` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dos valores enteros, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Multiplica dos valores enteros en la pila con una comprobación de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se multiplica por `value2`, con una comprobación de desbordamiento.  
  
4.  El resultado se inserta en la pila.  
  
 El `mul.ovf` instrucción multiplica el entero `value1` por entero `value2` e inserta el resultado en la pila. Se produce una excepción si el resultado no se ajusta al tipo de resultado.  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `mul.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dos valores enteros sin signo, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Multiplica dos valores sin signo en la pila con una comprobación de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value1` se multiplica por `value2`, con una comprobación de desbordamiento.  
  
4.  El resultado se inserta en la pila.  
  
 El `mul.ovf.un` instrucción multiplica el entero sin signo `value1` por entero sin signo `value2` e inserta el resultado en la pila. Se produce una excepción si el resultado no se ajusta al tipo de resultado.  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `mul.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte un valor en negativo e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|65|neg|Niega el valor actualmente en la parte superior de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se inserta en la pila.  
  
2.  Un valor se extrae de la pila y negar.  
  
3.  El resultado se inserta en la pila.  
  
 El `neg` instrucción niega el valor e inserta el resultado de la parte superior de la pila. El tipo de valor devuelto es el mismo que el tipo de operando.  
  
 Estándar es la negación de valores enteros del complemento a dos negación. En concreto, negando el número más negativo (que no tiene equivalente positivo) da como resultado el número más negativo. Para detectar este desbordamiento, utilice la <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrucción en su lugar (es decir, restar de 0).  
  
 Al convertir en negativo un número de punto flotante no puede desbordarse y negando NaN devuelve NaN.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `neg` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación una referencia de objeto a una nueva matriz unidimensional de base cero cuyos elementos son de un tipo específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|8D &LT; `T` >|newarr `etype`|Crea una nueva matriz con elementos de tipo `etype`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El número de elementos de la matriz se inserta en la pila.  
  
2.  El número de elementos se extrae de la pila y se crea la matriz.  
  
3.  Una referencia de objeto a la nueva matriz se inserta en la pila.  
  
 El `newarr` instrucción inserta una referencia de objeto (tipo `O`) a una nueva matriz unidimensional de base cero cuyos elementos son de tipo `etype` (un token de metadatos que describe el tipo). El número de elementos de la nueva matriz se debe especificar como un `native int`. Intervalo de índices de matriz válida desde cero hasta el número máximo de elementos menos uno.  
  
 Los elementos de una matriz pueden ser cualquier tipo, incluidos los tipos de valor.  
  
 Matrices unidimensionales de base cero de números se crean mediante un token de metadatos que se hace referencia al tipo de valor apropiado (<xref:System.Int32>, y así sucesivamente). Elementos de la matriz se inicializan en 0 del tipo adecuado.  
  
 Para matrices unidimensionales y multidimensionales se crean mediante <xref:System.Reflection.Emit.OpCodes.Newobj> lugar `newarr`. Normalmente, se crean mediante los métodos de la <xref:System.Array> clase en .NET Framework.  
  
 <xref:System.OutOfMemoryException> se produce si no hay memoria suficiente para satisfacer la solicitud.  
  
 <xref:System.OverflowException> se produce si `numElems` es menor que 0.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `newarr` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Crea un nuevo objeto o una nueva instancia de un tipo de valor e inserta en la pila de evaluación una referencia a objeto (de tipo <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Asigna un tipo de valor u objeto no inicializado y llama al método constructor `ctor`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Argumentos `arg1` a través de `argn` se insertan en la pila en secuencia.  
  
2.  Argumentos `argn` a través de `arg1` se extraen de la pila y se pasan a `ctor` para la creación de objetos.  
  
3.  Una referencia al nuevo objeto se inserta en la pila.  
  
 El `newobj` instrucción crea un nuevo objeto o una nueva instancia de un tipo de valor. `Ctor` es un token de metadatos (una `methodref` o `methoddef` que debe estar marcada como un constructor) que indica el nombre, la clase y la firma del constructor para llamar a.  
  
 El `newobj` instrucción asigna una nueva instancia de la clase asociada `ctor` e inicializa todos los campos de la nueva instancia en 0 (del tipo correcto) o referencias nulas según corresponda. A continuación, llama al constructor `ctor` con los argumentos especificados, junto con la instancia recién creada. Después de haber llamado al constructor, ahora inicializa la referencia de objeto (tipo `O`) se inserta en la pila.  
  
 Desde el punto de vista del constructor, el objeto sin inicializar es el argumento 0 y los otros argumentos pasados a newobj siguen en orden.  
  
 Todas las matrices unidimensionales de base cero se crean mediante <xref:System.Reflection.Emit.OpCodes.Newarr>, no `newobj`. Por otro lado, todas las demás matrices (de más de una dimensión o unidimensionales no en cero) se crean mediante `newobj`.  
  
 Tipos de valor no suelen crearse utilizando `newobj`. Normalmente, se asignan como argumentos o variables locales, mediante `newarr` (para las matrices unidimensionales de base cero), o como campos de objetos. Una vez asignados, se inicializan mediante <xref:System.Reflection.Emit.OpCodes.Initobj>. Sin embargo, el `newobj` instrucción puede usarse para crear una nueva instancia de un tipo de valor en la pila, que puede pasarse como argumento, almacenado en una variable local y así sucesivamente.  
  
 <xref:System.OutOfMemoryException> se produce si no hay memoria suficiente para satisfacer la solicitud.  
  
 <xref:System.MissingMethodException> se produce si un método de constructor `ctor` con el nombre indicado, clase y la firma no se encontró. Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `newobj` opcode:  
  
-   ILGenerator.Emit (código de operación, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rellena el espacio si los códigos de operación se han modificado. No se realiza ninguna operación significativa, aunque puede consumirse un ciclo de procesamiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|00|nop|Realiza una operación sin comportamiento.|  
  
 No hay ningún comportamiento de transición de pila definido para esta instrucción.  
  
 El `nop` operación no hace nada. Se pretende rellenar espacio si se han modificado los códigos de operación.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `nop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula el complemento bit a bit del valor entero que se encuentra en la parte superior de la pila e inserta el resultado, del mismo tipo, en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|66|not|Calcula el complemento bit a bit de un valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value` se inserta en la pila.  
  
2.  `value` se extrae de la pila y su bit a bit calculado el complemento.  
  
3.  El resultado se inserta en la pila.  
  
 El `not` instrucción calcula el complemento bit a bit de un valor entero e inserta el resultado en la pila. El tipo de valor devuelto es el mismo que el tipo de operando.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `not` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula el complemento bit a bit de los dos valores enteros situados en la parte superior de la pila e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|60|o|Calcula bit a bit o de dos valores enteros, devuelve un entero.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila y la operación OR bit a bit calculado.  
  
4.  El resultado se inserta en la pila.  
  
 El `or` instrucción calcula la operación OR bit a bit de dos valores de la parte superior de la pila, e inserta el resultado en la pila.  
  
 `Or` es una operación específica de valores enteros.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `or` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quita el valor situado en la parte superior de la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|26|pop|Extrae el valor superior de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Se extrae el valor superior de la pila.  
  
 El `pop` instrucción quita el elemento superior de la pila.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `pop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esta es una instrucción reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que la operación de dirección de matriz subsiguiente no realiza ninguna comprobación de tipo en tiempo de ejecución y devuelve un puntero administrado cuya mutabilidad está restringida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1E FE|de solo lectura.|Especifique que la operación de dirección de matriz subsiguiente no realiza ninguna comprobación de tipo en tiempo de ejecución y que devuelve un puntero administrado cuya mutabilidad está restringida.|  
  
 Este prefijo solo puede aparecer inmediatamente anterior el `ldelema` instrucciones y las llamadas a especial `Address` método en las matrices. Su efecto en la operación subsiguiente es doble:  
  
1.  En tiempo de ejecución se realiza ninguna operación de comprobación de tipo. Tenga en cuenta que normalmente es una comprobación de tipo implícito para la `ldelema` y `stelem` instrucciones cuando se usa en la referencia de tipo de matrices. Nunca hay una comprobación de tipo en tiempo de ejecución para las clases de valor, por lo que `readonly` es una operación inefectiva en ese caso.  
  
2.  El comprobador trata el resultado de la operación de dirección como un puntero administrado cuya mutabilidad está restringida.  
  
 Se dice que el puntero ha restringido la mutabilidad porque el tipo que define controla si el valor puede transformarse. Para las clases de valor que no exponen ningún campo público o métodos que actualizan el valor en su lugar, el puntero es de solo lectura (por lo tanto, el nombre del prefijo). En concreto, las clases que representan los tipos primitivos (por ejemplo, System.Int32) no exponen mutadores y, por tanto, son de solo lectura.  
  
 Un puntero administrado restringido de este modo puede usarse solo en las siguientes maneras:  
  
-   Como el `object` parámetro para el `ldfld`, `ldflda`, `stfld`, `call`, o`constrained callvirt` instrucciones.  
  
-   Como el `pointer` parámetro para el `ldobj` instrucción o a uno de los `ldind` instrucciones.  
  
-   Como el `source` parámetro para el `cpobj` instrucción.  
  
 Todas las demás operaciones no permitidas, incluido el `stobj`, `initobj`, o `mkrefany` operaciones o cualquiera de los `stind` instrucciones.  
  
 El propósito de la `readonly` prefijo es evitar una comprobación de tipo al recuperar un elemento de una matriz en código genérico. Por ejemplo, la expresión `arr[i].m()`, donde el tipo de elemento de la matriz `arr` es un tipo genérico que se ha restringido a tener una interfaz con el método `m`, podría compilar en MSIL siguiente.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Sin el `readonly` prefijo, el `ldelema` instrucción realizaría una comprobación de tipo en el caso donde! 0 fue un tipo de referencia. No solo es ineficaz esta comprobación de tipo, pero es incorrecto semánticamente. La comprobación de tipos para `ldelema` es una coincidencia exacta, que es demasiado segura. Si la matriz contuviera subclases del tipo! 0, el código anterior se producirá un error en la comprobación de tipos.  
  
 La dirección del elemento de matriz se captura, en lugar del propio elemento, para tener un identificador para `arr[i]` que funciona para ambos tipos de valor y tipos de referencia y, por tanto, se puede pasar a la `constrained callvirt` instrucción.  
  
 En general no sería seguro para omitir la comprobación en tiempo de ejecución si la matriz contiene elementos de un tipo de referencia. Para estar seguros, es necesario asegurarse de que ninguna modificación en la matriz se realizan a través de este puntero. Las reglas del verificador aseguran de esto. El puntero administrado restringido se puede pasar como el objeto de llamadas al método de instancia, por lo que no resulta en el sentido estricto de solo lectura para los tipos de valor, pero no hay ningún problema de seguridad para los tipos de valor.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `readonly` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el símbolo (token) de tipo incrustado en una referencia con tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Inserta el token de tipo almacenado en una referencia con tipo.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de tipo de valor se inserta en la pila.  
  
2.  La referencia con tipo se extrae de la pila y recupera su token de tipo correspondiente.  
  
3.  El token de tipo se inserta en la pila.  
  
 Una referencia con tipo contiene un token de tipo y una dirección para una instancia de objeto.  
  
 El `refanytype` instrucción recupera el token de tipo incrustado en la referencia con tipo. Consulte la <xref:System.Reflection.Emit.OpCodes.Mkrefany> escrito de instrucción para obtener información sobre la creación de referencias.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `refanytype` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera la dirección (de tipo <see langword="&amp;" />) incrustada en una referencia con tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|C2 &LT; `T` >|refanyval `type`|Inserta la dirección almacenada en una referencia con tipo.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de tipo de valor se inserta en la pila.  
  
2.  La referencia con tipo se extrae de la pila y recupera la dirección correspondiente.  
  
3.  La dirección se inserta en la pila.  
  
 Una referencia con tipo contiene un token de tipo y una dirección para una instancia de objeto.  
  
 El `refanyval` instrucción recupera la dirección incrustada en la referencia con tipo. El tipo incrustado en la referencia con tipo suministrada en la pila debe coincidir con el tipo especificado por `type` (los metadatos de un token, ya sea un `typedef` o `typeref`). Consulte la <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrucción para obtener contenido relacionado.  
  
 <xref:System.InvalidCastException> se produce si `type` no es idéntico al tipo almacenado en la referencia de tipo (en este caso, `type` se proporciona la clase a la <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrucción máquina que creó dicha referencia con tipo).  
  
 <xref:System.TypeLoadException> se produce si `type` no se encuentra.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `refanyval` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dos valores e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|5D|REM|Inserta el resultado de dividir `value1` por `value2` en la pila.|  
  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila y el resto de `value1` `div` `value2` calculado.  
  
4.  El resultado se inserta en la pila.  
  
 `result` = `value1` `rem` `value2` cumple las condiciones siguientes:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), y:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, inicio de sesión (`result`) = el inicio de sesión (`value1`), donde `div` es la instrucción de división que trunca hacia cero.  
  
 Si `value2` es cero o `value1` es infinito, el resultado es NaN. Si `value2` es infinito, el resultado es `value1` (convertido en negativo para `-infinity`).  
  
 Las operaciones integrales inician <xref:System.DivideByZeroException> si `value2` es cero.  
  
 Tenga en cuenta que en las plataformas basadas en Intel en un <xref:System.OverflowException> se produce al calcular (minint `rem` -1).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `rem` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dos valores sin signo e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|5E|REM.un|Inserta el resultado de dividir sin signo `value1` por sin signo `value2` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila y el resto de `value1` `div` `value2` calculado.  
  
4.  El resultado se inserta en la pila.  
  
 `result` = `value1` `rem.un` `value2` cumple las condiciones siguientes:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), y:  
  
 0 = `result`  <  `value2`, donde `div.un` es la instrucción de división sin signo.  
  
 El `rem.un` instrucción calcula `result` y lo inserta en la pila. `Rem.un` trata sus argumentos como enteros sin signo, mientras que <xref:System.Reflection.Emit.OpCodes.Rem> los trata como enteros con signo.  
  
 `Rem.un` se ha especificado para números de punto flotante.  
  
 Las operaciones integrales inician <xref:System.DivideByZeroException> si `value2` es cero.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `rem.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Regresa del método actual e inserta un valor devuelto (si existe) desde la pila de evaluación del destinatario de la llamada en la pila de evaluación del llamador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|2A|RET|Regresa del método, posiblemente devolver un valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El valor devuelto se extrae de la pila de evaluación del destinatario.  
  
2.  El valor devuelto obtenido en el paso 1 se inserta en la pila de evaluación del llamador.  
  
 Si el valor devuelto no está presente en la pila de evaluación del destinatario, se devuelve ningún valor (no hay comportamientos de transición de pila para el llamador o destinatario de la llamada de método).  
  
 El tipo de valor devuelto, si los hay, del método actual determina el tipo de valor capturarse desde la parte superior de la pila y copiar en la pila del método que llamó al método actual. La pila de evaluación del método actual debe estar vacía excepto para el valor que se va a devolver.  
  
 El `ret` instrucción no se puede usar para transferir el control fuera de un`try`, `filter`, `catch`, o `finally` bloque. Desde un `try` o `catch`, utilice el <xref:System.Reflection.Emit.OpCodes.Leave> instrucción con un destino de una `ret` instrucción que se encuentra fuera de los bloques de excepción todos los contenedores. Dado que el `filter` y `finally` bloques lógicamente forman parte del control de excepciones y no el método en el que su código está incrustado, las instrucciones de lenguaje intermedio de Microsoft (MSIL) generado correctamente no lleva a cabo un método de devolución desde dentro de un `filter` o `finally`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `ret` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vuelve a producir la excepción actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|1A FE|Rethrow|Vuelve a producir la excepción actual|  
  
 No se define ningún comportamiento de transición de pila para esta instrucción.  
  
 El `rethrow` sólo se permite la instrucción dentro del cuerpo de un `catch` controlador. Produce la misma excepción que se ha capturado por este controlador.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `rethrow` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desplaza un valor entero a la izquierda (en ceros) el número de bits especificado e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|62|shl|Desplaza un entero a la izquierda (desplazamiento en ceros).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se inserta en la pila.  
  
2.  La cantidad de bits de desplazamiento se inserta en la pila.  
  
3.  El número de bits de desplazamiento y el valor se extraen de la pila; el valor se desplazan a la izquierda el número especificado de bits.  
  
4.  El resultado se inserta en la pila.  
  
 El `shl` instrucción desplaza el valor (tipo `int32`, `int64` o `native int`) a la izquierda el número especificado de bits. El número de bits es un valor de tipo `int32` o `native int`. El valor devuelto se especifica si el número de bits de desplazamiento es mayor o igual que el ancho (en bits) del valor proporcionado.  
  
 `Shl` Inserta un bit cero en la posición inferior en cada turno.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `shl` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desplaza un valor entero (en signo) a la derecha el número de bits especificado e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|63|shr|Desplaza un entero a la derecha (desplazamiento de inicio de sesión).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se inserta en la pila.  
  
2.  La cantidad de bits de desplazamiento se inserta en la pila.  
  
3.  El número de bits de desplazamiento y el valor se extraen de la pila; el valor se desplaza a la derecha el número especificado de bits.  
  
4.  El resultado se inserta en la pila.  
  
 El `shr.un` instrucción desplaza el valor (tipo `int32`, `int64` o `native int`) directamente por el número especificado de bits. El número de bits es un valor de tipo `int32` o `native int`. El valor devuelto se especifica si el número de bits de desplazamiento es mayor o igual que el ancho (en bits) del valor proporcionado.  
  
 `Shr` replica el orden superior bit en cada turno, conserva el signo del valor original en el `result`.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `shr` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desplaza un valor entero sin signo (en ceros) a la derecha el número de bits especificado e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|64|shr.un|Desplaza un entero a la derecha (desplazamiento en ceros).|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se inserta en la pila.  
  
2.  La cantidad de bits de desplazamiento se inserta en la pila.  
  
3.  El número de bits de desplazamiento y el valor se extraen de la pila; el valor se desplaza a la derecha el número especificado de bits.  
  
4.  El resultado se inserta en la pila.  
  
 El `shr.un` instrucción desplaza el valor (tipo `int32`, `int64` o `native int`) directamente por el número especificado de bits. El número de bits es un valor de tipo `int32`, `int64` o `native int`. El valor devuelto se especifica si el número de bits de desplazamiento es mayor o igual que el ancho (en bits) del valor proporcionado.  
  
 `Shr.un` Inserta un bit cero en la posición superior en cada turno.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `shr.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserta en la pila de evaluación el tamaño, en bytes, de un tipo de valor suministrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 1C &LT; `T` >|sizeof `valType`|Inserta el tamaño, en bytes, de un tipo de valor como un `unsigned int32`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  El tamaño (en bytes) del tipo de valor proporcionado (`valType`) se inserta en la pila.  
  
 `valType` debe ser un token de metadatos (una `typeref` o `typedef`) que especifica un tipo de valor, el tipo de referencia o el parámetro de tipo genérico.  
  
 Para un tipo de referencia, el tamaño devuelto es el tamaño de un valor de la correspondiente referencia escriba (4 bytes en sistemas de 32 bits), no el tamaño de los datos almacenados en objetos que hace referencia el valor de referencia. Un parámetro de tipo genérico puede usarse solo en el cuerpo del tipo o método que lo define. Cuando se crea una instancia de ese tipo o método, el parámetro de tipo genérico se reemplaza por un tipo de valor o referencia.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `sizeof` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena el valor que se encuentra en la parte superior de la pila de evaluación en la ranura de argumento de una posición de índice especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 0B &LT; `unsigned int16` >|starg `num`|Extrae el valor superior de la pila y lo almacena en la ranura de argumento `num`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Se extrae el valor actualmente en la parte superior de la pila y se coloca en la ranura de argumento `num`.  
  
 El `starg` instrucción extrae un valor de la pila y lo coloca en la ranura de argumento `num`. El tipo del valor debe coincidir con el tipo del argumento, como se especifica en la firma del método actual.  
  
 Para conocer los procedimientos que toman una lista de argumentos de variable, la `starg` instrucción puede usarse solo para los argumentos fijos iniciales, no los de la parte variable de la firma.  
  
 Realizar operaciones de almacenamiento en argumentos que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila para el argumento. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `starg` opcode:  
  
-   ILGenerator.Emit (código de operación, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena el valor que se encuentra en la parte superior de la pila de evaluación en la ranura de argumento de una posición de índice especificada (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|Extrae el valor superior de la pila y lo almacena en la ranura de argumento `num`, forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Se extrae el valor actualmente en la parte superior de la pila y se coloca en la ranura de argumento `num`.  
  
 El `starg.s` instrucción extrae un valor de la pila y lo coloca en la ranura de argumento `num`. El tipo del valor debe coincidir con el tipo del argumento, como se especifica en la firma del método actual.  
  
 El `starg.s` instrucción proporciona una codificación eficaz para su uso con los 256 primeros argumentos.  
  
 Para conocer los procedimientos que toman una lista de argumentos de variable, la `starg.s` instrucción puede usarse solo para los argumentos fijos iniciales, no los de la parte variable de la firma.  
  
 Realizar operaciones de almacenamiento en argumentos que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila para el argumento. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `starg.s` opcode:  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reemplaza el elemento de matriz que se encuentra en una posición de índice dada por el valor de la pila de evaluación cuyo tipo se especifica en la instrucción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|A4 &LT; `T` >|stelem `typeTok`|Reemplaza el elemento de matriz en el índice proporcionado por un valor de tipo `typeTok` en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un valor de índice `index`, a un elemento de `array` se inserta en la pila.  
  
3.  Un valor del tipo especificado en la instrucción se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem` instrucción sustituye el valor del elemento en el índice de base cero proporcionado en la matriz unidimensional `array` con el valor. El valor tiene el tipo especificado por el token `typeTok` en la instrucción.  
  
 Las matrices son objetos y, por lo tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="native int" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Reemplaza un elemento de matriz en el índice proporcionado con el `native int` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.i` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `native int` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int8" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Reemplaza un elemento de matriz en el índice proporcionado con el `int8` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.i1` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int8` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int16" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Reemplaza un elemento de matriz en el índice proporcionado con el `int16` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.i2` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int16` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Reemplaza un elemento de matriz en el índice proporcionado con el `int32` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.i4` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int32` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int64" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Reemplaza un elemento de matriz en el índice proporcionado con el `int64` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.i8` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int64` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="float32" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Reemplaza un elemento de matriz en el índice proporcionado con el `float32` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.r4` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `float32` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="float64" /> en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|Reemplaza un elemento de matriz en el índice proporcionado con el `float64` valor de la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.r8` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `float64` valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor de referencia a objeto (de tipo <see langword="O" />) en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Reemplaza un elemento de matriz en el índice proporcionado con el `ref` valor (tipo `O`) en la pila.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto en una matriz, `array`, se inserta en la pila.  
  
2.  Un índice válido para un elemento en `array` se inserta en la pila.  
  
3.  Un valor se inserta en la pila.  
  
4.  El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.  
  
 El `stelem.ref` instrucción sustituye el valor del elemento en el índice proporcionado en la matriz unidimensional `array` con el `ref` (tipo `O`) valor insertado en la pila.  
  
 Las matrices son objetos y, por tanto, representado por un valor de tipo `O`. El índice es de tipo `native int`.  
  
 Tenga en cuenta que `stelem.ref` convierte implícitamente el valor proporcionado para el tipo de elemento de `array` antes de asignarle el valor del elemento de matriz. Esta conversión puede producir un error, incluso para el código comprobado. Por lo tanto el `stelem.ref` instrucción puede producir <xref:System.InvalidCastException>. Para las matrices unidimensionales que no son de base cero y las matrices multidimensionales, la <xref:System.Array> clase proporciona un <xref:System.Array.SetValue%2A> método.  
  
 <xref:System.NullReferenceException> se produce si `array` es una referencia nula.  
  
 <xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.  
  
 <xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye por un valor nuevo el valor almacenado en el campo de una referencia a objeto o puntero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|7D &LT; `T` >|stfld `field`|Reemplaza el valor de `field` del objeto con un nuevo valor.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un puntero o referencia de objeto se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la referencia o puntero al objeto se extraen de la pila; el valor de `field` en el objeto se reemplaza por el valor proporcionado.  
  
 El `stfld` instrucción sustituye el valor de un campo de un objeto (tipo `O`) o a través de un puntero (tipo `native int`, `&`, o `*`) con un valor especificado. `Field` es un token de metadatos que hace referencia a una referencia de miembro de campo. El `stfld` instrucción puede tener un prefijo de uno o ambos <xref:System.Reflection.Emit.OpCodes.Unaligned> y <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> se produce si la referencia de objeto o el puntero es una referencia nula y el campo no es estático.  
  
 <xref:System.MissingFieldException> se produce si `field` no se encuentra en los metadatos. Normalmente, esto se comprueba cuando la instrucción de lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo, no en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stfld` opcode:  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="native int" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|DF|stind.i|Almacena un `native int` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.i` instrucción almacena un `native int` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.i` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.i` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="int8" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|52|stind.i1|Almacena un `int8` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.i1` instrucción almacena un `int8` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.i1` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.i1` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="int16" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|53|stind.i2|Almacena un `int16` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.i2` instrucción almacena un `int16` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.2i` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.i2` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="int32" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|54|stind.i4|Almacena un `int32` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.i4` instrucción almacena un `int32` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.i4` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.i4` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="int64" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|55|stind.i8|Almacena un `int64` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.i8` instrucción almacena un `int64` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.i8` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.i` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="float32" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|56|stind.r4|Almacena un `float32` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.r4` instrucción almacena un `float32` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.r4` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.r4` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de tipo <see langword="float64" /> en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|57|stind.r8|Almacena un `float64` valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.r8` instrucción almacena un `float64` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.r8` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.r8` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Almacena un valor de referencia a objeto en una dirección suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|51|stind.ref|Almacena una referencia de objeto (tipo `O`) valor en una dirección dada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un valor se inserta en la pila.  
  
3.  El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.  
  
 El `stind.ref` instrucción almacena un valor de referencia de objeto en la dirección suministrada (tipo `native int`, `*`, o `&`).  
  
 Tipo de operación segura requiere que el `stind.ref` instrucción se utilice de manera coherente con el tipo de puntero. La operación de la `stind.ref` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.NullReferenceException> se produce si `addr` no se encuentra alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|Extrae un valor de la pila y lo almacena en la variable local `index`.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se extrae de la pila y se coloca en la variable local `index`.  
  
 El `stloc` instrucción extrae el valor superior de la pila de evaluación y lo traslada a número de variable local `index`, donde las variables locales están numeradas del 0 en adelante. El tipo del valor debe coincidir con el tipo de la variable local que se especifica en la firma local del método actual.  
  
 Almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila a la variable local. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 Instrucciones de lenguaje intermedio de Microsoft (MSIL) correcto requieren que `index` sea un índice local válido. Para el `stloc` instrucciones, `index` debe encontrarse en el intervalo de 0 a 65534 inclusive (en concreto, 65535 no es válido). La razón de excluir 65535 es pragmática: probablemente en las implementaciones utilizará un entero de 2 bytes para realizar un seguimiento del índice de una variable local, así como el número total de variables locales de un método determinado. Si se hubiera realizado un índice de 65535 válido, requeriría un entero más amplio realizar un seguimiento del número de variables locales de este método.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `stloc` opcode:  
  
-   ILGenerator.Emit (código de operación, LocalBuilder)  
  
-   ILGenerator.Emit (código de operación, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Extrae un valor de la pila en la variable local 0.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se extrae de la pila y se coloca en la variable local indizada por 0.  
  
 El `stloc.0` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada por 0. El tipo del valor debe coincidir con el tipo de la variable local que se especifica en la firma local del método actual.  
  
 `stloc.0` es una codificación especialmente eficaz para almacenar valores en la variable local 0.  
  
 Almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila a la variable local. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Extrae un valor de la pila en la variable local 1.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se extrae la pila y se coloca en la variable local indizada en 1.  
  
 El `stloc.1` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada en 1. El tipo del valor debe coincidir con el tipo de la variable local que se especifica en la firma local del método actual.  
  
 `stloc.1` es una codificación especialmente eficaz para almacenar valores en la variable local 1.  
  
 Almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila a la variable local. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Extrae un valor de la pila en la variable local 2|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se extrae la pila y se coloca en la variable local indizada por 2.  
  
 El `stloc.2` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada por 2. El tipo del valor debe coincidir con el tipo de la variable local que se especifica en la firma local del método actual.  
  
 `stloc.2` es una codificación especialmente eficaz para almacenar valores en la variable local 2.  
  
 Almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila a la variable local. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Extrae un valor de la pila en la variable local 3|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se extrae la pila y se coloca en la variable local indizada por 3.  
  
 El `stloc.3` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada por 3. El tipo del valor debe coincidir con el tipo de la variable local que se especifica en la firma local del método actual.  
  
 `stloc.3` es una codificación especialmente eficaz para almacenar valores en la variable local 3.  
  
 Almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila a la variable local. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en <paramref name="index" /> (forma corta).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Extrae un valor de la pila y lo almacena en la variable local `index`, forma abreviada.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se extrae de la pila y se coloca en la variable local `index`.  
  
 El `stloc.s` instrucción extrae el valor superior de la pila de evaluación y lo traslada a número de variable local `index`, donde las variables locales están numeradas del 0 en adelante. El tipo del valor debe coincidir con el tipo de la variable local que se especifica en la firma local del método actual.  
  
 El `stloc.s` instrucción proporciona una codificación eficaz para las variables locales del 0 al 255.  
  
 Almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes, trunca el valor cuando se desplaza de la pila a la variable local. Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) para el tamaño asociado al argumento.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `stloc.s` opcode:  
  
-   ILGenerator.Emit (código de operación, LocalBuilder)  
  
-   ILGenerator.Emit (código de operación, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia un valor del tipo especificado de la pila de evaluación y lo coloca en una dirección de memoria suministrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Almacena un valor de tipo `class` de la pila en la memoria.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
2.  Un objeto de tipo de valor de tipo `class` se inserta en la pila.  
  
3.  El objeto y la dirección se extraen de la pila; el objeto de tipo de valor se almacena en la dirección.  
  
 El `stobj` instrucción copia el objeto de tipo de valor en la dirección especificada por la dirección (un puntero de tipo `native int`, `*`, o `&`). El número de bytes copiados depende del tamaño de la clase representada por `class`, un token de metadatos que representa un tipo de valor.  
  
 La operación de la `stobj` instrucción puede ser modificada por una inmediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.  
  
 <xref:System.TypeLoadException> se produce si no se encuentra la clase. Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stobj` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sustituye el valor de un campo estático por un valor de la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Reemplaza el valor en `field` con un valor suministrado.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se inserta en la pila.  
  
2.  Un valor se extrae de la pila y se almacena en `field`.  
  
 El `stsfld` instrucción sustituye el valor de un campo estático con un valor de la pila. `field` es un token de metadatos que debe hacer referencia a un miembro de campo estático.  
  
 El `stsfld` instrucción puede ir precedida por <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> se produce si no se encuentra el campo en los metadatos. Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `stsfld` opcode:  
  
-   ILGenerator.Emit (código de operación, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resta un valor de otro e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|59|sub|Resta un valor de otro y devuelve un nuevo valor numérico.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value2` se resta de `value1`.  
  
4.  El resultado se inserta en la pila.  
  
 No se detecta el desbordamiento para operaciones con enteros (para controlar el desbordamiento adecuado, vea <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Resta de enteros se ajusta, en lugar de saturarse. Por ejemplo: suponiendo que los enteros de 8 bits, donde `value1` se establece en 0 y `value2` se establece en 1, el resultado de "encapsulado" es 255.  
  
 Desbordamiento de punto flotante devuelve `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `sub` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resta un valor entero de otro, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|ACELERADOR DE DESARROLLO|Sub.ovf|Resta un valor entero de otro con una comprobación de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value2` se resta de `value1` con una comprobación de desbordamiento.  
  
4.  El resultado se inserta en la pila.  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 Esta operación se realiza en enteros con signo; para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `sub.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resta un valor entero sin signo de otro, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|DB|Sub.ovf.un|Resta un valor de entero sin signo de otro con una comprobación de desbordamiento.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila; `value2` se resta de `value1` con una comprobación de desbordamiento.  
  
4.  El resultado se inserta en la pila.  
  
 <xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.  
  
 Esta operación se realiza en enteros con signo; para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `sub.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementa una tabla de saltos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >... < `int32` >|cambiar (`N`, `t1`, `t2`... `tN`)|Salta a uno de `N` valores.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Un valor se inserta en la pila.  
  
2.  El valor se extrae de la pila y la ejecución se transfiere a la instrucción en el desplazamiento indizado por el valor, donde el valor es menor que `N`.  
  
 El `switch` instrucción implementa una tabla de saltos. El formato de la instrucción es un `unsigned int32` que representa el número de destinos `N`, seguido de `N` saltar de valores int32 que especifican los destinos. Estos destinos se representan como desplazamientos (positivos o negativos) desde el principio de la instrucción que sigue este `switch` instrucción.  
  
 El `switch` instrucción extrae un valor de la pila y lo compara, como entero sin signo a `N`. Si el valor es menor que `N`, la ejecución se transfiere al destino indizado por valor, donde los destinos se numeran de 0 (por ejemplo, un valor de 0 toma el primer destino, un valor de 1 toma el segundo destino y así sucesivamente). Si el valor es mayor o igual que `N`, la ejecución continúa en la instrucción siguiente (paso explícito).  
  
 Si la instrucción de destino tiene uno o más códigos de prefijo, control sólo se transfiere al primero de estos prefijos.  
  
 Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción. (Estas transferencias están muy limitadas y deben usar la instrucción leave en su lugar).  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `switch` opcode. El `Label[]` argumento es una matriz de etiquetas que representan desplazamientos de 32 bits.  
  
-   ILGenerator.Emit (código de operación, Label[])  
  
   
  
## Examples  
 Ejemplo de código siguiente muestra el uso de la `Switch` opcode para generar una tabla de saltos mediante una matriz de <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ejecuta una instrucción máquina de llamada a método postfija de tal modo que el marco de pila del método actual se quita antes de que se ejecute la verdadera instrucción máquina de llamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 14|tail.|Finaliza la llamada subsiguiente métodos actuales|  
  
 No hay ningún comportamiento de transición de pila definido para esta instrucción.  
  
 El `tail` instrucción de prefijo debe preceder inmediatamente un <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, o <xref:System.Reflection.Emit.OpCodes.Callvirt> instrucción. Indica que el marco de pila del método actual se debe quitar antes de ejecuta la instrucción de llamada. También implica que el valor devuelto de la llamada siguiente también es el valor devuelto por el método actual y, por lo tanto, la llamada puede convertirse en un salto entre métodos.  
  
 La pila debe estar vacía excepto para los argumentos que se transfieren por la llamada siguiente. La instrucción que sigue a la instrucción de llamada debe ser ret. Por lo tanto es la secuencia de código solo es válido `tail. call` (o `calli` o `callvirt`). Instrucciones de lenguaje intermedio de Microsoft (MSIL) correcta no deben crear una rama a la `call` instrucción, pero se puede bifurcar a la subsiguiente <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 El marco actual no puede descartarse cuando el control se transfiere desde el código de confianza al código de confianza, ya que esto podría poner en peligro la seguridad de identidad del código. Comprobaciones de seguridad de .NET Framework, por tanto, pueden hacer los `tail` va a omitir, dejando un estándar <xref:System.Reflection.Emit.OpCodes.Call> instrucción. De forma similar, para poder permitir la salida de una región sincronizada una vez devuelta la llamada, el `tail` prefijo se omite cuando se utiliza para salir de un método que está marcada como sincronizado.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `tail` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Instancia de un objeto código de operación.</param>
        <summary>Devuelve true o false si el código de operación suministrado utiliza un argumento de un solo byte.</summary>
        <returns><see langword="True" /> o <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para buscar qué códigos de operación MSIL son "short", para su uso en código optimizado.  
  
 `TakesSingleByteArgument` Devuelve `true` si el <xref:System.Reflection.Emit.OpCode> instancia toma un argumento de un solo byte en los casos siguientes:  
  
-   El código de operación realiza una instrucción de bifurcación para una dirección de un tamaño de bytes (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Br_S> y <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   El código de operación inserta un valor de byte en la pila (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   El código de operación hace referencia a una variable o argumento a través de un tamaño de bytes "corto" (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> y <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 De lo contrario, devuelve `false`.  
  
 El ejemplo siguiente muestra el uso de `TakesSingleByteArgument` reflejando en el `OpCodes` clase y las pruebas para ver si cada `OpCode` campo toma un argumento de un byte.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Produce el objeto de excepción que se encuentra actualmente en la pila de evaluación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|7A|throw|Inicia una excepción.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto (una excepción) se inserta en la pila.  
  
2.  La referencia de objeto se extrae de la pila y la excepción producida.  
  
 El `throw` instrucción inicia el objeto de excepción (tipo `O`) actualmente en la pila.  
  
 <xref:System.NullReferenceException> se produce si la referencia de objeto es una referencia nula.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `throw` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que una dirección que se encuentra actualmente en la parte superior de la pila de evaluación puede no estar alineada con el tamaño natural de la instrucción máquina <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> o <see langword="cpblk" /> inmediatamente posterior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|sin alinear. `alignment`|Indica que se puede desalinear la siguiente instrucción de puntero.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
 `Unaligned` Especifica que la dirección (un puntero no administrado, `native int`) en la pila puede no estar alineada con el tamaño natural del siguiente inmediatamente `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` instrucción. Es decir, para un <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instrucción la alineación de la dirección no puede ser un límite de 4 bytes. Para `initblk` y `cpblk` la alineación predeterminada es dependiente de la arquitectura (4 bytes en CPU de 32 bits, 8 bytes en las CPU de 64 bits). Deben usar generadores de código que no se limitan sus resultados a un tamaño de palabra de 32 bits `unaligned` si en tiempo de compilación no se sabe que la alineación es de 8 bytes.  
  
 El valor de alineación debe ser 1, 2 o 4 y significa que el código generado debe asumir que la dirección es de byte, doble byte, o cuatro bytes alinean, respectivamente. Tenga en cuenta que transitorio punteros (tipo `*`) siempre están alineados.  
  
 Mientras que la alineación de un `cpblk` instrucción lógicamente requeriría dos números (uno para el origen) y otro para el destino, no hay ningún impacto perceptible en el rendimiento si sólo se especifica el número más bajo.  
  
 El `unaligned` y `volatile` se pueden combinar en cualquier orden. Debe preceder inmediatamente a un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` instrucción. Solo el <xref:System.Reflection.Emit.OpCodes.Volatile> se permiten prefijos para los <xref:System.Reflection.Emit.OpCodes.Ldsfld> y <xref:System.Reflection.Emit.OpCodes.Stsfld> instrucciones.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar el `unaligned` opcode:  
  
-   ILGenerator.Emit (código de operación, etiqueta)  
  
-   ILGenerator.Emit (código de operación, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte la representación de un tipo de valor al que se le ha aplicado la conversión boxing en la forma que tendría al aplicarle la conversión unboxing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|79 < `T` >|aplicar la conversión unboxing `valType`|Extrae los datos de tipo de valor de `obj`, su representación en forma de caja.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto se inserta en la pila.  
  
2.  La referencia de objeto se extrae de la pila y se aplica la conversión unboxing a un puntero de tipo de valor.  
  
3.  El puntero de tipo de valor se inserta en la pila.  
  
 Un tipo de valor tiene dos representaciones distintas dentro de Common Language Infrastructure (CLI):  
  
-   Una forma "sin procesar" que se utiliza cuando un tipo de valor se incrusta dentro de otro objeto.  
  
-   Una forma de 'conversión boxing', donde los datos en el tipo de valor se empaquetan (boxed) en un objeto de modo que puede existir como una entidad independiente.  
  
 El `unbox` instrucción convierte la referencia de objeto (tipo `O`), la conversión boxing de representación de un tipo de valor a un puntero de tipo de valor (un puntero administrado, tipo `&`), sus aplicar conversión unboxing al formulario. El tipo de valor suministrado (`valType`) es un token de metadatos que indica el tipo de valor contenido dentro del objeto sometido a conversión boxing.  
  
 A diferencia de <xref:System.Reflection.Emit.OpCodes.Box>, que es necesario para realizar una copia de un tipo de valor para su uso en el objeto, `unbox` no es necesario para copiar el tipo de valor del objeto. Normalmente, sólo calcula la dirección del tipo de valor que ya se encuentra dentro del objeto sometido a conversión boxing.  
  
 <xref:System.InvalidCastException> se produce si el objeto no está empaquetado como `valType`.  
  
 <xref:System.NullReferenceException> se produce si la referencia de objeto es una referencia nula.  
  
 <xref:System.TypeLoadException> se produce si el valor de tipo `valType` no se encuentra. Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, en lugar de en tiempo de ejecución.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `unbox` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Convierte la representación a la que se aplica la conversión boxing de un tipo especificada en la instrucción a su forma de conversión unboxing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|A5 &LT; `T` >|unbox.Any `typeTok`|Extraiga los datos `obj`, su representación en forma de caja.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una referencia de objeto `obj` se inserta en la pila.  
  
2.  La referencia de objeto se extrae de la pila o la conversión unboxing al tipo especificado en la instrucción.  
  
3.  El tipo de valor o referencia de objeto resultante se inserta en la pila.  
  
 Cuando se aplica a la forma de conversión boxing de un tipo de valor, el `unbox.any` instrucción extrae el valor contenido dentro de `obj` (de tipo `O`) y, por tanto, es equivalente a `unbox` seguido `ldobj`.  
  
 Cuando se aplica a un tipo de referencia, el `unbox.any` instrucción tiene el mismo efecto que `castclass` `typeTok`.  
  
 Si el operando `typeTok` es un parámetro de tipo genérico, a continuación, el comportamiento en tiempo de ejecución está determinado por el tipo especificado para ese parámetro de tipo genérico.  
  
 <xref:System.InvalidCastException> se produce si `obj` no es un tipo de conversión boxing.  
  
 <xref:System.NullReferenceException> se produce si `obj` es una referencia nula.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `unbox.any` opcode:  
  
-   ILGenerator.Emit (código de operación, tipo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que una dirección que se encuentra actualmente en la parte superior de la pila de evaluación puede ser volátil y los resultados de leer esa ubicación no se pueden almacenar en la caché o no se pueden suprimir múltiples almacenamientos en esa ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Indica que la siguiente referencia de puntero es volátil.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  Una dirección se inserta en la pila.  
  
 `volatile`. Especifica que la dirección es una dirección volátil (es decir, se puede hacer referencia a externamente para el subproceso actual de ejecución) y los resultados de la lectura que no puede almacenarse en caché de ubicación o que no se pueden suprimir múltiples almacenamientos en esa ubicación. Marcar un acceso como `volatile` afecta a sólo ese acceso; los demás accesos a la misma ubicación deben marcarse por separado. Acceso a ubicaciones volátiles no es necesario realizar atómicamente.  
  
 El <xref:System.Reflection.Emit.OpCodes.Unaligned> y `volatile` se pueden combinar en cualquier orden. Debe preceder inmediatamente a un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` instrucción. Solo el `volatile` se permiten prefijos para los <xref:System.Reflection.Emit.OpCodes.Ldsfld> y <xref:System.Reflection.Emit.OpCodes.Stsfld> instrucciones.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `volatile` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula la operación XOR bit a bit de los dos valores superiores de la pila de evaluación e inserta el resultado en la pila.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:  
  
|Formato|Formato de ensamblado.|Descripción|  
|------------|---------------------|-----------------|  
|61|xor|Calcula la operación XOR bit a bit de dos valores enteros y devuelve un entero.|  
  
 El comportamiento de transición de pila, en orden secuencial, es:  
  
1.  `value1` se inserta en la pila.  
  
2.  `value2` se inserta en la pila.  
  
3.  `value2` y `value1` se extraen de la pila y su bit a bit XOR calculada.  
  
4.  La operación XOR bit a bit de `value2` y `value1` se inserta en la pila.  
  
 El `xor` instrucción calcula la operación XOR bit a bit de los dos primeros valores de la pila y deja el resultado en la pila.  
  
 `Xor` es una operación específica de valores enteros.  
  
 La siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `xor` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
