<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a136bc8fb48fe619f1be21928afbfcd9094d7463" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="e8764-101">Proporciona representaciones de campo de las instrucciones del Lenguaje intermedio de Microsoft (MSIL) para su emisión por parte de los miembros de la clase <see cref="T:System.Reflection.Emit.ILGenerator" /> (como <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span>
      <span class="sxs-lookup">
        <span data-stu-id="e8764-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-102">Para obtener una descripción detallada de los códigos de operación de miembro, vea la documentación de Common Language Infrastructure (CLI), especialmente "Partition III: CIL Instruction Set" y "Partición II: definición y semántica de los metadatos".</span><span class="sxs-lookup"><span data-stu-id="e8764-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="e8764-103">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="e8764-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8764-104">En el ejemplo siguiente se muestra la construcción de un método dinámico utilizando <xref:System.Reflection.Emit.ILGenerator> para emitir `OpCodes` en un <xref:System.Reflection.Emit.MethodBuilder>.</span><span class="sxs-lookup"><span data-stu-id="e8764-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-105">Suma dos valores e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-105">Adds two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-106">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-107">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-107">Format</span></span>|<span data-ttu-id="e8764-108">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-108">Assembly Format</span></span>|<span data-ttu-id="e8764-109">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-110">58</span><span class="sxs-lookup"><span data-stu-id="e8764-110">58</span></span>|<span data-ttu-id="e8764-111">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-111">add</span></span>|<span data-ttu-id="e8764-112">Agrega dos valores numéricos, devuelve un nuevo valor numérico.</span><span class="sxs-lookup"><span data-stu-id="e8764-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="e8764-113">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-114">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-115">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-116">`value2` y `value1` se extrae de la pila; `value1` se agrega a `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-117">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-118">No se detecta el desbordamiento para operaciones con enteros (para el control de desbordamiento adecuado, vea <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="e8764-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="e8764-119">Adición de números enteros se ajusta, en lugar de satura.</span><span class="sxs-lookup"><span data-stu-id="e8764-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="e8764-120">Por ejemplo, si suponemos enteros de 8 bits donde `value1` se establece en 255 y `value2` se establece en 1, el resultado ajustado sería 0 en lugar de 256.</span><span class="sxs-lookup"><span data-stu-id="e8764-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="e8764-121">Desbordamiento de punto flotante devuelve `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="e8764-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="e8764-122">En la tabla siguiente se enumeran los tipos de operandos aceptables y el tipo de datos del resultado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="e8764-123">Si no hay ninguna entrada para una combinación de tipos concreta (por ejemplo, `int32` y `float`; `int32` y `int64`), es un válido lenguaje intermedio de Microsoft (MSIL) y se genera un error.</span><span class="sxs-lookup"><span data-stu-id="e8764-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="e8764-124">operando</span><span class="sxs-lookup"><span data-stu-id="e8764-124">operand</span></span>|<span data-ttu-id="e8764-125">tipo de value1</span><span class="sxs-lookup"><span data-stu-id="e8764-125">value1 type</span></span>|<span data-ttu-id="e8764-126">tipo de value2</span><span class="sxs-lookup"><span data-stu-id="e8764-126">value2 type</span></span>|<span data-ttu-id="e8764-127">tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="e8764-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="e8764-128">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="e8764-129">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="e8764-130">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="e8764-131">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="e8764-132">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="e8764-133">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="e8764-134">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="e8764-135">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="e8764-136">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="e8764-137">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="e8764-138">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="e8764-139">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="e8764-140">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="e8764-141">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="e8764-142">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `add` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-144">Suma dos enteros, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-145">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-146">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-146">Format</span></span>|<span data-ttu-id="e8764-147">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-147">Assembly Format</span></span>|<span data-ttu-id="e8764-148">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-149">D6</span><span class="sxs-lookup"><span data-stu-id="e8764-149">D6</span></span>|<span data-ttu-id="e8764-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="e8764-150">add.ovf</span></span>|<span data-ttu-id="e8764-151">Agrega dos valores enteros con signo con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="e8764-152">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-153">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-154">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-155">`value2` y `value1` se extrae de la pila; `value1` se agrega a `value2` con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="e8764-156">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-157"><xref:System.OverflowException> se produce si el resultado no está representado en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-158">Puede realizar esta operación en enteros con signo.</span><span class="sxs-lookup"><span data-stu-id="e8764-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="e8764-159">Para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="e8764-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="e8764-160">En la tabla siguiente se enumeran los tipos de operandos aceptables y el tipo de datos del resultado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="e8764-161">Si no hay ninguna entrada para una combinación de tipos concreta (por ejemplo, `int32` y `float`; `int32` y `int64`), es una instrucción de lenguaje intermedio de Microsoft (MSIL) válida y se genera un error.</span><span class="sxs-lookup"><span data-stu-id="e8764-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="e8764-162">operando</span><span class="sxs-lookup"><span data-stu-id="e8764-162">operand</span></span>|<span data-ttu-id="e8764-163">tipo de value1</span><span class="sxs-lookup"><span data-stu-id="e8764-163">value1 type</span></span>|<span data-ttu-id="e8764-164">tipo de value2</span><span class="sxs-lookup"><span data-stu-id="e8764-164">value2 type</span></span>|<span data-ttu-id="e8764-165">tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="e8764-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="e8764-166">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="e8764-167">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="e8764-168">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="e8764-169">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="e8764-170">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="e8764-171">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="e8764-172">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="e8764-173">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="e8764-174">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="e8764-175">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="e8764-176">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="e8764-177">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="e8764-178">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="e8764-179">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="e8764-180">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `add.ovf` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-182">Suma dos valores enteros sin signo, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-183">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-184">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-184">Format</span></span>|<span data-ttu-id="e8764-185">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-185">Assembly Format</span></span>|<span data-ttu-id="e8764-186">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-187">D7</span><span class="sxs-lookup"><span data-stu-id="e8764-187">D7</span></span>|<span data-ttu-id="e8764-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="e8764-188">add.ovf.un</span></span>|<span data-ttu-id="e8764-189">Agrega dos valores enteros sin signo con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="e8764-190">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-191">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-192">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-193">`value2` y `value1` se extrae de la pila; `value1` se agrega a `value2` con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="e8764-194">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-195"><xref:System.OverflowException> se produce si el resultado no está representado en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-196">Puede realizar esta operación en enteros con signo.</span><span class="sxs-lookup"><span data-stu-id="e8764-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="e8764-197">Para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="e8764-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="e8764-198">En la tabla siguiente se enumeran los tipos de operandos aceptables y el tipo de datos del resultado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="e8764-199">Si no hay ninguna entrada para una combinación de tipos concreta (por ejemplo, `int32` y `float`; `int32` y `int64`), es una instrucción de lenguaje intermedio de Microsoft (MSIL) válida y se genera un error.</span><span class="sxs-lookup"><span data-stu-id="e8764-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="e8764-200">operando</span><span class="sxs-lookup"><span data-stu-id="e8764-200">operand</span></span>|<span data-ttu-id="e8764-201">tipo de value1</span><span class="sxs-lookup"><span data-stu-id="e8764-201">value1 type</span></span>|<span data-ttu-id="e8764-202">tipo de value2</span><span class="sxs-lookup"><span data-stu-id="e8764-202">value2 type</span></span>|<span data-ttu-id="e8764-203">tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="e8764-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="e8764-204">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="e8764-205">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="e8764-206">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="e8764-207">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="e8764-208">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="e8764-209">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="e8764-210">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="e8764-211">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="e8764-212">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="e8764-213">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="e8764-214">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="e8764-215">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="e8764-216">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="e8764-217">agregar</span><span class="sxs-lookup"><span data-stu-id="e8764-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="e8764-218">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `add.ovf.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-220">Calcula la operación AND bit a bit de dos valores e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-221">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-222">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-222">Format</span></span>|<span data-ttu-id="e8764-223">Instrucción</span><span class="sxs-lookup"><span data-stu-id="e8764-223">Instruction</span></span>|<span data-ttu-id="e8764-224">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="e8764-225">5F</span><span class="sxs-lookup"><span data-stu-id="e8764-225">5F</span></span>|<span data-ttu-id="e8764-226">y</span><span class="sxs-lookup"><span data-stu-id="e8764-226">and</span></span>|<span data-ttu-id="e8764-227">Determina la operación AND bit a bit de dos valores enteros.</span><span class="sxs-lookup"><span data-stu-id="e8764-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="e8764-228">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-229">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-230">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-231">`value1` y `value2` se extrae de la pila; se calcula la operación AND bit a bit de los dos valores.</span><span class="sxs-lookup"><span data-stu-id="e8764-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="e8764-232">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-233">El `and` instrucción calcula la operación AND bit a bit de los dos valores superiores de la pila y deja el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="e8764-234">`And` es una operación específica de valores enteros.</span><span class="sxs-lookup"><span data-stu-id="e8764-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="e8764-235">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `and` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-237">Devuelve un puntero no administrado a la lista de argumentos del método actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-237">Returns an unmanaged pointer to the argument list of the current method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-238">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-239">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-239">Format</span></span>|<span data-ttu-id="e8764-240">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-240">Assembly Format</span></span>|<span data-ttu-id="e8764-241">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="e8764-242">FE 00</span></span>|<span data-ttu-id="e8764-243">arglist</span><span class="sxs-lookup"><span data-stu-id="e8764-243">arglist</span></span>|<span data-ttu-id="e8764-244">Devuelve un identificador de la lista de argumentos del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="e8764-245">Esta operación no se realizan ningún comportamientos de la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="e8764-246">El `arglist` instrucción devuelve un identificador opaco (un puntero no administrado, de tipo `native int`) que representa la lista de argumentos del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="e8764-247">Este identificador es válido solo durante la duración del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="e8764-248">Sin embargo, puede pasar el identificador a otros métodos como el método actual se encuentra en el subproceso de control.</span><span class="sxs-lookup"><span data-stu-id="e8764-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="e8764-249">Sólo se puede ejecutar el `arglist` instrucción dentro de un método que toma un número variable de argumentos.</span><span class="sxs-lookup"><span data-stu-id="e8764-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="e8764-250">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `arglist` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-252">Transfiere el control a una instrucción máquina de destino si dos valores son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-252">Transfers control to a target instruction if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-253">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-254">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-254">Format</span></span>|<span data-ttu-id="e8764-255">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-255">Assembly Format</span></span>|<span data-ttu-id="e8764-256">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-257">3B < `int32` ></span></span>|<span data-ttu-id="e8764-258">beq `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-258">beq `target`</span></span>|<span data-ttu-id="e8764-259">Bifurcación para la instrucción máquina de destino en el desplazamiento `target` si los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="e8764-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="e8764-260">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-261">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-262">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-263">`value2` y `value1` se extraen de la pila; si `value1` es igual a `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-264">El `beq` instrucción transfiere el control a la instrucción de destino especificada si `value1` es igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="e8764-265">El efecto es el mismo que realizar una `ceq` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-266">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-267">Los tipos de operandos aceptables se encapsulan a continuación:</span><span class="sxs-lookup"><span data-stu-id="e8764-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="e8764-268">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="e8764-269">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción (dichas transferencias están muy limitadas y debe utilizar el <xref:System.Reflection.Emit.OpCodes.Leave> instrucción en su lugar).</span><span class="sxs-lookup"><span data-stu-id="e8764-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="e8764-270">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `beq` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-271">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-272">Transfiere el control a una instrucción máquina de destino (forma corta) si dos valores son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-272">Transfers control to a target instruction (short form) if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-273">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-274">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-274">Format</span></span>|<span data-ttu-id="e8764-275">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-275">Assembly Format</span></span>|<span data-ttu-id="e8764-276">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-277">2E < `int8` ></span></span>|<span data-ttu-id="e8764-278">beq.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-278">beq.s `target`</span></span>|<span data-ttu-id="e8764-279">Bifurcación para la instrucción máquina de destino en el desplazamiento `target` si son iguales, forma abreviada</span><span class="sxs-lookup"><span data-stu-id="e8764-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="e8764-280">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-281">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-282">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-283">`value2` y `value1` se extraen de la pila; si `value1` es igual a `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-284">El `beq.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es igual a `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="e8764-285">El efecto es el mismo que realizar una `ceq` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-286">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-287">Los tipos de operandos aceptables se encapsulan a continuación:</span><span class="sxs-lookup"><span data-stu-id="e8764-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="e8764-288">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="e8764-289">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción (dichas transferencias están muy limitadas y debe utilizar el <xref:System.Reflection.Emit.OpCodes.Leave> instrucción en su lugar).</span><span class="sxs-lookup"><span data-stu-id="e8764-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="e8764-290">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `beq.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-291">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-292">Transfiere el control a una instrucción máquina de destino si el primer valor es mayor o igual que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-293">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-294">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-294">Format</span></span>|<span data-ttu-id="e8764-295">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-295">Assembly Format</span></span>|<span data-ttu-id="e8764-296">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="e8764-297">3C `<int32>`</span></span>|<span data-ttu-id="e8764-298">bge `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-298">bge `target`</span></span>|<span data-ttu-id="e8764-299">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="e8764-300">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-301">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-302">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-303">`value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-304">El `bge` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor o igual que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="e8764-305">El efecto es idéntico a realizar una `clt.un` instrucción seguido por un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-306">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-307">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-308">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-309">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bge` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-310">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-311">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor o igual que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-312">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-313">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-313">Format</span></span>|<span data-ttu-id="e8764-314">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-314">Assembly Format</span></span>|<span data-ttu-id="e8764-315">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="e8764-316">2F `<int8>`</span></span>|<span data-ttu-id="e8764-317">bge.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-317">bge.s `target`</span></span>|<span data-ttu-id="e8764-318">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor, la forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="e8764-319">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-320">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-321">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-322">`value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-323">El `bge.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor o igual que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="e8764-324">El efecto es idéntico a realizar una `clt.un` instrucción seguido por un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-325">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-326">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-327">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-328">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bge.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-329">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-330">Transfiere el control a una instrucción máquina de destino si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-331">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-332">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-332">Format</span></span>|<span data-ttu-id="e8764-333">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-333">Assembly Format</span></span>|<span data-ttu-id="e8764-334">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="e8764-335">41 `<int32>`</span></span>|<span data-ttu-id="e8764-336">bge.un `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-336">bge.un `target`</span></span>|<span data-ttu-id="e8764-337">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-338">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-339">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-340">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-341">`value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-342">El `bge.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor o igual que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-343">El efecto es idéntico a realizar una `clt` instrucción seguido por un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-344">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-345">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-346">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-347">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bge.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-348">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-349">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-350">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-351">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-351">Format</span></span>|<span data-ttu-id="e8764-352">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-352">Assembly Format</span></span>|<span data-ttu-id="e8764-353">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-354">34 < `int8` ></span></span>|<span data-ttu-id="e8764-355">bge.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-355">bge.un.s `target`</span></span>|<span data-ttu-id="e8764-356">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor o igual que el segundo valor (valores sin signo), forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="e8764-357">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-358">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-359">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-360">`value2` y `value1` se extraen de la pila; si `value1` es mayor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-361">El `bge.un.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor o igual que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-362">El efecto es idéntico a realizar una `clt` instrucción seguido por un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-363">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-364">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-365">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-366">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bge.un.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-367">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-368">Transfiere el control a una instrucción máquina de destino si el primer valor es mayor que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-368">Transfers control to a target instruction if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-369">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-370">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-370">Format</span></span>|<span data-ttu-id="e8764-371">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-371">Assembly Format</span></span>|<span data-ttu-id="e8764-372">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-373">3D < `int32` ></span></span>|<span data-ttu-id="e8764-374">bgt `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-374">bgt `target`</span></span>|<span data-ttu-id="e8764-375">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="e8764-376">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-377">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-378">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-379">`value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-380">El `bgt` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="e8764-381">El efecto es idéntico a realizar una `cgt` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-382">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-383">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-384">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-385">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bgt` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-386">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-387">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-388">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-389">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-389">Format</span></span>|<span data-ttu-id="e8764-390">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-390">Assembly Format</span></span>|<span data-ttu-id="e8764-391">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-392">30 < `int8` ></span></span>|<span data-ttu-id="e8764-393">bgt.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-393">bgt.s `target`</span></span>|<span data-ttu-id="e8764-394">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor, la forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="e8764-395">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-396">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-397">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-398">`value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-399">El `bgt.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="e8764-400">El efecto es idéntico a realizar una `cgt` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-401">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-402">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-403">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-404">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bgt.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-405">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-406">Transfiere el control a una instrucción máquina de destino si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-407">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-408">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-408">Format</span></span>|<span data-ttu-id="e8764-409">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-409">Assembly Format</span></span>|<span data-ttu-id="e8764-410">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-411">42 < `int32` ></span></span>|<span data-ttu-id="e8764-412">bgt.un `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-412">bgt.un `target`</span></span>|<span data-ttu-id="e8764-413">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-414">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-415">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-416">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-417">`value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-418">El `bgt.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-419">El efecto es idéntico a realizar una `cgt.un` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-420">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-421">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-422">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-423">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bgt.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-424">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-425">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es mayor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-426">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-427">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-427">Format</span></span>|<span data-ttu-id="e8764-428">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-428">Assembly Format</span></span>|<span data-ttu-id="e8764-429">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-430">35 < `int8` ></span></span>|<span data-ttu-id="e8764-431">bgt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-431">bgt.un.s `target`</span></span>|<span data-ttu-id="e8764-432">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es mayor que el segundo valor (valores sin signo), forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="e8764-433">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-434">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-435">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-436">`value2` y `value1` se extraen de la pila; si `value1` es mayor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-437">El `bgt.un.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es mayor que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-438">El efecto es idéntico a realizar una `cgt.un` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-439">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-440">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-441">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-442">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bgt.un.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-443">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-444">Transfiere el control a una instrucción máquina de destino si el primer valor es menor o igual que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-445">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-446">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-446">Format</span></span>|<span data-ttu-id="e8764-447">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-447">Assembly Format</span></span>|<span data-ttu-id="e8764-448">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="e8764-449">3E `<int32>`</span></span>|<span data-ttu-id="e8764-450">ble `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-450">ble `target`</span></span>|<span data-ttu-id="e8764-451">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="e8764-452">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-453">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-454">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-455">`value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-456">El `ble` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor o igual que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="e8764-457">El efecto es idéntico a realizar un `cgt` instrucción (`cgt.un` para valores flotantes) seguida de un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-458">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-459">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-460">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-461">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ble` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-462">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-463">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor o igual que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-464">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-465">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-465">Format</span></span>|<span data-ttu-id="e8764-466">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-466">Assembly Format</span></span>|<span data-ttu-id="e8764-467">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="e8764-468">31 `<int8>`</span></span>|<span data-ttu-id="e8764-469">ble.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-469">ble.s `target`</span></span>|<span data-ttu-id="e8764-470">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor, la forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="e8764-471">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-472">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-473">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-474">`value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-475">El `ble.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor o igual que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="e8764-476">El efecto es idéntico a realizar una `cgt` instrucción (`cgt.un` para valores flotantes) instrucción seguido por un`brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-477">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-478">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-479">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-480">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ble.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-481">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-482">Transfiere el control a una instrucción máquina de destino si el primer valor es menor o igual que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-483">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-484">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-484">Format</span></span>|<span data-ttu-id="e8764-485">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-485">Assembly Format</span></span>|<span data-ttu-id="e8764-486">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="e8764-487">43 `<int32>`</span></span>|<span data-ttu-id="e8764-488">ble.un `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-488">ble.un `target`</span></span>|<span data-ttu-id="e8764-489">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-490">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-491">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-492">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-493">`value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-494">El `ble.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor o igual que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-495">El efecto es idéntico a realizar un `cgt.un` instrucción (`cgt` para valores flotantes) seguida de un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-496">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-497">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-498">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-499">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ble.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-500">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-501">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor o igual que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-502">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-503">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-503">Format</span></span>|<span data-ttu-id="e8764-504">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-504">Assembly Format</span></span>|<span data-ttu-id="e8764-505">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="e8764-506">36 `<int8>`</span></span>|<span data-ttu-id="e8764-507">ble.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-507">ble.un.s `target`</span></span>|<span data-ttu-id="e8764-508">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor o igual que el segundo valor (valores sin signo), forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="e8764-509">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-510">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-511">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-512">`value2` y `value1` se extraen de la pila; si `value1` es menor o igual que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-513">El `ble.un.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor o igual que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-514">El efecto es idéntico a realizar un `cgt.un` instrucción (`cgt` para valores flotantes) seguida de un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-515">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-516">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-517">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-518">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ble.un.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-519">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-520">Transfiere el control a una instrucción máquina de destino si el primer valor es menor que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-520">Transfers control to a target instruction if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-521">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-522">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-522">Format</span></span>|<span data-ttu-id="e8764-523">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-523">Assembly Format</span></span>|<span data-ttu-id="e8764-524">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-525">3F < `int32` ></span></span>|<span data-ttu-id="e8764-526">blt `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-526">blt `target`</span></span>|<span data-ttu-id="e8764-527">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="e8764-528">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-529">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-530">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-531">`value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-532">El `blt` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor o igual que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="e8764-533">El efecto es idéntico a realizar una `clt` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-534">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-535">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-536">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-537">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `blt` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-538">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-539">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor que el segundo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-540">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-541">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-541">Format</span></span>|<span data-ttu-id="e8764-542">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-542">Assembly Format</span></span>|<span data-ttu-id="e8764-543">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-544">32 < `int8` ></span></span>|<span data-ttu-id="e8764-545">blt.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-545">blt.s `target`</span></span>|<span data-ttu-id="e8764-546">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor, la forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="e8764-547">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-548">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-549">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-550">`value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-551">El `blt.s` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="e8764-552">El efecto es idéntico a realizar una `clt` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-553">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-554">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-555">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-556">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `blt.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-557">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-558">Transfiere el control a una instrucción máquina de destino si el primer valor es menor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-559">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-560">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-560">Format</span></span>|<span data-ttu-id="e8764-561">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-561">Assembly Format</span></span>|<span data-ttu-id="e8764-562">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-563">44 < `int32` ></span></span>|<span data-ttu-id="e8764-564">blt.un `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-564">blt.un `target`</span></span>|<span data-ttu-id="e8764-565">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-566">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-567">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-568">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-569">`value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-570">El `blt.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-571">El efecto es idéntico a realizar una `clt.un` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-572">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-573">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-574">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-575">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `blt.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-576">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-577">Transfiere el control a una instrucción máquina de destino (forma corta) si el primer valor es menor que el segundo valor, cuando se comparan valores enteros sin signo o valores flotantes desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-578">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-579">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-579">Format</span></span>|<span data-ttu-id="e8764-580">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-580">Assembly Format</span></span>|<span data-ttu-id="e8764-581">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-582">37 < `int8` ></span></span>|<span data-ttu-id="e8764-583">blt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-583">blt.un.s `target`</span></span>|<span data-ttu-id="e8764-584">Bifurcación para la instrucción máquina de destino en el desplazamiento especificado si el primer valor es menor que el segundo valor (valores sin signo), forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="e8764-585">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-586">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-587">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-588">`value2` y `value1` se extraen de la pila; si `value1` es menor que `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-589">El `blt.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` es menor que `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-590">El efecto es idéntico a realizar una `clt.un` instrucción seguido por un `brtrue` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-591">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-592">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-593">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-594">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `blt.un.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-595">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-596">Transfiere el control a una instrucción máquina de destino cuando dos valores enteros sin signo o dos valores flotantes desordenados no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-597">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-598">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-598">Format</span></span>|<span data-ttu-id="e8764-599">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-599">Assembly Format</span></span>|<span data-ttu-id="e8764-600">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-601">40 < `int32` ></span></span>|<span data-ttu-id="e8764-602">bne.un `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-602">bne.un `target`</span></span>|<span data-ttu-id="e8764-603">Bifurcación para el destino de instrucción en el desplazamiento especificado si dos valores enteros sin signo no son iguales (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-604">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-605">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-606">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-607">`value2` y `value1` se extraen de la pila; si `value1` no es igual a `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-608">El `bne.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` no es igual a `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-609">El efecto es idéntico a realizar una `ceq` instrucción seguido por un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-610">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-611">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-612">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-613">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bne.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-614">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-615">Transfiere el control a una instrucción máquina de destino (forma corta) cuando dos valores enteros sin signo o dos valores flotantes desordenados no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-616">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-617">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-617">Format</span></span>|<span data-ttu-id="e8764-618">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-618">Assembly Format</span></span>|<span data-ttu-id="e8764-619">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-620">33 < `int8` ></span></span>|<span data-ttu-id="e8764-621">bne.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-621">bne.un.s `target`</span></span>|<span data-ttu-id="e8764-622">Bifurcación para el destino de instrucción en el desplazamiento especificado si dos valores enteros sin signo son no iguales (valores sin signo), forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="e8764-623">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-624">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-625">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-626">`value2` y `value1` se extraen de la pila; si `value1` no es igual a `value2`, se realiza la operación de bifurcación.</span><span class="sxs-lookup"><span data-stu-id="e8764-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="e8764-627">El `bne.un` instrucción transfiere el control a la instrucción de destino especificada si `value1` no es igual a `value2`, cuando se comparan con valores enteros sin signo o valores flotantes desordenados.</span><span class="sxs-lookup"><span data-stu-id="e8764-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="e8764-628">El efecto es idéntico a realizar una `ceq` instrucción seguido por un `brfalse` bifurcación a la instrucción máquina de destino específica.</span><span class="sxs-lookup"><span data-stu-id="e8764-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="e8764-629">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-630">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-631">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-632">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `bne.un.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-633">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-634">Convierte un tipo de valor en una referencia a objeto (tipo <see langword="O" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-634">Converts a value type to an object reference (type <see langword="O" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-635">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-636">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-636">Format</span></span>|<span data-ttu-id="e8764-637">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-637">Assembly Format</span></span>|<span data-ttu-id="e8764-638">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-639">8C < `T` ></span></span>|<span data-ttu-id="e8764-640">Cuadro de `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="e8764-640">box `valTypeToken`</span></span>|<span data-ttu-id="e8764-641">Convertir un tipo de valor (del tipo especificado en `valTypeToken`) a una referencia a objeto real.</span><span class="sxs-lookup"><span data-stu-id="e8764-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="e8764-642">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-643">Un tipo de valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-644">El tipo de valor se extrae de la pila; el `box` se realiza la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="e8764-645">Referencia de objeto para el tipo de valor "conversión boxing" resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-646">Un tipo de valor tiene dos representaciones distintas en Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="e8764-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="e8764-647">Una forma "sin procesar" que se utiliza cuando un tipo de valor se incrusta dentro de otro objeto o en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="e8764-648">Una forma de 'conversión boxing', donde los datos en el tipo de valor se empaquetan (boxed) en un objeto de modo que pueda existir como una entidad independiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="e8764-649">El `box` instrucción convierte el tipo de valor (con conversión unboxing) "sin procesar" en una referencia de objeto (tipo `O`).</span><span class="sxs-lookup"><span data-stu-id="e8764-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="e8764-650">Esto se consigue creando un nuevo objeto y copiar los datos del tipo de valor en el objeto recién asignado.</span><span class="sxs-lookup"><span data-stu-id="e8764-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="e8764-651">`valTypeToken` es un token de metadatos que indica el tipo del tipo de valor en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="e8764-652"><xref:System.OutOfMemoryException> se produce si no hay memoria suficiente para satisfacer la solicitud.</span><span class="sxs-lookup"><span data-stu-id="e8764-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="e8764-653"><xref:System.TypeLoadException> se produce si no se encuentra la clase.</span><span class="sxs-lookup"><span data-stu-id="e8764-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="e8764-654">Normalmente, esto se detecta cuando el lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo, en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-655">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `box` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-656">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-657">Transfiere el control incondicionalmente a una instrucción de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-657">Unconditionally transfers control to a target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-658">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-659">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-659">Format</span></span>|<span data-ttu-id="e8764-660">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-660">Assembly Format</span></span>|<span data-ttu-id="e8764-661">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-662">38 < `int32` ></span></span>|<span data-ttu-id="e8764-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-663">br `target`</span></span>|<span data-ttu-id="e8764-664">Realiza una bifurcación para una instrucción máquina de destino en el desplazamiento especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="e8764-665">Esta operación no se realizan ningún comportamientos de la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="e8764-666">El `br` instrucción transfiere el control incondicionalmente a una instrucción máquina de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="e8764-667">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-668">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-669">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-670">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `br` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-671">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-672">Transfiere incondicionalmente el control a una instrucción máquina de destino (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-672">Unconditionally transfers control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-673">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-674">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-674">Format</span></span>|<span data-ttu-id="e8764-675">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-675">Assembly Format</span></span>|<span data-ttu-id="e8764-676">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-677">2B < `int8` ></span></span>|<span data-ttu-id="e8764-678">br.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-678">br.s `target`</span></span>|<span data-ttu-id="e8764-679">Realiza una bifurcación para una instrucción máquina de destino en el desplazamiento especificado, la forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="e8764-680">Esta operación no se realizan ningún comportamientos de la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="e8764-681">El `br.s` instrucción transfiere el control incondicionalmente a una instrucción máquina de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="e8764-682">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-683">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-684">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-685">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `br.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-686">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-687">Indica a Common Language Infrastructure (CLI) que informe al depurador de que se ha recorrido un punto de interrupción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-688">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-689">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-689">Format</span></span>|<span data-ttu-id="e8764-690">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-690">Assembly Format</span></span>|<span data-ttu-id="e8764-691">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-692">01</span><span class="sxs-lookup"><span data-stu-id="e8764-692">01</span></span>|<span data-ttu-id="e8764-693">break</span><span class="sxs-lookup"><span data-stu-id="e8764-693">break</span></span>|<span data-ttu-id="e8764-694">informa al depurador que se ha alcanzado un punto de interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8764-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="e8764-695">Esta operación no se realizan ningún comportamientos de la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="e8764-696">El `break` instrucción es para la compatibilidad con la depuración.</span><span class="sxs-lookup"><span data-stu-id="e8764-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="e8764-697">Indica la CLI que informe al depurador que se ha recorrido un punto de interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8764-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="e8764-698">No tiene ningún otro efecto en el estado del intérprete.</span><span class="sxs-lookup"><span data-stu-id="e8764-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="e8764-699">El `break` instrucción tiene el tamaño más pequeño posible instrucción habilitar código aplicación de revisiones con un punto de interrupción y afecta mínimamente al código circundante.</span><span class="sxs-lookup"><span data-stu-id="e8764-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="e8764-700">El `break` instrucción puede interceptar un depurador, no hacer nada o iniciar una excepción de seguridad.</span><span class="sxs-lookup"><span data-stu-id="e8764-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="e8764-701">El comportamiento exacto es definido por la implementación.</span><span class="sxs-lookup"><span data-stu-id="e8764-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="e8764-702">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `break` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-704">Transfiere el control a una instrucción máquina de destino si <paramref name="value" /> es <see langword="false" />, una referencia nula (<see langword="Nothing" /> en Visual Basic) o cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-705">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-706">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-706">Format</span></span>|<span data-ttu-id="e8764-707">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-707">Assembly Format</span></span>|<span data-ttu-id="e8764-708">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-709">39 < `int32` ></span></span>|<span data-ttu-id="e8764-710">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="e8764-711">brnull `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="e8764-712">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-712">brzero `target`</span></span>|<span data-ttu-id="e8764-713">Realiza una bifurcación para una instrucción máquina de destino en el desplazamiento especificado si `false`.</span><span class="sxs-lookup"><span data-stu-id="e8764-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="e8764-714">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-715">`value` se inserta en la pila con una operación anterior.</span><span class="sxs-lookup"><span data-stu-id="e8764-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="e8764-716">`value` se extrae de la pila; Si `value` es `false`, crear una bifurcación en `target`.</span><span class="sxs-lookup"><span data-stu-id="e8764-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="e8764-717">El `brfalse` instrucción (y sus alias `brnull` y `brzero`) transfiere el control a la instrucción de destino especificada si `value` (de tipo `int32`, `int64`, referencia de objeto `O`administrados puntero `&`, puntero transitorio `*`, `native int`) es cero (`false`).</span><span class="sxs-lookup"><span data-stu-id="e8764-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="e8764-718">Si `value` es distinto de cero (`true`) la ejecución continúa en la instrucción siguiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="e8764-719">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-720">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-721">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-722">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `brfalse` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-723">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-724">Transfiere el control a una instrucción máquina de destino si <paramref name="value" /> es <see langword="false" />, una referencia nula o cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-725">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-726">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-726">Format</span></span>|<span data-ttu-id="e8764-727">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-727">Assembly Format</span></span>|<span data-ttu-id="e8764-728">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-729">2C <`int8` ></span></span>|<span data-ttu-id="e8764-730">brfalse.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="e8764-731">brnull.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="e8764-732">brzero.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-732">brzero.s `target`</span></span>|<span data-ttu-id="e8764-733">Realiza una bifurcación para una instrucción máquina de destino en el desplazamiento especificado si `false`, forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="e8764-734">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-735">`value` se inserta en la pila con una operación anterior.</span><span class="sxs-lookup"><span data-stu-id="e8764-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="e8764-736">`value` se extrae de la pila; Si `value` es `false`, crear una bifurcación en `target`.</span><span class="sxs-lookup"><span data-stu-id="e8764-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="e8764-737">El `brfalse.s` instrucción (y sus alias `brnull` y `brzero`) transfiere el control a la instrucción de destino especificada si `value` (de tipo `int32`, `int64`, referencia de objeto `O`administrados puntero `&`, puntero transitorio `*`, `native int`) es cero (`false`).</span><span class="sxs-lookup"><span data-stu-id="e8764-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="e8764-738">Si `value` es distinto de cero (`true`) la ejecución continúa en la instrucción siguiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="e8764-739">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-740">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-741">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-742">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `brfalse.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-743">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-744">Transfiere el control a una instrucción máquina de destino si <paramref name="value" /> es <see langword="true" />, no es null o es distinto de cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-745">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-746">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-746">Format</span></span>|<span data-ttu-id="e8764-747">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-747">Assembly Format</span></span>|<span data-ttu-id="e8764-748">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-749">3A < `int32` ></span></span>|<span data-ttu-id="e8764-750">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="e8764-751">brinst `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-751">brinst `target`</span></span>|<span data-ttu-id="e8764-752">Realiza una bifurcación para una instrucción máquina de destino en el desplazamiento especificado si es distinto de cero (`true`).</span><span class="sxs-lookup"><span data-stu-id="e8764-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="e8764-753">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-754">`value` se inserta en la pila con una operación anterior.</span><span class="sxs-lookup"><span data-stu-id="e8764-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="e8764-755">`value` se extrae de la pila; Si `value` es `true`, crear una bifurcación en `target`.</span><span class="sxs-lookup"><span data-stu-id="e8764-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="e8764-756">El `brtrue` instrucción transfiere el control a la instrucción de destino especificada si `value` (tipo `native int`) es distinto de cero (`true`).</span><span class="sxs-lookup"><span data-stu-id="e8764-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="e8764-757">Si `value` es cero (`false`) la ejecución continúa en la instrucción siguiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="e8764-758">Si `value` es una referencia de objeto (tipo `O`), a continuación, `brinst` (un alias para `brtrue`) transfiere el control si representa una instancia de un objeto (por ejemplo, si no es la referencia de objeto null; vea <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="e8764-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="e8764-759">La instrucción de destino se representa como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-760">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-761">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-762">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `brtrue` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-763">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-764">Transfiere el control a una instrucción máquina de destino (forma corta) si <paramref name="value" /> es <see langword="true" />, no es null o es distinto de cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-765">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-766">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-766">Format</span></span>|<span data-ttu-id="e8764-767">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-767">Assembly Format</span></span>|<span data-ttu-id="e8764-768">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-769">2D < `int8` ></span></span>|<span data-ttu-id="e8764-770">brtrue.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="e8764-771">brinst.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-771">brinst.s `target`</span></span>|<span data-ttu-id="e8764-772">Realiza una bifurcación para una instrucción máquina de destino en el desplazamiento especificado si es distinto de cero (`true`), forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="e8764-773">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-774">`value` se inserta en la pila con una operación anterior.</span><span class="sxs-lookup"><span data-stu-id="e8764-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="e8764-775">`value` se extrae de la pila; Si `value` es `true`, crear una bifurcación en `target`.</span><span class="sxs-lookup"><span data-stu-id="e8764-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="e8764-776">El `brtrue.s` instrucción transfiere el control a la instrucción de destino especificada si `value` (tipo `native int`) es distinto de cero (`true`).</span><span class="sxs-lookup"><span data-stu-id="e8764-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="e8764-777">Si `value` es cero (`false`) la ejecución continúa en la instrucción siguiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="e8764-778">Si `value` es una referencia de objeto (tipo `O`), a continuación, `brinst` (un alias para `brtrue`) transfiere el control si representa una instancia de un objeto (por ejemplo, si no es la referencia de objeto null; vea <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="e8764-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="e8764-779">La instrucción de destino se representa como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-780">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="e8764-781">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="e8764-782">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `brtrue.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-783">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-784">Llama al método indicado por el descriptor del método que se ha pasado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-784">Calls the method indicated by the passed method descriptor.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-785">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-786">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-786">Format</span></span>|<span data-ttu-id="e8764-787">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-787">Assembly Format</span></span>|<span data-ttu-id="e8764-788">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-789">28 < `T` ></span></span>|<span data-ttu-id="e8764-790">Llamar a `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="e8764-790">call `methodDesc`</span></span>|<span data-ttu-id="e8764-791">Llame al método descrito por `methodDesc`.</span><span class="sxs-lookup"><span data-stu-id="e8764-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="e8764-792">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-793">Argumentos del método `arg1` a través de `argN` se insertan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-794">Argumentos del método `arg1` a través de `argN` se extrae de la pila; la llamada al método se realiza con estos argumentos y el control se transfiere al método que hace referencia el descriptor del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="e8764-795">Cuando haya finalizado, un valor devuelto es generado por el método del destinatario y envía al llamador.</span><span class="sxs-lookup"><span data-stu-id="e8764-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="e8764-796">El valor devuelto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-797">El `call` instrucción llama al método indicado por el descriptor del método pasado con la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="e8764-798">El descriptor del método es un símbolo (token) de metadatos que indica el método de llamada y el número, tipo y orden de los argumentos que se han colocado en la pila que se pasan a dicho método, así como la convención de llamada que se usará.</span><span class="sxs-lookup"><span data-stu-id="e8764-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="e8764-799">El `call` instrucción puede ir precedido inmediatamente por un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) instrucción para especificar que el estado del método actual debe liberarse antes de transferir el control con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="e8764-800">Si la llamada transfiere el control a un método de mayor confianza que el método de origen, no se libera el marco de pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="e8764-801">En su lugar, la ejecución continúa en modo silencioso como si el `tail` no se ha suministrado.</span><span class="sxs-lookup"><span data-stu-id="e8764-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="e8764-802">El token de metadatos incluye información suficiente para determinar si la llamada es a un método estático, un método de instancia, un método virtual o una función global.</span><span class="sxs-lookup"><span data-stu-id="e8764-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="e8764-803">En todos estos casos, la dirección de destino se determina del todo en el descriptor del método (contrastar esto con el <xref:System.Reflection.Emit.OpCodes.Callvirt> instrucciones para llamar a métodos virtuales, donde la dirección de destino también depende del tipo en tiempo de ejecución de la referencia a la instancia que se insertan delante del <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span><span class="sxs-lookup"><span data-stu-id="e8764-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="e8764-804">Los argumentos se colocan en la pila en orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="e8764-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="e8764-805">Es decir, el primer argumento se calcula y se coloca en la pila, el segundo argumento y, luego, el tercero, hasta que todos los argumentos necesarios son parte superior de la pila en orden descendente.</span><span class="sxs-lookup"><span data-stu-id="e8764-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="e8764-806">Existen tres casos especiales importantes:</span><span class="sxs-lookup"><span data-stu-id="e8764-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="e8764-807">Llama a una instancia (o virtual) método debe insertar esa referencia a la instancia antes de cualquiera de los argumentos visibles al usuario.</span><span class="sxs-lookup"><span data-stu-id="e8764-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="e8764-808">La referencia a la instancia no debe ser una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="e8764-809">La firma que se incluyen en los metadatos no contiene una entrada en la lista de parámetros para la `this` puntero; en su lugar, utiliza un bit para indicar si el método requiere que se pase el `this` puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="e8764-810">Es válido para llamar a un método virtual mediante `call` (en lugar de `callvirt`); Esto indica que es el método debe resolverse mediante la clase especificada por método en lugar de como se especifica dinámicamente desde el objeto que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="e8764-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="e8764-811">Tenga en cuenta que un delegado `Invoke` método puede llamarse con cualquiera el `call` o `callvirt` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="e8764-812"><xref:System.Security.SecurityException> se puede producir si la seguridad del sistema no concede al llamador acceso al método llamado.</span><span class="sxs-lookup"><span data-stu-id="e8764-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="e8764-813">La comprobación de seguridad puede producirse cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e8764-814">Al llamar a métodos de System.Object en tipos de valor, considere el uso de la `constrained` con el prefijo del `callvirt` instrucción en lugar de emitir un `call` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="e8764-815">Esto elimina la necesidad para emitir lenguaje intermedio diferente dependiendo de si el tipo de valor invalida el método, evitar un posible problema de control de versiones.</span><span class="sxs-lookup"><span data-stu-id="e8764-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="e8764-816">Considere el uso de la `constrained` prefijo al invocar métodos de interfaz en tipos de valor, ya que el método de tipo de valor implementa el método de interfaz se puede cambiar mediante un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="e8764-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="e8764-817">Estos problemas se describen con más detalle en la <xref:System.Reflection.Emit.OpCodes.Constrained> código de operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="e8764-818">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `call` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-819">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="e8764-820">ILGenerator.EmitCall (código de operación, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="e8764-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e8764-821">El <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> método se proporciona para `varargs` llamadas.</span><span class="sxs-lookup"><span data-stu-id="e8764-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="e8764-822">Use la <xref:System.Reflection.Emit.ILGenerator.Emit%2A> método para las llamadas normales.</span><span class="sxs-lookup"><span data-stu-id="e8764-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-823">Llama al método indicado en la pila de evaluación (como puntero a un punto de entrada) con los argumentos descritos mediante una convención de llamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-824">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-825">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-825">Format</span></span>|<span data-ttu-id="e8764-826">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-826">Assembly Format</span></span>|<span data-ttu-id="e8764-827">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-828">29 < `T` ></span></span>|<span data-ttu-id="e8764-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="e8764-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="e8764-830">Llama al método que apunta con los argumentos descritos mediante la convención de llamada.</span><span class="sxs-lookup"><span data-stu-id="e8764-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="e8764-831">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-832">Argumentos del método `arg1` a través de `argN` se insertan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-833">El puntero de entrada del método se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-834">Argumentos del método `arg1` a través de `argN` y el puntero de entrada del método se extraen de la pila; se realiza la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="e8764-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="e8764-835">Cuando haya finalizado, un valor devuelto es generado por el método del destinatario y envía al llamador.</span><span class="sxs-lookup"><span data-stu-id="e8764-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="e8764-836">El valor devuelto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-837">El `calli` instrucción llama al puntero de entrada de método con los argumentos `arg1` a través de `argN`.</span><span class="sxs-lookup"><span data-stu-id="e8764-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="e8764-838">Los tipos de estos argumentos se describen mediante la convención de llamada específica (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="e8764-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="e8764-839">El `calli` instrucción puede estar precedido inmediatamente por un `tail` prefijo (<xref:System.Reflection.Emit.OpCodes.Tailcall>) para especificar que el estado del método actual debe liberarse antes de transferir el control.</span><span class="sxs-lookup"><span data-stu-id="e8764-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="e8764-840">Si la llamada transfiere el control a un método de mayor confianza que el método de origen, el marco de pila no se liberará; en su lugar, la ejecución continúa silenciosamente como si el `tail` no se ha suministrado.</span><span class="sxs-lookup"><span data-stu-id="e8764-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="e8764-841">Se supone que el puntero de entrada del método es un puntero específico a código nativo (del equipo de destino) que se puede llamar legítimamente con los argumentos descritos mediante la convención de llamada (un token de metadatos para una firma independiente).</span><span class="sxs-lookup"><span data-stu-id="e8764-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="e8764-842">Un puntero con estas características puede crearse con el <xref:System.Reflection.Emit.OpCodes.Ldftn> o <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instrucciones, o pasar desde código nativo.</span><span class="sxs-lookup"><span data-stu-id="e8764-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="e8764-843">La convención de llamada no está activada de forma dinámica, por lo que el código que utiliza un `calli` instrucciones no funcionan correctamente si el destino no utiliza realmente la convención de llamada especificada.</span><span class="sxs-lookup"><span data-stu-id="e8764-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="e8764-844">Los argumentos se colocan en la pila en orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="e8764-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="e8764-845">Es decir, el primer argumento se calcula y se coloca en la pila, el segundo argumento y, luego, el tercero, hasta que todos los argumentos necesarios son parte superior de la pila en orden descendente.</span><span class="sxs-lookup"><span data-stu-id="e8764-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="e8764-846">La secuencia de código de compilación de argumento para una instancia o un método virtual debe insertar esa referencia a la instancia (que no debe ser una referencia nula) antes de cualquiera de los argumentos visibles al usuario.</span><span class="sxs-lookup"><span data-stu-id="e8764-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="e8764-847"><xref:System.Security.SecurityException> se puede producir si la seguridad del sistema no concede al llamador acceso al método llamado.</span><span class="sxs-lookup"><span data-stu-id="e8764-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="e8764-848">La comprobación de seguridad puede producirse cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-849">El siguiente <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> métodos pueden usarse para realizar un `calli` instrucciones sobre la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="e8764-850">Tenga en cuenta que `calli` debe llamarse a través de la por debajo de los métodos en lugar de usar la <xref:System.Reflection.Emit.ILGenerator.Emit%2A> clase para colocar la instrucción directamente en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="e8764-851">ILGenerator.EmitCalli (Opcode, CallingConventions, Type, Type [], Type[]) para las llamadas mediante una convención de llamada administrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="e8764-852">ILGenerator.EmitCalli (Opcode, CallingConvention, Type, Type[]) para las llamadas mediante una convención llamada no administrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-853">Llama a un método enlazado tardíamente en un objeto e inserta el valor devuelto en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-854">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-855">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-855">Format</span></span>|<span data-ttu-id="e8764-856">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-856">Assembly Format</span></span>|<span data-ttu-id="e8764-857">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-858">6F < `T` ></span></span>|<span data-ttu-id="e8764-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="e8764-859">callvirt `method`</span></span>|<span data-ttu-id="e8764-860">Llama a un método específico asociado con `obj`.</span><span class="sxs-lookup"><span data-stu-id="e8764-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="e8764-861">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-862">Una referencia de objeto `obj` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-863">Argumentos del método `arg1` a través de `argN` se insertan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-864">Argumentos del método `arg1` a través de `argN` y la referencia de objeto `obj` se extrae de la pila; la llamada al método se realiza con estos argumentos y el control se transfiere al método en `obj` que hace referencia el token de metadatos del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="e8764-865">Cuando haya finalizado, un valor devuelto es generado por el método del destinatario y envía al llamador.</span><span class="sxs-lookup"><span data-stu-id="e8764-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="e8764-866">El valor devuelto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-867">El `callvirt` instrucción llama a un método enlazado tardíamente en un objeto.</span><span class="sxs-lookup"><span data-stu-id="e8764-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="e8764-868">Es decir, el método se elige en función del tipo en tiempo de ejecución de `obj` en lugar de la clase en tiempo de compilación visible en el puntero del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="e8764-869">`Callvirt` puede utilizarse para llamar a ambos virtual y métodos de instancia.</span><span class="sxs-lookup"><span data-stu-id="e8764-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="e8764-870">El `callvirt` instrucción puede estar precedido inmediatamente por un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefijo para especificar que el marco de pila actual debe liberarse antes de transferir el control.</span><span class="sxs-lookup"><span data-stu-id="e8764-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="e8764-871">Si la llamada transfiere el control a un método de mayor confianza que el método original, el marco de pila no se liberará.</span><span class="sxs-lookup"><span data-stu-id="e8764-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="e8764-872">El token de metadatos del método proporciona el nombre, la clase y la firma del método para llamar a.</span><span class="sxs-lookup"><span data-stu-id="e8764-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="e8764-873">La clase asociada `obj` es la clase de los cuales es una instancia.</span><span class="sxs-lookup"><span data-stu-id="e8764-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="e8764-874">Si la clase define un método no estático que coincide con el nombre del método indicado y la firma, se llama a este método.</span><span class="sxs-lookup"><span data-stu-id="e8764-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="e8764-875">En caso contrario, se comprueban todas las clases de la cadena de la clase base de esta clase en orden.</span><span class="sxs-lookup"><span data-stu-id="e8764-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="e8764-876">Es un error si no se encuentra ningún método.</span><span class="sxs-lookup"><span data-stu-id="e8764-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="e8764-877">`Callvirt` extrae el objeto y los argumentos asociados de la pila de evaluación antes de llamar al método.</span><span class="sxs-lookup"><span data-stu-id="e8764-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="e8764-878">Si el método tiene un valor devuelto, se inserta en la pila una vez completado el método.</span><span class="sxs-lookup"><span data-stu-id="e8764-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="e8764-879">En el lado del destinatario, el `obj` se obtiene acceso al parámetro como argumento 0, `arg1` como argumento 1 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="e8764-880">Los argumentos se colocan en la pila en orden de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="e8764-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="e8764-881">Es decir, el primer argumento se calcula y se coloca en la pila, el segundo argumento y, luego, el tercero, hasta que todos los argumentos necesarios son parte superior de la pila en orden descendente.</span><span class="sxs-lookup"><span data-stu-id="e8764-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="e8764-882">La referencia a la instancia `obj` (siempre necesario para `callvirt`) se debe insertar antes de cualquiera de los argumentos visibles al usuario.</span><span class="sxs-lookup"><span data-stu-id="e8764-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="e8764-883">La firma (incluida en el token de metadatos) no debe contener una entrada en la lista de parámetros para este puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="e8764-884">Tenga en cuenta que también se puede llamar al método virtual mediante la <xref:System.Reflection.Emit.OpCodes.Call> instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="e8764-885"><xref:System.MissingMethodException> se produce si un método no estático con el nombre indicado y la firma no se encontró en la clase asociada `obj` o cualquiera de sus clases base.</span><span class="sxs-lookup"><span data-stu-id="e8764-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="e8764-886">Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-887"><xref:System.NullReferenceException> se produce si obj es null.</span><span class="sxs-lookup"><span data-stu-id="e8764-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="e8764-888"><xref:System.Security.SecurityException> se produce si la seguridad del sistema no concede al llamador acceso al método llamado.</span><span class="sxs-lookup"><span data-stu-id="e8764-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="e8764-889">La comprobación de seguridad puede producirse cuando el archivo de CIL se convierte en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e8764-890">Al llamar a métodos de System.Object en tipos de valor, considere el uso de la `constrained` con el prefijo del `callvirt` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="e8764-891">Esto elimina la necesidad para emitir lenguaje intermedio diferente dependiendo de si el tipo de valor invalida el método, evitar un posible problema de control de versiones.</span><span class="sxs-lookup"><span data-stu-id="e8764-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="e8764-892">Considere el uso de la `constrained` prefijo al invocar métodos de interfaz en tipos de valor, ya que el método de tipo de valor implementa el método de interfaz se puede cambiar mediante un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="e8764-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="e8764-893">Estos problemas se describen con más detalle en la <xref:System.Reflection.Emit.OpCodes.Constrained> código de operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="e8764-894">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `callvirt` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-895">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="e8764-896">ILGenerator.EmitCall (código de operación, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="e8764-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-897">Intenta convertir un objeto pasado por referencia en la clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-897">Attempts to cast an object passed by reference to the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-898">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-899">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-899">Format</span></span>|<span data-ttu-id="e8764-900">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-900">Assembly Format</span></span>|<span data-ttu-id="e8764-901">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-902">74 < `T` ></span></span>|<span data-ttu-id="e8764-903">castclass `class`</span><span class="sxs-lookup"><span data-stu-id="e8764-903">castclass `class`</span></span>|<span data-ttu-id="e8764-904">Convierte el objeto en un nuevo objeto de tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="e8764-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="e8764-905">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-906">Una referencia de objeto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-907">La referencia de objeto se extrae de la pila; se convierte el objeto de referencia especificado `class`.</span><span class="sxs-lookup"><span data-stu-id="e8764-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="e8764-908">Si se realiza correctamente, se inserta una nueva referencia de objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-909">El `castclass` instrucción intenta convertir la referencia al objeto (tipo `O`) parte superior de la pila en una clase especificada.</span><span class="sxs-lookup"><span data-stu-id="e8764-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="e8764-910">La nueva clase se especifica mediante un símbolo (token) de metadatos que indica la clase deseada.</span><span class="sxs-lookup"><span data-stu-id="e8764-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="e8764-911">Si la clase del objeto en la parte superior de la pila no implementa la nueva clase (suponiendo que la nueva clase es una interfaz) y no es una clase derivada de la nueva clase un <xref:System.InvalidCastException> se produce.</span><span class="sxs-lookup"><span data-stu-id="e8764-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="e8764-912">Si la referencia de objeto es una referencia nula, `castclass` se realiza correctamente y devuelve el nuevo objeto como una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="e8764-913"><xref:System.InvalidCastException> se produce si obj no se puede convertir a la clase.</span><span class="sxs-lookup"><span data-stu-id="e8764-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="e8764-914"><xref:System.TypeLoadException> se produce si no se pudo encontrar la clase.</span><span class="sxs-lookup"><span data-stu-id="e8764-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="e8764-915">Normalmente, esto se detecta cuando una instrucción de lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-915">This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-916">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `castclass` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-917">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-918">Compara dos valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-918">Compares two values.</span>
          </span>
          <span data-ttu-id="e8764-919">Si son iguales, el valor entero 1 <see langword="(int32" />) se inserta en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-920">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-921">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-921">Format</span></span>|<span data-ttu-id="e8764-922">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-922">Assembly Format</span></span>|<span data-ttu-id="e8764-923">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="e8764-924">FE 01</span></span>|<span data-ttu-id="e8764-925">ceq</span><span class="sxs-lookup"><span data-stu-id="e8764-925">ceq</span></span>|<span data-ttu-id="e8764-926">Inserta 1 si `value1` es igual a `value2`; en caso contrario, inserta 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="e8764-927">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-928">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-929">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-930">`value2` y `value1` se extrae de la pila; `value1` se compara con `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-931">Si `value1` es igual a `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-932">El `ceq` instrucción compara `value1` y `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="e8764-933">Si `value1` es igual a `value2`, a continuación, 1 (de tipo `int32`) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="e8764-934">En caso contrario, 0 (de tipo `int32`) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="e8764-935">Número de punto flotante, `ceq` devolverá 0 si los números están desordenados (cualquiera o ambos son NaN).</span><span class="sxs-lookup"><span data-stu-id="e8764-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="e8764-936">Los valores infinitos son iguales a sí mismos.</span><span class="sxs-lookup"><span data-stu-id="e8764-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="e8764-937">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ceq` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-939">Compara dos valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-939">Compares two values.</span>
          </span>
          <span data-ttu-id="e8764-940">Si el primer valor es mayor que el segundo, se inserta el valor entero 1 <see langword="(int32" />) en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-941">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-942">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-942">Format</span></span>|<span data-ttu-id="e8764-943">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-943">Assembly Format</span></span>|<span data-ttu-id="e8764-944">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="e8764-945">FE 02</span></span>|<span data-ttu-id="e8764-946">cgt</span><span class="sxs-lookup"><span data-stu-id="e8764-946">cgt</span></span>|<span data-ttu-id="e8764-947">Inserta 1 si `value1` es mayor que `value2`; en caso contrario, inserta 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="e8764-948">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-949">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-950">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-951">`value2` y `value1` se extrae de la pila; `cgt` comprueba si `value1` es mayor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-952">Si `value1` es mayor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-953">El `cgt` instrucción compara `value1` y `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="e8764-954">Si `value1` es estrictamente mayor que `value2`, un `int32` valor de 1 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="e8764-955">En caso contrario, un `int32` el valor 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="e8764-956">Números de punto flotante, `cgt` devuelve 0 si los números están desordenados (es decir, si uno de los argumentos o ambos son NaN).</span><span class="sxs-lookup"><span data-stu-id="e8764-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="e8764-957">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `cgt` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-959">Compara dos valores sin signo o desordenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-959">Compares two unsigned or unordered values.</span>
          </span>
          <span data-ttu-id="e8764-960">Si el primer valor es mayor que el segundo, se inserta el valor entero 1 <see langword="(int32" />) en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-961">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-962">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-962">Format</span></span>|<span data-ttu-id="e8764-963">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-963">Assembly Format</span></span>|<span data-ttu-id="e8764-964">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="e8764-965">FE 03</span></span>|<span data-ttu-id="e8764-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="e8764-966">cgt.un</span></span>|<span data-ttu-id="e8764-967">Inserta 1 si `value1` es mayor que `value2`; en caso contrario, inserta 0 (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-968">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-969">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-970">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-971">`value2` y `value1` se extrae de la pila; `cgt.un` comprueba si `value1` es mayor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-972">Si `value1` es mayor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-973">Un `int32` valor de 1 se inserta en la pila si se cumple alguna de las siguientes acciones `true` :</span><span class="sxs-lookup"><span data-stu-id="e8764-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="e8764-974">Números de punto flotante, `value1` no está ordenado con respecto a `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="e8764-975">Para los valores enteros, `value1` es estrictamente mayor que `value2` cuando se consideran como números sin signo.</span><span class="sxs-lookup"><span data-stu-id="e8764-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="e8764-976">En caso contrario, un `int32` el valor 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="e8764-977">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `cgt.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-979">Produce <see cref="T:System.ArithmeticException" /> si el valor no es un número finito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-980">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-981">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-981">Format</span></span>|<span data-ttu-id="e8764-982">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-982">Assembly Format</span></span>|<span data-ttu-id="e8764-983">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-984">C3</span><span class="sxs-lookup"><span data-stu-id="e8764-984">C3</span></span>|<span data-ttu-id="e8764-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="e8764-985">ckfinite</span></span>|<span data-ttu-id="e8764-986">iniciar <xref:System.ArithmeticException> si el valor no es un número finito.</span><span class="sxs-lookup"><span data-stu-id="e8764-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="e8764-987">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-988">`value` se inserta en la pila...</span><span class="sxs-lookup"><span data-stu-id="e8764-988">`value` is pushed onto the stack..</span></span>  
  
2.  <span data-ttu-id="e8764-989">`value` se extrae de la pila y la `ckfinite` instrucción se realiza en él.</span><span class="sxs-lookup"><span data-stu-id="e8764-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="e8764-990">`value` se vuelve a insertar en la pila si no se produce ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-991">El `ckfinite instruction` produce <xref:System.ArithmeticException> si `value` (un número de punto flotante) es un valor de "not a number" (NaN) o un `+-` valor infinito.</span><span class="sxs-lookup"><span data-stu-id="e8764-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="e8764-992">`Ckfinite` deja el valor en la pila si no se produce ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="e8764-993">Ejecución no se especifica si `value` no es un número de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="e8764-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="e8764-994"><xref:System.ArithmeticException> se produce si `value` no es un número "normal".</span><span class="sxs-lookup"><span data-stu-id="e8764-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="e8764-995">Tenga en cuenta que una excepción especial o una clase derivada de <xref:System.ArithmeticException> puede ser más adecuado, pasando el valor incorrecto al controlador de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="e8764-996">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ckfinite` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-998">Compara dos valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-998">Compares two values.</span>
          </span>
          <span data-ttu-id="e8764-999">Si el primer valor es menor que el segundo, se inserta el valor entero 1 <see langword="(int32" />) en la pila de evaluación; en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1000">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1001">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1001">Format</span></span>|<span data-ttu-id="e8764-1002">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1002">Assembly Format</span></span>|<span data-ttu-id="e8764-1003">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="e8764-1004">FE 04</span></span>|<span data-ttu-id="e8764-1005">clt</span><span class="sxs-lookup"><span data-stu-id="e8764-1005">clt</span></span>|<span data-ttu-id="e8764-1006">Inserta 1 si `value1` es menor que `value2`; en caso contrario, inserta 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="e8764-1007">El comportamiento de transición de pila, en orden secuencial, es: `value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1007">The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack.</span></span>  
  
1.  <span data-ttu-id="e8764-1008">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1008">`value2` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1009">`value2` y `value1` se extrae de la pila; `clt` comprueba si `value1` es menor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1009">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
3.  <span data-ttu-id="e8764-1010">Si `value1` es menor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1010">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1011">El `clt` instrucción compara `value1` y `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1011">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="e8764-1012">Si `value1` es estrictamente menor que `value2`, un `int32` valor de 1 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1012">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="e8764-1013">En caso contrario, un `int32` el valor 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1013">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="e8764-1014">Números de punto flotante, `clt` devuelve 0 si los números están desordenados (es decir, si uno de los argumentos o ambos son NaN).</span><span class="sxs-lookup"><span data-stu-id="e8764-1014">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="e8764-1015">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `clt` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1015">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1016">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1016">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1017">Compara los valores sin signo o desordenados <paramref name="value1" /> y <paramref name="value2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1017">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span>
          </span>
          <span data-ttu-id="e8764-1018">Si <paramref name="value1" /> es menor que <paramref name="value2" />, se inserta en la pila de evaluación el valor entero 1 <see langword="(int32" />); en caso contrario, se inserta 0 (<see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1018">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1019">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1019">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1020">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1020">Format</span></span>|<span data-ttu-id="e8764-1021">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1021">Assembly Format</span></span>|<span data-ttu-id="e8764-1022">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1022">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1023">FE 05</span><span class="sxs-lookup"><span data-stu-id="e8764-1023">FE 05</span></span>|<span data-ttu-id="e8764-1024">clt.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1024">clt.un</span></span>|<span data-ttu-id="e8764-1025">Inserta 1 si `value1` es menor que `value2`; en caso contrario, inserta 0 (valores sin signo).</span><span class="sxs-lookup"><span data-stu-id="e8764-1025">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="e8764-1026">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1026">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1027">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1027">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1028">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1028">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-1029">`value2` y `value1` se extrae de la pila; `clt.un` comprueba si `value1` es menor que `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1029">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-1030">Si `value1` es menor que `value2`, 1 se inserta en la pila; en caso contrario, se inserta 0 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1030">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1031">El `clt.un` instrucción compara `value1` y `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1031">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="e8764-1032">Un `int32` valor de 1 se inserta en la pila si se cumple alguna de las siguientes acciones:</span><span class="sxs-lookup"><span data-stu-id="e8764-1032">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="e8764-1033">`value1` es estrictamente menor que `value2` (como para `clt`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1033">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="e8764-1034">Números de punto flotante, `value1` no está ordenado con respecto a `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1034">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="e8764-1035">Para los valores enteros, `value1` es estrictamente menor que `value2` cuando se consideran como números sin signo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1035">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="e8764-1036">En caso contrario, un `int32` el valor 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1036">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="e8764-1037">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `clt.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1039">Restringe el tipo en el que se realiza una llamada a método virtual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1039">Constrains the type on which a virtual method call is made.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1040">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1040">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1041">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1041">Format</span></span>|<span data-ttu-id="e8764-1042">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1042">Assembly Format</span></span>|<span data-ttu-id="e8764-1043">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1044">FE 16 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-1044">FE 16 < `T` ></span></span>|<span data-ttu-id="e8764-1045">restringido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1045">constrained.</span></span> `thisType`|<span data-ttu-id="e8764-1046">Llamada a un método virtual en un tipo restringido a ser de tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1046">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="e8764-1047">El `constrained` prefijo sólo se permite en un `callvirt` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1047">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="e8764-1048">El estado de la pila MSIL en este momento debe ser como sigue:</span><span class="sxs-lookup"><span data-stu-id="e8764-1048">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="e8764-1049">Un puntero administrado, `ptr`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1049">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="e8764-1050">El tipo de `ptr` debe ser un puntero administrado (`&`) a `thisType`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1050">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="e8764-1051">Tenga en cuenta que esto es diferente del caso de una instrucción máquina sin prefijo `callvirt` instrucción, lo que espera una referencia de `thisType`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1051">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="e8764-1052">Argumentos del método `arg1` a través de `argN` se insertan en la pila, al igual que con una instrucción máquina sin prefijo `callvirt` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1052">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="e8764-1053">El `constrained` prefijo está diseñado para permitir `callvirt` instrucciones que realizarse en una uniforme de forma independiente de si `thisType` es un tipo de valor o un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-1053">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="e8764-1054">Cuando un `callvirt` `method` ha prefijado una instrucción por `constrained` `thisType`, la instrucción se ejecuta como sigue:</span><span class="sxs-lookup"><span data-stu-id="e8764-1054">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="e8764-1055">Si `thisType` es un tipo de referencia (en lugar de un tipo de valor), a continuación, `ptr` se desreferencia y se pasa como el puntero 'this' a la `callvirt` de `method`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1055">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="e8764-1056">Si `thisType` es un tipo de valor y `thisType` implementa `method` , a continuación, `ptr` se pasa sin modificar como el puntero 'this' a un `call` `method` instrucciones para la implementación de `method` por `thisType`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1056">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="e8764-1057">Si `thisType` es un tipo de valor y `thisType` no implementa `method` , a continuación, `ptr` desreferenciar, una conversión boxing y se pasa como el puntero 'this' a la `callvirt` `method` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1057">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="e8764-1058">Puede producirse este último caso solo cuando `method` se definió en <xref:System.Object>, <xref:System.ValueType>, o <xref:System.Enum> y no se reemplaza por `thisType`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1058">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="e8764-1059">En este caso, la conversión boxing hace una copia del objeto original que se va a realizarse.</span><span class="sxs-lookup"><span data-stu-id="e8764-1059">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="e8764-1060">Sin embargo, dado que ninguno de los métodos de <xref:System.Object>, <xref:System.ValueType>, y <xref:System.Enum> modificar el estado del objeto, no se puede detectar este hecho.</span><span class="sxs-lookup"><span data-stu-id="e8764-1060">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="e8764-1061">El `constrained` prefijo es compatible con los generadores de IL que crean código genérico.</span><span class="sxs-lookup"><span data-stu-id="e8764-1061">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="e8764-1062">Normalmente el `callvirt` instrucción no es válida en tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-1062">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="e8764-1063">En su lugar, es necesario que los compiladores de lenguaje intermedio realizan de forma eficaz la transformación de 'this' se ha indicado anteriormente en tiempo de compilación, dependiendo del tipo de `ptr` y la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="e8764-1063">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="e8764-1064">Sin embargo, cuando `ptr` es un tipo genérico que se desconoce en tiempo de compilación, no es posible realizar esta transformación en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1064">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="e8764-1065">El `constrained` opcode permite que los compiladores de IL realizar una llamada a una función virtual en una uniforme forma independientemente de si `ptr` es un tipo de valor o un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-1065">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="e8764-1066">Aunque está previsto para el caso donde `thisType` es una variable de tipo genérico, la `constrained` prefijo también funciona para tipos no genéricos y puede reducir la complejidad de generar llamadas virtuales en lenguajes que ocultan la distinción entre tipos de valor y tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-1066">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="e8764-1067">Mediante el `constrained` prefijo también evita posibles problemas de versiones con tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-1067">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="e8764-1068">Si el `constrained` no se utiliza el prefijo, se debe emitir lenguaje intermedio diferente dependiendo de si un tipo de valor invalida un método de System.Object.</span><span class="sxs-lookup"><span data-stu-id="e8764-1068">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="e8764-1069">Por ejemplo, si un tipo de valor `V` invalida el método Object.ToString (), un `call` `V.ToString()` se emite una instrucción; si no es así, un `box` instrucción y un `callvirt` `Object.ToString()` se emite la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1069">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="e8764-1070">Puede surgir un problema de control de versiones en el primer caso, si más adelante se quita la invalidación y en el último caso si más tarde se agrega una invalidación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1070">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="e8764-1071">El `constrained` prefijo también se utiliza para la invocación de métodos de interfaz en tipos de valor, porque el método de tipo de valor implementa el método de interfaz se puede cambiar mediante un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1071">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="e8764-1072">Si el `constrained` no se utiliza el prefijo, el compilador se ve obligado a elegir qué del valor de los métodos del tipo para enlazar en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1072">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="e8764-1073">Mediante el `constrained` prefijo permite que el código MSIL enlazar con el método que implementa el método de interfaz en tiempo de ejecución, en lugar de en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1073">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="e8764-1074">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `constrained` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1074">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1075">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-1075">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1076">Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1076">Converts the value on top of the evaluation stack to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1077">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1077">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1078">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1078">Format</span></span>|<span data-ttu-id="e8764-1079">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1079">Assembly Format</span></span>|<span data-ttu-id="e8764-1080">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1080">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1081">D3</span><span class="sxs-lookup"><span data-stu-id="e8764-1081">D3</span></span>|<span data-ttu-id="e8764-1082">conv.i</span><span class="sxs-lookup"><span data-stu-id="e8764-1082">conv.i</span></span>|<span data-ttu-id="e8764-1083">Convertir en `native int`e inserta `native int` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1083">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1084">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1084">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1085">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1085">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1086">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1086">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1087">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1087">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1088">El `conv.i` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1088">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1089">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1089">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1090">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1090">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1091">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1091">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1092">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1092">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1093">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1093">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1094">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1094">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1095">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1095">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1096">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1096">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1097">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1097">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1098">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1098">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1099">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.i` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1099">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1100">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1100">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1101">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="int8" /> y luego lo extiende (lo rellena) hasta <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1101">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1102">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1102">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1103">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1103">Format</span></span>|<span data-ttu-id="e8764-1104">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1104">Assembly Format</span></span>|<span data-ttu-id="e8764-1105">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1105">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1106">67</span><span class="sxs-lookup"><span data-stu-id="e8764-1106">67</span></span>|<span data-ttu-id="e8764-1107">conv.i1</span><span class="sxs-lookup"><span data-stu-id="e8764-1107">conv.i1</span></span>|<span data-ttu-id="e8764-1108">Convertir en `int8`e inserta `int32` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1108">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1109">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1109">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1110">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1110">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1111">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1111">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1112">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1112">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1113">El `conv.i1` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1113">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1114">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1114">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1115">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1115">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1116">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1116">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1117">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1117">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1118">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1118">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1119">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1119">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1120">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1120">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1121">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1121">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1122">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1122">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1123">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1123">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1124">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.i1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1124">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1125">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1125">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1126">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="int16" /> y luego lo extiende (lo rellena) hasta <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1126">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1127">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1127">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1128">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1128">Format</span></span>|<span data-ttu-id="e8764-1129">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1129">Assembly Format</span></span>|<span data-ttu-id="e8764-1130">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1130">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1131">68</span><span class="sxs-lookup"><span data-stu-id="e8764-1131">68</span></span>|<span data-ttu-id="e8764-1132">conv.i2</span><span class="sxs-lookup"><span data-stu-id="e8764-1132">conv.i2</span></span>|<span data-ttu-id="e8764-1133">Convertir en `int16`e inserta `int32` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1133">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1134">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1134">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1135">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1135">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1136">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1136">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1137">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1137">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1138">El `conv.i2` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1138">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1139">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1139">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1140">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1140">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1141">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1141">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1142">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1142">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1143">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1143">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1144">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1144">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1145">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1145">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1146">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1146">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1147">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1147">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1148">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1148">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1149">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.i2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1149">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1150">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1150">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1151">Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1151">Converts the value on top of the evaluation stack to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1152">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1152">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1153">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1153">Format</span></span>|<span data-ttu-id="e8764-1154">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1154">Assembly Format</span></span>|<span data-ttu-id="e8764-1155">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1155">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1156">69</span><span class="sxs-lookup"><span data-stu-id="e8764-1156">69</span></span>|<span data-ttu-id="e8764-1157">conv.i4</span><span class="sxs-lookup"><span data-stu-id="e8764-1157">conv.i4</span></span>|<span data-ttu-id="e8764-1158">Convertir en `int32`e inserta `int32` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1158">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1159">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1159">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1160">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1160">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1161">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1161">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1162">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1162">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1163">El `conv.i4` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1163">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1164">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1164">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1165">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1165">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1166">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1166">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1167">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1167">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1168">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1168">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1169">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1169">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1170">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1170">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1171">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1171">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1172">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1172">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1173">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1173">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1174">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1175">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1175">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1176">Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1176">Converts the value on top of the evaluation stack to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1177">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1178">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1178">Format</span></span>|<span data-ttu-id="e8764-1179">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1179">Assembly Format</span></span>|<span data-ttu-id="e8764-1180">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1181">6A</span><span class="sxs-lookup"><span data-stu-id="e8764-1181">6A</span></span>|<span data-ttu-id="e8764-1182">conv.i8</span><span class="sxs-lookup"><span data-stu-id="e8764-1182">conv.i8</span></span>|<span data-ttu-id="e8764-1183">Convertir en `int64`e inserta `int64` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1183">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1184">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1185">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1185">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1186">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1186">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1187">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1187">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1188">El `conv.i8` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1188">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1189">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1189">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1190">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1190">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1191">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1191">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1192">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1192">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1193">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1193">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1194">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1194">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1195">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1195">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1196">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1196">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1197">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1197">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1198">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1198">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1199">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1201">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="native int" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1201">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1202">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1203">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1203">Format</span></span>|<span data-ttu-id="e8764-1204">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1204">Assembly Format</span></span>|<span data-ttu-id="e8764-1205">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1206">D4</span><span class="sxs-lookup"><span data-stu-id="e8764-1206">D4</span></span>|<span data-ttu-id="e8764-1207">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="e8764-1207">conv.ovf.i</span></span>|<span data-ttu-id="e8764-1208">Convertir en un `native int` (en la pila como `native int`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1208">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1209">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1210">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1210">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1211">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1211">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1212">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1212">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1213">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1213">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1214">El `conv.ovf.i` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1214">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1215">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1215">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1216">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1216">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1217">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1217">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1218"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1218"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1219">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1219">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1220">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1220">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1221">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="native int" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1221">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1222">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1222">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1223">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1223">Format</span></span>|<span data-ttu-id="e8764-1224">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1224">Assembly Format</span></span>|<span data-ttu-id="e8764-1225">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1225">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1226">8A</span><span class="sxs-lookup"><span data-stu-id="e8764-1226">8A</span></span>|<span data-ttu-id="e8764-1227">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1227">conv.ovf.i.un</span></span>|<span data-ttu-id="e8764-1228">Convierte un valor sin signo en un `native int` (en la pila como `native int`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1228">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1229">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1229">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1230">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1230">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1231">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1231">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1232">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1232">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1233">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1233">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1234">El `conv.ovf.i.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1234">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1235">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1235">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1236">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1236">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1237">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1237">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1238"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1238"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1239">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1240">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1240">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1241">Convierte el valor con signo situado en la parte superior de la pila de evaluación en un <see langword="int8" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1241">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1242">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1242">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1243">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1243">Format</span></span>|<span data-ttu-id="e8764-1244">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1244">Assembly Format</span></span>|<span data-ttu-id="e8764-1245">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1245">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1246">B3</span><span class="sxs-lookup"><span data-stu-id="e8764-1246">B3</span></span>|<span data-ttu-id="e8764-1247">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="e8764-1247">conv.ovf.i1</span></span>|<span data-ttu-id="e8764-1248">Convertir en un `int8` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1248">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1249">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1249">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1250">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1250">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1251">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1251">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1252">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1252">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1253">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1253">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1254">El `conv.ovf.i1` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1254">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1255">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1255">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1256">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1256">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1257">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1257">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1258"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1258"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1259">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1260">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1260">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1261">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en un <see langword="int8" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1261">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1262">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1263">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1263">Format</span></span>|<span data-ttu-id="e8764-1264">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1264">Assembly Format</span></span>|<span data-ttu-id="e8764-1265">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1266">82</span><span class="sxs-lookup"><span data-stu-id="e8764-1266">82</span></span>|<span data-ttu-id="e8764-1267">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1267">conv.ovf.i1.un</span></span>|<span data-ttu-id="e8764-1268">Convierte un valor sin signo en un `int8` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1268">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1269">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1269">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1270">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1270">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1271">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1271">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1272">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1272">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1273">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1273">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1274">El `conv.ovf.i1.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1274">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1275">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1275">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1276">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1276">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1277">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1277">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1278"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1278"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1279">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i1.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1281">Convierte el valor con signo situado en la parte superior de la pila de evaluación en un <see langword="int16" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1281">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1282">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1283">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1283">Format</span></span>|<span data-ttu-id="e8764-1284">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1284">Assembly Format</span></span>|<span data-ttu-id="e8764-1285">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1286">B5</span><span class="sxs-lookup"><span data-stu-id="e8764-1286">B5</span></span>|<span data-ttu-id="e8764-1287">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="e8764-1287">conv.ovf.i2</span></span>|<span data-ttu-id="e8764-1288">Convertir en un `int16` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1288">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1289">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1290">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1290">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1291">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1291">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1292">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1292">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1293">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1293">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1294">El `conv.ovf.i2` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1294">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1295">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1295">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1296">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1296">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1297">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1297">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1298"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1298"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1299">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1299">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1300">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1300">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1301">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en un <see langword="int16" /> con signo, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1301">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1302">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1302">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1303">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1303">Format</span></span>|<span data-ttu-id="e8764-1304">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1304">Assembly Format</span></span>|<span data-ttu-id="e8764-1305">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1305">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1306">83</span><span class="sxs-lookup"><span data-stu-id="e8764-1306">83</span></span>|<span data-ttu-id="e8764-1307">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1307">conv.ovf.i2.un</span></span>|<span data-ttu-id="e8764-1308">Convierte un valor sin signo en un `int16` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1308">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1309">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1309">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1310">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1310">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1311">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1311">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1312">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1312">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1313">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1313">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1314">El `conv.ovf.i2.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1314">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1315">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1315">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1316">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1316">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1317">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1317">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1318"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1318"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1319">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i2.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1319">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1320">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1320">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1321">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1321">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1322">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1322">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1323">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1323">Format</span></span>|<span data-ttu-id="e8764-1324">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1324">Assembly Format</span></span>|<span data-ttu-id="e8764-1325">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1325">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1326">B7</span><span class="sxs-lookup"><span data-stu-id="e8764-1326">B7</span></span>|<span data-ttu-id="e8764-1327">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="e8764-1327">conv.ovf.i4</span></span>|<span data-ttu-id="e8764-1328">Convertir en un `int32` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1328">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1329">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1329">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1330">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1330">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1331">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1331">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1332">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1332">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1333">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1333">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1334">El `conv.ovf.i4` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1334">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1335">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1335">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1336">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1336">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1337">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1337">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1338"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1338"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1339">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1339">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1340">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1340">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1341">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1341">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1342">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1342">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1343">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1343">Format</span></span>|<span data-ttu-id="e8764-1344">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1344">Assembly Format</span></span>|<span data-ttu-id="e8764-1345">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1345">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1346">84</span><span class="sxs-lookup"><span data-stu-id="e8764-1346">84</span></span>|<span data-ttu-id="e8764-1347">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1347">conv.ovf.i4.un</span></span>|<span data-ttu-id="e8764-1348">Convierte un valor sin signo en un `int32` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1348">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1349">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1349">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1350">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1350">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1351">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1351">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1352">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1352">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1353">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1353">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1354">El `conv.ovf.i4.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1354">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1355">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1355">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1356">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1356">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1357">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1357">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1358"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1358"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1359">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i4.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1360">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1360">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1361">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="int64" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1361">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1362">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1363">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1363">Format</span></span>|<span data-ttu-id="e8764-1364">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1364">Assembly Format</span></span>|<span data-ttu-id="e8764-1365">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1366">B9</span><span class="sxs-lookup"><span data-stu-id="e8764-1366">B9</span></span>|<span data-ttu-id="e8764-1367">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="e8764-1367">conv.ovf.i8</span></span>|<span data-ttu-id="e8764-1368">Convertir en un `int64` (en la pila como `int64`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1368">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1369">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1370">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1370">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1371">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1371">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1372">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1372">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1373">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1373">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1374">El `conv.ovf.i8` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1374">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1375">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1375">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1376">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1376">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1377">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1377">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1378"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1378"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1379">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1379">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1380">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1380">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1381">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="int64" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1381">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1382">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1382">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1383">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1383">Format</span></span>|<span data-ttu-id="e8764-1384">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1384">Assembly Format</span></span>|<span data-ttu-id="e8764-1385">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1385">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1386">85</span><span class="sxs-lookup"><span data-stu-id="e8764-1386">85</span></span>|<span data-ttu-id="e8764-1387">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1387">conv.ovf.i8.un</span></span>|<span data-ttu-id="e8764-1388">Convierte un valor sin signo en un `int64` (en la pila como `int64`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1388">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1389">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1389">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1390">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1390">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1391">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1391">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1392">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1392">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1393">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1393">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1394">El `conv.ovf.i8.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1394">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1395">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1395">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1396">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1396">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1397">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1397">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1398"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1398"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1399">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.i8.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1399">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1400">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1400">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1401">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned native int" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1401">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1402">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1402">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1403">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1403">Format</span></span>|<span data-ttu-id="e8764-1404">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1404">Assembly Format</span></span>|<span data-ttu-id="e8764-1405">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1405">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1406">D5</span><span class="sxs-lookup"><span data-stu-id="e8764-1406">D5</span></span>|<span data-ttu-id="e8764-1407">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="e8764-1407">conv.ovf.u</span></span>|<span data-ttu-id="e8764-1408">Convertir en un `unsigned native int` (en la pila como `native int`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1408">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1409">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1409">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1410">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1410">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1411">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1411">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1412">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1412">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1413">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1413">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1414">El `conv.ovf.u` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1414">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1415">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1415">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1416">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1416">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1417">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1417">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1418"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1418"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1419">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1419">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1420">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1420">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1421">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned native int" /> y produce <see cref="T:System.OverflowException" /> en caso de desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1421">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1422">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1422">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1423">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1423">Format</span></span>|<span data-ttu-id="e8764-1424">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1424">Assembly Format</span></span>|<span data-ttu-id="e8764-1425">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1425">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1426">8B</span><span class="sxs-lookup"><span data-stu-id="e8764-1426">8B</span></span>|<span data-ttu-id="e8764-1427">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1427">conv.ovf.u.un</span></span>|<span data-ttu-id="e8764-1428">Convierte un valor sin signo en un `unsigned native int` (en la pila como `native int`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1428">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1429">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1429">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1430">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1430">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1431">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1431">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1432">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1432">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1433">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1433">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1434">El `conv.ovf.u.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1434">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1435">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1435">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1436">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1436">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1437">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1437">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1438"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1438"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1439">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.uvf.u.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1439">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1440">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1440">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1441">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int8" />, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1441">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1442">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1442">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1443">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1443">Format</span></span>|<span data-ttu-id="e8764-1444">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1444">Assembly Format</span></span>|<span data-ttu-id="e8764-1445">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1445">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1446">B4</span><span class="sxs-lookup"><span data-stu-id="e8764-1446">B4</span></span>|<span data-ttu-id="e8764-1447">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="e8764-1447">conv.ovf.u1</span></span>|<span data-ttu-id="e8764-1448">Convertir en un `unsigned int8` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1448">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1449">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1449">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1450">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1450">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1451">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1451">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1452">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1452">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1453">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1453">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1454">El `conv.ovf.u1` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1454">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1455">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1455">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1456">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1456">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1457">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1457">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1458"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1458"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1459">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1460">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1461">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int8" />, lo extiende hasta <see langword="int32" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1461">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1462">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1463">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1463">Format</span></span>|<span data-ttu-id="e8764-1464">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1464">Assembly Format</span></span>|<span data-ttu-id="e8764-1465">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1466">86</span><span class="sxs-lookup"><span data-stu-id="e8764-1466">86</span></span>|<span data-ttu-id="e8764-1467">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1467">conv.ovf.u1.un</span></span>|<span data-ttu-id="e8764-1468">Convierte un valor sin signo en un `unsigned int8` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1468">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1469">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1470">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1470">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1471">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1471">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1472">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1472">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1473">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1473">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1474">El `conv.ovf.u1.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1474">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1475">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1475">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1476">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1476">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1477">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1477">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1478"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1478"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1479">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u1.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1479">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1480">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1480">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1481">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int16" />, lo extiende hasta <see langword="int32" /> y produce <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1481">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1482">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1482">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1483">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1483">Format</span></span>|<span data-ttu-id="e8764-1484">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1484">Assembly Format</span></span>|<span data-ttu-id="e8764-1485">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1485">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1486">B6</span><span class="sxs-lookup"><span data-stu-id="e8764-1486">B6</span></span>|<span data-ttu-id="e8764-1487">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="e8764-1487">conv.ovf.u2</span></span>|<span data-ttu-id="e8764-1488">Convertir en un `unsigned int16` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1488">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1489">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1489">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1490">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1490">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1491">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1491">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1492">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1492">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1493">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1493">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1494">El `conv.ovf.u2` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1494">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1495">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1495">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1496">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1496">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1497">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1497">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1498"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1498"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1499">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1500">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1500">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1501">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int16" />, lo extiende hasta <see langword="int32" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1501">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1502">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1503">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1503">Format</span></span>|<span data-ttu-id="e8764-1504">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1504">Assembly Format</span></span>|<span data-ttu-id="e8764-1505">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1506">87</span><span class="sxs-lookup"><span data-stu-id="e8764-1506">87</span></span>|<span data-ttu-id="e8764-1507">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1507">conv.ovf.u2.un</span></span>|<span data-ttu-id="e8764-1508">Convierte un valor sin signo en un `unsigned int16` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1508">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1509">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1510">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1510">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1511">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1511">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1512">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1512">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1513">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1513">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1514">El `conv.ovf.u2.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1514">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1515">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1515">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1516">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1516">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1517">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1517">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1518"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1518"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1519">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u2.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1519">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1520">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1520">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1521">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int32" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1521">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1522">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1522">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1523">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1523">Format</span></span>|<span data-ttu-id="e8764-1524">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1524">Assembly Format</span></span>|<span data-ttu-id="e8764-1525">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1525">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1526">B8</span><span class="sxs-lookup"><span data-stu-id="e8764-1526">B8</span></span>|<span data-ttu-id="e8764-1527">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="e8764-1527">conv.ovf.u4</span></span>|<span data-ttu-id="e8764-1528">Convertir en un `unsigned int32` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1528">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1529">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1529">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1530">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1530">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1531">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1531">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1532">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1532">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1533">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1533">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1534">El `conv.ovf.u4` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1534">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1535">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1535">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1536">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1536">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1537">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1537">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1538"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1538"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1539">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1539">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1540">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1540">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1541">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int32" /> y produce <see cref="T:System.OverflowException" /> en caso de desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1541">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1542">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1542">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1543">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1543">Format</span></span>|<span data-ttu-id="e8764-1544">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1544">Assembly Format</span></span>|<span data-ttu-id="e8764-1545">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1545">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1546">88</span><span class="sxs-lookup"><span data-stu-id="e8764-1546">88</span></span>|<span data-ttu-id="e8764-1547">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1547">conv.ovf.u4.un</span></span>|<span data-ttu-id="e8764-1548">Convierte un valor sin signo en un `unsigned int32` (en la pila como `int32`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1548">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1549">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1549">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1550">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1550">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1551">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1551">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1552">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1552">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1553">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1553">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1554">El `conv.ovf.u4.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1554">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1555">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1555">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1556">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1556">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1557">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1557">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1558"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1558"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1559">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u4.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1559">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1560">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1560">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1561">Convierte el valor con signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int64" /> e inicia <see cref="T:System.OverflowException" /> si se produce desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1561">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1562">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1562">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1563">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1563">Format</span></span>|<span data-ttu-id="e8764-1564">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1564">Assembly Format</span></span>|<span data-ttu-id="e8764-1565">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1565">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1566">BA</span><span class="sxs-lookup"><span data-stu-id="e8764-1566">BA</span></span>|<span data-ttu-id="e8764-1567">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="e8764-1567">conv.ovf.u8</span></span>|<span data-ttu-id="e8764-1568">Convertir en un `unsigned int64` (en la pila como `int64`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1568">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1569">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1569">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1570">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1570">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1571">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1571">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1572">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1572">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1573">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1573">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1574">El `conv.ovf.u8` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1574">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1575">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1575">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1576">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1576">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1577">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1577">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1578"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1578"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1579">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1579">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1580">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1580">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1581">Convierte el valor sin signo situado en la parte superior de la pila de evaluación en <see langword="unsigned int64" /> y produce <see cref="T:System.OverflowException" /> en caso de desbordamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1581">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1582">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1582">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1583">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1583">Format</span></span>|<span data-ttu-id="e8764-1584">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1584">Assembly Format</span></span>|<span data-ttu-id="e8764-1585">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1585">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1586">89</span><span class="sxs-lookup"><span data-stu-id="e8764-1586">89</span></span>|<span data-ttu-id="e8764-1587">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1587">conv.ovf.u8.un</span></span>|<span data-ttu-id="e8764-1588">Convierte un valor sin signo en un `unsigned int64` (en la pila como `int64`) e inicia una excepción si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-1588">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="e8764-1589">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1589">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1590">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1590">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1591">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1591">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="e8764-1592">Si se produce desbordamiento, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1592">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="e8764-1593">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1593">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1594">El `conv.ovf.u8.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y coloca ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1594">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1595">Si el valor es demasiado grande o demasiado pequeño para representarlo mediante el tipo de destino, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1595">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="e8764-1596">Las conversiones de números de punto flotante en valores enteros truncan el número hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1596">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="e8764-1597">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.ovf.i` o `conv.ovf.u` se usan, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1597">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="e8764-1598"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1598"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-1599">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.ovf.u8.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1599">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1600">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1600">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1601">Convierte el valor entero sin signo situado en la parte superior de la pila de evaluación en <see langword="float32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1601">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1602">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1602">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1603">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1603">Format</span></span>|<span data-ttu-id="e8764-1604">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1604">Assembly Format</span></span>|<span data-ttu-id="e8764-1605">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1605">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1606">76</span><span class="sxs-lookup"><span data-stu-id="e8764-1606">76</span></span>|<span data-ttu-id="e8764-1607">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1607">conv.r.un</span></span>|<span data-ttu-id="e8764-1608">Convert entero sin signo en punto flotante, insertar `F` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1608">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1609">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1609">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1610">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1610">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1611">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1611">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1612">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1612">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1613">El `conv.r.un` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1613">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1614">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1614">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1615">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1615">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1616">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1616">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1617">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1617">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1618">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1618">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1619">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1619">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1620">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1620">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1621">Si se produce desbordamiento al convertir un tipo de punto flotante en un entero de la `result` devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1621">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="e8764-1622">El `conv.r.un` operación toma un entero de la pila, lo interpreta como valor sin signo y lo reemplaza con un número de punto flotante para representar el entero: ya sea un `float32`, si esto es lo suficientemente ancha para representar el entero sin pérdida de precisión, o bien un `float64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1622">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="e8764-1623">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1623">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="e8764-1624">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.r.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1626">Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="float32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1626">Converts the value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1627">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1628">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1628">Format</span></span>|<span data-ttu-id="e8764-1629">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1629">Assembly Format</span></span>|<span data-ttu-id="e8764-1630">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1631">6B</span><span class="sxs-lookup"><span data-stu-id="e8764-1631">6B</span></span>|<span data-ttu-id="e8764-1632">conv.r4</span><span class="sxs-lookup"><span data-stu-id="e8764-1632">conv.r4</span></span>|<span data-ttu-id="e8764-1633">Convertir en `float32`e inserta `F` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1633">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1634">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1635">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1635">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1636">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1636">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1637">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1637">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1638">El `conv.r4` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1638">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1639">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1639">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1640">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1640">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1641">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1641">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1642">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1642">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1643">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1643">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1644">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1644">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1645">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1645">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1646">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1646">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1647">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1647">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="e8764-1648">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.r4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1648">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1649">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1649">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1650">Convierte el valor situado en la parte superior de la pila de evaluación en <see langword="float64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1650">Converts the value on top of the evaluation stack to <see langword="float64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1651">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1651">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1652">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1652">Format</span></span>|<span data-ttu-id="e8764-1653">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1653">Assembly Format</span></span>|<span data-ttu-id="e8764-1654">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1654">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1655">6C</span><span class="sxs-lookup"><span data-stu-id="e8764-1655">6C</span></span>|<span data-ttu-id="e8764-1656">conv.r8</span><span class="sxs-lookup"><span data-stu-id="e8764-1656">conv.r8</span></span>|<span data-ttu-id="e8764-1657">Convertir en `float64`e inserta `F` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1657">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1658">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1658">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1659">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1659">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1660">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1660">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1661">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1661">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1662">El `conv.r8` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1662">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1663">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1663">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1664">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1664">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1665">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1665">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1666">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1666">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1667">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1667">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1668">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1668">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1669">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1669">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1670">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1670">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1671">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1671">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="e8764-1672">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.r8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1672">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1673">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1673">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1674">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned native int" /> y lo extiende hasta <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1674">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1675">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1675">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1676">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1676">Format</span></span>|<span data-ttu-id="e8764-1677">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1677">Assembly Format</span></span>|<span data-ttu-id="e8764-1678">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1678">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1679">E0</span><span class="sxs-lookup"><span data-stu-id="e8764-1679">E0</span></span>|<span data-ttu-id="e8764-1680">conv.u</span><span class="sxs-lookup"><span data-stu-id="e8764-1680">conv.u</span></span>|<span data-ttu-id="e8764-1681">Convertir en `unsigned native int`e inserta `native int` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1681">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1682">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1682">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1683">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1683">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1684">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1684">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1685">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1685">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1686">El `conv.u` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1686">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1687">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1687">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1688">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1688">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1689">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1689">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1690">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1690">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1691">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1691">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1692">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1692">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1693">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1693">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1694">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1694">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1695">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1695">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1696">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1696">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1697">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.u` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1699">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int8" /> y lo extiende hasta <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1699">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1700">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1701">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1701">Format</span></span>|<span data-ttu-id="e8764-1702">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1702">Assembly Format</span></span>|<span data-ttu-id="e8764-1703">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1704">D2</span><span class="sxs-lookup"><span data-stu-id="e8764-1704">D2</span></span>|<span data-ttu-id="e8764-1705">conv.U1</span><span class="sxs-lookup"><span data-stu-id="e8764-1705">conv.u1</span></span>|<span data-ttu-id="e8764-1706">Convertir en `int8`e inserta `int32` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1706">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1707">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1708">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1708">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1709">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1709">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1710">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1710">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1711">El `conv.u1` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1711">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1712">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1712">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1713">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1713">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1714">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1714">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1715">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1715">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1716">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1716">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1717">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1717">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1718">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1718">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1719">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1719">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1720">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1720">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1721">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1721">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1722">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.u1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1723">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1723">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1724">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int16" /> y lo extiende hasta <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1724">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1725">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1726">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1726">Format</span></span>|<span data-ttu-id="e8764-1727">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1727">Assembly Format</span></span>|<span data-ttu-id="e8764-1728">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1729">D1</span><span class="sxs-lookup"><span data-stu-id="e8764-1729">D1</span></span>|<span data-ttu-id="e8764-1730">conv.u2</span><span class="sxs-lookup"><span data-stu-id="e8764-1730">conv.u2</span></span>|<span data-ttu-id="e8764-1731">Convertir en `int16`e inserta `int32` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1731">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1732">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1733">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1733">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1734">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1734">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1735">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1735">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1736">El `conv.u2` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1736">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1737">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1737">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1738">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1738">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1739">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1739">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1740">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1740">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1741">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1741">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1742">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1742">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1743">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1743">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1744">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1744">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1745">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1745">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1746">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1746">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1747">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.u2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1747">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1748">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1748">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1749">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int32" /> y lo extiende hasta <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1749">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1750">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1750">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1751">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1751">Format</span></span>|<span data-ttu-id="e8764-1752">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1752">Assembly Format</span></span>|<span data-ttu-id="e8764-1753">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1753">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1754">6D</span><span class="sxs-lookup"><span data-stu-id="e8764-1754">6D</span></span>|<span data-ttu-id="e8764-1755">conv.u4</span><span class="sxs-lookup"><span data-stu-id="e8764-1755">conv.u4</span></span>|<span data-ttu-id="e8764-1756">Convertir en `unsigned int32`e inserta `int32` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1756">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1757">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1757">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1758">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1758">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1759">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1759">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1760">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1760">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1761">El `conv.u4` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1761">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1762">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1762">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1763">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1763">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1764">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1764">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1765">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1765">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1766">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1766">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1767">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1767">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1768">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1768">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1769">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1769">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1770">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1770">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1771">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1771">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1772">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.u4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1772">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1773">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1773">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1774">Convierte el valor que se encuentra en la parte superior de la pila de evaluación en <see langword="unsigned int64" /> y lo extiende hasta <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1774">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1775">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1775">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1776">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1776">Format</span></span>|<span data-ttu-id="e8764-1777">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1777">Assembly Format</span></span>|<span data-ttu-id="e8764-1778">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1778">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1779">6E</span><span class="sxs-lookup"><span data-stu-id="e8764-1779">6E</span></span>|<span data-ttu-id="e8764-1780">conv.u8</span><span class="sxs-lookup"><span data-stu-id="e8764-1780">conv.u8</span></span>|<span data-ttu-id="e8764-1781">Convertir en `int64`e inserta `int64` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1781">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="e8764-1782">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1782">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1783">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1783">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1784">`value` se extrae de la pila y la conversión se intenta la operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1784">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="e8764-1785">Si la conversión se realiza correctamente, el valor resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1785">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1786">El `conv.u8` código de operación convierte el `value` encima de la pila en el tipo especificado en el código de operación y deja ese valor en la parte superior de la pila convertido.</span><span class="sxs-lookup"><span data-stu-id="e8764-1786">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="e8764-1787">Los valores enteros de menos de 4 bytes se extienden a `int32` cuando se cargan en la pila de evaluación (a menos que `conv.i` o `conv.u` se utiliza, en cuyo caso el resultado también es `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1787">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="e8764-1788">Valores de punto flotante se convierten en el `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1788">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="e8764-1789">Conversión de números de punto flotante a valores enteros trunca el número en cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1789">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="e8764-1790">Al convertir de un `float64` a un `float32`, se puede perder precisión.</span><span class="sxs-lookup"><span data-stu-id="e8764-1790">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="e8764-1791">Si `value` es demasiado grande para caber en un `float32 (F)`, infinito positivo (si `value` es positivo) o infinito negativo (si `value` es negativo) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1791">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="e8764-1792">En caso de desbordamiento de convertir un tipo de entero a otro, se truncan los bits de orden superior.</span><span class="sxs-lookup"><span data-stu-id="e8764-1792">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="e8764-1793">Si el resultado es menor que un `int32`, el valor es la extensión de signo para rellenar la ranura.</span><span class="sxs-lookup"><span data-stu-id="e8764-1793">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="e8764-1794">Si se produce desbordamiento al convertir a un tipo de punto flotante en un entero, el valor devuelto no está especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1794">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="e8764-1795">Nunca se produce ninguna excepción cuando se utiliza este campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1795">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="e8764-1796">Vea <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> y <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obtener instrucciones máquina equivalentes que se iniciará una excepción cuando el tipo de resultado no representa correctamente el valor del resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1796">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="e8764-1797">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `conv.u8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1797">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1798">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1798">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1799">Copia un número de bytes especificado de una dirección de origen en una dirección de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1799">Copies a specified number bytes from a source address to a destination address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1800">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1800">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1801">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1801">Format</span></span>|<span data-ttu-id="e8764-1802">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1802">Assembly Format</span></span>|<span data-ttu-id="e8764-1803">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1803">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1804">FE 17</span><span class="sxs-lookup"><span data-stu-id="e8764-1804">FE 17</span></span>|<span data-ttu-id="e8764-1805">cpblk</span><span class="sxs-lookup"><span data-stu-id="e8764-1805">cpblk</span></span>|<span data-ttu-id="e8764-1806">Copiar datos desde un bloque de memoria a otro.</span><span class="sxs-lookup"><span data-stu-id="e8764-1806">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="e8764-1807">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1807">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1808">La dirección de destino se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1808">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1809">La dirección de origen se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1809">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-1810">El número de bytes que se va a copiar se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1810">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-1811">El número de bytes, la dirección de origen y la dirección de destino se extrae de la pila; el número especificado de bytes se copia desde la dirección de origen en la dirección de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-1811">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="e8764-1812">El `cpblk` instrucción copia un número (tipo `unsigned int32`) de bytes a partir de una dirección de origen (de tipo `*`, `native int`, o `&`) a una dirección de destino (de tipo `*`, `native int`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1812">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="e8764-1813">El comportamiento de `cpblk` se especifica si las áreas de origen y de destino se superponen.</span><span class="sxs-lookup"><span data-stu-id="e8764-1813">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="e8764-1814">`cpblk` se da por supuesto que el origen y el destino direccionado se alinean con el tamaño natural de la máquina.</span><span class="sxs-lookup"><span data-stu-id="e8764-1814">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="e8764-1815">El `cpblk` instrucción puede ir precedida inmediatamente el `unaligned.<prefix>` instrucción para indicar que el origen o el destino está desalineado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1815">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="e8764-1816">La operación de la `cpblk` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1816">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-1817"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-1817"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-1818">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `cpblk` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1819">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1820">Copia el tipo de valor situado en la dirección de un objeto (de tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" />) en la dirección del objeto de destino (de tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1820">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1821">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1822">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1822">Format</span></span>|<span data-ttu-id="e8764-1823">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1823">Assembly Format</span></span>|<span data-ttu-id="e8764-1824">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1825">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-1825">70 < `T` ></span></span>|<span data-ttu-id="e8764-1826">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="e8764-1826">cpobj `classTok`</span></span>|<span data-ttu-id="e8764-1827">Copia un valor de tipo de un objeto de origen a un objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-1827">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="e8764-1828">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1829">La referencia de objeto de destino se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1829">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1830">La referencia de objeto de origen se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1830">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-1831">Las referencias a dos objetos se extraen de la pila; el tipo de valor en la dirección del objeto de origen se copia a la dirección del objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-1831">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="e8764-1832">El comportamiento de `cpobj` no se especifica si las referencias no son punteros a instancias de la clase representado por el token de clase de objeto de origen y destino `classTok` (un `typeref` o `typedef`), o si `classTok` no representa un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-1832">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="e8764-1833"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-1833"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-1834">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `cpobj` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1834">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1835">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-1835">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1836">Divide dos valores e inserta el resultado como punto flotante (de tipo <see langword="F" />) o cociente (de tipo <see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1836">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1837">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1837">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1838">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1838">Format</span></span>|<span data-ttu-id="e8764-1839">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1839">Assembly Format</span></span>|<span data-ttu-id="e8764-1840">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1840">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1841">5B</span><span class="sxs-lookup"><span data-stu-id="e8764-1841">5B</span></span>|<span data-ttu-id="e8764-1842">div</span><span class="sxs-lookup"><span data-stu-id="e8764-1842">div</span></span>|<span data-ttu-id="e8764-1843">Divide dos valores para devolver un resultado de punto flotante o cociente.</span><span class="sxs-lookup"><span data-stu-id="e8764-1843">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="e8764-1844">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1844">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1845">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1845">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1846">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1846">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-1847">`value2` y `value1` se extrae de la pila; `value1` se divide por `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1847">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-1848">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1848">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1849">`result` = `value1` div value2 cumple las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="e8764-1849">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="e8764-1850">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, y:</span><span class="sxs-lookup"><span data-stu-id="e8764-1850">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="e8764-1851">inicio de sesión (`result`) = +, if firmar (`value1`) = el inicio de sesión (`value2`), o - si inicio de sesión (`value1`) ~ = inicio de sesión (`value2`)</span><span class="sxs-lookup"><span data-stu-id="e8764-1851">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="e8764-1852">El `div` instrucción calcula el resultado y lo inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1852">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="e8764-1853">División de enteros se trunca hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1853">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="e8764-1854">División de un número finito por cero genera el valor infinito firmado correctamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-1854">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="e8764-1855">Dividir cero entre cero o infinito por infinito, se obtiene el valor NaN (no-un-número).</span><span class="sxs-lookup"><span data-stu-id="e8764-1855">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="e8764-1856">Cualquier número dividido entre infinito generará un valor de cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1856">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="e8764-1857">Las operaciones integrales inician <xref:System.ArithmeticException> si el resultado no se puede representar en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1857">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="e8764-1858">Esto puede suceder si `value1` es el valor negativo máximo, y `value2` es -1.</span><span class="sxs-lookup"><span data-stu-id="e8764-1858">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="e8764-1859">Las operaciones integrales inician <xref:System.DivideByZeroException> si `value2` es cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-1859">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="e8764-1860">Tenga en cuenta que en plataformas basadas en Intel en un <xref:System.OverflowException> se produce al calcular (minint div -1).</span><span class="sxs-lookup"><span data-stu-id="e8764-1860">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="e8764-1861">Operaciones de punto flotante nunca producen una excepción (que generan valores NaN o infinitos en su lugar).</span><span class="sxs-lookup"><span data-stu-id="e8764-1861">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="e8764-1862">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `div` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1862">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1863">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1863">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1864">Divide dos valores enteros sin signo e inserta el resultado (<see langword="int32" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1864">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1865">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1865">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1866">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1866">Format</span></span>|<span data-ttu-id="e8764-1867">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1867">Assembly Format</span></span>|<span data-ttu-id="e8764-1868">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1868">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1869">5C</span><span class="sxs-lookup"><span data-stu-id="e8764-1869">5C</span></span>|<span data-ttu-id="e8764-1870">div.un</span><span class="sxs-lookup"><span data-stu-id="e8764-1870">div.un</span></span>|<span data-ttu-id="e8764-1871">Divide dos valores sin signo y devuelve un cociente.</span><span class="sxs-lookup"><span data-stu-id="e8764-1871">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="e8764-1872">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1872">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1873">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1873">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1874">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1874">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-1875">`value2` y `value1` se extrae de la pila; `value1` se divide por `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1875">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-1876">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1876">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1877">El `div.un` instrucción calcula `value1` dividido por `value2`, ambos como enteros sin signo e inserta el `result` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1877">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="e8764-1878">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `div.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1878">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1879">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1879">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1880">Copia el valor que se encuentra en la parte superior de la pila de evaluación e inserta la copia en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1880">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1881">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1881">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1882">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1882">Format</span></span>|<span data-ttu-id="e8764-1883">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1883">Assembly Format</span></span>|<span data-ttu-id="e8764-1884">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1884">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1885">25</span><span class="sxs-lookup"><span data-stu-id="e8764-1885">25</span></span>|<span data-ttu-id="e8764-1886">dup</span><span class="sxs-lookup"><span data-stu-id="e8764-1886">dup</span></span>|<span data-ttu-id="e8764-1887">Duplica el valor en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1887">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="e8764-1888">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1888">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1889">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1889">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1890">`value` se extrae de la pila para la duplicación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1890">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="e8764-1891">`value` se vuelve a insertar en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1891">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-1892">Un valor duplicado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1892">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1893">El `dup` instrucción duplica el elemento superior de la pila y deja dos valores idénticos encima.</span><span class="sxs-lookup"><span data-stu-id="e8764-1893">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="e8764-1894">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `dup` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1895">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1895">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1896">Vuelve a transferir el control de la cláusula <see langword="filter" /> de una excepción al controlador de excepciones de la Infraestructura de Common Language Runtime (CLI).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1896">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1897">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1897">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1898">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1898">Format</span></span>|<span data-ttu-id="e8764-1899">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1899">Assembly Format</span></span>|<span data-ttu-id="e8764-1900">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1900">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1901">FE 11</span><span class="sxs-lookup"><span data-stu-id="e8764-1901">FE 11</span></span>|<span data-ttu-id="e8764-1902">endfilter</span><span class="sxs-lookup"><span data-stu-id="e8764-1902">endfilter</span></span>|<span data-ttu-id="e8764-1903">Cláusula de filtro de extremo de control de excepciones de SEH.</span><span class="sxs-lookup"><span data-stu-id="e8764-1903">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="e8764-1904">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1904">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1905">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1905">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1906">`value` se extrae de la pila; `endfilter` se ejecuta y el control se transfiere al controlador de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-1906">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="e8764-1907">`Value` (que debe ser de tipo `int32` y es uno de un conjunto específico de valores) se devuelve de la cláusula de filtro.</span><span class="sxs-lookup"><span data-stu-id="e8764-1907">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="e8764-1908">Debe ser uno de:</span><span class="sxs-lookup"><span data-stu-id="e8764-1908">It should be one of:</span></span>  
  
-   <span data-ttu-id="e8764-1909">`exception_continue_search` (`value` = 0) para continuar la búsqueda de un controlador de excepciones</span><span class="sxs-lookup"><span data-stu-id="e8764-1909">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="e8764-1910">`exception_execute_handler` (`value` = 1) para iniciar la segunda fase del control de excepciones donde se ejecutan bloques finally hasta que el controlador asociado a esta cláusula de filtro se encuentra.</span><span class="sxs-lookup"><span data-stu-id="e8764-1910">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="e8764-1911">Tras la detección, se ejecuta el controlador.</span><span class="sxs-lookup"><span data-stu-id="e8764-1911">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="e8764-1912">Otros valores enteros pueden generar resultados no especificados.</span><span class="sxs-lookup"><span data-stu-id="e8764-1912">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="e8764-1913">El punto de entrada de un filtro, como se muestra en la tabla de excepciones del método, debe ser la primera instrucción del bloque de filtro código.</span><span class="sxs-lookup"><span data-stu-id="e8764-1913">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="e8764-1914">El `endfilter` instrucción debe ser la última instrucción del bloque de filtro código (por lo tanto, solo puede haber uno `endfilter` para cada bloque filter).</span><span class="sxs-lookup"><span data-stu-id="e8764-1914">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="e8764-1915">Después de ejecutar el `endfilter` instrucción, el control lógicamente fluye hacia el mecanismo de control de excepciones de CLI.</span><span class="sxs-lookup"><span data-stu-id="e8764-1915">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="e8764-1916">No se puede transferir el control a un bloque de filtros excepto a través del mecanismo de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-1916">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="e8764-1917">No se puede transferir el control fuera de un bloque de filtros excepto mediante el uso de un `throw` instrucción o mediante la ejecución de la última `endfilter` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1917">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="e8764-1918">No se puede incrustar un `try` bloquear dentro de un `filter` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-1918">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="e8764-1919">Si se produce una excepción dentro de la `filter` bloque, se interceptan y un valor de 0 (`exception_continue_search`) se devuelve.</span><span class="sxs-lookup"><span data-stu-id="e8764-1919">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="e8764-1920">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `endfilter` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1920">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1921">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1921">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1922">Vuelve a transferir el control de la cláusula <see langword="fault" /> o <see langword="finally" /> de un bloque de excepción al controlador de excepciones de Common Language Infrastructure (CLI).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1922">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1923">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1923">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1924">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1924">Format</span></span>|<span data-ttu-id="e8764-1925">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1925">Assembly Format</span></span>|<span data-ttu-id="e8764-1926">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1926">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1927">DC</span><span class="sxs-lookup"><span data-stu-id="e8764-1927">DC</span></span>|<span data-ttu-id="e8764-1928">endfinally</span><span class="sxs-lookup"><span data-stu-id="e8764-1928">endfinally</span></span><br /><br /> <span data-ttu-id="e8764-1929">endfault</span><span class="sxs-lookup"><span data-stu-id="e8764-1929">endfault</span></span>|<span data-ttu-id="e8764-1930">Finaliza el `finally` o `fault` cláusula de un bloque de excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1930">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="e8764-1931">No hay ninguna pila de comportamientos de transición para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1931">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-1932">`Endfinally` y `endfault` indicar el final de la `finally` o `fault` cláusula para ese desenredo de pila pueda continuar hasta que se invoca el controlador de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-1932">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="e8764-1933">El `endfinally` o `endfault` instrucción transfiere el control al mecanismo de excepciones de CLI.</span><span class="sxs-lookup"><span data-stu-id="e8764-1933">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="e8764-1934">Después, este mecanismo busca la siguiente `finally` cláusula en la cadena si se salió del bloque protegido con una instrucción leave.</span><span class="sxs-lookup"><span data-stu-id="e8764-1934">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="e8764-1935">Si se salió del bloque protegido con una excepción, la CLI buscará la próxima `finally` o `fault`, o escriba el controlador de excepciones elegido durante el primer paso del control de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-1935">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="e8764-1936">Un `endfinally` instrucción podría aparecer sólo léxicamente en un `finally` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-1936">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="e8764-1937">A diferencia de la `endfilter` instrucciones, no es necesario que el bloque finalice con un `endfinally` instrucción y puede haber tantos `endfinally` instrucciones dentro del bloque según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="e8764-1937">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="e8764-1938">Las mismas restricciones se aplican a la `endfault` instrucción y `fault` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-1938">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="e8764-1939">No se puede transferir el control a un `finally` (o `fault`) bloquear excepto a través del mecanismo de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-1939">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="e8764-1940">No se puede transferir el control fuera de un `finally` (o `fault`) bloquear excepto mediante el uso de un `throw` instrucción o ejecutar la `endfinally` (o `endfault`) instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-1940">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="e8764-1941">En concreto, no puedan "caer" de un `finally` (o `fault`) bloque o para ejecutar un <xref:System.Reflection.Emit.OpCodes.Ret> o <xref:System.Reflection.Emit.OpCodes.Leave> instrucción dentro de un `finally` (o `fault`) bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-1941">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="e8764-1942">Tenga en cuenta que la `endfault` y `endfinally` instrucciones son alias, que se corresponden con el mismo código de operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-1942">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="e8764-1943">Los siguientes <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar el `endfinally` (`endfault`) código de operación, así como el `ILGenerator` método <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="e8764-1943">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="e8764-1944">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1944">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="e8764-1945">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="e8764-1945">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1946">Inicializa un bloque de memoria especificado en una dirección específica con el tamaño y el valor inicial dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1946">Initializes a specified block of memory at a specific address to a given size and initial value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1947">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1947">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1948">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1948">Format</span></span>|<span data-ttu-id="e8764-1949">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1949">Assembly Format</span></span>|<span data-ttu-id="e8764-1950">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1950">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1951">FE 18</span><span class="sxs-lookup"><span data-stu-id="e8764-1951">FE 18</span></span>|<span data-ttu-id="e8764-1952">initblk</span><span class="sxs-lookup"><span data-stu-id="e8764-1952">initblk</span></span>|<span data-ttu-id="e8764-1953">Establezca cada ubicación en un bloque de memoria en un valor determinado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1953">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="e8764-1954">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1954">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1955">Una dirección inicial se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1955">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1956">Un valor de inicialización se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1956">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-1957">El número de bytes que se va a inicializar se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1957">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-1958">El número de bytes, el valor de inicialización y la dirección inicial se extrae de la pila y la inicialización se lleva a cabo según sus valores.</span><span class="sxs-lookup"><span data-stu-id="e8764-1958">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="e8764-1959">El `initblk` el número de conjuntos de instrucciones (`unsigned int32`) de bytes a partir de la dirección especificada (de tipo `native int`, `&`, o `*`) en el valor de inicialización (de tipo `unsigned int8`).</span><span class="sxs-lookup"><span data-stu-id="e8764-1959">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="e8764-1960">`initblk` se da por supuesto que la dirección inicial está alineada con el tamaño natural de la máquina.</span><span class="sxs-lookup"><span data-stu-id="e8764-1960">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="e8764-1961">La operación de la `initblk` instrucciones pueden ser modificadas por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-1961">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-1962"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-1962"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-1963">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `initblk` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1963">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1964">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-1964">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1965">Inicializa cada uno de los campos del tipo de valor en la dirección especificada en una referencia nula o en un valor 0 del tipo primitivo correspondiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1965">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1966">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1966">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1967">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1967">Format</span></span>|<span data-ttu-id="e8764-1968">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1968">Assembly Format</span></span>|<span data-ttu-id="e8764-1969">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1969">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1970">FE 15 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-1970">FE 15 < `T` ></span></span>|<span data-ttu-id="e8764-1971">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="e8764-1971">`initobj` `typeTok`</span></span>|<span data-ttu-id="e8764-1972">Inicializa un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-1972">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="e8764-1973">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1973">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1974">La dirección del tipo de valor para inicializar se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1974">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1975">La dirección se extrae de la pila; el tipo de valor en la dirección especificada se inicializa como tipo `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1975">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="e8764-1976">El `initobj` instrucción inicializa cada campo del tipo de valor especificado mediante la dirección insertada (de tipo `native int`, `&`, o `*`) en una referencia null o un valor 0 del tipo primitivo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-1976">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="e8764-1977">Después de que se llama a este método, la instancia está lista para un método de constructor al que llamar.</span><span class="sxs-lookup"><span data-stu-id="e8764-1977">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="e8764-1978">Si `typeTok` es un tipo de referencia, esta instrucción tiene el mismo efecto que `ldnull` seguido de `stind.ref`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1978">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="e8764-1979">A diferencia de <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` no se llame al método de constructor.</span><span class="sxs-lookup"><span data-stu-id="e8764-1979">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="e8764-1980">`Initobj` está diseñado para inicializar tipos de valor, mientras que `newobj` se usa para asignar e inicializar objetos.</span><span class="sxs-lookup"><span data-stu-id="e8764-1980">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="e8764-1981">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `initobj` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-1981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-1982">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-1982">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-1983">Comprueba si una referencia a objeto (de tipo <see langword="O" />) es una instancia de una clase determinada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-1983">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-1984">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-1984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-1985">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-1985">Format</span></span>|<span data-ttu-id="e8764-1986">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-1986">Assembly Format</span></span>|<span data-ttu-id="e8764-1987">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-1987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-1988">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-1988">75 < `T` ></span></span>|<span data-ttu-id="e8764-1989">isinst `class`</span><span class="sxs-lookup"><span data-stu-id="e8764-1989">isinst `class`</span></span>|<span data-ttu-id="e8764-1990">Comprueba si una referencia de objeto es una instancia de `class`, que devuelve una referencia nula o una instancia de esa clase o interfaz.</span><span class="sxs-lookup"><span data-stu-id="e8764-1990">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="e8764-1991">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-1991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-1992">Una referencia de objeto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1992">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-1993">La referencia de objeto se extrae de la pila y probada para ver si se trata de una instancia de la clase pasada en `class`.</span><span class="sxs-lookup"><span data-stu-id="e8764-1993">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="e8764-1994">El resultado (una referencia de objeto o una referencia nula) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1994">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-1995">`Class` es un token de metadatos que indica la clase deseada.</span><span class="sxs-lookup"><span data-stu-id="e8764-1995">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="e8764-1996">Si implementa la clase del objeto en la parte superior de la pila `class` (si `class` es una interfaz) o es una clase derivada de `class` (si `class` es una clase regular), a continuación, se convierte al tipo `class` y se inserta el resultado en la pila, exactamente como si fuesen <xref:System.Reflection.Emit.OpCodes.Castclass> si se hubiese llamado.</span><span class="sxs-lookup"><span data-stu-id="e8764-1996">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="e8764-1997">En caso contrario, se inserta una referencia nula en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-1997">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="e8764-1998">Si la propia referencia de objeto es una referencia nula, a continuación, `isinst` igualmente devuelve una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-1998">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="e8764-1999"><xref:System.TypeLoadException> se produce si no se pudo encontrar la clase.</span><span class="sxs-lookup"><span data-stu-id="e8764-1999"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="e8764-2000">Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-2000">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-2001">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `isinst` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2002">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2002">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2003">Sale del método actual y salta al método especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2003">Exits current method and jumps to specified method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2004">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2005">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2005">Format</span></span>|<span data-ttu-id="e8764-2006">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2006">Assembly Format</span></span>|<span data-ttu-id="e8764-2007">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2008">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2008">27 < `T` ></span></span>|<span data-ttu-id="e8764-2009">jmp `method`</span><span class="sxs-lookup"><span data-stu-id="e8764-2009">jmp `method`</span></span>|<span data-ttu-id="e8764-2010">Sale del método actual y salta al método especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-2010">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="e8764-2011">No hay ninguna pila de comportamientos de transición para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-2011">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-2012">El `jmp` instrucción (jump) transfiere el control al método especificado por `method`, que es un símbolo (token) de metadatos para una referencia de método.</span><span class="sxs-lookup"><span data-stu-id="e8764-2012">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="e8764-2013">Los argumentos actuales se transfieren al método de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2013">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="e8764-2014">La pila de evaluación debe estar vacía cuando se ejecuta esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-2014">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="e8764-2015">La convención de llamada, el número y el tipo de argumentos en la dirección de destino deben coincidir con los del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2015">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="e8764-2016">El `jmp` instrucción no se puede usar para transferir el control fuera de un `try`, `filter`, `catch`, o `finally` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-2016">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="e8764-2017">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `jmp` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2017">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2018">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2018">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2019">Carga un argumento (al que hace referencia un valor de índice especificado) en la pila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2019">Loads an argument (referenced by a specified index value) onto the stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2020">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2021">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2021">Format</span></span>|<span data-ttu-id="e8764-2022">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2022">Assembly Format</span></span>|<span data-ttu-id="e8764-2023">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2024">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2024">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="e8764-2025">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-2025">ldarg `index`</span></span>|<span data-ttu-id="e8764-2026">Carga el argumento en `index` en pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2026">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="e8764-2027">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2028">El valor del argumento en `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2028">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2029">El `ldarg` instrucción inserta el argumento que se encuentra en el índice `index`, donde los argumentos están indizados del 0 en adelante, en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2029">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2030">El `ldarg` instrucción se puede utilizar para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2030">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="e8764-2031">El tipo del valor del argumento es el mismo que el tipo del argumento, tal y como especifica la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2031">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-2032">Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarg` instrucción puede usarse sólo para los argumentos fijos iniciales, no los de la parte variable de la firma (vea la <xref:System.Reflection.Emit.OpCodes.Arglist> instrucción para obtener más detalles).</span><span class="sxs-lookup"><span data-stu-id="e8764-2032">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="e8764-2033">Los argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2033">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-2034">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2034">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-2035">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarg` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2035">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2036">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="e8764-2036">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2037">Carga el argumento que se encuentra en el índice 0 en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2037">Loads the argument at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2038">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2038">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2039">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2039">Format</span></span>|<span data-ttu-id="e8764-2040">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2040">Assembly Format</span></span>|<span data-ttu-id="e8764-2041">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2041">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2042">02</span><span class="sxs-lookup"><span data-stu-id="e8764-2042">02</span></span>|<span data-ttu-id="e8764-2043">ldarg.0</span><span class="sxs-lookup"><span data-stu-id="e8764-2043">ldarg.0</span></span>|<span data-ttu-id="e8764-2044">Carga el argumento 0 en la pila</span><span class="sxs-lookup"><span data-stu-id="e8764-2044">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="e8764-2045">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2045">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2046">El valor del argumento en el índice 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2046">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2047">El `ldarg.0` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2047">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="e8764-2048">El `ldarg.0` instrucción inserta el argumento indizado en 0 en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2048">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2049">El `ldarg.0` instrucción se puede utilizar para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2049">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="e8764-2050">El tipo del valor del argumento es el mismo que el tipo del argumento, tal y como especifica la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2050">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-2051">Los argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2051">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-2052">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2052">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-2053">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarg.0` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2053">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2054">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2054">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2055">Carga el argumento que se encuentra en el índice 1 en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2055">Loads the argument at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2056">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2056">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2057">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2057">Format</span></span>|<span data-ttu-id="e8764-2058">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2058">Assembly Format</span></span>|<span data-ttu-id="e8764-2059">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2059">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2060">03</span><span class="sxs-lookup"><span data-stu-id="e8764-2060">03</span></span>|<span data-ttu-id="e8764-2061">ldarg.1</span><span class="sxs-lookup"><span data-stu-id="e8764-2061">ldarg.1</span></span>|<span data-ttu-id="e8764-2062">Carga el argumento 1 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2062">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="e8764-2063">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2063">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2064">El valor del argumento en el índice 1 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2064">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2065">El `ldarg.1` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-2065">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="e8764-2066">El `ldarg.1` instrucción inserta el argumento indizado en 1 en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2066">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2067">El `ldarg.1` instrucción se puede utilizar para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2067">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="e8764-2068">El tipo del valor del argumento es el mismo que el tipo del argumento, tal y como especifica la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2068">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-2069">Los argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2069">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-2070">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2070">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-2071">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarg.1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2071">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2072">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2072">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2073">Carga el argumento que se encuentra en el índice 2 en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2073">Loads the argument at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2074">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2074">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2075">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2075">Format</span></span>|<span data-ttu-id="e8764-2076">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2076">Assembly Format</span></span>|<span data-ttu-id="e8764-2077">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2077">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2078">04</span><span class="sxs-lookup"><span data-stu-id="e8764-2078">04</span></span>|<span data-ttu-id="e8764-2079">ldarg.2</span><span class="sxs-lookup"><span data-stu-id="e8764-2079">ldarg.2</span></span>|<span data-ttu-id="e8764-2080">Carga el argumento 2 en pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2080">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="e8764-2081">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2081">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2082">El valor del argumento en el índice 2 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2082">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2083">El `ldarg.2` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 2.</span><span class="sxs-lookup"><span data-stu-id="e8764-2083">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="e8764-2084">El `ldarg.2` instrucción inserta el argumento indizado en 2 en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2084">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2085">El `ldarg.2` instrucción se puede utilizar para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2085">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="e8764-2086">El tipo del valor del argumento es el mismo que el tipo del argumento, tal y como especifica la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2086">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-2087">Los argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2087">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-2088">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-2089">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarg.2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2091">Carga el argumento que se encuentra en el índice 3 en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2091">Loads the argument at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2092">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2093">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2093">Format</span></span>|<span data-ttu-id="e8764-2094">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2094">Assembly Format</span></span>|<span data-ttu-id="e8764-2095">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2096">05</span><span class="sxs-lookup"><span data-stu-id="e8764-2096">05</span></span>|<span data-ttu-id="e8764-2097">ldarg.3</span><span class="sxs-lookup"><span data-stu-id="e8764-2097">ldarg.3</span></span>|<span data-ttu-id="e8764-2098">Carga el argumento 3 en pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2098">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="e8764-2099">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2100">El valor del argumento en el índice 3 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2100">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2101">El `ldarg.3` instrucción es una codificación eficaz para cargar el valor del argumento en el índice 3.</span><span class="sxs-lookup"><span data-stu-id="e8764-2101">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="e8764-2102">El `ldarg.3` instrucción inserta el argumento indizado en 3 en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2102">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2103">El `ldarg.3` instrucción se puede utilizar para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2103">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="e8764-2104">El tipo del valor del argumento es el mismo que el tipo del argumento, tal y como especifica la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2104">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-2105">Los argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2105">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-2106">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-2107">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarg.3` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2108">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2108">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2109">Carga el argumento (al que hace referencia un índice de forma corta especificado) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2109">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2110">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2111">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2111">Format</span></span>|<span data-ttu-id="e8764-2112">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2112">Assembly Format</span></span>|<span data-ttu-id="e8764-2113">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2114">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2114">0E < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-2115">ldarg.s `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-2115">ldarg.s `index`</span></span>|<span data-ttu-id="e8764-2116">Carga el argumento en `index` en pila, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2116">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="e8764-2117">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2118">El valor del argumento en `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2118">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2119">El `ldarg.s` instrucción es una codificación eficaz para cargar los argumentos indizados del 4 al 255.</span><span class="sxs-lookup"><span data-stu-id="e8764-2119">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="e8764-2120">El `ldarg.s` instrucción inserta el argumento que se encuentra en el índice `index`, donde los argumentos están indizados del 0 en adelante, en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2120">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2121">El `ldarg.s` instrucción se puede utilizar para cargar un tipo de valor o un valor primitivo en la pila al copiarlo desde un argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2121">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="e8764-2122">El tipo del valor del argumento es el mismo que el tipo del argumento, tal y como especifica la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-2122">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-2123">Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarg.s` instrucción puede usarse sólo para los argumentos fijos iniciales, no los de la parte variable de la firma (vea la <xref:System.Reflection.Emit.OpCodes.Arglist> instrucción para obtener más detalles).</span><span class="sxs-lookup"><span data-stu-id="e8764-2123">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="e8764-2124">Los argumentos que contienen un valor entero menor que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2124">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-2125">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2125">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-2126">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarg.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2127">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-2127">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2128">Carga la dirección de un argumento en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2128">Load an argument address onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2129">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2130">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2130">Format</span></span>|<span data-ttu-id="e8764-2131">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2131">Assembly Format</span></span>|<span data-ttu-id="e8764-2132">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2133">FE 0A &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2133">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="e8764-2134">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-2134">ldarga `index`</span></span>|<span data-ttu-id="e8764-2135">Obtiene la dirección del argumento indizado en `index`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2135">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="e8764-2136">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2137">La dirección `addr` del argumento indizado por `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2137">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2138">El `ldarga` instrucción obtiene la dirección (de tipo `*`) del argumento indizado por `index`, donde los argumentos están indizados del 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-2138">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="e8764-2139">La dirección `addr` siempre está alineado en un límite natural del equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2139">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="e8764-2140">Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarga` instrucción puede usarse sólo para los argumentos fijos iniciales, no los de la parte variable de la firma.</span><span class="sxs-lookup"><span data-stu-id="e8764-2140">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="e8764-2141">`ldarga` se utiliza para pasar de parámetros por referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-2141">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="e8764-2142">En otros casos, <xref:System.Reflection.Emit.OpCodes.Ldarg> y <xref:System.Reflection.Emit.OpCodes.Starg> se debe usar.</span><span class="sxs-lookup"><span data-stu-id="e8764-2142">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="e8764-2143">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarga` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2143">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2144">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="e8764-2144">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2145">Carga la dirección de un argumento (forma corta) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2145">Load an argument address, in short form, onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2146">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2146">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2147">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2147">Format</span></span>|<span data-ttu-id="e8764-2148">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2148">Assembly Format</span></span>|<span data-ttu-id="e8764-2149">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2149">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2150">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2150">0F < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-2151">ldarga.s `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-2151">ldarga.s `index`</span></span>|<span data-ttu-id="e8764-2152">Obtiene la dirección del argumento indizado en `index`, forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-2152">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="e8764-2153">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2153">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2154">La dirección `addr` del argumento indizado por `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2154">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2155">`ldarga.s` (la forma abreviada de `ldarga`) debe utilizarse para los números de argumento 0 y 255, y es una codificación más eficaz.</span><span class="sxs-lookup"><span data-stu-id="e8764-2155">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="e8764-2156">El `ldarga.s` instrucción obtiene la dirección (de tipo`*`) del argumento indizado por `index`, donde los argumentos están indizados del 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-2156">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="e8764-2157">La dirección `addr` siempre está alineado en un límite natural del equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2157">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="e8764-2158">Para conocer los procedimientos que toman una lista de argumentos de longitud variable, la `ldarga.s` instrucción puede usarse sólo para los argumentos fijos iniciales, no los de la parte variable de la firma.</span><span class="sxs-lookup"><span data-stu-id="e8764-2158">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="e8764-2159">`ldarga.s` se utiliza para pasar de parámetros por referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-2159">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="e8764-2160">En otros casos, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> y <xref:System.Reflection.Emit.OpCodes.Starg_S> se debe usar.</span><span class="sxs-lookup"><span data-stu-id="e8764-2160">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="e8764-2161">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldarga.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2161">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2162">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-2162">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2163">Inserta en la pila de evaluación un valor suministrado de tipo <see langword="int32" /> como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2163">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2164">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2164">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2165">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2165">Format</span></span>|<span data-ttu-id="e8764-2166">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2166">Assembly Format</span></span>|<span data-ttu-id="e8764-2167">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2167">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2168">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2168">20 < `int32` ></span></span>|<span data-ttu-id="e8764-2169">ldc.i4 `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-2169">ldc.i4 `num`</span></span>|<span data-ttu-id="e8764-2170">Inserta el valor `num` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2170">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2171">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2171">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2172">El valor `num` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2172">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2173">Tenga en cuenta que hay codificaciones especiales de cortas (y por lo tanto, más eficaces) para los enteros -128 a 127 y codificaciones especialmente cortas de -1 a 8.</span><span class="sxs-lookup"><span data-stu-id="e8764-2173">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="e8764-2174">Todas las codificaciones cortas insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2174">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="e8764-2175">Se utilizan codificaciones más largas para los enteros de 8 bytes y 4 y 8 números de punto flotante de bytes, así como los valores de 4 bytes que no caben en la forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-2175">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="e8764-2176">Hay tres formas de insertar una constante de entero de 8 bytes en la pila</span><span class="sxs-lookup"><span data-stu-id="e8764-2176">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="e8764-2177">Use la <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instrucciones para las constantes que se deben expresar en más de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-2177">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="e8764-2178">Use la <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instrucción seguido por un <xref:System.Reflection.Emit.OpCodes.Conv_I8> para las constantes que requieran de 9 a 32 bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="e8764-2179">Utilice una instrucción de forma corta seguida de un <xref:System.Reflection.Emit.OpCodes.Conv_I8> para las constantes que se pueden expresar en 8 bits o menos.</span><span class="sxs-lookup"><span data-stu-id="e8764-2179">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="e8764-2180">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2181">ILGenerator.Emit (código de operación, int)</span><span class="sxs-lookup"><span data-stu-id="e8764-2181">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2182">Inserta en la pila de evaluación el valor entero 0 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2182">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2183">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2184">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2184">Format</span></span>|<span data-ttu-id="e8764-2185">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2185">Assembly Format</span></span>|<span data-ttu-id="e8764-2186">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2187">16</span><span class="sxs-lookup"><span data-stu-id="e8764-2187">16</span></span>|<span data-ttu-id="e8764-2188">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="e8764-2188">ldc.i4.0</span></span>|<span data-ttu-id="e8764-2189">Inserta 0 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2189">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2190">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2191">El valor 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2191">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2192">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2192">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2193">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2193">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2194">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.0` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2194">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2195">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2195">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2196">Inserta en la pila de evaluación el valor entero 1 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2196">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2197">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2197">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2198">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2198">Format</span></span>|<span data-ttu-id="e8764-2199">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2199">Assembly Format</span></span>|<span data-ttu-id="e8764-2200">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2200">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2201">17</span><span class="sxs-lookup"><span data-stu-id="e8764-2201">17</span></span>|<span data-ttu-id="e8764-2202">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="e8764-2202">ldc.i4.1</span></span>|<span data-ttu-id="e8764-2203">Inserta 1 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2203">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2204">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2204">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2205">El valor 1 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2205">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2206">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2206">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2207">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2207">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2208">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2209">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2209">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2210">Inserta en la pila de evaluación el valor entero 2 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2210">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2211">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2212">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2212">Format</span></span>|<span data-ttu-id="e8764-2213">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2213">Assembly Format</span></span>|<span data-ttu-id="e8764-2214">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2215">18</span><span class="sxs-lookup"><span data-stu-id="e8764-2215">18</span></span>|<span data-ttu-id="e8764-2216">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="e8764-2216">ldc.i4.2</span></span>|<span data-ttu-id="e8764-2217">Inserta 2 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2217">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2218">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2219">El valor 2 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2219">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2220">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2220">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2221">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2221">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2222">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2222">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2223">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2223">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2224">Inserta en la pila de evaluación el valor entero 3 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2224">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2225">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2225">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2226">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2226">Format</span></span>|<span data-ttu-id="e8764-2227">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2227">Assembly Format</span></span>|<span data-ttu-id="e8764-2228">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2228">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2229">19</span><span class="sxs-lookup"><span data-stu-id="e8764-2229">19</span></span>|<span data-ttu-id="e8764-2230">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="e8764-2230">ldc.i4.3</span></span>|<span data-ttu-id="e8764-2231">Inserta 3 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2231">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2232">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2232">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2233">El valor 3 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2233">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2234">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2234">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2235">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2235">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2236">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.3` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2236">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2237">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2237">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2238">Inserta en la pila de evaluación el valor entero 4 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2238">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2239">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2239">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2240">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2240">Format</span></span>|<span data-ttu-id="e8764-2241">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2241">Assembly Format</span></span>|<span data-ttu-id="e8764-2242">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2242">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2243">1A</span><span class="sxs-lookup"><span data-stu-id="e8764-2243">1A</span></span>|<span data-ttu-id="e8764-2244">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="e8764-2244">ldc.i4.4</span></span>|<span data-ttu-id="e8764-2245">Inserta 4 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2245">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2246">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2246">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2247">El valor 4 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2247">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2248">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2248">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2249">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2249">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2250">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2252">Inserta en la pila de evaluación el valor entero 5 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2252">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2253">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2254">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2254">Format</span></span>|<span data-ttu-id="e8764-2255">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2255">Assembly Format</span></span>|<span data-ttu-id="e8764-2256">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2257">1B</span><span class="sxs-lookup"><span data-stu-id="e8764-2257">1B</span></span>|<span data-ttu-id="e8764-2258">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="e8764-2258">ldc.i4.5</span></span>|<span data-ttu-id="e8764-2259">Inserta 5 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2259">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2260">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2261">El valor 5 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2261">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2262">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2262">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2263">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2263">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2264">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.5` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2264">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2265">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2265">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2266">Inserta en la pila de evaluación el valor entero 6 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2266">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2267">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2267">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2268">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2268">Format</span></span>|<span data-ttu-id="e8764-2269">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2269">Assembly Format</span></span>|<span data-ttu-id="e8764-2270">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2270">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2271">1C</span><span class="sxs-lookup"><span data-stu-id="e8764-2271">1C</span></span>|<span data-ttu-id="e8764-2272">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="e8764-2272">ldc.i4.6</span></span>|<span data-ttu-id="e8764-2273">Inserta 6 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2273">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2274">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2274">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2275">El valor 6 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2275">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2276">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2276">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2277">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2277">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2278">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.6` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2278">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2279">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2279">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2280">Inserta en la pila de evaluación el valor entero 7 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2280">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2281">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2281">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2282">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2282">Format</span></span>|<span data-ttu-id="e8764-2283">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2283">Assembly Format</span></span>|<span data-ttu-id="e8764-2284">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2284">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2285">1D</span><span class="sxs-lookup"><span data-stu-id="e8764-2285">1D</span></span>|<span data-ttu-id="e8764-2286">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="e8764-2286">ldc.i4.7</span></span>|<span data-ttu-id="e8764-2287">Inserta 7 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2287">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2288">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2288">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2289">El valor 7 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2289">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2290">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2290">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2291">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2291">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2292">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.7` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2293">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2293">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2294">Inserta en la pila de evaluación el valor entero 8 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2294">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2295">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2296">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2296">Format</span></span>|<span data-ttu-id="e8764-2297">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2297">Assembly Format</span></span>|<span data-ttu-id="e8764-2298">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2299">1E</span><span class="sxs-lookup"><span data-stu-id="e8764-2299">1E</span></span>|<span data-ttu-id="e8764-2300">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="e8764-2300">ldc.i4.8</span></span>|<span data-ttu-id="e8764-2301">Inserta 8 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2301">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2302">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2303">El valor 8 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2303">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2304">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2304">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2305">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2305">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2306">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2306">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2307">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2307">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2308">Inserta en la pila de evaluación el valor entero -1 como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2308">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2309">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2309">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2310">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2310">Format</span></span>|<span data-ttu-id="e8764-2311">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2311">Assembly Format</span></span>|<span data-ttu-id="e8764-2312">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2312">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2313">15</span><span class="sxs-lookup"><span data-stu-id="e8764-2313">15</span></span>|<span data-ttu-id="e8764-2314">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="e8764-2314">ldc.i4.m1</span></span>|<span data-ttu-id="e8764-2315">Inserta -1 en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2315">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2316">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2316">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2317">El valor -1 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2317">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2318">Esto es una codificación corta especial para la inserción del valor entero de 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-2318">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="e8764-2319">Todas las codificaciones cortas especiales insertan enteros de 4 bytes en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2319">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="e8764-2320">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.m1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2322">Inserta en la pila de evaluación el valor <see langword="int8" /> suministrado como <see langword="int32" /> (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2322">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2323">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2324">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2324">Format</span></span>|<span data-ttu-id="e8764-2325">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2325">Assembly Format</span></span>|<span data-ttu-id="e8764-2326">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2327">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2327">1F < `int8` ></span></span>|<span data-ttu-id="e8764-2328">ldc.i4.s `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-2328">ldc.i4.s `num`</span></span>|<span data-ttu-id="e8764-2329">Inserta `num` en la pila como `int32`, forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-2329">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="e8764-2330">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2331">El valor `num` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2331">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2332">`ldc.i4.s` es una codificación más eficaz para insertar los enteros entre -128 a 127 en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2332">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2333">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i4.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2333">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2334">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-2334">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2335">Inserta en la pila de evaluación un valor suministrado de tipo <see langword="int64" /> como <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2336">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2337">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2337">Format</span></span>|<span data-ttu-id="e8764-2338">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2338">Assembly Format</span></span>|<span data-ttu-id="e8764-2339">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2340">21 < `int64` ></span></span>|<span data-ttu-id="e8764-2341">ldc.i8 `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="e8764-2342">Inserta `num` en la pila como `int64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="e8764-2343">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2344">El valor `num` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2345">Esta codificación inserta un `int64` valor en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2346">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2347">ILGenerator.Emit (OpCode, long)</span><span class="sxs-lookup"><span data-stu-id="e8764-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2348">Inserta en la pila de evaluación un valor suministrado de tipo <see langword="float32" /> como tipo <see langword="F" /> (flotante).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2349">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2350">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2350">Format</span></span>|<span data-ttu-id="e8764-2351">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2351">Assembly Format</span></span>|<span data-ttu-id="e8764-2352">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2353">22 < `float32` ></span></span>|<span data-ttu-id="e8764-2354">ldc.r4 `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="e8764-2355">Inserta `num` en la pila como `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="e8764-2356">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2357">El valor `num` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2358">Esta codificación inserta un `float32` valor en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2359">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.r4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2360">ILGenerator.Emit (OpCode, único)</span><span class="sxs-lookup"><span data-stu-id="e8764-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2361">Inserta en la pila de evaluación un valor suministrado de tipo <see langword="float64" /> como tipo <see langword="F" /> (flotante).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2362">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2363">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2363">Format</span></span>|<span data-ttu-id="e8764-2364">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2364">Assembly Format</span></span>|<span data-ttu-id="e8764-2365">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2366">23 < `float64` ></span></span>|<span data-ttu-id="e8764-2367">ldc.r8 `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="e8764-2368">Inserta `num` en la pila como `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="e8764-2369">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2370">El valor `num` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2371">Esta codificación inserta un `float64` valor en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2372">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldc.r8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2373">ILGenerator.Emit (OpCode, double)</span><span class="sxs-lookup"><span data-stu-id="e8764-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2374">Carga el elemento que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como el tipo definido en la instrucción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2375">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2376">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2376">Format</span></span>|<span data-ttu-id="e8764-2377">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2377">Assembly Format</span></span>|<span data-ttu-id="e8764-2378">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2379">A3 < `T` ></span></span>|<span data-ttu-id="e8764-2380">ldelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="e8764-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="e8764-2381">Carga el elemento en `index` en la parte superior de la pila como tipo `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="e8764-2382">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2383">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2384">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2385">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2386">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2387">El `ldelem` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2388">Las matrices son objetos y, por lo tanto, se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2389">El tipo del valor devuelto se especifica el token `typeTok` en la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="e8764-2390"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2391"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite superior de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2392">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2393">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2394">Carga el elemento de tipo <see langword="native int" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2395">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2396">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2396">Format</span></span>|<span data-ttu-id="e8764-2397">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2397">Assembly Format</span></span>|<span data-ttu-id="e8764-2398">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2399">97</span><span class="sxs-lookup"><span data-stu-id="e8764-2399">97</span></span>|<span data-ttu-id="e8764-2400">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="e8764-2400">ldelem.i</span></span>|<span data-ttu-id="e8764-2401">Carga el elemento de tipo `native int` en `index` en la parte superior de la pila como un `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="e8764-2402">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2403">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2404">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2405">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2406">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2407">El `ldelem.i` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2408">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2409">El valor devuelto para `ldelem.i` es `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="e8764-2410">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2411"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2412"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2413"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2414">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.i` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2416">Carga el elemento de tipo <see langword="int8" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2417">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2418">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2418">Format</span></span>|<span data-ttu-id="e8764-2419">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2419">Assembly Format</span></span>|<span data-ttu-id="e8764-2420">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2421">90</span><span class="sxs-lookup"><span data-stu-id="e8764-2421">90</span></span>|<span data-ttu-id="e8764-2422">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="e8764-2422">ldelem.i1</span></span>|<span data-ttu-id="e8764-2423">Carga el elemento de tipo `int8` en `index` en la parte superior de la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2424">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2425">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2426">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2427">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2428">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2429">El `ldelem.i1` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2430">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2431">El valor devuelto para `ldelem.i1` es `int8`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="e8764-2432">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2433"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2434"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2435"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2436">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.i1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2438">Carga el elemento de tipo <see langword="int16" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2439">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2440">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2440">Format</span></span>|<span data-ttu-id="e8764-2441">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2441">Assembly Format</span></span>|<span data-ttu-id="e8764-2442">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2443">92</span><span class="sxs-lookup"><span data-stu-id="e8764-2443">92</span></span>|<span data-ttu-id="e8764-2444">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="e8764-2444">ldelem.i2</span></span>|<span data-ttu-id="e8764-2445">Carga el elemento de tipo `int16` en `index` en la parte superior de la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2446">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2447">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2448">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2449">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2450">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2451">El `ldelem.i2` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2452">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2453">El valor devuelto para `ldelem.i2` es `int16`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="e8764-2454">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2455"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2456"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2457"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2458">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.i2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2460">Carga el elemento de tipo <see langword="int32" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2461">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2462">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2462">Format</span></span>|<span data-ttu-id="e8764-2463">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2463">Assembly Format</span></span>|<span data-ttu-id="e8764-2464">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2465">94</span><span class="sxs-lookup"><span data-stu-id="e8764-2465">94</span></span>|<span data-ttu-id="e8764-2466">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="e8764-2466">ldelem.i4</span></span>|<span data-ttu-id="e8764-2467">Carga el elemento de tipo `int32` en `index` en la parte superior de la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2468">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2469">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2470">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2471">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2472">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2473">El `ldelem.i4` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2474">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2475">El valor devuelto para `ldelem.i4` es `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2476">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2477"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2478"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2479"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2480">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2482">Carga el elemento de tipo <see langword="int64" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2483">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2484">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2484">Format</span></span>|<span data-ttu-id="e8764-2485">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2485">Assembly Format</span></span>|<span data-ttu-id="e8764-2486">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2487">96</span><span class="sxs-lookup"><span data-stu-id="e8764-2487">96</span></span>|<span data-ttu-id="e8764-2488">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="e8764-2488">ldelem.i8</span></span>|<span data-ttu-id="e8764-2489">Carga el elemento de tipo `int64` en `index` en la parte superior de la pila como un `int64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="e8764-2490">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2491">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2492">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2493">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2494">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2495">El `ldelem.i8` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2496">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2497">El valor devuelto para `ldelem.i8` es `int64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="e8764-2498">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2499"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2500"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2501"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2502">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2504">Carga el elemento de tipo <see langword="float32" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como tipo <see langword="F" /> (flotante).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2505">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2506">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2506">Format</span></span>|<span data-ttu-id="e8764-2507">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2507">Assembly Format</span></span>|<span data-ttu-id="e8764-2508">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2509">98</span><span class="sxs-lookup"><span data-stu-id="e8764-2509">98</span></span>|<span data-ttu-id="e8764-2510">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="e8764-2510">ldelem.r4</span></span>|<span data-ttu-id="e8764-2511">Carga el elemento de tipo `float32` en `index` en la parte superior de la pila como un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="e8764-2512">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2513">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2514">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2515">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2516">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2517">El `ldelem.r4` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2518">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2519">El valor devuelto para `ldelem.r4` es `float32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="e8764-2520">Valores de punto flotante se convierten al tipo `F` cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2521"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2522"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2523"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2524">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.r4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2526">Carga el elemento de tipo <see langword="float64" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como tipo <see langword="F" /> (flotante).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2527">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2528">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2528">Format</span></span>|<span data-ttu-id="e8764-2529">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2529">Assembly Format</span></span>|<span data-ttu-id="e8764-2530">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2531">99</span><span class="sxs-lookup"><span data-stu-id="e8764-2531">99</span></span>|<span data-ttu-id="e8764-2532">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="e8764-2532">ldelem.r8</span></span>|<span data-ttu-id="e8764-2533">Carga el elemento de tipo `float64` en `index` en la parte superior de la pila como tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="e8764-2534">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2535">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2536">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2537">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2538">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2539">El `ldelem.r8` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2540">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2541">El valor devuelto para `ldelem.r8` es `float64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="e8764-2542">Valores de punto flotante se convierten al tipo `F` cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2543"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2544"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2545"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2546">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.r8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2548">Carga el elemento que contiene una referencia a objeto en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como tipo <see langword="O" /> (referencia a objeto).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2549">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2550">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2550">Format</span></span>|<span data-ttu-id="e8764-2551">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2551">Assembly Format</span></span>|<span data-ttu-id="e8764-2552">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2553">9A</span><span class="sxs-lookup"><span data-stu-id="e8764-2553">9A</span></span>|<span data-ttu-id="e8764-2554">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="e8764-2554">ldelem.ref</span></span>|<span data-ttu-id="e8764-2555">Carga el elemento con una referencia a objeto en `index` en la parte superior de la pila como tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="e8764-2556">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2557">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2558">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2559">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2560">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2561">El `ldelem.ref` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2562">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2563">El valor devuelto para `ldelem.ref` es de tipo `O` (referencia a objeto).</span><span class="sxs-lookup"><span data-stu-id="e8764-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="e8764-2564"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2565"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2566"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2567">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.ref` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2569">Carga el elemento de tipo <see langword="unsigned int8" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2570">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2571">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2571">Format</span></span>|<span data-ttu-id="e8764-2572">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2572">Assembly Format</span></span>|<span data-ttu-id="e8764-2573">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2574">91</span><span class="sxs-lookup"><span data-stu-id="e8764-2574">91</span></span>|<span data-ttu-id="e8764-2575">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="e8764-2575">ldelem.u1</span></span>|<span data-ttu-id="e8764-2576">Carga el elemento de tipo `unsigned int8` en `index` en la parte superior de la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2577">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2578">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2579">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2580">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2581">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2582">El `ldelem.u1` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2583">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2584">El valor devuelto para `ldelem.u1` es `int8`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="e8764-2585">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2586"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2587"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2588"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2589">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.u1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2591">Carga el elemento de tipo <see langword="unsigned int16" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2592">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2593">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2593">Format</span></span>|<span data-ttu-id="e8764-2594">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2594">Assembly Format</span></span>|<span data-ttu-id="e8764-2595">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2596">93</span><span class="sxs-lookup"><span data-stu-id="e8764-2596">93</span></span>|<span data-ttu-id="e8764-2597">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="e8764-2597">ldelem.u2</span></span>|<span data-ttu-id="e8764-2598">Carga el elemento de tipo `unsigned int16` en la posición de índice en la parte superior de la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2599">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2600">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2601">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2602">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2603">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2604">El `ldelem.u2` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2605">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2606">El valor devuelto para `ldelem.u2` es `int16`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="e8764-2607">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2608"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2609"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2610"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2611">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.u2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2613">Carga el elemento de tipo <see langword="unsigned int32" /> que se encuentra en una posición de índice de matriz especificada en la parte superior de la pila de evaluación como <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2614">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2615">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2615">Format</span></span>|<span data-ttu-id="e8764-2616">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2616">Assembly Format</span></span>|<span data-ttu-id="e8764-2617">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2618">95</span><span class="sxs-lookup"><span data-stu-id="e8764-2618">95</span></span>|<span data-ttu-id="e8764-2619">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="e8764-2619">ldelem.u4</span></span>|<span data-ttu-id="e8764-2620">Carga el elemento de tipo `unsigned int32` en la posición de índice en la parte superior de la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2621">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2622">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2623">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2624">`index` y `array` se extrae de la pila; el valor almacenado en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2625">El valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2626">El `ldelem.u4` instrucción carga el valor del elemento con el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2627">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2628">El valor devuelto para `ldelem.u4` es `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2629">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2630"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2631"><xref:System.ArrayTypeMismatchException> se produce si la matriz no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2632"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2633">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelem.u4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2635">Carga la dirección del elemento de la matriz que se encuentra en un índice de la matriz especificado en la parte superior de la pila de evaluación como tipo <see langword="&amp;" /> (puntero administrado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2636">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2637">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2637">Format</span></span>|<span data-ttu-id="e8764-2638">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2638">Assembly Format</span></span>|<span data-ttu-id="e8764-2639">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2640">8F < `T` ></span></span>|<span data-ttu-id="e8764-2641">ldelema `class`</span><span class="sxs-lookup"><span data-stu-id="e8764-2641">ldelema `class`</span></span>|<span data-ttu-id="e8764-2642">Carga la dirección del elemento de matriz en `index` en la parte superior de la pila de evaluación como tipo `&` (puntero administrado).</span><span class="sxs-lookup"><span data-stu-id="e8764-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="e8764-2643">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2644">Una referencia de objeto `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2645">Un valor de índice `index` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-2646">`index` y `array` se extrae de la pila; la dirección almacenada en la posición `index` en `array` se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="e8764-2647">La dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2648">El `ldelema` se utiliza para recuperar la dirección de un objeto en un índice determinado en una matriz de objetos (de tipo `class`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="e8764-2649">El `ldelema` instrucción carga la dirección del valor en el índice `index` (tipo `native int`) en la matriz unidimensional de base cero `array` y lo coloca en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="e8764-2650">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-2651">El valor debe ser de tipo `class` pasado con la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="e8764-2652">El valor devuelto para `ldelema` es un puntero administrado (tipo `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="e8764-2653">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2654"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-2655"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-2656"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-2657">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldelema` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2658">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2659">Encuentra el valor de un campo en el objeto cuya referencia se encuentra actualmente en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2660">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2661">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2661">Format</span></span>|<span data-ttu-id="e8764-2662">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2662">Assembly Format</span></span>|<span data-ttu-id="e8764-2663">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2664">7B < `T` ></span></span>|<span data-ttu-id="e8764-2665">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="e8764-2665">ldfld `field`</span></span>|<span data-ttu-id="e8764-2666">Inserta el valor de un campo en un objeto especificado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2667">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2668">Una referencia de objeto (o puntero) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2669">La referencia de objeto (o puntero) se extrae de la pila; el valor del campo especificado en el objeto se encuentra.</span><span class="sxs-lookup"><span data-stu-id="e8764-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="e8764-2670">El valor almacenado en el campo se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2671">El `ldfld` instrucción inserta el valor de un campo situado en un objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="e8764-2672">El objeto debe encontrarse en la pila como una referencia de objeto (tipo `O`), un puntero administrado (tipo `&`), un puntero no administrado (tipo `native int`), un puntero transitorio (tipo `*`), o una instancia de un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="e8764-2673">No se permite el uso de un puntero no administrado en código comprobable.</span><span class="sxs-lookup"><span data-stu-id="e8764-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="e8764-2674">El campo del objeto se especifica mediante un símbolo (token) de metadatos que debe hacer referencia a un miembro de campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="e8764-2675">El tipo de valor devuelto es el mismo que el asociado con el campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="e8764-2676">El campo puede ser un campo de instancia (en cuyo caso el objeto debe no ser una referencia nula) o un campo estático.</span><span class="sxs-lookup"><span data-stu-id="e8764-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="e8764-2677">El `ldfld` instrucción puede ir precedida de una o ambas de las <xref:System.Reflection.Emit.OpCodes.Unaligned> y <xref:System.Reflection.Emit.OpCodes.Volatile> prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="e8764-2678"><xref:System.NullReferenceException> se produce si el objeto es null y el campo no es estático.</span><span class="sxs-lookup"><span data-stu-id="e8764-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="e8764-2679"><xref:System.MissingFieldException> se produce si el campo especificado no se encuentra en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="e8764-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="e8764-2680">Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="e8764-2681">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldfld` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2682">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2683">Busca la dirección de un campo en el objeto cuya referencia se encuentra actualmente en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2684">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2685">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2685">Format</span></span>|<span data-ttu-id="e8764-2686">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2686">Assembly Format</span></span>|<span data-ttu-id="e8764-2687">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2688">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2688">7C < `T` ></span></span>|<span data-ttu-id="e8764-2689">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="e8764-2689">ldflda `field`</span></span>|<span data-ttu-id="e8764-2690">Inserta la dirección de `field` en un objeto especificado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2691">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2692">Una referencia de objeto (o puntero) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2693">La referencia de objeto (o puntero) se extrae de la pila; la dirección del campo especificado en el objeto se encuentra.</span><span class="sxs-lookup"><span data-stu-id="e8764-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="e8764-2694">La dirección del campo especificado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2695">El `ldflda` instrucción inserta la dirección de un campo situado en un objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="e8764-2696">El objeto debe encontrarse en la pila como una referencia de objeto (tipo `O`), un puntero administrado (tipo `&`), un puntero no administrado (tipo `native int`), un puntero transitorio (tipo `*`), o una instancia de un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="e8764-2697">No se permite el uso de un puntero no administrado en código comprobable.</span><span class="sxs-lookup"><span data-stu-id="e8764-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="e8764-2698">El campo del objeto se especifica mediante un símbolo (token) de metadatos que debe hacer referencia a un miembro de campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="e8764-2699">El valor devuelto por `ldflda` es un puntero administrado (tipo `&`) a menos que el objeto se inserta en la pila como un puntero no administrado, en cuyo caso la dirección de devolución es también un puntero no administrado (tipo `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="e8764-2700">El `ldflda` instrucción puede ir precedida de una o ambas de las <xref:System.Reflection.Emit.OpCodes.Unaligned> y <xref:System.Reflection.Emit.OpCodes.Volatile> prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="e8764-2701"><xref:System.InvalidOperationException> se produce si el objeto no está dentro del dominio de aplicación desde el que se está accediendo.</span><span class="sxs-lookup"><span data-stu-id="e8764-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="e8764-2702">No se puede cargar la dirección de un campo que no está en el acceso a dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="e8764-2703"><xref:System.NullReferenceException> se produce si el objeto es null y el campo no es estático.</span><span class="sxs-lookup"><span data-stu-id="e8764-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="e8764-2704"><xref:System.MissingFieldException> se produce si el campo especificado no se encuentra en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="e8764-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="e8764-2705">Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="e8764-2706">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldflda` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2707">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2708">Inserta en la pila de evaluación un puntero no administrado (de tipo <see langword="native int" />) al código nativo que implementa un método específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2709">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2710">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2710">Format</span></span>|<span data-ttu-id="e8764-2711">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2711">Assembly Format</span></span>|<span data-ttu-id="e8764-2712">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2713">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="e8764-2714">ldftn `method`</span><span class="sxs-lookup"><span data-stu-id="e8764-2714">ldftn `method`</span></span>|<span data-ttu-id="e8764-2715">Inserta un puntero a un método al que hace referencia `method` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2716">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2717">El puntero no administrado a un método específico se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2718">El método específico (`method`) se puede llamar mediante el <xref:System.Reflection.Emit.OpCodes.Calli> instrucción si hace referencia a un método administrado (o un código auxiliar que realiza la transición de código administrado al código no administrado).</span><span class="sxs-lookup"><span data-stu-id="e8764-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="e8764-2719">El valor devuelto hace referencia a código nativo mediante la convención de llamada de CLR.</span><span class="sxs-lookup"><span data-stu-id="e8764-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="e8764-2720">This (puntero) método no se debe pasar a código nativo no administrado como una rutina de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="e8764-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="e8764-2721">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldftn` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2722">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2723">Carga indirectamente un valor de tipo <see langword="native int" /> como <see langword="native int" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2724">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2725">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2725">Format</span></span>|<span data-ttu-id="e8764-2726">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2726">Assembly Format</span></span>|<span data-ttu-id="e8764-2727">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2728">4D</span><span class="sxs-lookup"><span data-stu-id="e8764-2728">4D</span></span>|<span data-ttu-id="e8764-2729">ldind.i</span><span class="sxs-lookup"><span data-stu-id="e8764-2729">ldind.i</span></span>|<span data-ttu-id="e8764-2730">Carga el `native int` valor en la dirección `addr` en la pila como un `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="e8764-2731">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2732">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2733">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2734">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2735">El `ldind.i` instrucción carga indirectamente un `native int` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="e8764-2736">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2737">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2738">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2739">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2740">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2741">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2742">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2743">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2744"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2745">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.i` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2747">Carga indirectamente un valor de tipo <see langword="int8" /> como <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2748">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2749">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2749">Format</span></span>|<span data-ttu-id="e8764-2750">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2750">Assembly Format</span></span>|<span data-ttu-id="e8764-2751">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2752">46</span><span class="sxs-lookup"><span data-stu-id="e8764-2752">46</span></span>|<span data-ttu-id="e8764-2753">ldind.i1</span><span class="sxs-lookup"><span data-stu-id="e8764-2753">ldind.i1</span></span>|<span data-ttu-id="e8764-2754">Carga el `int8` valor en la dirección `addr` en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2755">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2756">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2757">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2758">El valor obtenido se inserta en la pila...</span><span class="sxs-lookup"><span data-stu-id="e8764-2758">The fetched value is pushed onto the stack..</span></span>  
  
 <span data-ttu-id="e8764-2759">El `ldind.i1` instrucción carga indirectamente un `int8` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2760">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2761">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2762">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2763">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2764">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2765">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2766">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2767">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2768"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2769">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.i1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2771">Carga indirectamente un valor de tipo <see langword="int16" /> como <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2772">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2773">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2773">Format</span></span>|<span data-ttu-id="e8764-2774">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2774">Assembly Format</span></span>|<span data-ttu-id="e8764-2775">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2776">48</span><span class="sxs-lookup"><span data-stu-id="e8764-2776">48</span></span>|<span data-ttu-id="e8764-2777">ldind.i2</span><span class="sxs-lookup"><span data-stu-id="e8764-2777">ldind.i2</span></span>|<span data-ttu-id="e8764-2778">Carga el `int16` valor en la dirección `addr` en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2779">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2780">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2781">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2782">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2783">El `ldind.i2` instrucción carga indirectamente un `int16` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2784">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2785">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2786">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2787">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2788">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2789">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2790">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2791">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2792"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2793">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.i2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2795">Carga indirectamente un valor de tipo <see langword="int32" /> como <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2796">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2797">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2797">Format</span></span>|<span data-ttu-id="e8764-2798">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2798">Assembly Format</span></span>|<span data-ttu-id="e8764-2799">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2800">4A</span><span class="sxs-lookup"><span data-stu-id="e8764-2800">4A</span></span>|<span data-ttu-id="e8764-2801">ldind.i4</span><span class="sxs-lookup"><span data-stu-id="e8764-2801">ldind.i4</span></span>|<span data-ttu-id="e8764-2802">Carga el `int32` valor en la dirección `addr` en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2803">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2804">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2805">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2806">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2807">El `ldind.i4` instrucción carga indirectamente un `int32` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2808">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2809">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2810">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2811">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2812">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2813">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2814">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2815">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2816"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2817">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2819">Carga indirectamente un valor de tipo <see langword="int64" /> como <see langword="int64" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2820">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2821">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2821">Format</span></span>|<span data-ttu-id="e8764-2822">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2822">Assembly Format</span></span>|<span data-ttu-id="e8764-2823">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2824">4C</span><span class="sxs-lookup"><span data-stu-id="e8764-2824">4C</span></span>|<span data-ttu-id="e8764-2825">ldind.i8</span><span class="sxs-lookup"><span data-stu-id="e8764-2825">ldind.i8</span></span>|<span data-ttu-id="e8764-2826">Carga el `int64` valor en la dirección `addr` en la pila como un `int64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="e8764-2827">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2828">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2829">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2830">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2831">El `ldind.i8` instrucción carga indirectamente un `int64` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `int64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="e8764-2832">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2833">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2834">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2835">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2836">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2837">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2838">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2839">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2840"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2841">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2843">Carga indirectamente un valor de tipo <see langword="float32" /> como tipo <see langword="F" /> (flotante) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2844">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2845">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2845">Format</span></span>|<span data-ttu-id="e8764-2846">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2846">Assembly Format</span></span>|<span data-ttu-id="e8764-2847">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2848">4E</span><span class="sxs-lookup"><span data-stu-id="e8764-2848">4E</span></span>|<span data-ttu-id="e8764-2849">ldind.r4</span><span class="sxs-lookup"><span data-stu-id="e8764-2849">ldind.r4</span></span>|<span data-ttu-id="e8764-2850">Carga el `float32` valor en la dirección `addr` en la pila como un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="e8764-2851">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2852">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2853">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2854">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2855">El `ldind.r4` instrucción carga indirectamente un `float32` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="e8764-2856">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2857">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2858">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2859">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2860">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2861">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2862">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2863">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2864"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2865">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.r4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2867">Carga indirectamente un valor de tipo <see langword="float64" /> como tipo <see langword="F" /> (flotante) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2868">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2869">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2869">Format</span></span>|<span data-ttu-id="e8764-2870">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2870">Assembly Format</span></span>|<span data-ttu-id="e8764-2871">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2872">4F</span><span class="sxs-lookup"><span data-stu-id="e8764-2872">4F</span></span>|<span data-ttu-id="e8764-2873">ldind.r8</span><span class="sxs-lookup"><span data-stu-id="e8764-2873">ldind.r8</span></span>|<span data-ttu-id="e8764-2874">Carga el `float64` valor en la dirección `addr` en la pila como un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="e8764-2875">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2876">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2877">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2878">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2879">El `ldind.r8` instrucción carga indirectamente un `float64` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `float64`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="e8764-2880">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2881">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2882">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2883">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2884">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2885">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2886">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2887">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2888"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2889">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.r8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2891">Carga indirectamente una referencia a objeto como tipo <see langword="O" /> (referencia a objeto) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2892">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2893">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2893">Format</span></span>|<span data-ttu-id="e8764-2894">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2894">Assembly Format</span></span>|<span data-ttu-id="e8764-2895">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2896">50</span><span class="sxs-lookup"><span data-stu-id="e8764-2896">50</span></span>|<span data-ttu-id="e8764-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="e8764-2897">ldind.ref</span></span>|<span data-ttu-id="e8764-2898">Carga la referencia al objeto en la dirección `addr` en la pila como un tipo `O`</span><span class="sxs-lookup"><span data-stu-id="e8764-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="e8764-2899">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2900">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2901">La dirección se extrae de la pila; la referencia de objeto que se encuentra en la dirección se recupera.</span><span class="sxs-lookup"><span data-stu-id="e8764-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2902">La referencia obtenida se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2903">El `ldind.ref` instrucción carga indirectamente la referencia de objeto la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="e8764-2904">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2905">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2906">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2907">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2908">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2909">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2910">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2911">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2912"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2913">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.ref` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2915">Carga indirectamente un valor de tipo <see langword="unsigned int8" /> como <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2916">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2917">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2917">Format</span></span>|<span data-ttu-id="e8764-2918">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2918">Assembly Format</span></span>|<span data-ttu-id="e8764-2919">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2920">47</span><span class="sxs-lookup"><span data-stu-id="e8764-2920">47</span></span>|<span data-ttu-id="e8764-2921">ldind.u1</span><span class="sxs-lookup"><span data-stu-id="e8764-2921">ldind.u1</span></span>|<span data-ttu-id="e8764-2922">Carga el `unsigned int8` valor en la dirección `addr` en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2923">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2924">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2925">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2926">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2927">El `ldind.u1` instrucción carga indirectamente un `unsigned int8` valor de la dirección especificada (de tipo`native int`, `&`, o \*) en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2928">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2929">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2930">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2931">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2932">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2933">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2934">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2935">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2936"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2937">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.u1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2939">Carga indirectamente un valor de tipo <see langword="unsigned int16" /> como <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2940">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2941">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2941">Format</span></span>|<span data-ttu-id="e8764-2942">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2942">Assembly Format</span></span>|<span data-ttu-id="e8764-2943">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2944">49</span><span class="sxs-lookup"><span data-stu-id="e8764-2944">49</span></span>|<span data-ttu-id="e8764-2945">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="e8764-2945">ldind.u2</span></span>|<span data-ttu-id="e8764-2946">Carga el `unsigned int16` valor en la dirección `addr` en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2947">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2948">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2949">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2950">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2951">El `ldind.u2` instrucción carga indirectamente un `unsigned int16` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2952">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2953">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2954">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2955">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2956">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2957">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2958">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2959">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2960"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2961">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.u2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2963">Carga indirectamente un valor de tipo <see langword="unsigned int32" /> como <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2964">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2965">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2965">Format</span></span>|<span data-ttu-id="e8764-2966">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2966">Assembly Format</span></span>|<span data-ttu-id="e8764-2967">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2968">4B</span><span class="sxs-lookup"><span data-stu-id="e8764-2968">4B</span></span>|<span data-ttu-id="e8764-2969">ldind.u4</span><span class="sxs-lookup"><span data-stu-id="e8764-2969">ldind.u4</span></span>|<span data-ttu-id="e8764-2970">Carga el `unsigned int32` valor en la dirección `addr` en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="e8764-2971">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2972">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2973">La dirección se extrae de la pila; se captura el valor situado en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="e8764-2974">El valor obtenido se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2975">El `ldind.u4` instrucción carga indirectamente un `unsigned int32` valor de la dirección especificada (de tipo `native int`, `&`, o \*) en la pila como un `int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="e8764-2976">Todos los `ldind` instrucciones son accesos directos para un <xref:System.Reflection.Emit.OpCodes.Ldobj> instrucción que especifica la clase de valor integrado correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="e8764-2977">Tenga en cuenta que los valores enteros de menos de 4 bytes se extienden a `int32` (no `native int`) cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="e8764-2978">Valores de punto flotante se convierten en `F` escriba cuando se cargan en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-2979">Con el formato correcto Microsoft Intermediate Language (MSIL) se asegura de que el `ldind` instrucciones se usan de forma coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="e8764-2980">La dirección insertada inicialmente en la pila debe estar alineada con el tamaño natural de los objetos en el equipo o un <xref:System.NullReferenceException> pueden producirse (vea la <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción para medidas preventivas con el prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="e8764-2981">Los resultados de todas las instrucciones de MSIL que devuelven direcciones (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> y <xref:System.Reflection.Emit.OpCodes.Ldarga>) están correctamente alineados.</span><span class="sxs-lookup"><span data-stu-id="e8764-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="e8764-2982">Para tipos de datos mayores de 1 byte, el orden de bytes depende de la CPU de destino.</span><span class="sxs-lookup"><span data-stu-id="e8764-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="e8764-2983">Código que se base en el orden de bytes podría no funcionar en todas las plataformas.</span><span class="sxs-lookup"><span data-stu-id="e8764-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="e8764-2984"><xref:System.NullReferenceException> se puede producir si se detecta una dirección no válida.</span><span class="sxs-lookup"><span data-stu-id="e8764-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="e8764-2985">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldind.u4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-2987">Inserta en la pila de evaluación el número de elementos de una matriz unidimensional de base cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-2988">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-2989">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-2989">Format</span></span>|<span data-ttu-id="e8764-2990">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-2990">Assembly Format</span></span>|<span data-ttu-id="e8764-2991">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-2992">8E</span><span class="sxs-lookup"><span data-stu-id="e8764-2992">8E</span></span>|<span data-ttu-id="e8764-2993">ldlen</span><span class="sxs-lookup"><span data-stu-id="e8764-2993">ldlen</span></span>|<span data-ttu-id="e8764-2994">Inserta la longitud (de tipo `natural unsigned int`) de una matriz en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-2995">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-2996">Una referencia de objeto a una matriz se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-2997">La referencia de la matriz se extrae de la pila y se calcula la longitud.</span><span class="sxs-lookup"><span data-stu-id="e8764-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="e8764-2998">La longitud se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-2999">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3000">La longitud se devuelve como un `natural unsigned int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="e8764-3001"><xref:System.NullReferenceException> se produce si la referencia de la matriz es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3002">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldlen` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3004">Carga en la pila de evaluación la variable local que se encuentra en un índice específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3004">Loads the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3005">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3006">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3006">Format</span></span>|<span data-ttu-id="e8764-3007">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3007">Assembly Format</span></span>|<span data-ttu-id="e8764-3008">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3009">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="e8764-3010">ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-3010">ldloc `index`</span></span>|<span data-ttu-id="e8764-3011">Carga la variable local en el índice `index` en pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="e8764-3012">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3013">El valor de la variable local en el índice especificado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3014">El `ldloc` instrucción inserta el contenido del número de variable local en el índice pasado en la pila de evaluación, donde las variables locales están numeradas del 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="e8764-3015">Las variables locales se inicializan en 0 antes de especificar el método sólo si el indicador de inicialización del método es true.</span><span class="sxs-lookup"><span data-stu-id="e8764-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="e8764-3016">Existen 65.535 (2 ^ 16 - 1) variables locales posibles (0-65534).</span><span class="sxs-lookup"><span data-stu-id="e8764-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="e8764-3017">Índice 65.535 no es válido, ya que probablemente en las implementaciones utilizará un entero de 2 bytes para realizar el seguimiento de índice del local, junto con el número total de variables locales de un método determinado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="e8764-3018">Si ha realizado un índice de 65535 válido, se necesitaría un entero más amplio realizar un seguimiento del número de variables locales en un método de este tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="e8764-3019">El `ldloc.0`, `ldloc.1`, `ldloc.2`, y `ldloc.3` instrucciones proporcionan una codificación eficaz para tener acceso a las cuatro primeras variables locales.</span><span class="sxs-lookup"><span data-stu-id="e8764-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="e8764-3020">El tipo del valor es el mismo que el tipo de la variable local, que se especifica en el encabezado del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="e8764-3021">Vea las variables locales de I. de partición que sea menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-3022">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-3023">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `ldloc` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="e8764-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="e8764-3025">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="e8764-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3026">Carga en la pila de evaluación la variable local que se encuentra en el índice 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3026">Loads the local variable at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3027">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3028">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3028">Format</span></span>|<span data-ttu-id="e8764-3029">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3029">Assembly Format</span></span>|<span data-ttu-id="e8764-3030">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3031">06</span><span class="sxs-lookup"><span data-stu-id="e8764-3031">06</span></span>|<span data-ttu-id="e8764-3032">ldloc.0</span><span class="sxs-lookup"><span data-stu-id="e8764-3032">ldloc.0</span></span>|<span data-ttu-id="e8764-3033">Carga la variable local que se encuentra en el índice 0 en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="e8764-3034">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3035">El valor de la variable local en el índice 0 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3036">`ldloc.0` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitir el acceso a la variable local en el índice 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="e8764-3037">El tipo del valor es el mismo que el tipo de la variable local, que se especifica en el encabezado del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="e8764-3038">Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-3039">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-3040">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldloc.0` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3042">Carga en la pila de evaluación la variable local que se encuentra en el índice 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3042">Loads the local variable at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3043">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3044">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3044">Format</span></span>|<span data-ttu-id="e8764-3045">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3045">Assembly Format</span></span>|<span data-ttu-id="e8764-3046">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3047">07</span><span class="sxs-lookup"><span data-stu-id="e8764-3047">07</span></span>|<span data-ttu-id="e8764-3048">ldloc.1</span><span class="sxs-lookup"><span data-stu-id="e8764-3048">ldloc.1</span></span>|<span data-ttu-id="e8764-3049">Carga en la pila de evaluación la variable local que se encuentra en el índice 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="e8764-3050">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3051">El valor de la variable local en el índice 1 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3052">`ldloc.1` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitir el acceso a la variable local en el índice 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="e8764-3053">El tipo del valor es el mismo que el tipo de la variable local, que se especifica en el encabezado del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="e8764-3054">Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-3055">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-3056">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldloc.1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3058">Carga en la pila de evaluación la variable local que se encuentra en el índice 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3058">Loads the local variable at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3059">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3060">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3060">Format</span></span>|<span data-ttu-id="e8764-3061">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3061">Assembly Format</span></span>|<span data-ttu-id="e8764-3062">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3063">08</span><span class="sxs-lookup"><span data-stu-id="e8764-3063">08</span></span>|<span data-ttu-id="e8764-3064">ldloc.2</span><span class="sxs-lookup"><span data-stu-id="e8764-3064">ldloc.2</span></span>|<span data-ttu-id="e8764-3065">Carga en la pila de evaluación la variable local que se encuentra en el índice 2.</span><span class="sxs-lookup"><span data-stu-id="e8764-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="e8764-3066">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3067">El valor de la variable local en el índice 2 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3068">`ldloc.2` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitir el acceso a la variable local en el índice 2.</span><span class="sxs-lookup"><span data-stu-id="e8764-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="e8764-3069">El tipo del valor es el mismo que el tipo de la variable local, que se especifica en el encabezado del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="e8764-3070">Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-3071">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-3072">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldloc.2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3074">Carga en la pila de evaluación la variable local que se encuentra en el índice 3.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3074">Loads the local variable at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3075">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3076">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3076">Format</span></span>|<span data-ttu-id="e8764-3077">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3077">Assembly Format</span></span>|<span data-ttu-id="e8764-3078">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3079">09</span><span class="sxs-lookup"><span data-stu-id="e8764-3079">09</span></span>|<span data-ttu-id="e8764-3080">ldloc.3</span><span class="sxs-lookup"><span data-stu-id="e8764-3080">ldloc.3</span></span>|<span data-ttu-id="e8764-3081">Carga en la pila de evaluación la variable local que se encuentra en el índice 3.</span><span class="sxs-lookup"><span data-stu-id="e8764-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="e8764-3082">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3083">El valor de la variable local en el índice 3 se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3084">`ldloc.3` es una codificación especialmente eficaz para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitir el acceso a la variable local en el índice 3.</span><span class="sxs-lookup"><span data-stu-id="e8764-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="e8764-3085">El tipo del valor es el mismo que el tipo de la variable local, que se especifica en el encabezado del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="e8764-3086">Las variables locales que son menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-3087">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-3088">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldloc.3` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3090">Carga en la pila de evaluación la variable local que se encuentra en un índice específico (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3091">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3092">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3092">Format</span></span>|<span data-ttu-id="e8764-3093">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3093">Assembly Format</span></span>|<span data-ttu-id="e8764-3094">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-3096">ldloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-3096">ldloc.s `index`</span></span>|<span data-ttu-id="e8764-3097">Carga la variable local en el índice `index` en pila, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="e8764-3098">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3099">El valor de la variable local en el índice especificado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3100">El `ldloc.s` instrucción inserta el contenido del número de variable local en el índice pasado en la pila de evaluación, donde las variables locales están numeradas del 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="e8764-3101">Las variables locales se inicializan en 0 antes de especificar el método si el indicador de inicialización del método es true.</span><span class="sxs-lookup"><span data-stu-id="e8764-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="e8764-3102">Existen 256 (2 ^ 8) variables locales posibles (0-255) en la forma abreviada, que es una codificación más eficaz que `ldloc`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="e8764-3103">El tipo del valor es el mismo que el tipo de la variable local, que se especifica en el encabezado del método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="e8764-3104">Vea las variables locales de I. de partición que sea menores que la longitud de 4 bytes se expanden al tipo `int32` cuando se cargan en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="e8764-3105">Valores de punto flotante se expanden hasta su tamaño nativo (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="e8764-3106">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `ldloc.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="e8764-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="e8764-3108">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3109">Carga en la pila de evaluación la dirección de la variable local que se encuentra en un índice específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3110">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3111">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3111">Format</span></span>|<span data-ttu-id="e8764-3112">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3112">Assembly Format</span></span>|<span data-ttu-id="e8764-3113">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3114">OD FE &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="e8764-3115">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-3115">ldloca `index`</span></span>|<span data-ttu-id="e8764-3116">Carga la dirección de la variable local en `index` en la pila de evaluación.</span><span class="sxs-lookup"><span data-stu-id="e8764-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="e8764-3117">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3118">La dirección almacenada en la variable local en el índice especificado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3119">El `ldloca` instrucción inserta la dirección del número de variable local en el índice pasado en la pila, donde las variables locales están numeradas del 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="e8764-3120">El valor insertado en la pila ya está alineado correctamente para su uso con instrucciones como <xref:System.Reflection.Emit.OpCodes.Ldind_I> y <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="e8764-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="e8764-3121">El resultado es un puntero transitorio (tipo `*`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="e8764-3122">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldloca` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3123">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="e8764-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3124">Carga en la pila de evaluación la dirección de la variable local que se encuentra en un índice específico (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3125">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3126">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3126">Format</span></span>|<span data-ttu-id="e8764-3127">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3127">Assembly Format</span></span>|<span data-ttu-id="e8764-3128">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-3130">ldloca.s `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-3130">ldloca.s `index`</span></span>|<span data-ttu-id="e8764-3131">Carga la dirección de la variable local en `index` en la pila de evaluación, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="e8764-3132">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3133">La dirección almacenada en la variable local en el índice especificado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3134">El `ldloca.s` instrucción inserta la dirección del número de variable local en el índice pasado en la pila, donde las variables locales están numeradas del 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="e8764-3135">El valor insertado en la pila ya está alineado correctamente para su uso con instrucciones como <xref:System.Reflection.Emit.OpCodes.Ldind_I> y <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="e8764-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="e8764-3136">El resultado es un puntero transitorio (tipo `*`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="e8764-3137">El `ldloca.s` instrucción proporciona una codificación eficaz para su uso con las variables locales 0 y 255.</span><span class="sxs-lookup"><span data-stu-id="e8764-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="e8764-3138">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldloca.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3139">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3140">Inserta una referencia nula (de tipo <see langword="O" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3141">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3142">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3142">Format</span></span>|<span data-ttu-id="e8764-3143">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3143">Assembly Format</span></span>|<span data-ttu-id="e8764-3144">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3145">14</span><span class="sxs-lookup"><span data-stu-id="e8764-3145">14</span></span>|<span data-ttu-id="e8764-3146">ldnull</span><span class="sxs-lookup"><span data-stu-id="e8764-3146">ldnull</span></span>|<span data-ttu-id="e8764-3147">Inserta una referencia nula en la pila</span><span class="sxs-lookup"><span data-stu-id="e8764-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="e8764-3148">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3149">Una referencia de objeto nulo se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3150">`ldnull` Inserta una referencia nula (tipo `O`) en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="e8764-3151">Esto se utiliza para inicializar ubicaciones antes de que se rellenan con datos o cuando han quedado obsoletas.</span><span class="sxs-lookup"><span data-stu-id="e8764-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="e8764-3152">`ldnull` Proporciona una referencia nula que no depende del tamaño.</span><span class="sxs-lookup"><span data-stu-id="e8764-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="e8764-3153">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldnull` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3155">Copia en la parte superior de la pila de evaluación el objeto de tipo de valor al que señala una dirección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3156">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3157">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3157">Format</span></span>|<span data-ttu-id="e8764-3158">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3158">Assembly Format</span></span>|<span data-ttu-id="e8764-3159">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3160">71 < `T` ></span></span>|<span data-ttu-id="e8764-3161">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="e8764-3161">ldobj `class`</span></span>|<span data-ttu-id="e8764-3162">Copia una instancia de tipo de valor `class` a la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3163">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3164">La dirección de un objeto de tipo de valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3165">La dirección se extrae de la pila y se busca la instancia en esa dirección particular.</span><span class="sxs-lookup"><span data-stu-id="e8764-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="e8764-3166">El valor del objeto almacenado en esa dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3167">El `ldobj` instrucción se utiliza para pasar un tipo de valor como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="e8764-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="e8764-3168">El `ldobj` instrucción copia el valor al que señala `addrOfValObj` (de tipo `&`, `*`, o `native int`) a la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="e8764-3169">El número de bytes que se copia depende del tamaño de la clase (según lo especificado por el `class` parámetro).</span><span class="sxs-lookup"><span data-stu-id="e8764-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="e8764-3170">El `class` parámetro es un token de metadatos que representa el tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="e8764-3171">La operación de la `ldobj` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-3172"><xref:System.TypeLoadException> se produce si no se pudo encontrar la clase.</span><span class="sxs-lookup"><span data-stu-id="e8764-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="e8764-3173">Normalmente, esto se detecta cuando la instrucción de lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-3174">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldobj` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3175">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3176">Inserta el valor de un campo estático en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3176">Pushes the value of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3177">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3178">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3178">Format</span></span>|<span data-ttu-id="e8764-3179">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3179">Assembly Format</span></span>|<span data-ttu-id="e8764-3180">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3181">7E < `T` ></span></span>|<span data-ttu-id="e8764-3182">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="e8764-3182">ldsfld `field`</span></span>|<span data-ttu-id="e8764-3183">Inserta el valor de `field` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3184">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3185">El valor del campo específico se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3186">El `ldsfld` instrucción inserta el valor de un estático (compartido entre todas las instancias de una clase) en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="e8764-3187">El tipo de valor devuelto está asociado con el token de metadatos pasado `field`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="e8764-3188">El `ldsfld` instrucción puede tener un <xref:System.Reflection.Emit.OpCodes.Volatile> prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="e8764-3189">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldsfld` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3190">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3191">Inserta la dirección de un campo estático en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3191">Pushes the address of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3192">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3193">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3193">Format</span></span>|<span data-ttu-id="e8764-3194">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3194">Assembly Format</span></span>|<span data-ttu-id="e8764-3195">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3196">7F < `T` ></span></span>|<span data-ttu-id="e8764-3197">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="e8764-3197">ldsflda `field`</span></span>|<span data-ttu-id="e8764-3198">Inserta la dirección de `field` en la pila</span><span class="sxs-lookup"><span data-stu-id="e8764-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="e8764-3199">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3200">La dirección de un campo específico se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3201">El `ldsflda` instrucción inserta la dirección de un estático (compartido entre todas las instancias de una clase) en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="e8764-3202">La dirección puede estar representada mediante un puntero transitorio (tipo `*`) si el token de metadatos `field` hace referencia a un tipo cuya memoria se administra.</span><span class="sxs-lookup"><span data-stu-id="e8764-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="e8764-3203">En caso contrario, se corresponde con un puntero no administrado (tipo `native int`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="e8764-3204">Tenga en cuenta que `field` puede ser estático global con una dirección virtual relativa asignada (el desplazamiento del campo de la dirección base en el que el archivo PE contenedor se carga en memoria) donde se administra la memoria.</span><span class="sxs-lookup"><span data-stu-id="e8764-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="e8764-3205">El `ldsflda` instrucción puede tener un <xref:System.Reflection.Emit.OpCodes.Volatile> prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="e8764-3206"><xref:System.MissingFieldException> se produce si el campo no se encuentra en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="e8764-3207">Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="e8764-3208">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldsflda` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3209">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3210">Inserta una nueva referencia de objeto a un literal de cadena almacenado en los metadatos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3210">Pushes a new object reference to a string literal stored in the metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3211">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3212">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3212">Format</span></span>|<span data-ttu-id="e8764-3213">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3213">Assembly Format</span></span>|<span data-ttu-id="e8764-3214">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3215">72 < `T` ></span></span>|<span data-ttu-id="e8764-3216">ldstr `mdToken`</span><span class="sxs-lookup"><span data-stu-id="e8764-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="e8764-3217">Inserta un objeto de cadena para el token de cadena de metadatos `mdToken`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="e8764-3218">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3219">Una referencia de objeto a una cadena se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3220">El `ldstr` instrucción inserta una referencia de objeto (tipo `O`) a un nuevo objeto de cadena que representa el literal de cadena específico almacenado en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="e8764-3221">El `ldstr` instrucción asigna la cantidad de memoria y realiza las conversiones de formato necesarias para convertir el literal de cadena de la forma que en el archivo para el formato de cadena necesario en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="e8764-3222">Common Language Infrastructure (CLI) garantiza que el resultado de dos `ldstr` instrucciones que hacen referencia a dos tokens de metadatos que tienen la misma secuencia de caracteres devuelven exactamente el mismo objeto de cadena (un proceso conocido como "interning").</span><span class="sxs-lookup"><span data-stu-id="e8764-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="e8764-3223">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldstr` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3224">ILGenerator.Emit (código de operación, cadena)</span><span class="sxs-lookup"><span data-stu-id="e8764-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3225">Convierte un símbolo (token) de metadatos en su representación en tiempo de ejecución y lo inserta en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3226">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3227">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3227">Format</span></span>|<span data-ttu-id="e8764-3228">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3228">Assembly Format</span></span>|<span data-ttu-id="e8764-3229">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3230">D0 < `T` ></span></span>|<span data-ttu-id="e8764-3231">ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="e8764-3231">ldtoken `token`</span></span>|<span data-ttu-id="e8764-3232">Convierte un símbolo (token) de metadatos en su representación en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="e8764-3233">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3234">El token pasado se convierte en un `RuntimeHandle` y se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3235">El `ldtoken` instrucción inserta un `RuntimeHandle` para el token de metadatos especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="e8764-3236">A `RuntimeHandle` puede ser un `fieldref/fielddef`, `methodref/methoddef`, o un `typeref/typedef`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="e8764-3237">El valor insertado en la pila se puede utilizar en las llamadas a `Reflection` métodos en la biblioteca de clases del sistema.</span><span class="sxs-lookup"><span data-stu-id="e8764-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="e8764-3238">Para obtener información sobre los identificadores en tiempo de ejecución, vea las clases siguientes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, y <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="e8764-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="e8764-3239">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `ldtoken` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3240">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="e8764-3241">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="e8764-3242">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3243">Inserta en la pila de evaluación un puntero no administrado (de tipo <see langword="native int" />) al código nativo que implementa un método virtual concreto que está asociado al objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3244">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3245">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3245">Format</span></span>|<span data-ttu-id="e8764-3246">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3246">Assembly Format</span></span>|<span data-ttu-id="e8764-3247">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3248">FE 07 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="e8764-3249">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="e8764-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="e8764-3250">Inserta el puntero al método virtual de un objeto `method` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3251">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3252">Una referencia de objeto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3253">La referencia de objeto se extrae de la pila y la dirección del punto de entrada al método (tal y como especifica el token de metadatos `method`) se busca.</span><span class="sxs-lookup"><span data-stu-id="e8764-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="e8764-3254">El puntero a `method` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3255">El puntero no administrado resultante se inserta en la pila por la `ldvirtftn` instrucción se puede llamar mediante el <xref:System.Reflection.Emit.OpCodes.Calli> instrucción si hace referencia a un método administrado (o un código auxiliar que realiza la transición de código administrado al código no administrado).</span><span class="sxs-lookup"><span data-stu-id="e8764-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="e8764-3256">Señala el puntero no administrado a código nativo mediante la convención de llamada de CLR.</span><span class="sxs-lookup"><span data-stu-id="e8764-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="e8764-3257">This (puntero) método no se debe pasar a código nativo no administrado como una rutina de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="e8764-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="e8764-3258">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ldvirtftn` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3259">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3260">Sale de una región de código protegida y transfiere el control incondicionalmente a una instrucción máquina de destino específica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3261">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3262">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3262">Format</span></span>|<span data-ttu-id="e8764-3263">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3263">Assembly Format</span></span>|<span data-ttu-id="e8764-3264">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3265">DD < `int32` ></span></span>|<span data-ttu-id="e8764-3266">deje `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-3266">leave `target`</span></span>|<span data-ttu-id="e8764-3267">Sale de una región de código protegida.</span><span class="sxs-lookup"><span data-stu-id="e8764-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="e8764-3268">Hay un comportamiento de transición de pila especificado para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-3269">El `leave` instrucción transfiere incondicionalmente el control a la instrucción máquina de destino específica, representada como un desfase con signo de 4 bytes desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-3270">El `leave` instrucción es similar a la `br` instrucción, pero se puede utilizar para salir de un `try`, `filter`, o `catch` bloquear mientras que las instrucciones de bifurcación normales sólo se pueden utilizar en estos bloques para transferir el control dentro de él.</span><span class="sxs-lookup"><span data-stu-id="e8764-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="e8764-3271">El `leave` instrucción vacía la pila de evaluación y garantiza que la circundantes correspondientes `finally` los bloques se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="e8764-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="e8764-3272">No se puede utilizar un `leave` instrucciones para salir de un `finally` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="e8764-3273">Para facilitar la generación de código para controladores de excepciones es válido desde dentro de un bloque catch para usar un `leave` instrucción para transferir el control a cualquier instrucción dentro asociado `try` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="e8764-3274">Si una instrucción tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="e8764-3275">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `leave` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3276">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3277">Sale de una región de código protegida y transfiere el control incondicionalmente a una instrucción máquina de destino (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3278">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3279">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3279">Format</span></span>|<span data-ttu-id="e8764-3280">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3280">Assembly Format</span></span>|<span data-ttu-id="e8764-3281">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3282">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3282">DE < `int8` ></span></span>|<span data-ttu-id="e8764-3283">leave.s `target`</span><span class="sxs-lookup"><span data-stu-id="e8764-3283">leave.s `target`</span></span>|<span data-ttu-id="e8764-3284">Salir de una región protegida de código, de forma abreviada.</span><span class="sxs-lookup"><span data-stu-id="e8764-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="e8764-3285">Hay un comportamiento de transición de pila especificado para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-3286">El `leave.s` instrucción transfiere incondicionalmente el control a la instrucción de destino ha pasado, representada como un desplazamiento de 1 byte con signo desde el principio de la instrucción que sigue a la instrucción actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="e8764-3287">El `leave.s` instrucción es similar a la `br` instrucción, pero se puede utilizar para salir de un `try`, `filter`, o `catch` bloquear mientras que las instrucciones de bifurcación normales sólo se pueden utilizar en estos bloques para transferir el control dentro de él.</span><span class="sxs-lookup"><span data-stu-id="e8764-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="e8764-3288">El `leave.s` instrucción vacía la pila de evaluación y garantiza que la circundantes correspondientes `finally` los bloques se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="e8764-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="e8764-3289">No se puede utilizar un `leave.s` instrucciones para salir de un `finally` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="e8764-3290">Para facilitar la generación de código para controladores de excepciones es válido desde dentro de un bloque catch para usar un `leave.s` instrucción para transferir el control a cualquier instrucción dentro asociado `try` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="e8764-3291">Si una instrucción tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="e8764-3292">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `leave.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3293">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3294">Asigna un número determinado de bytes del bloque de memoria dinámica local e inserta la dirección (un puntero transitorio de tipo <see langword="*" />) del primer byte asignado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3295">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3296">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3296">Format</span></span>|<span data-ttu-id="e8764-3297">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3297">Assembly Format</span></span>|<span data-ttu-id="e8764-3298">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="e8764-3299">FE 0F</span></span>|<span data-ttu-id="e8764-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="e8764-3300">localloc</span></span>|<span data-ttu-id="e8764-3301">Asignar espacio en el montón local.</span><span class="sxs-lookup"><span data-stu-id="e8764-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="e8764-3302">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3303">El número de bytes que se va a asignar se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3304">El número de bytes se extrae de la pila; se asigna una cantidad de memoria correspondientes al tamaño del montón local.</span><span class="sxs-lookup"><span data-stu-id="e8764-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="e8764-3305">Un puntero al primer byte de la memoria asignada se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3306">El `localloc` instrucción asigna `size` (tipo `natural unsigned int`) grupo de bytes a partir de la memoria dinámica local y devuelve la dirección (un puntero transitorio, escriba `*`) del primer byte asignado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="e8764-3307">El bloque de memoria devuelto se inicializa en 0 sólo si el indicador de inicialización del método es `true`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="e8764-3308">Cuando se ejecuta el método actual un <xref:System.Reflection.Emit.OpCodes.Ret>, el bloque de memoria local debe ponerse a disposición para su reutilización.</span><span class="sxs-lookup"><span data-stu-id="e8764-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="e8764-3309">La dirección resultante se alinea para que cualquier tipo de datos primitivos se puede almacenar allí mediante la `stind` instrucciones (como <xref:System.Reflection.Emit.OpCodes.Stind_I4>) y se cargan mediante la `ldind` instrucciones (como <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span><span class="sxs-lookup"><span data-stu-id="e8764-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="e8764-3310">El `localloc` instrucción no puede aparecer dentro de un `filter`, `catch`, `finally`, o `fault` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="e8764-3311"><xref:System.StackOverflowException> se produce si no hay memoria suficiente para atender la solicitud.</span><span class="sxs-lookup"><span data-stu-id="e8764-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="e8764-3312">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `localloc` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3314">Inserta en la pila de evaluación una referencia con tipo a una instancia de un tipo específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3315">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3316">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3316">Format</span></span>|<span data-ttu-id="e8764-3317">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3317">Assembly Format</span></span>|<span data-ttu-id="e8764-3318">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3319">C6 < `T` ></span></span>|<span data-ttu-id="e8764-3320">mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="e8764-3320">mkrefany `class`</span></span>|<span data-ttu-id="e8764-3321">Inserta una referencia con tipo de tipo `class` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3322">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3323">Un puntero al elemento de datos se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3324">El puntero se extrae y se convierte en una referencia con tipo de tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="e8764-3325">La referencia con tipo se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3326">El `mkrefany` instrucción es compatible con el paso de las referencias a tipos dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="e8764-3327">El puntero debe ser de tipo `&`, `*`, o `native int`y contener la dirección válida de un fragmento de datos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="e8764-3328">`Class` es el símbolo (token) de clase que describe el tipo de datos al que hace referencia el puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="e8764-3329">`Mkrefany` Inserta una referencia con tipo en la pila, proporcionando un descriptor opaco del puntero y el tipo de `class`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="e8764-3330">La operación solo es válida que puede realizar con una referencia con tipo es pasarla a un método que requiera una referencia con tipo como parámetro.</span><span class="sxs-lookup"><span data-stu-id="e8764-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="e8764-3331">El destinatario, a continuación, puede usar el <xref:System.Reflection.Emit.OpCodes.Refanytype> y <xref:System.Reflection.Emit.OpCodes.Refanyval> instrucciones para recuperar el tipo (clase) y la dirección, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="e8764-3332"><xref:System.TypeLoadException> se produce si `class` no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="e8764-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="e8764-3333">Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-3334">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `mkrefany` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3335">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3336">Multiplica dos valores e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3336">Multiplies two values and pushes the result on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3337">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3338">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3338">Format</span></span>|<span data-ttu-id="e8764-3339">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3339">Assembly Format</span></span>|<span data-ttu-id="e8764-3340">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3341">5A</span><span class="sxs-lookup"><span data-stu-id="e8764-3341">5A</span></span>|<span data-ttu-id="e8764-3342">mul</span><span class="sxs-lookup"><span data-stu-id="e8764-3342">mul</span></span>|<span data-ttu-id="e8764-3343">Multiplica dos valores de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3344">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3345">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3346">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3347">`value2` y `value1` se extrae de la pila; `value1` se multiplica por `value2`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="e8764-3348">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3349">El `mul` instrucción multiplica `value1` por `value2` e inserta el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="e8764-3350">Operaciones con enteros truncan sin notificación los bits superiores si se produce desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="e8764-3351">Vea <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> operación con el control del desbordamiento de multiplicación para una específica de valores enteros.</span><span class="sxs-lookup"><span data-stu-id="e8764-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="e8764-3352">Para los tipos de punto flotante, 0 \* infinito = NaN.</span><span class="sxs-lookup"><span data-stu-id="e8764-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="e8764-3353">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `mul` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3355">Multiplica dos valores enteros, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3356">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3357">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3357">Format</span></span>|<span data-ttu-id="e8764-3358">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3358">Assembly Format</span></span>|<span data-ttu-id="e8764-3359">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3360">D8</span><span class="sxs-lookup"><span data-stu-id="e8764-3360">D8</span></span>|<span data-ttu-id="e8764-3361">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="e8764-3361">mul.ovf</span></span>|<span data-ttu-id="e8764-3362">Multiplica dos valores enteros en la pila con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="e8764-3363">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3364">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3365">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3366">`value2` y `value1` se extrae de la pila; `value1` se multiplica por `value2`, con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="e8764-3367">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3368">El `mul.ovf` instrucción multiplica el entero `value1` por entero `value2` e inserta el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="e8764-3369">Se produce una excepción si el resultado no se ajusta al tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="e8764-3370"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-3371">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `mul.ovf` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3373">Multiplica dos valores enteros sin signo, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3374">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3375">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3375">Format</span></span>|<span data-ttu-id="e8764-3376">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3376">Assembly Format</span></span>|<span data-ttu-id="e8764-3377">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3378">D9</span><span class="sxs-lookup"><span data-stu-id="e8764-3378">D9</span></span>|<span data-ttu-id="e8764-3379">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="e8764-3379">mul.ovf.un</span></span>|<span data-ttu-id="e8764-3380">Multiplica dos valores sin signo en la pila con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="e8764-3381">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3382">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3383">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3384">`value2` y `value1` se extrae de la pila; `value1` se multiplica por `value2`, con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="e8764-3385">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3386">El `mul.ovf.un` instrucción multiplica el entero sin signo `value1` por entero sin signo `value2` e inserta el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="e8764-3387">Se produce una excepción si el resultado no se ajusta al tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="e8764-3388"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-3389">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `mul.ovf.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3391">Convierte un valor en negativo e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3391">Negates a value and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3392">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3393">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3393">Format</span></span>|<span data-ttu-id="e8764-3394">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3394">Assembly Format</span></span>|<span data-ttu-id="e8764-3395">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3396">65</span><span class="sxs-lookup"><span data-stu-id="e8764-3396">65</span></span>|<span data-ttu-id="e8764-3397">neg</span><span class="sxs-lookup"><span data-stu-id="e8764-3397">neg</span></span>|<span data-ttu-id="e8764-3398">Niega el valor actualmente en la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3399">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3400">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3401">Un valor se extrae de la pila y se niega.</span><span class="sxs-lookup"><span data-stu-id="e8764-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="e8764-3402">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3403">El `neg` instrucción niega el valor e inserta el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="e8764-3404">El tipo de valor devuelto es el mismo que el tipo de operando.</span><span class="sxs-lookup"><span data-stu-id="e8764-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="e8764-3405">Negación de valores enteros es el estándar del complemento a dos negación.</span><span class="sxs-lookup"><span data-stu-id="e8764-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="e8764-3406">En concreto, produce el número negativo más niega el número más negativo (que no tiene equivalente positivo).</span><span class="sxs-lookup"><span data-stu-id="e8764-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="e8764-3407">Para detectar este desbordamiento, utilice la <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrucción en su lugar (es decir, restar de 0).</span><span class="sxs-lookup"><span data-stu-id="e8764-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="e8764-3408">Niega un número de punto flotante no se produce desbordamiento y niega NaN devuelve NaN.</span><span class="sxs-lookup"><span data-stu-id="e8764-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="e8764-3409">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `neg` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3411">Inserta en la pila de evaluación una referencia de objeto a una nueva matriz unidimensional de base cero cuyos elementos son de un tipo específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3412">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3413">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3413">Format</span></span>|<span data-ttu-id="e8764-3414">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3414">Assembly Format</span></span>|<span data-ttu-id="e8764-3415">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3416">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3416">8D < `T` ></span></span>|<span data-ttu-id="e8764-3417">newarr `etype`</span><span class="sxs-lookup"><span data-stu-id="e8764-3417">newarr `etype`</span></span>|<span data-ttu-id="e8764-3418">Crea una nueva matriz con elementos de tipo `etype`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="e8764-3419">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3420">El número de elementos de la matriz se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3421">El número de elementos se extrae de la pila y se crea la matriz.</span><span class="sxs-lookup"><span data-stu-id="e8764-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="e8764-3422">Una referencia de objeto a la nueva matriz se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3423">El `newarr` instrucción inserta una referencia de objeto (tipo `O`) a una nueva matriz unidimensional de base cero cuyos elementos son de tipo `etype` (símbolo (token) de metadatos que describe el tipo).</span><span class="sxs-lookup"><span data-stu-id="e8764-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="e8764-3424">El número de elementos de la nueva matriz se debe especificar como un `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="e8764-3425">Intervalo de índices de matriz válida entre cero y el número máximo de elementos menos uno.</span><span class="sxs-lookup"><span data-stu-id="e8764-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="e8764-3426">Los elementos de una matriz pueden ser cualquier tipo, incluidos los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="e8764-3427">Matrices unidimensionales de base cero de números se crean mediante un símbolo (token) de metadatos hace referencia al tipo de valor adecuado (<xref:System.Int32>, y así sucesivamente).</span><span class="sxs-lookup"><span data-stu-id="e8764-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="e8764-3428">Elementos de la matriz se inicializan en 0 del tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="e8764-3429">Para matrices unidimensionales y multidimensionales se crean mediante <xref:System.Reflection.Emit.OpCodes.Newobj> en lugar de `newarr`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="e8764-3430">Normalmente, se crean utilizando los métodos de la <xref:System.Array> clase en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="e8764-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="e8764-3431"><xref:System.OutOfMemoryException> se produce si no hay memoria suficiente para satisfacer la solicitud.</span><span class="sxs-lookup"><span data-stu-id="e8764-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="e8764-3432"><xref:System.OverflowException> se produce si `numElems` es menor que 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="e8764-3433">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `newarr` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3434">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3435">Crea un nuevo objeto o una nueva instancia de un tipo de valor e inserta una referencia a objeto (de tipo <see langword="O" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3436">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3437">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3437">Format</span></span>|<span data-ttu-id="e8764-3438">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3438">Assembly Format</span></span>|<span data-ttu-id="e8764-3439">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3440">73 < `T` ></span></span>|<span data-ttu-id="e8764-3441">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="e8764-3441">newobj `ctor`</span></span>|<span data-ttu-id="e8764-3442">Asigna un tipo de objeto o valor no inicializado y llama al método de constructor `ctor`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="e8764-3443">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3444">Argumentos `arg1` a través de `argn` se insertan en la pila en secuencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="e8764-3445">Argumentos `argn` a través de `arg1` se extrae de la pila y se pasan a `ctor` para la creación de objetos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="e8764-3446">Una referencia al nuevo objeto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3447">El `newobj` instrucción crea un nuevo objeto o una nueva instancia de un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="e8764-3448">`Ctor` es un token de metadatos (un `methodref` o `methoddef` que debe marcarse como constructor) que indica el nombre, la clase y la firma del constructor al que llamar.</span><span class="sxs-lookup"><span data-stu-id="e8764-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="e8764-3449">El `newobj` instrucción asigna una nueva instancia de la clase asociada `ctor` e inicializa todos los campos en la nueva instancia en 0 (del tipo correcto) o en referencias nulas según corresponda.</span><span class="sxs-lookup"><span data-stu-id="e8764-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="e8764-3450">A continuación, llama al constructor `ctor` con los argumentos dados junto con la instancia recién creada.</span><span class="sxs-lookup"><span data-stu-id="e8764-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="e8764-3451">Después de llamar al constructor, ahora inicializado referencia de objeto (tipo `O`) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="e8764-3452">Desde el punto de vista del constructor, el objeto sin inicializar es el argumento 0 y los demás argumentos que se pasan a newobj le siguen en orden.</span><span class="sxs-lookup"><span data-stu-id="e8764-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="e8764-3453">Todas las matrices unidimensionales de base cero se crean mediante <xref:System.Reflection.Emit.OpCodes.Newarr>, no `newobj`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="e8764-3454">Por otro lado, todas las demás matrices (de más de una dimensión o unidimensionales no de base cero) se crean mediante `newobj`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="e8764-3455">Tipos de valor no suelen crearse mediante `newobj`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="e8764-3456">Normalmente, se asignan como argumentos o variables locales, mediante `newarr` (para las matrices unidimensionales de base cero), o como campos de objetos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="e8764-3457">Una vez asignados, se inicializan mediante <xref:System.Reflection.Emit.OpCodes.Initobj>.</span><span class="sxs-lookup"><span data-stu-id="e8764-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="e8764-3458">Sin embargo, la `newobj` instrucción puede usarse para crear una nueva instancia de un tipo de valor en la pila, que después puede pasarse como argumento, almacenado en una variable local y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="e8764-3459"><xref:System.OutOfMemoryException> se produce si no hay memoria suficiente para satisfacer la solicitud.</span><span class="sxs-lookup"><span data-stu-id="e8764-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="e8764-3460"><xref:System.MissingMethodException> se produce si un método de constructor `ctor` con el nombre indicado, clase y la firma no se pudieron encontrar.</span><span class="sxs-lookup"><span data-stu-id="e8764-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="e8764-3461">Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-3462">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `newobj` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3464">Rellena el espacio si los códigos de operación se han modificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3464">Fills space if opcodes are patched.</span>
          </span>
          <span data-ttu-id="e8764-3465">No se realiza ninguna operación significativa, aunque puede consumirse un ciclo de procesamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3465">No meaningful operation is performed although a processing cycle can be consumed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3466">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3467">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3467">Format</span></span>|<span data-ttu-id="e8764-3468">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3468">Assembly Format</span></span>|<span data-ttu-id="e8764-3469">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3470">00</span><span class="sxs-lookup"><span data-stu-id="e8764-3470">00</span></span>|<span data-ttu-id="e8764-3471">nop</span><span class="sxs-lookup"><span data-stu-id="e8764-3471">nop</span></span>|<span data-ttu-id="e8764-3472">Realiza una operación sin comportamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="e8764-3473">Hay un comportamiento de transición de pila definido para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-3474">El `nop` operación no hace nada.</span><span class="sxs-lookup"><span data-stu-id="e8764-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="e8764-3475">Está diseñado para que rellene el espacio si los códigos de operación se han modificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="e8764-3476">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `nop` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3478">Calcula el complemento bit a bit del valor entero que se encuentra en la parte superior de la pila e inserta el resultado, del mismo tipo, en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3479">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3480">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3480">Format</span></span>|<span data-ttu-id="e8764-3481">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3481">Assembly Format</span></span>|<span data-ttu-id="e8764-3482">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3483">66</span><span class="sxs-lookup"><span data-stu-id="e8764-3483">66</span></span>|<span data-ttu-id="e8764-3484">not</span><span class="sxs-lookup"><span data-stu-id="e8764-3484">not</span></span>|<span data-ttu-id="e8764-3485">Calcula el complemento bit a bit de un valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="e8764-3486">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3487">`value` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3488">`value` se extrae de la pila y su bit a bit complemento calculado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="e8764-3489">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3490">El `not` calcula el complemento bit a bit de un valor entero e inserta el resultado en la pila de instrucciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="e8764-3491">El tipo de valor devuelto es el mismo que el tipo de operando.</span><span class="sxs-lookup"><span data-stu-id="e8764-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="e8764-3492">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `not` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3494">Calcula el complemento bit a bit de los dos valores enteros situados en la parte superior de la pila e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3495">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3496">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3496">Format</span></span>|<span data-ttu-id="e8764-3497">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3497">Assembly Format</span></span>|<span data-ttu-id="e8764-3498">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3499">60</span><span class="sxs-lookup"><span data-stu-id="e8764-3499">60</span></span>|<span data-ttu-id="e8764-3500">o bien</span><span class="sxs-lookup"><span data-stu-id="e8764-3500">or</span></span>|<span data-ttu-id="e8764-3501">Calcula bit a bit o de dos valores enteros y devuelve un entero.</span><span class="sxs-lookup"><span data-stu-id="e8764-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="e8764-3502">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3503">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3504">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3505">`value2` y `value1` se extraen de la pila y la operación OR bit a bit calculado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="e8764-3506">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3507">El `or` instrucción calcula la operación OR bit a bit de dos valores parte superior de la pila e inserta el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3508">`Or` es una operación específica de valores enteros.</span><span class="sxs-lookup"><span data-stu-id="e8764-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="e8764-3509">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `or` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3511">Quita el valor situado en la parte superior de la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3511">Removes the value currently on top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3512">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3513">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3513">Format</span></span>|<span data-ttu-id="e8764-3514">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3514">Assembly Format</span></span>|<span data-ttu-id="e8764-3515">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3516">26</span><span class="sxs-lookup"><span data-stu-id="e8764-3516">26</span></span>|<span data-ttu-id="e8764-3517">pop</span><span class="sxs-lookup"><span data-stu-id="e8764-3517">pop</span></span>|<span data-ttu-id="e8764-3518">Extrae el valor superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3519">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3520">Se extrae el valor superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="e8764-3521">El `pop` instrucción quita el elemento superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="e8764-3522">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `pop` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3524">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3524">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3525">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3525">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3526">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3526">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3527">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3527">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3528">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3528">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3529">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3529">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3530">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3530">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3531">Esta es una instrucción reservada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3531">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3532">Especifica que la operación de dirección de matriz subsiguiente no realiza ninguna comprobación de tipo en tiempo de ejecución y devuelve un puntero administrado cuya mutabilidad está restringida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3533">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3534">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3534">Format</span></span>|<span data-ttu-id="e8764-3535">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3535">Assembly Format</span></span>|<span data-ttu-id="e8764-3536">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3537">1E FE</span><span class="sxs-lookup"><span data-stu-id="e8764-3537">FE 1E</span></span>|<span data-ttu-id="e8764-3538">de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="e8764-3538">readonly.</span></span>|<span data-ttu-id="e8764-3539">Especificar que la operación de dirección de matriz subsiguiente lleva a cabo ninguna comprobación de tipo en tiempo de ejecución y devuelve un puntero administrado cuya mutabilidad está restringida.</span><span class="sxs-lookup"><span data-stu-id="e8764-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="e8764-3540">Este prefijo sólo puede aparecer inmediatamente anterior la `ldelema` instrucciones y las llamadas a especial `Address` método en las matrices.</span><span class="sxs-lookup"><span data-stu-id="e8764-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="e8764-3541">Su efecto en la operación subsiguiente es doble:</span><span class="sxs-lookup"><span data-stu-id="e8764-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="e8764-3542">En tiempo de ejecución, se realiza ninguna operación de comprobación de tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="e8764-3543">Tenga en cuenta que normalmente es una comprobación de tipos implícita para el `ldelema` y `stelem` instrucciones cuando se usa en la referencia de tipo matrices.</span><span class="sxs-lookup"><span data-stu-id="e8764-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="e8764-3544">Nunca hay una comprobación de tipo en tiempo de ejecución para las clases de valor, por lo que `readonly` es una operación inefectiva en ese caso.</span><span class="sxs-lookup"><span data-stu-id="e8764-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="e8764-3545">El comprobador trata el resultado de la operación de dirección como un puntero administrado cuya mutabilidad está restringida.</span><span class="sxs-lookup"><span data-stu-id="e8764-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="e8764-3546">Se dice que el puntero ha restringido la mutabilidad porque el tipo de definición controla si el valor puede transformarse.</span><span class="sxs-lookup"><span data-stu-id="e8764-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="e8764-3547">Para las clases de valor que no exponen ningún campo público o métodos que actualizan el valor en su lugar, el puntero es de solo lectura (por lo tanto, el nombre del prefijo).</span><span class="sxs-lookup"><span data-stu-id="e8764-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="e8764-3548">En particular, las clases que representan los tipos primitivos (por ejemplo, System.Int32) no exponen mutadores y, por tanto, son de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="e8764-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="e8764-3549">Un puntero administrado restringido de este modo puede utilizarse solo de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="e8764-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="e8764-3550">Como el `object` parámetro para el `ldfld`, `ldflda`, `stfld`, `call`, o`constrained callvirt` instrucciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="e8764-3551">Como el `pointer` parámetro a la `ldobj` instrucción o a uno de los `ldind` instrucciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="e8764-3552">Como el `source` parámetro para el `cpobj` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="e8764-3553">Todas las demás operaciones no permitidos, incluidas la `stobj`, `initobj`, o `mkrefany` operaciones, o cualquiera de los `stind` instrucciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="e8764-3554">El propósito de la `readonly` prefijo es evitar una comprobación de tipo al capturar un elemento de una matriz en código genérico.</span><span class="sxs-lookup"><span data-stu-id="e8764-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="e8764-3555">Por ejemplo, la expresión `arr[i].m()`, donde el tipo de elemento de la matriz `arr` es un tipo genérico que se ha restringido a tener una interfaz con el método `m`, podría compilar al MSIL siguiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="e8764-3556">Sin el `readonly` prefijo, el `ldelema` instrucción realizaría una comprobación de tipo en el caso donde! 0 fuera un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="e8764-3557">No solo es eficaz esta comprobación de tipo, pero es incorrecto semánticamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="e8764-3558">La comprobación de tipos para `ldelema` es una coincidencia exacta, que es demasiado segura.</span><span class="sxs-lookup"><span data-stu-id="e8764-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="e8764-3559">Si la matriz contuviera subclases de tipo! 0, el código anterior se producirá un error en la comprobación de tipos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="e8764-3560">La dirección del elemento de matriz se recupera, en lugar del propio elemento, con el fin de tener un identificador de `arr[i]` que funciona para ambos tipos de valores y tipos de referencia y, por tanto, puede pasarse a la `constrained callvirt` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="e8764-3561">En general no sería seguro para omitir la comprobación en tiempo de ejecución si la matriz contuviera elementos de un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="e8764-3562">Para estar seguros, es necesario asegurarse de que ninguna modificación en la matriz se realizan a través de este puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="e8764-3563">Las reglas del verificador garantizan esto.</span><span class="sxs-lookup"><span data-stu-id="e8764-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="e8764-3564">El puntero administrado restringido se puede pasar como el objeto de llamadas de método de instancia, por lo que no resulta en sentido estricto de solo lectura para los tipos de valor, pero no hay ningún problema de seguridad de tipo para tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="e8764-3565">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `readonly` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3567">Recupera el símbolo (token) de tipo incrustado en una referencia con tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3567">Retrieves the type token embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3568">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3569">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3569">Format</span></span>|<span data-ttu-id="e8764-3570">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3570">Assembly Format</span></span>|<span data-ttu-id="e8764-3571">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="e8764-3572">FE 1D</span></span>|<span data-ttu-id="e8764-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="e8764-3573">refanytype</span></span>|<span data-ttu-id="e8764-3574">Inserta el símbolo (token) de tipo almacenado en una referencia con tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="e8764-3575">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3576">Una referencia de tipo de valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3577">La referencia con tipo se extrae de la pila y recupera su símbolo (token) de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="e8764-3578">El token de tipo se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3579">Una referencia con tipo contiene un símbolo (token) de tipo y una dirección para una instancia de objeto.</span><span class="sxs-lookup"><span data-stu-id="e8764-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="e8764-3580">El `refanytype` instrucción recupera el símbolo (token) de tipo incrustado en la referencia con tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="e8764-3581">Consulte la <xref:System.Reflection.Emit.OpCodes.Mkrefany> escrito de instrucción para obtener información sobre la creación de referencias.</span><span class="sxs-lookup"><span data-stu-id="e8764-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="e8764-3582">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `refanytype` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3584">Recupera la dirección (de tipo <see langword="&amp;" />) incrustada en una referencia con tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3585">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3586">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3586">Format</span></span>|<span data-ttu-id="e8764-3587">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3587">Assembly Format</span></span>|<span data-ttu-id="e8764-3588">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3589">C2 < `T` ></span></span>|<span data-ttu-id="e8764-3590">refanyval `type`</span><span class="sxs-lookup"><span data-stu-id="e8764-3590">refanyval `type`</span></span>|<span data-ttu-id="e8764-3591">Inserta la dirección almacenada en una referencia con tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="e8764-3592">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3593">Una referencia de tipo de valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3594">La referencia con tipo se extrae de la pila y recupera la dirección correspondiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="e8764-3595">La dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3596">Una referencia con tipo contiene un símbolo (token) de tipo y una dirección para una instancia de objeto.</span><span class="sxs-lookup"><span data-stu-id="e8764-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="e8764-3597">El `refanyval` instrucción recupera la dirección incrustada en la referencia con tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="e8764-3598">El tipo incrustado en la referencia con tipo suministrada en la pila debe coincidir con el tipo especificado por `type` (metadatos de un símbolo (token), ya sea un `typedef` o `typeref`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="e8764-3599">Consulte la <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrucciones para el contenido relacionado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="e8764-3600"><xref:System.InvalidCastException> se produce si `type` no es idéntico al tipo almacenado en la referencia de tipo (en este caso, `type` se proporciona la clase a la <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrucción máquina que creó dicha referencia con tipo).</span><span class="sxs-lookup"><span data-stu-id="e8764-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="e8764-3601"><xref:System.TypeLoadException> se produce si `type` no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="e8764-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="e8764-3602">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `refanyval` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3603">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3604">Divide dos valores e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3604">Divides two values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3605">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3606">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3606">Format</span></span>|<span data-ttu-id="e8764-3607">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3607">Assembly Format</span></span>|<span data-ttu-id="e8764-3608">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3609">5D</span><span class="sxs-lookup"><span data-stu-id="e8764-3609">5D</span></span>|<span data-ttu-id="e8764-3610">REM</span><span class="sxs-lookup"><span data-stu-id="e8764-3610">rem</span></span>|<span data-ttu-id="e8764-3611">Inserta el resultado de dividir `value1` por `value2` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="e8764-3612">ReplaceThisText</span><span class="sxs-lookup"><span data-stu-id="e8764-3612">ReplaceThisText</span></span>  
  
 <span data-ttu-id="e8764-3613">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3613">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3614">Un `value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3614">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3615">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3615">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3616">`value2` y `value1` se extraen de la pila y el resto de `value1` `div` `value2` calculado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3616">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="e8764-3617">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3617">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3618">`result` = `value1` `rem` `value2` cumple las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="e8764-3618">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="e8764-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), y:</span><span class="sxs-lookup"><span data-stu-id="e8764-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="e8764-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, inicio de sesión (`result`) = el inicio de sesión (`value1`), donde `div` es la instrucción de división que trunca hacia cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="e8764-3621">Si `value2` es cero o `value1` es infinito, el resultado es NaN.</span><span class="sxs-lookup"><span data-stu-id="e8764-3621">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="e8764-3622">Si `value2` es infinito, el resultado es `value1` (convertido en negativo para `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="e8764-3622">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="e8764-3623">Las operaciones integrales inician <xref:System.DivideByZeroException> si `value2` es cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-3623">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="e8764-3624">Tenga en cuenta que en las plataformas basadas en Intel en un <xref:System.OverflowException> se produce al realizar el cálculo (minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="e8764-3624">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="e8764-3625">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `rem` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3627">Divide dos valores sin signo e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3627">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3628">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3629">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3629">Format</span></span>|<span data-ttu-id="e8764-3630">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3630">Assembly Format</span></span>|<span data-ttu-id="e8764-3631">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3632">5E</span><span class="sxs-lookup"><span data-stu-id="e8764-3632">5E</span></span>|<span data-ttu-id="e8764-3633">REM.un</span><span class="sxs-lookup"><span data-stu-id="e8764-3633">rem.un</span></span>|<span data-ttu-id="e8764-3634">Inserta el resultado de dividir sin signo `value1` por sin signo `value2` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3634">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3635">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3636">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3636">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3637">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3637">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3638">`value2` y `value1` se extraen de la pila y el resto de `value1` `div` `value2` calculado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3638">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="e8764-3639">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3639">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3640">`result` = `value1` `rem.un` `value2` cumple las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="e8764-3640">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="e8764-3641">`result` = `value1` - `value2` x (`value1` `div.un` `value2`), y:</span><span class="sxs-lookup"><span data-stu-id="e8764-3641">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="e8764-3642">0 = `result`  <  `value2`, donde `div.un` es la instrucción de división sin signo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3642">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="e8764-3643">El `rem.un` instrucción calcula `result` y lo inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3643">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="e8764-3644">`Rem.un` trata sus argumentos como enteros sin signo, mientras que <xref:System.Reflection.Emit.OpCodes.Rem> los trata como enteros con signo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3644">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="e8764-3645">`Rem.un` no está especificado para números de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="e8764-3645">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="e8764-3646">Las operaciones integrales inician <xref:System.DivideByZeroException> si `value2` es cero.</span><span class="sxs-lookup"><span data-stu-id="e8764-3646">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="e8764-3647">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `rem.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3647">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3648">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3648">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3649">Regresa del método actual e inserta un valor devuelto (si existe) desde la pila de evaluación del destinatario de la llamada en la pila de evaluación del llamador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3649">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3650">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3650">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3651">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3651">Format</span></span>|<span data-ttu-id="e8764-3652">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3652">Assembly Format</span></span>|<span data-ttu-id="e8764-3653">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3653">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3654">2A</span><span class="sxs-lookup"><span data-stu-id="e8764-3654">2A</span></span>|<span data-ttu-id="e8764-3655">RET</span><span class="sxs-lookup"><span data-stu-id="e8764-3655">ret</span></span>|<span data-ttu-id="e8764-3656">Regresa del método, posiblemente devolver un valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3656">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="e8764-3657">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3657">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3658">El valor devuelto se extrae de la pila de evaluación del destinatario.</span><span class="sxs-lookup"><span data-stu-id="e8764-3658">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3659">El valor devuelto obtenido en el paso 1 se inserta en la pila de evaluación del llamador.</span><span class="sxs-lookup"><span data-stu-id="e8764-3659">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="e8764-3660">Si el valor devuelto no está presente en la pila de evaluación del destinatario de la llamada, se devuelve ningún valor (no hay comportamientos de transición de pila para el destinatario o el autor de la llamada de método).</span><span class="sxs-lookup"><span data-stu-id="e8764-3660">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="e8764-3661">El tipo de valor devuelto, si existe, del método actual determina el tipo del valor que se va a capturar en la parte superior de la pila y copiar en la pila del método que llamó al método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-3661">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="e8764-3662">La pila de evaluación del método actual debe estar vacía salvo por el valor que se va a devolver.</span><span class="sxs-lookup"><span data-stu-id="e8764-3662">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="e8764-3663">El `ret` instrucción no se puede usar para transferir el control fuera de un`try`, `filter`, `catch`, o `finally` bloque.</span><span class="sxs-lookup"><span data-stu-id="e8764-3663">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="e8764-3664">Desde un `try` o `catch`, use la <xref:System.Reflection.Emit.OpCodes.Leave> instrucción con un destino de una `ret` instrucción que se encuentra fuera de los bloques de excepción todos los contenedores.</span><span class="sxs-lookup"><span data-stu-id="e8764-3664">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="e8764-3665">Dado que la `filter` y `finally` bloques lógicamente forman parte del control de excepciones y no del método en el que su código está incrustado, las instrucciones de lenguaje intermedio de Microsoft (MSIL) correctamente generadas no realizan un método de devolución desde dentro de un `filter` o `finally`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3665">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="e8764-3666">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `ret` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3666">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3667">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3667">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3668">Vuelve a producir la excepción actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3668">Rethrows the current exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3669">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3669">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3670">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3670">Format</span></span>|<span data-ttu-id="e8764-3671">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3671">Assembly Format</span></span>|<span data-ttu-id="e8764-3672">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3672">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3673">FE 1A</span><span class="sxs-lookup"><span data-stu-id="e8764-3673">FE 1A</span></span>|<span data-ttu-id="e8764-3674">rethrow</span><span class="sxs-lookup"><span data-stu-id="e8764-3674">rethrow</span></span>|<span data-ttu-id="e8764-3675">Vuelve a producir la excepción actual</span><span class="sxs-lookup"><span data-stu-id="e8764-3675">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="e8764-3676">No hay definido ningún comportamiento de transición de pila para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3676">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-3677">El `rethrow` sólo se permite la instrucción dentro del cuerpo de un `catch` controlador.</span><span class="sxs-lookup"><span data-stu-id="e8764-3677">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="e8764-3678">Devuelve la misma excepción que ha sido detectada por este controlador.</span><span class="sxs-lookup"><span data-stu-id="e8764-3678">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="e8764-3679">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `rethrow` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3679">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3680">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3680">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3681">Desplaza un valor entero a la izquierda (en ceros) el número de bits especificado e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3681">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3682">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3682">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3683">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3683">Format</span></span>|<span data-ttu-id="e8764-3684">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3684">Assembly Format</span></span>|<span data-ttu-id="e8764-3685">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3685">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3686">62</span><span class="sxs-lookup"><span data-stu-id="e8764-3686">62</span></span>|<span data-ttu-id="e8764-3687">shl</span><span class="sxs-lookup"><span data-stu-id="e8764-3687">shl</span></span>|<span data-ttu-id="e8764-3688">Desplaza un entero a la izquierda (desplazamiento en ceros).</span><span class="sxs-lookup"><span data-stu-id="e8764-3688">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="e8764-3689">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3689">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3690">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3690">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3691">La cantidad de bits de desplazamiento se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3691">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3692">El número de bits de desplazamiento y el valor se extraen de la pila; el valor se desplaza a la izquierda el número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-3692">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="e8764-3693">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3693">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3694">El `shl` instrucción desplaza el valor (tipo `int32`, `int64` o `native int`) a la izquierda el número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-3694">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="e8764-3695">El número de bits es un valor de tipo `int32` o `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3695">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="e8764-3696">El valor devuelto no está especificado, si el número de bits de desplazamiento es mayor o igual que el ancho (en bits) del valor proporcionado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3696">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="e8764-3697">`Shl` Inserta un bit cero en la posición inferior en cada turno.</span><span class="sxs-lookup"><span data-stu-id="e8764-3697">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="e8764-3698">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `shl` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3700">Desplaza un valor entero (en signo) a la derecha el número de bits especificado e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3700">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3701">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3702">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3702">Format</span></span>|<span data-ttu-id="e8764-3703">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3703">Assembly Format</span></span>|<span data-ttu-id="e8764-3704">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3705">63</span><span class="sxs-lookup"><span data-stu-id="e8764-3705">63</span></span>|<span data-ttu-id="e8764-3706">shr</span><span class="sxs-lookup"><span data-stu-id="e8764-3706">shr</span></span>|<span data-ttu-id="e8764-3707">Desplaza un entero a la derecha (desplazamiento de inicio de sesión).</span><span class="sxs-lookup"><span data-stu-id="e8764-3707">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="e8764-3708">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3709">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3709">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3710">La cantidad de bits de desplazamiento se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3710">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3711">El número de bits de desplazamiento y el valor se extraen de la pila; el valor se desplaza a la derecha el número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-3711">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="e8764-3712">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3712">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3713">El `shr.un` instrucción desplaza el valor (tipo `int32`, `int64` o `native int`) derecha por el número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-3713">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="e8764-3714">El número de bits es un valor de tipo `int32` o `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3714">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="e8764-3715">El valor devuelto no está especificado, si el número de bits de desplazamiento es mayor o igual que el ancho (en bits) del valor proporcionado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3715">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="e8764-3716">`Shr` replica el orden alto bit en cada desplazamiento, conservando el signo del valor original en el `result`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3716">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="e8764-3717">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `shr` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3717">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3718">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3718">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3719">Desplaza un valor entero sin signo (en ceros) a la derecha el número de bits especificado e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3719">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3720">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3720">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3721">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3721">Format</span></span>|<span data-ttu-id="e8764-3722">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3722">Assembly Format</span></span>|<span data-ttu-id="e8764-3723">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3723">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3724">64</span><span class="sxs-lookup"><span data-stu-id="e8764-3724">64</span></span>|<span data-ttu-id="e8764-3725">shr.un</span><span class="sxs-lookup"><span data-stu-id="e8764-3725">shr.un</span></span>|<span data-ttu-id="e8764-3726">Desplaza un entero a la derecha (desplazamiento en ceros).</span><span class="sxs-lookup"><span data-stu-id="e8764-3726">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="e8764-3727">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3727">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3728">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3728">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3729">La cantidad de bits de desplazamiento se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3729">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3730">El número de bits de desplazamiento y el valor se extraen de la pila; el valor se desplaza a la derecha el número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-3730">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="e8764-3731">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3731">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3732">El `shr.un` instrucción desplaza el valor (tipo `int32`, `int64` o `native int`) derecha por el número especificado de bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-3732">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="e8764-3733">El número de bits es un valor de tipo `int32`, `int64` o `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3733">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="e8764-3734">El valor devuelto no está especificado, si el número de bits de desplazamiento es mayor o igual que el ancho (en bits) del valor proporcionado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3734">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="e8764-3735">`Shr.un` Inserta un bit cero en la posición más alta en cada turno.</span><span class="sxs-lookup"><span data-stu-id="e8764-3735">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="e8764-3736">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `shr.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3736">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3737">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3737">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3738">Inserta en la pila de evaluación el tamaño, en bytes, de un tipo de valor suministrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3738">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3739">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3739">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3740">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3740">Format</span></span>|<span data-ttu-id="e8764-3741">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3741">Assembly Format</span></span>|<span data-ttu-id="e8764-3742">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3742">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3743">FE 1C &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3743">FE 1C < `T` ></span></span>|<span data-ttu-id="e8764-3744">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="e8764-3744">sizeof `valType`</span></span>|<span data-ttu-id="e8764-3745">Inserta el tamaño, en bytes, de un tipo de valor como un `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3745">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="e8764-3746">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3746">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3747">El tamaño (en bytes) del tipo de valor suministrado (`valType`) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3747">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3748">`valType` debe ser un token de metadatos (un `typeref` o `typedef`) que especifica un tipo de valor, un tipo de referencia o un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="e8764-3748">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="e8764-3749">Para un tipo de referencia, el tamaño devuelto es el tamaño de un valor de referencia de los correspondientes escriba (4 bytes en sistemas de 32 bits), no el tamaño de los datos almacenados en objetos que hace referencia el valor de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-3749">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="e8764-3750">Un parámetro de tipo genérico se puede utilizar sólo en el cuerpo del tipo o método que lo define.</span><span class="sxs-lookup"><span data-stu-id="e8764-3750">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="e8764-3751">Cuando se crea una instancia de ese tipo o método, el parámetro de tipo genérico se reemplaza por un tipo de valor o tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="e8764-3751">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="e8764-3752">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `sizeof` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3752">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3753">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3753">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3754">Almacena el valor que se encuentra en la parte superior de la pila de evaluación en la ranura de argumento de una posición de índice especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3754">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3755">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3755">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3756">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3756">Format</span></span>|<span data-ttu-id="e8764-3757">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3757">Assembly Format</span></span>|<span data-ttu-id="e8764-3758">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3758">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3759">FE 0B &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3759">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="e8764-3760">starg `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-3760">starg `num`</span></span>|<span data-ttu-id="e8764-3761">Extrae el valor superior de la pila y lo almacena en la ranura de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3761">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="e8764-3762">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3762">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3763">Se extrae el valor actualmente en la parte superior de la pila y se coloca en la ranura de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3763">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="e8764-3764">El `starg` instrucción extrae un valor de la pila y lo coloca en la ranura de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3764">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="e8764-3765">El tipo del valor debe coincidir con el tipo del argumento, como se especifica en la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-3765">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-3766">Para conocer los procedimientos que toman una lista de argumentos variable, la `starg` instrucción puede usarse sólo para los argumentos fijos iniciales, no los de la parte variable de la firma.</span><span class="sxs-lookup"><span data-stu-id="e8764-3766">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="e8764-3767">Realizar operaciones de almacenamiento en argumentos que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3767">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="e8764-3768">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3768">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-3769">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `starg` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3770">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="e8764-3770">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3771">Almacena el valor que se encuentra en la parte superior de la pila de evaluación en la ranura de argumento de una posición de índice especificada (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3771">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3772">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3773">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3773">Format</span></span>|<span data-ttu-id="e8764-3774">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3774">Assembly Format</span></span>|<span data-ttu-id="e8764-3775">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3776">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3776">10 < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-3777">starg.s `num`</span><span class="sxs-lookup"><span data-stu-id="e8764-3777">starg.s `num`</span></span>|<span data-ttu-id="e8764-3778">Extrae el valor superior de la pila y lo almacena en la ranura de argumento `num`, forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-3778">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="e8764-3779">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3780">Se extrae el valor actualmente en la parte superior de la pila y se coloca en la ranura de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3780">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="e8764-3781">El `starg.s` instrucción extrae un valor de la pila y lo coloca en la ranura de argumento `num`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3781">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="e8764-3782">El tipo del valor debe coincidir con el tipo del argumento, como se especifica en la firma del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-3782">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="e8764-3783">El `starg.s` instrucción proporciona una codificación eficaz para su uso con los 256 primeros argumentos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3783">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="e8764-3784">Para conocer los procedimientos que toman una lista de argumentos variable, la `starg.s` instrucción puede usarse sólo para los argumentos fijos iniciales, no los de la parte variable de la firma.</span><span class="sxs-lookup"><span data-stu-id="e8764-3784">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="e8764-3785">Realizar operaciones de almacenamiento en argumentos que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3785">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="e8764-3786">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-3786">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-3787">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `starg.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3787">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3788">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-3788">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3789">Reemplaza el elemento de matriz que se encuentra en una posición de índice dada por el valor de la pila de evaluación cuyo tipo se especifica en la instrucción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3789">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3790">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3790">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3791">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3791">Format</span></span>|<span data-ttu-id="e8764-3792">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3792">Assembly Format</span></span>|<span data-ttu-id="e8764-3793">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3793">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3794">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3794">A4 < `T` ></span></span>|<span data-ttu-id="e8764-3795">stelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="e8764-3795">stelem `typeTok`</span></span>|<span data-ttu-id="e8764-3796">Reemplaza el elemento de matriz en la posición de índice suministrada por un valor de tipo `typeTok` en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3796">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3797">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3797">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3798">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3798">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3799">Un valor de índice, `index`, a un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3799">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3800">Un valor del tipo especificado en la instrucción se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3800">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3801">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3801">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3802">El `stelem` instrucción sustituye el valor del elemento en el índice de base cero proporcionado en la matriz unidimensional `array` con el valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3802">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="e8764-3803">El valor tiene el tipo especificado por el token `typeTok` en la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-3803">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="e8764-3804">Las matrices son objetos y, por lo tanto, se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3804">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3805">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3805">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3806"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3806"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3807"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3807"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3808"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3808"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3809">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3809">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3810">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-3810">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3811">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="native int" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3811">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3812">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3812">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3813">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3813">Format</span></span>|<span data-ttu-id="e8764-3814">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3814">Assembly Format</span></span>|<span data-ttu-id="e8764-3815">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3815">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3816">9B</span><span class="sxs-lookup"><span data-stu-id="e8764-3816">9B</span></span>|<span data-ttu-id="e8764-3817">stelem.i</span><span class="sxs-lookup"><span data-stu-id="e8764-3817">stelem.i</span></span>|<span data-ttu-id="e8764-3818">Reemplaza un elemento de matriz en el índice proporcionado con la `native int` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3818">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3819">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3819">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3820">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3820">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3821">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3821">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3822">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3822">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3823">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3823">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3824">El `stelem.i` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `native int` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3824">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3825">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3825">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3826">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3826">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3827"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3827"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3828"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3828"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3829"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3829"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3830">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.i` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3830">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3831">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3831">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3832">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int8" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3832">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3833">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3833">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3834">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3834">Format</span></span>|<span data-ttu-id="e8764-3835">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3835">Assembly Format</span></span>|<span data-ttu-id="e8764-3836">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3836">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3837">9C</span><span class="sxs-lookup"><span data-stu-id="e8764-3837">9C</span></span>|<span data-ttu-id="e8764-3838">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="e8764-3838">stelem.i1</span></span>|<span data-ttu-id="e8764-3839">Reemplaza un elemento de matriz en el índice proporcionado con la `int8` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3839">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3840">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3840">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3841">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3841">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3842">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3842">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3843">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3843">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3844">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3844">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3845">El `stelem.i1` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int8` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3845">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3846">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3846">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3847">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3847">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3848"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3848"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3849"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3849"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3850"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3850"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3851">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.i1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3851">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3852">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3852">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3853">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int16" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3853">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3854">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3855">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3855">Format</span></span>|<span data-ttu-id="e8764-3856">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3856">Assembly Format</span></span>|<span data-ttu-id="e8764-3857">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3858">9D</span><span class="sxs-lookup"><span data-stu-id="e8764-3858">9D</span></span>|<span data-ttu-id="e8764-3859">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="e8764-3859">stelem.i2</span></span>|<span data-ttu-id="e8764-3860">Reemplaza un elemento de matriz en el índice proporcionado con la `int16` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3860">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3861">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3862">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3862">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3863">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3863">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3864">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3864">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3865">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3865">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3866">El `stelem.i2` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int16` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3866">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3867">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3867">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3868">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3868">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3869"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3869"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3870"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3870"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3871"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3871"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3872">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.i2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3872">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3873">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3873">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3874">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3874">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3875">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3875">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3876">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3876">Format</span></span>|<span data-ttu-id="e8764-3877">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3877">Assembly Format</span></span>|<span data-ttu-id="e8764-3878">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3878">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3879">9E</span><span class="sxs-lookup"><span data-stu-id="e8764-3879">9E</span></span>|<span data-ttu-id="e8764-3880">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="e8764-3880">stelem.i4</span></span>|<span data-ttu-id="e8764-3881">Reemplaza un elemento de matriz en el índice proporcionado con la `int32` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3881">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3882">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3882">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3883">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3883">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3884">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3884">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3885">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3885">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3886">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3886">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3887">El `stelem.i4` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int32` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3887">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3888">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3888">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3889">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3889">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3890"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3890"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3891"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3891"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3892"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3892"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3893">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3893">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3894">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3894">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3895">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="int64" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3895">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3896">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3896">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3897">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3897">Format</span></span>|<span data-ttu-id="e8764-3898">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3898">Assembly Format</span></span>|<span data-ttu-id="e8764-3899">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3899">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3900">9F</span><span class="sxs-lookup"><span data-stu-id="e8764-3900">9F</span></span>|<span data-ttu-id="e8764-3901">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="e8764-3901">stelem.i8</span></span>|<span data-ttu-id="e8764-3902">Reemplaza un elemento de matriz en el índice proporcionado con la `int64` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3902">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3903">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3903">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3904">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3904">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3905">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3905">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3906">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3906">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3907">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3907">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3908">El `stelem.i8` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `int64` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3908">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3909">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3909">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3910">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3910">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3911"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3911"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3912"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3912"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3913"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3913"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3914">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3916">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="float32" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3916">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3917">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3918">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3918">Format</span></span>|<span data-ttu-id="e8764-3919">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3919">Assembly Format</span></span>|<span data-ttu-id="e8764-3920">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3921">A0</span><span class="sxs-lookup"><span data-stu-id="e8764-3921">A0</span></span>|<span data-ttu-id="e8764-3922">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="e8764-3922">stelem.r4</span></span>|<span data-ttu-id="e8764-3923">Reemplaza un elemento de matriz en el índice proporcionado con la `float32` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3923">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3924">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3925">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3925">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3926">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3926">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3927">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3927">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3928">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3928">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3929">El `stelem.r4` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `float32` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3929">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3930">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3930">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3931">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3931">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3932"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3932"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3933"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3933"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3934"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3934"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3935">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.r4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3935">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3936">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3936">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3937">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor <see langword="float64" /> en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3937">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3938">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3938">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3939">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3939">Format</span></span>|<span data-ttu-id="e8764-3940">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3940">Assembly Format</span></span>|<span data-ttu-id="e8764-3941">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3941">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3942">A1</span><span class="sxs-lookup"><span data-stu-id="e8764-3942">A1</span></span>|<span data-ttu-id="e8764-3943">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="e8764-3943">stelem.r8</span></span>|<span data-ttu-id="e8764-3944">Reemplaza un elemento de matriz en el índice proporcionado con la `float64` valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3944">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3945">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3945">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3946">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3946">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3947">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3947">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3948">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3948">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3949">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3949">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3950">El `stelem.r8` instrucción sustituye el valor del elemento `index` en la matriz unidimensional `array` con el `float64` valor insertado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3950">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3951">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3951">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3952">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3952">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3953"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3953"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3954"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3954"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3955"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3955"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3956">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.r8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3956">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3957">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3957">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3958">Sustituye el elemento de la matriz que se encuentra en una posición de índice determinada por el valor de referencia a objeto (de tipo <see langword="O" />) en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3958">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3959">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3959">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3960">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3960">Format</span></span>|<span data-ttu-id="e8764-3961">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3961">Assembly Format</span></span>|<span data-ttu-id="e8764-3962">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3962">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3963">A2</span><span class="sxs-lookup"><span data-stu-id="e8764-3963">A2</span></span>|<span data-ttu-id="e8764-3964">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="e8764-3964">stelem.ref</span></span>|<span data-ttu-id="e8764-3965">Reemplaza un elemento de matriz en la posición de índice suministrada con el `ref` valor (tipo `O`) en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3965">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="e8764-3966">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3966">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3967">Una referencia de objeto a una matriz, `array`, se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3967">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3968">Un índice válido para un elemento de `array` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3968">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3969">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3969">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="e8764-3970">El valor, el índice y la referencia de la matriz se extraen de la pila; el valor se coloca en el elemento de matriz en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3970">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="e8764-3971">El `stelem.ref` instrucción sustituye el valor del elemento en el índice proporcionado en la matriz unidimensional `array` con el `ref` (tipo `O`) valor que se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3971">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-3972">Las matrices son objetos y, por lo que se representa mediante un valor de tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3972">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="e8764-3973">El índice es de tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3973">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="e8764-3974">Tenga en cuenta que `stelem.ref` convierte implícitamente el valor suministrado para el tipo de elemento de `array` antes de asignar el valor al elemento de matriz.</span><span class="sxs-lookup"><span data-stu-id="e8764-3974">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="e8764-3975">Esta conversión puede producir un error, incluso para el código comprobado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3975">This cast can fail, even for verified code.</span></span> <span data-ttu-id="e8764-3976">Por lo tanto la `stelem.ref` instrucción puede producir <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="e8764-3976">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="e8764-3977">Para las matrices unidimensionales que no son de base cero y las matrices multidimensionales, la <xref:System.Array> clase proporciona un <xref:System.Array.SetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e8764-3977">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="e8764-3978"><xref:System.NullReferenceException> se produce si `array` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-3978"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-3979"><xref:System.IndexOutOfRangeException> se produce si `index` es negativo o mayor que el límite de `array`.</span><span class="sxs-lookup"><span data-stu-id="e8764-3979"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="e8764-3980"><xref:System.ArrayTypeMismatchException> se produce si `array` no contiene elementos del tipo requerido.</span><span class="sxs-lookup"><span data-stu-id="e8764-3980"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="e8764-3981">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stelem.ref` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-3981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-3982">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-3982">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-3983">Sustituye por un valor nuevo el valor almacenado en el campo de una referencia a objeto o puntero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-3983">Replaces the value stored in the field of an object reference or pointer with a new value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-3984">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-3984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-3985">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-3985">Format</span></span>|<span data-ttu-id="e8764-3986">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-3986">Assembly Format</span></span>|<span data-ttu-id="e8764-3987">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-3987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-3988">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-3988">7D < `T` ></span></span>|<span data-ttu-id="e8764-3989">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="e8764-3989">stfld `field`</span></span>|<span data-ttu-id="e8764-3990">Reemplaza el valor de `field` del objeto con un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-3990">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="e8764-3991">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-3991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-3992">Una referencia de objeto o un puntero se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3992">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-3993">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-3993">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-3994">El valor y la referencia o puntero al objeto se extraen de la pila; el valor de `field` en el objeto se reemplaza con el valor proporcionado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3994">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="e8764-3995">El `stfld` instrucción sustituye el valor de un campo de un objeto (tipo `O`) o a través de un puntero (tipo `native int`, `&`, o `*`) con un valor determinado.</span><span class="sxs-lookup"><span data-stu-id="e8764-3995">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="e8764-3996">`Field` es un símbolo (token) de metadatos que hace referencia a una referencia de miembro de campo.</span><span class="sxs-lookup"><span data-stu-id="e8764-3996">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="e8764-3997">El `stfld` instrucción puede tener un prefijo de uno o ambos <xref:System.Reflection.Emit.OpCodes.Unaligned> y <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="e8764-3997">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="e8764-3998"><xref:System.NullReferenceException> se produce si la referencia de objeto o el puntero es una referencia nula y el campo no es estático.</span><span class="sxs-lookup"><span data-stu-id="e8764-3998"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="e8764-3999"><xref:System.MissingFieldException> se produce si `field` no se encuentra en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="e8764-3999"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="e8764-4000">Normalmente, esto se comprueba cuando la instrucción de lenguaje intermedio de Microsoft (MSIL) se convierte en código nativo, no en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-4000">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="e8764-4001">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stfld` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4002">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-4002">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4003">Almacena un valor de tipo <see langword="native int" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4003">Stores a value of type <see langword="native int" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4004">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4005">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4005">Format</span></span>|<span data-ttu-id="e8764-4006">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4006">Assembly Format</span></span>|<span data-ttu-id="e8764-4007">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4008">DF</span><span class="sxs-lookup"><span data-stu-id="e8764-4008">DF</span></span>|<span data-ttu-id="e8764-4009">stind.i</span><span class="sxs-lookup"><span data-stu-id="e8764-4009">stind.i</span></span>|<span data-ttu-id="e8764-4010">Almacena un `native int` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4010">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4011">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4011">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4012">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4012">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4013">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4013">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4014">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4014">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4015">El `stind.i` instrucción almacena un `native int` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4015">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4016">Operación segura de tipos requiere que la `stind.i` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4016">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4017">La operación de la `stind.i` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4017">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4018"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4018"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4019">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.i` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4019">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4020">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4020">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4021">Almacena un valor de tipo <see langword="int8" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4021">Stores a value of type <see langword="int8" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4022">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4022">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4023">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4023">Format</span></span>|<span data-ttu-id="e8764-4024">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4024">Assembly Format</span></span>|<span data-ttu-id="e8764-4025">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4025">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4026">52</span><span class="sxs-lookup"><span data-stu-id="e8764-4026">52</span></span>|<span data-ttu-id="e8764-4027">stind.i1</span><span class="sxs-lookup"><span data-stu-id="e8764-4027">stind.i1</span></span>|<span data-ttu-id="e8764-4028">Almacena un `int8` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4028">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4029">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4029">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4030">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4030">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4031">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4031">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4032">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4032">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4033">El `stind.i1` instrucción almacenes una `int8` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4033">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4034">Operación segura de tipos requiere que la `stind.i1` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4034">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4035">La operación de la `stind.i1` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4035">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4036"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4036"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4037">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.i1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4039">Almacena un valor de tipo <see langword="int16" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4039">Stores a value of type <see langword="int16" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4040">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4040">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4041">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4041">Format</span></span>|<span data-ttu-id="e8764-4042">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4042">Assembly Format</span></span>|<span data-ttu-id="e8764-4043">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4044">53</span><span class="sxs-lookup"><span data-stu-id="e8764-4044">53</span></span>|<span data-ttu-id="e8764-4045">stind.i2</span><span class="sxs-lookup"><span data-stu-id="e8764-4045">stind.i2</span></span>|<span data-ttu-id="e8764-4046">Almacena un `int16` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4046">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4047">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4047">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4048">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4048">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4049">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4049">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4050">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4050">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4051">El `stind.i2` instrucción almacenes una `int16` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4051">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4052">Operación segura de tipos requiere que la `stind.2i` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4052">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4053">La operación de la `stind.i2` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4053">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4054"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4054"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4055">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.i2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4055">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4056">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4056">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4057">Almacena un valor de tipo <see langword="int32" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4057">Stores a value of type <see langword="int32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4058">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4058">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4059">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4059">Format</span></span>|<span data-ttu-id="e8764-4060">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4060">Assembly Format</span></span>|<span data-ttu-id="e8764-4061">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4061">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4062">54</span><span class="sxs-lookup"><span data-stu-id="e8764-4062">54</span></span>|<span data-ttu-id="e8764-4063">stind.i4</span><span class="sxs-lookup"><span data-stu-id="e8764-4063">stind.i4</span></span>|<span data-ttu-id="e8764-4064">Almacena un `int32` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4064">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4065">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4065">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4066">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4066">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4067">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4067">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4068">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4068">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4069">El `stind.i4` instrucción almacenes una `int32` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4069">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4070">Operación segura de tipos requiere que la `stind.i4` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4070">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4071">La operación de la `stind.i4` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4071">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4072"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4072"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4073">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.i4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4075">Almacena un valor de tipo <see langword="int64" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4075">Stores a value of type <see langword="int64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4076">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4077">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4077">Format</span></span>|<span data-ttu-id="e8764-4078">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4078">Assembly Format</span></span>|<span data-ttu-id="e8764-4079">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4080">55</span><span class="sxs-lookup"><span data-stu-id="e8764-4080">55</span></span>|<span data-ttu-id="e8764-4081">stind.i8</span><span class="sxs-lookup"><span data-stu-id="e8764-4081">stind.i8</span></span>|<span data-ttu-id="e8764-4082">Almacena un `int64` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4082">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4083">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4084">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4084">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4085">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4085">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4086">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4086">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4087">El `stind.i8` instrucción almacenes una `int64` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4087">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4088">Operación segura de tipos requiere que la `stind.i8` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4088">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4089">La operación de la `stind.i` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4089">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4090"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4090"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4091">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.i8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4091">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4092">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4092">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4093">Almacena un valor de tipo <see langword="float32" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4093">Stores a value of type <see langword="float32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4094">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4094">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4095">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4095">Format</span></span>|<span data-ttu-id="e8764-4096">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4096">Assembly Format</span></span>|<span data-ttu-id="e8764-4097">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4097">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4098">56</span><span class="sxs-lookup"><span data-stu-id="e8764-4098">56</span></span>|<span data-ttu-id="e8764-4099">stind.r4</span><span class="sxs-lookup"><span data-stu-id="e8764-4099">stind.r4</span></span>|<span data-ttu-id="e8764-4100">Almacena un `float32` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4100">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4101">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4101">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4102">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4102">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4103">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4103">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4104">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4104">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4105">El `stind.r4` instrucción almacena un `float32` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4105">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4106">Operación segura de tipos requiere que la `stind.r4` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4106">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4107">La operación de la `stind.r4` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4107">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4108"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4108"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4109">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.r4` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4109">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4110">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4110">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4111">Almacena un valor de tipo <see langword="float64" /> en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4111">Stores a value of type <see langword="float64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4112">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4112">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4113">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4113">Format</span></span>|<span data-ttu-id="e8764-4114">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4114">Assembly Format</span></span>|<span data-ttu-id="e8764-4115">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4115">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4116">57</span><span class="sxs-lookup"><span data-stu-id="e8764-4116">57</span></span>|<span data-ttu-id="e8764-4117">stind.r8</span><span class="sxs-lookup"><span data-stu-id="e8764-4117">stind.r8</span></span>|<span data-ttu-id="e8764-4118">Almacena un `float64` valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4118">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4119">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4119">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4120">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4120">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4121">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4121">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4122">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4122">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4123">El `stind.r8` instrucción almacena un `float64` valor en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4123">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4124">Operación segura de tipos requiere que la `stind.r8` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4124">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4125">La operación de la `stind.r8` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4125">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4126"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4126"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4127">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.r8` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4128">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4128">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4129">Almacena un valor de referencia a objeto en una dirección suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4129">Stores a object reference value at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4130">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4131">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4131">Format</span></span>|<span data-ttu-id="e8764-4132">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4132">Assembly Format</span></span>|<span data-ttu-id="e8764-4133">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4134">51</span><span class="sxs-lookup"><span data-stu-id="e8764-4134">51</span></span>|<span data-ttu-id="e8764-4135">stind.ref</span><span class="sxs-lookup"><span data-stu-id="e8764-4135">stind.ref</span></span>|<span data-ttu-id="e8764-4136">Almacena una referencia a objeto (tipo `O`) valor en una dirección determinada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4136">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="e8764-4137">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4138">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4138">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4139">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4139">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4140">El valor y la dirección se extraen de la pila; el valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4140">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4141">El `stind.ref` instrucción almacena un valor de referencia de objeto en la dirección suministrada (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4141">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="e8764-4142">Operación segura de tipos requiere que la `stind.ref` instrucción utilizarse de manera coherente con el tipo del puntero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4142">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="e8764-4143">La operación de la `stind.ref` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4143">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4144"><xref:System.NullReferenceException> se produce si `addr` no está alineado naturalmente para el tipo de argumento que implica el sufijo de la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4144"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="e8764-4145">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stind.ref` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4145">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4146">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4146">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4147">Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4147">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4148">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4148">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4149">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4149">Format</span></span>|<span data-ttu-id="e8764-4150">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4150">Assembly Format</span></span>|<span data-ttu-id="e8764-4151">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4151">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4152">FE 0E &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4152">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="e8764-4153">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-4153">stloc `index`</span></span>|<span data-ttu-id="e8764-4154">Extrae un valor de la pila y lo almacena en la variable local `index`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4154">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="e8764-4155">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4155">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4156">Un valor se extrae de la pila y se coloca en la variable local `index`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4156">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="e8764-4157">El `stloc` instrucción máquina extrae el valor superior de la pila de evaluación y lo mueve al número de variable local `index`, donde las variables locales son con el número 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-4157">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="e8764-4158">El tipo del valor debe coincidir con el tipo de la variable local tal como se especifica en la firma local del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-4158">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="e8764-4159">Al almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila a la variable local.</span><span class="sxs-lookup"><span data-stu-id="e8764-4159">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="e8764-4160">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4160">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-4161">Instrucciones de lenguaje intermedio de Microsoft (MSIL) correcto requieren que `index` sea un índice local válido.</span><span class="sxs-lookup"><span data-stu-id="e8764-4161">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="e8764-4162">Para el `stloc` instrucciones, `index` debe encontrarse en el intervalo de 0 a 65534 inclusive (en concreto, 65535 no es válido).</span><span class="sxs-lookup"><span data-stu-id="e8764-4162">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="e8764-4163">La razón de excluir 65535 es práctica: probablemente en las implementaciones utilizará un entero de 2 bytes para realizar el seguimiento de índice de una variable local, así como el número total de variables locales de un método determinado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4163">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="e8764-4164">Si ha realizado un índice de 65535 válido, se necesitaría un entero más amplio realizar un seguimiento del número de variables locales en un método de este tipo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4164">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="e8764-4165">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `stloc` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4165">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="e8764-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="e8764-4167">ILGenerator.Emit (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="e8764-4167">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4168">Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4168">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4169">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4169">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4170">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4170">Format</span></span>|<span data-ttu-id="e8764-4171">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4171">Assembly Format</span></span>|<span data-ttu-id="e8764-4172">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4172">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4173">0A</span><span class="sxs-lookup"><span data-stu-id="e8764-4173">0A</span></span>|<span data-ttu-id="e8764-4174">stloc.0</span><span class="sxs-lookup"><span data-stu-id="e8764-4174">stloc.0</span></span>|<span data-ttu-id="e8764-4175">Extrae un valor de la pila en la variable local 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-4175">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="e8764-4176">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4176">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4177">Un valor se extrae de la pila y se coloca en la variable local indizada por 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-4177">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="e8764-4178">El `stloc.0` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada por 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-4178">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="e8764-4179">El tipo del valor debe coincidir con el tipo de la variable local tal como se especifica en la firma local del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-4179">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="e8764-4180">`stloc.0` es una codificación especialmente eficaz para almacenar valores en la variable local 0.</span><span class="sxs-lookup"><span data-stu-id="e8764-4180">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="e8764-4181">Al almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila a la variable local.</span><span class="sxs-lookup"><span data-stu-id="e8764-4181">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="e8764-4182">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4182">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-4183">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stloc.0` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4183">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4184">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4184">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4185">Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4185">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4186">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4186">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4187">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4187">Format</span></span>|<span data-ttu-id="e8764-4188">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4188">Assembly Format</span></span>|<span data-ttu-id="e8764-4189">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4189">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4190">0B</span><span class="sxs-lookup"><span data-stu-id="e8764-4190">0B</span></span>|<span data-ttu-id="e8764-4191">stloc.1</span><span class="sxs-lookup"><span data-stu-id="e8764-4191">stloc.1</span></span>|<span data-ttu-id="e8764-4192">Extrae un valor de la pila en la variable local 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-4192">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="e8764-4193">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4193">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4194">Un valor se extrae de la pila y se coloca en la variable local indizada en 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-4194">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="e8764-4195">El `stloc.1` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada en 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-4195">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="e8764-4196">El tipo del valor debe coincidir con el tipo de la variable local tal como se especifica en la firma local del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-4196">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="e8764-4197">`stloc.1` es una codificación especialmente eficaz para almacenar valores en la variable local 1.</span><span class="sxs-lookup"><span data-stu-id="e8764-4197">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="e8764-4198">Al almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila a la variable local.</span><span class="sxs-lookup"><span data-stu-id="e8764-4198">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="e8764-4199">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4199">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-4200">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stloc.1` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4202">Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4202">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4203">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4204">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4204">Format</span></span>|<span data-ttu-id="e8764-4205">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4205">Assembly Format</span></span>|<span data-ttu-id="e8764-4206">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4207">0C</span><span class="sxs-lookup"><span data-stu-id="e8764-4207">0C</span></span>|<span data-ttu-id="e8764-4208">stloc.2</span><span class="sxs-lookup"><span data-stu-id="e8764-4208">stloc.2</span></span>|<span data-ttu-id="e8764-4209">Extrae un valor de la pila en la variable local 2</span><span class="sxs-lookup"><span data-stu-id="e8764-4209">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="e8764-4210">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4211">Un valor se extrae de la pila y se coloca en la variable local indizada en 2.</span><span class="sxs-lookup"><span data-stu-id="e8764-4211">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="e8764-4212">El `stloc.2` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada en 2.</span><span class="sxs-lookup"><span data-stu-id="e8764-4212">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="e8764-4213">El tipo del valor debe coincidir con el tipo de la variable local tal como se especifica en la firma local del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-4213">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="e8764-4214">`stloc.2` es una codificación especialmente eficaz para almacenar valores en la variable local 2.</span><span class="sxs-lookup"><span data-stu-id="e8764-4214">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="e8764-4215">Al almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila a la variable local.</span><span class="sxs-lookup"><span data-stu-id="e8764-4215">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="e8764-4216">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4216">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-4217">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stloc.2` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4217">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4218">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4218">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4219">Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en el índice 3.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4219">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4220">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4220">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4221">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4221">Format</span></span>|<span data-ttu-id="e8764-4222">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4222">Assembly Format</span></span>|<span data-ttu-id="e8764-4223">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4223">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4224">0D</span><span class="sxs-lookup"><span data-stu-id="e8764-4224">0D</span></span>|<span data-ttu-id="e8764-4225">stloc.3</span><span class="sxs-lookup"><span data-stu-id="e8764-4225">stloc.3</span></span>|<span data-ttu-id="e8764-4226">Extrae un valor de la pila en la variable local 3</span><span class="sxs-lookup"><span data-stu-id="e8764-4226">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="e8764-4227">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4227">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4228">Un valor se extrae de la pila y se coloca en la variable local indizada en 3.</span><span class="sxs-lookup"><span data-stu-id="e8764-4228">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="e8764-4229">El `stloc.3` instrucción extrae el valor superior de la pila de evaluación y lo traslada a la variable local indizada en 3.</span><span class="sxs-lookup"><span data-stu-id="e8764-4229">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="e8764-4230">El tipo del valor debe coincidir con el tipo de la variable local tal como se especifica en la firma local del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-4230">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="e8764-4231">`stloc.3` es una codificación especialmente eficaz para almacenar valores en la variable local 3.</span><span class="sxs-lookup"><span data-stu-id="e8764-4231">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="e8764-4232">Al almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila a la variable local.</span><span class="sxs-lookup"><span data-stu-id="e8764-4232">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="e8764-4233">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4233">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-4234">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stloc.3` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4234">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4235">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4235">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4236">Extrae el valor actual de la parte superior de la pila de evaluación y lo almacena en la lista de variables locales en <paramref name="index" /> (forma corta).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4236">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4237">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4237">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4238">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4238">Format</span></span>|<span data-ttu-id="e8764-4239">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4239">Assembly Format</span></span>|<span data-ttu-id="e8764-4240">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4240">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4241">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4241">13 < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-4242">stloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="e8764-4242">stloc.s `index`</span></span>|<span data-ttu-id="e8764-4243">Extrae un valor de la pila y lo almacena en la variable local `index`, forma corta.</span><span class="sxs-lookup"><span data-stu-id="e8764-4243">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="e8764-4244">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4244">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4245">Un valor se extrae de la pila y se coloca en la variable local `index`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4245">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="e8764-4246">El `stloc.s` instrucción máquina extrae el valor superior de la pila de evaluación y lo mueve al número de variable local `index`, donde las variables locales son con el número 0 en adelante.</span><span class="sxs-lookup"><span data-stu-id="e8764-4246">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="e8764-4247">El tipo del valor debe coincidir con el tipo de la variable local tal como se especifica en la firma local del método actual.</span><span class="sxs-lookup"><span data-stu-id="e8764-4247">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="e8764-4248">El `stloc.s` instrucción proporciona una codificación eficaz para las variables locales 0 y 255.</span><span class="sxs-lookup"><span data-stu-id="e8764-4248">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="e8764-4249">Al almacenar en variables locales que contienen un valor entero menor que la longitud de 4 bytes trunca el valor de medida que se mueven de la pila a la variable local.</span><span class="sxs-lookup"><span data-stu-id="e8764-4249">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="e8764-4250">Valores de punto flotante se redondean desde su tamaño nativo (tipo `F`) hasta el tamaño asociado al argumento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4250">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="e8764-4251">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `stloc.s` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="e8764-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="e8764-4253">ILGenerator.Emit (código de operación, byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-4253">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4254">Copia un valor del tipo especificado de la pila de evaluación y lo coloca en una dirección de memoria suministrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4254">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4255">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4255">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4256">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4256">Format</span></span>|<span data-ttu-id="e8764-4257">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4257">Assembly Format</span></span>|<span data-ttu-id="e8764-4258">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4258">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4259">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4259">81 < `T` ></span></span>|<span data-ttu-id="e8764-4260">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="e8764-4260">stobj `class`</span></span>|<span data-ttu-id="e8764-4261">Almacena un valor de tipo `class` de la pila en la memoria.</span><span class="sxs-lookup"><span data-stu-id="e8764-4261">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="e8764-4262">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4262">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4263">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4263">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4264">Un objeto de tipo de valor de tipo `class` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4264">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4265">El objeto y la dirección se extraen de la pila; el objeto de tipo de valor se almacena en la dirección.</span><span class="sxs-lookup"><span data-stu-id="e8764-4265">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="e8764-4266">El `stobj` instrucción copia el objeto de tipo de valor en la dirección especificada por la dirección (un puntero de tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4266">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="e8764-4267">El número de bytes que se copia depende del tamaño de la clase representada por `class`, un token de metadatos que representa un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-4267">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="e8764-4268">La operación de la `stobj` instrucción puede ser modificado por una inmediatamente anterior a <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> instrucción con el prefijo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4268">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="e8764-4269"><xref:System.TypeLoadException> se produce si no se pudo encontrar la clase.</span><span class="sxs-lookup"><span data-stu-id="e8764-4269"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="e8764-4270">Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-4270">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="e8764-4271">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stobj` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4271">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4272">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-4272">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4273">Sustituye el valor de un campo estático por un valor de la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4273">Replaces the value of a static field with a value from the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4274">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4274">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4275">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4275">Format</span></span>|<span data-ttu-id="e8764-4276">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4276">Assembly Format</span></span>|<span data-ttu-id="e8764-4277">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4277">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4278">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4278">80 < `T` ></span></span>|<span data-ttu-id="e8764-4279">stsfld `field`</span><span class="sxs-lookup"><span data-stu-id="e8764-4279">stsfld `field`</span></span>|<span data-ttu-id="e8764-4280">Reemplaza el valor de `field` con un valor suministrado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4280">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="e8764-4281">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4281">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4282">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4282">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4283">Un valor se extrae de la pila y se almacena en `field`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4283">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="e8764-4284">El `stsfld` instrucción sustituye el valor de un campo estático con un valor de la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4284">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="e8764-4285">`field` es un símbolo (token) de metadatos que debe hacer referencia a un miembro de campo estático.</span><span class="sxs-lookup"><span data-stu-id="e8764-4285">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="e8764-4286">El `stsfld` instrucción puede ir precedida por <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="e8764-4286">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="e8764-4287"><xref:System.MissingFieldException> se produce si el campo no se encuentra en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="e8764-4287"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="e8764-4288">Normalmente, esto se comprueba cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, no en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-4288">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="e8764-4289">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `stsfld` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4289">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4290">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="e8764-4290">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4291">Resta un valor de otro e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4291">Subtracts one value from another and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4292">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4292">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4293">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4293">Format</span></span>|<span data-ttu-id="e8764-4294">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4294">Assembly Format</span></span>|<span data-ttu-id="e8764-4295">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4295">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4296">59</span><span class="sxs-lookup"><span data-stu-id="e8764-4296">59</span></span>|<span data-ttu-id="e8764-4297">sub</span><span class="sxs-lookup"><span data-stu-id="e8764-4297">sub</span></span>|<span data-ttu-id="e8764-4298">Resta un valor de otro y devuelve un nuevo valor numérico.</span><span class="sxs-lookup"><span data-stu-id="e8764-4298">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="e8764-4299">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4299">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4300">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4300">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4301">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4301">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4302">`value2` y `value1` se extrae de la pila; `value2` se resta de `value1`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4302">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="e8764-4303">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4303">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4304">No se detecta el desbordamiento para operaciones con enteros (para el control de desbordamiento adecuado, vea <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="e8764-4304">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="e8764-4305">Resta de enteros se ajusta, en lugar de satura.</span><span class="sxs-lookup"><span data-stu-id="e8764-4305">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="e8764-4306">Por ejemplo: trata de enteros de 8 bits donde `value1` se establece en 0 y `value2` se establece en 1, el resultado de "encapsulado" será 255.</span><span class="sxs-lookup"><span data-stu-id="e8764-4306">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="e8764-4307">Desbordamiento de punto flotante devuelve `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4307">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="e8764-4308">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `sub` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4308">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4309">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4309">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4310">Resta un valor entero de otro, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4310">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4311">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4311">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4312">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4312">Format</span></span>|<span data-ttu-id="e8764-4313">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4313">Assembly Format</span></span>|<span data-ttu-id="e8764-4314">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4314">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4315">DA</span><span class="sxs-lookup"><span data-stu-id="e8764-4315">DA</span></span>|<span data-ttu-id="e8764-4316">Sub.ovf</span><span class="sxs-lookup"><span data-stu-id="e8764-4316">sub.ovf</span></span>|<span data-ttu-id="e8764-4317">Resta un valor entero de otro con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4317">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="e8764-4318">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4318">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4319">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4319">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4320">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4320">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4321">`value2` y `value1` se extrae de la pila; `value2` se resta de `value1` con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4321">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="e8764-4322">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4322">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4323"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4323"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-4324">Esta operación se realiza en enteros con signo; para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="e8764-4324">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="e8764-4325">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `sub.ovf` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4325">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4326">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4326">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4327">Resta un valor entero sin signo de otro, realiza una comprobación de desbordamiento e inserta el resultado en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4327">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4328">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4328">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4329">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4329">Format</span></span>|<span data-ttu-id="e8764-4330">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4330">Assembly Format</span></span>|<span data-ttu-id="e8764-4331">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4331">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4332">DB</span><span class="sxs-lookup"><span data-stu-id="e8764-4332">DB</span></span>|<span data-ttu-id="e8764-4333">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="e8764-4333">sub.ovf.un</span></span>|<span data-ttu-id="e8764-4334">Resta un valor de entero sin signo de otro con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4334">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="e8764-4335">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4335">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4336">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4336">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4337">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4337">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4338">`value2` y `value1` se extrae de la pila; `value2` se resta de `value1` con una comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="e8764-4338">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="e8764-4339">El resultado se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4339">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4340"><xref:System.OverflowException> se produce si el resultado no puede representarse en el tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4340"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="e8764-4341">Esta operación se realiza en enteros con signo; para valores de punto flotante, utilice <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="e8764-4341">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="e8764-4342">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `sub.ovf.un` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4342">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4343">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4343">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4344">Implementa una tabla de saltos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4344">Implements a jump table.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4345">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4345">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4346">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4346">Format</span></span>|<span data-ttu-id="e8764-4347">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4347">Assembly Format</span></span>|<span data-ttu-id="e8764-4348">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4348">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="e8764-4350">cambiar (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="e8764-4350">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="e8764-4351">Salta a uno de `N` valores.</span><span class="sxs-lookup"><span data-stu-id="e8764-4351">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="e8764-4352">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4352">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4353">Un valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4353">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4354">El valor se extrae de la pila y la ejecución se transfiere a la instrucción en el desplazamiento indizado por el valor, donde el valor es menor que `N`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4354">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="e8764-4355">El `switch` instrucción implementa una tabla de saltos.</span><span class="sxs-lookup"><span data-stu-id="e8764-4355">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="e8764-4356">El formato de la instrucción es un `unsigned int32` que representa el número de destinos `N`, seguido de `N` valores int32 que especifican saltar destinos.</span><span class="sxs-lookup"><span data-stu-id="e8764-4356">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="e8764-4357">Estos destinos se representan como desplazamientos (positivos o negativos) desde el principio de la instrucción que sigue a este `switch` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4357">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="e8764-4358">El `switch` instrucción extrae un valor de la pila y lo compara, como un entero sin signo, a `N`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4358">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="e8764-4359">Si el valor es menor que `N`, la ejecución se transfiere al destino indizado por valor, donde los destinos se numeran de 0 (por ejemplo, un valor de 0 toma el primer destino, un valor de 1 toma el segundo destino y así sucesivamente).</span><span class="sxs-lookup"><span data-stu-id="e8764-4359">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="e8764-4360">Si el valor es mayor o igual que `N`, la ejecución continúa en la instrucción siguiente (paso explícito).</span><span class="sxs-lookup"><span data-stu-id="e8764-4360">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="e8764-4361">Si la instrucción de destino tiene uno o más códigos de prefijo, el control solo se transfiere al primero de estos prefijos.</span><span class="sxs-lookup"><span data-stu-id="e8764-4361">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="e8764-4362">Controlar las transferencias dentro y fuera de `try`, `catch`, `filter`, y `finally` bloques no se puede realizar por esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4362">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="e8764-4363">(Estas transferencias están muy limitadas y deben usar la instrucción leave en su lugar).</span><span class="sxs-lookup"><span data-stu-id="e8764-4363">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="e8764-4364">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `switch` código de operación.</span><span class="sxs-lookup"><span data-stu-id="e8764-4364">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="e8764-4365">El `Label[]` argumento es una matriz de etiquetas que representan desplazamientos de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="e8764-4365">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="e8764-4366">ILGenerator.Emit(OpCode, Label[])</span><span class="sxs-lookup"><span data-stu-id="e8764-4366">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8764-4367">El ejemplo de código siguiente muestra el uso de la `Switch` código de operación para generar una tabla de saltos mediante una matriz de <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="e8764-4367">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4368">Ejecuta una instrucción máquina de llamada a método postfija de tal modo que el marco de pila del método actual se quita antes de que se ejecute la verdadera instrucción máquina de llamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4368">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4369">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4370">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4370">Format</span></span>|<span data-ttu-id="e8764-4371">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4371">Assembly Format</span></span>|<span data-ttu-id="e8764-4372">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4373">FE 14</span><span class="sxs-lookup"><span data-stu-id="e8764-4373">FE 14</span></span>|<span data-ttu-id="e8764-4374">final.</span><span class="sxs-lookup"><span data-stu-id="e8764-4374">tail.</span></span>|<span data-ttu-id="e8764-4375">Llamada posterior termina los métodos actuales</span><span class="sxs-lookup"><span data-stu-id="e8764-4375">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="e8764-4376">Hay un comportamiento de transición de pila definido para esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4376">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="e8764-4377">El `tail` instrucción de prefijo debe preceder inmediatamente una <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, o <xref:System.Reflection.Emit.OpCodes.Callvirt> instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4377">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="e8764-4378">Indica que el marco de pila del método actual se debe quitar antes de que se ejecute la instrucción de llamada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4378">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="e8764-4379">También implica que el valor devuelto de la llamada siguiente es también el valor devuelto por el método actual y, por lo tanto, la llamada se puede convertir en un salto entre métodos.</span><span class="sxs-lookup"><span data-stu-id="e8764-4379">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="e8764-4380">La pila debe estar vacía salvo por los argumentos que se transfieren por la llamada siguiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-4380">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="e8764-4381">La instrucción que sigue a la instrucción de llamada debe ser ret. Por lo tanto es la secuencia de código solo tiene validez `tail. call` (o `calli` o `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="e8764-4381">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="e8764-4382">Instrucciones de lenguaje intermedio de Microsoft (MSIL) correcta no deben crear una bifurcación en el `call` instrucción, pero se puede crear una bifurcación en la subsiguiente <xref:System.Reflection.Emit.OpCodes.Ret>.</span><span class="sxs-lookup"><span data-stu-id="e8764-4382">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="e8764-4383">El marco actual no puede descartarse cuando el control se transfiere desde el código de confianza al código de confianza, ya que esto podría poner en peligro la seguridad de identidad del código.</span><span class="sxs-lookup"><span data-stu-id="e8764-4383">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="e8764-4384">Las comprobaciones de seguridad de .NET Framework, por tanto, pueden hacer el `tail` que se omitan, dejando un estándar <xref:System.Reflection.Emit.OpCodes.Call> instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4384">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="e8764-4385">De forma similar, en orden para permitir la salida de una región sincronizada después de que vuelva la llamada, el `tail` prefijo se omite cuando se utiliza para salir de un método que está marcada como sincronizado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4385">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="e8764-4386">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `tail` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4386">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4387">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4387">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">
          <span data-ttu-id="e8764-4388">Instancia de un objeto Opcode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4388">An instance of an Opcode object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e8764-4389">Devuelve true o false si el código de operación suministrado utiliza un argumento de un solo byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4389">Returns true or false if the supplied opcode takes a single byte argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e8764-4390">
            <see langword="True" /> o <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4390">
              <see langword="True" /> or <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4391">Este método puede utilizarse para buscar los códigos de operación MSIL son "corto", para su uso en código optimizado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4391">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="e8764-4392">`TakesSingleByteArgument` Devuelve `true` si el <xref:System.Reflection.Emit.OpCode> instancia toma un argumento de un solo byte en los casos siguientes:</span><span class="sxs-lookup"><span data-stu-id="e8764-4392">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="e8764-4393">El código de operación realiza una instrucción de bifurcación a una dirección de tamaño de bytes (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Br_S> y <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="e8764-4393">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="e8764-4394">El código de operación inserta un valor de byte en la pila (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="e8764-4394">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="e8764-4395">El código de operación hace referencia a una variable o argumento a través de la bytes de tamaño "forma corta" (por ejemplo, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> y <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="e8764-4395">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="e8764-4396">De lo contrario, devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4396">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="e8764-4397">El ejemplo siguiente muestra el uso de `TakesSingleByteArgument` reflejando en el `OpCodes` clase y las pruebas para ver si cada `OpCode` campo toma un argumento de un solo byte.</span><span class="sxs-lookup"><span data-stu-id="e8764-4397">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4398">Produce el objeto de excepción que se encuentra actualmente en la pila de evaluación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4398">Throws the exception object currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4399">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4399">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4400">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4400">Format</span></span>|<span data-ttu-id="e8764-4401">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4401">Assembly Format</span></span>|<span data-ttu-id="e8764-4402">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4402">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4403">7A</span><span class="sxs-lookup"><span data-stu-id="e8764-4403">7A</span></span>|<span data-ttu-id="e8764-4404">throw</span><span class="sxs-lookup"><span data-stu-id="e8764-4404">throw</span></span>|<span data-ttu-id="e8764-4405">Produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4405">Throws an exception.</span></span>|  
  
 <span data-ttu-id="e8764-4406">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4406">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4407">Una referencia de objeto (a una excepción) se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4407">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4408">La referencia de objeto se extrae de la pila y la excepción producida.</span><span class="sxs-lookup"><span data-stu-id="e8764-4408">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="e8764-4409">El `throw` instrucción produce el objeto de excepción (tipo `O`) actualmente en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4409">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="e8764-4410"><xref:System.NullReferenceException> se produce si la referencia de objeto es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-4410"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-4411">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `throw` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4411">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4412">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4412">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4413">Indica que una dirección que se encuentra actualmente en la parte superior de la pila de evaluación puede no estar alineada con el tamaño natural de la instrucción máquina <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> o <see langword="cpblk" /> inmediatamente posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4413">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4414">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4414">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4415">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4415">Format</span></span>|<span data-ttu-id="e8764-4416">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4416">Assembly Format</span></span>|<span data-ttu-id="e8764-4417">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4417">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4418">FE 12 &LT; `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4418">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="e8764-4419">desalineadas.</span><span class="sxs-lookup"><span data-stu-id="e8764-4419">unaligned.</span></span> `alignment`|<span data-ttu-id="e8764-4420">Indica que la siguiente instrucción de puntero puede estar no alineada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4420">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="e8764-4421">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4421">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4422">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4422">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4423">`Unaligned` Especifica que la dirección (un puntero no administrado, `native int`) en la pila puede no estar alineada con el tamaño natural de los siguientes inmediatamente `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4423">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="e8764-4424">Es decir, para una <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instrucción la alineación de la dirección no puede ser un límite de 4 bytes.</span><span class="sxs-lookup"><span data-stu-id="e8764-4424">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="e8764-4425">Para `initblk` y `cpblk` la alineación predeterminada es depende de la arquitectura (4 bytes en CPU de 32 bits, 8 bytes en CPU de 64 bits).</span><span class="sxs-lookup"><span data-stu-id="e8764-4425">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="e8764-4426">Deben usar generadores de código que no limitan sus resultados a un tamaño de palabra de 32 bits `unaligned` si en tiempo de compilación no se sabe que la alineación es de 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="e8764-4426">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="e8764-4427">El valor de alineación debe ser 1, 2 o 4 y significa que el código generado debe asumir que la dirección es de byte, doble byte, o alineación de cuatro bytes, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-4427">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="e8764-4428">Tenga en cuenta que transitorio punteros (tipo `*`) siempre se alinean.</span><span class="sxs-lookup"><span data-stu-id="e8764-4428">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="e8764-4429">Mientras que la alineación de un `cpblk` instrucción lógicamente requeriría dos números (uno para el origen) y otro para el destino, no hay ningún efecto apreciable en el rendimiento si sólo se especifica el número más bajo.</span><span class="sxs-lookup"><span data-stu-id="e8764-4429">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="e8764-4430">El `unaligned` y `volatile` se pueden combinar en cualquier orden.</span><span class="sxs-lookup"><span data-stu-id="e8764-4430">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="e8764-4431">Debe preceder inmediatamente a un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4431">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="e8764-4432">Solo el <xref:System.Reflection.Emit.OpCodes.Volatile> prefijo está permitido para la <xref:System.Reflection.Emit.OpCodes.Ldsfld> y <xref:System.Reflection.Emit.OpCodes.Stsfld> instrucciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-4432">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="e8764-4433">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas del método se pueden utilizar la `unaligned` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4434">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="e8764-4434">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="e8764-4435">ILGenerator.Emit (código de operación, Byte)</span><span class="sxs-lookup"><span data-stu-id="e8764-4435">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4436">Convierte la representación de un tipo de valor al que se le ha aplicado la conversión boxing en la forma que tendría al aplicarle la conversión unboxing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4436">Converts the boxed representation of a value type to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4437">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4438">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4438">Format</span></span>|<span data-ttu-id="e8764-4439">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4439">Assembly Format</span></span>|<span data-ttu-id="e8764-4440">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4441">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4441">79 < `T` ></span></span>|<span data-ttu-id="e8764-4442">aplicar la conversión unboxing `valType`</span><span class="sxs-lookup"><span data-stu-id="e8764-4442">unbox `valType`</span></span>|<span data-ttu-id="e8764-4443">Extrae los datos de tipo de valor de `obj`, su representación en forma de una conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="e8764-4443">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="e8764-4444">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4445">Una referencia de objeto se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4445">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4446">La referencia de objeto se extrae de la pila y se aplica la conversión unboxing a un puntero de tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="e8764-4446">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="e8764-4447">El puntero de tipo de valor se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4447">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4448">Un tipo de valor tiene dos representaciones distintas en Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="e8764-4448">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="e8764-4449">Una forma "sin procesar" que se utiliza cuando un tipo de valor se incrusta dentro de otro objeto.</span><span class="sxs-lookup"><span data-stu-id="e8764-4449">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="e8764-4450">Una forma de 'conversión boxing', donde los datos en el tipo de valor se empaquetan (boxed) en un objeto de modo que pueda existir como una entidad independiente.</span><span class="sxs-lookup"><span data-stu-id="e8764-4450">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="e8764-4451">El `unbox` instrucción convierte la referencia de objeto (tipo `O`), la representación de un tipo de valor, una conversión boxing a un puntero de tipo de valor (un puntero administrado, tipo `&`), su conversión unboxing formulario.</span><span class="sxs-lookup"><span data-stu-id="e8764-4451">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="e8764-4452">El tipo de valor suministrado (`valType`) es un token de metadatos que indica el tipo del tipo de valor contenido dentro del objeto sometido a conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="e8764-4452">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="e8764-4453">A diferencia de <xref:System.Reflection.Emit.OpCodes.Box>, que es necesario para realizar una copia de un tipo de valor para su uso en el objeto `unbox` no es necesario para copiar el tipo de valor del objeto.</span><span class="sxs-lookup"><span data-stu-id="e8764-4453">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="e8764-4454">Normalmente, sólo calcula la dirección del tipo de valor que ya está presente dentro del objeto sometido a conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="e8764-4454">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="e8764-4455"><xref:System.InvalidCastException> se produce si el objeto no está empaquetado como `valType`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4455"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="e8764-4456"><xref:System.NullReferenceException> se produce si la referencia de objeto es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-4456"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-4457"><xref:System.TypeLoadException> se produce si el tipo de valor `valType` no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="e8764-4457"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="e8764-4458">Normalmente, esto se detecta cuando las instrucciones de lenguaje intermedio de Microsoft (MSIL) se convierten en código nativo, en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e8764-4458">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="e8764-4459">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `unbox` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4460">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-4460">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4461">Convierte la representación a la que se aplica la conversión boxing de un tipo especificada en la instrucción a su forma de conversión unboxing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4461">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4462">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio (MSIL) de Microsoft, junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4462">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4463">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4463">Format</span></span>|<span data-ttu-id="e8764-4464">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4464">Assembly Format</span></span>|<span data-ttu-id="e8764-4465">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4466">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="e8764-4466">A5 < `T` ></span></span>|<span data-ttu-id="e8764-4467">unbox.Any `typeTok`</span><span class="sxs-lookup"><span data-stu-id="e8764-4467">unbox.any `typeTok`</span></span>|<span data-ttu-id="e8764-4468">Extraer los datos de `obj`, su representación en forma de una conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="e8764-4468">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="e8764-4469">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4470">Una referencia de objeto `obj` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4470">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4471">La referencia de objeto se extrae de la pila y se aplica la conversión unboxing al tipo especificado en la instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4471">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="e8764-4472">El tipo de valor o referencia de objeto resultante se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4472">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4473">Cuando se aplica a la forma de conversión boxing de un tipo de valor, el `unbox.any` instrucción extrae el valor contenido dentro de `obj` (de tipo `O`) y, por tanto, es equivalente a `unbox` seguido de `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4473">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="e8764-4474">Cuando se aplica a un tipo de referencia, el `unbox.any` instrucción tiene el mismo efecto que `castclass` `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4474">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="e8764-4475">Si el operando `typeTok` es un parámetro de tipo genérico, a continuación, el comportamiento en tiempo de ejecución viene determinado por el tipo especificado para ese parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="e8764-4475">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="e8764-4476"><xref:System.InvalidCastException> se produce si `obj` no es un tipo de conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="e8764-4476"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="e8764-4477"><xref:System.NullReferenceException> se produce si `obj` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="e8764-4477"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="e8764-4478">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `unbox.any` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4478">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4479">ILGenerator.Emit (código de operación, tipo)</span><span class="sxs-lookup"><span data-stu-id="e8764-4479">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4480">Especifica que una dirección que se encuentra actualmente en la parte superior de la pila de evaluación puede ser volátil y los resultados de leer esa ubicación no se pueden almacenar en la caché o no se pueden suprimir múltiples almacenamientos en esa ubicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4480">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4481">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4481">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4482">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4482">Format</span></span>|<span data-ttu-id="e8764-4483">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4483">Assembly Format</span></span>|<span data-ttu-id="e8764-4484">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4484">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4485">FE 13</span><span class="sxs-lookup"><span data-stu-id="e8764-4485">FE 13</span></span>|<span data-ttu-id="e8764-4486">volátiles.</span><span class="sxs-lookup"><span data-stu-id="e8764-4486">volatile.</span></span>|<span data-ttu-id="e8764-4487">Indica que la referencia del puntero subsiguiente es volátil.</span><span class="sxs-lookup"><span data-stu-id="e8764-4487">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="e8764-4488">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4488">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4489">Una dirección se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4489">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4490">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="e8764-4490">`volatile`.</span></span> <span data-ttu-id="e8764-4491">Especifica que la dirección es una dirección volátil (es decir, se puede agregar como referencia externamente para el subproceso actual de ejecución) y los resultados de la lectura que no se pueden almacenar en caché de ubicación o que no se pueden suprimir múltiples almacenamientos en esa ubicación.</span><span class="sxs-lookup"><span data-stu-id="e8764-4491">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="e8764-4492">Al marcar un acceso como `volatile` afecta a sólo ese acceso; los demás accesos a la misma ubicación deben marcarse por separado.</span><span class="sxs-lookup"><span data-stu-id="e8764-4492">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="e8764-4493">Acceso a ubicaciones volátiles no es necesario realizar atómicamente.</span><span class="sxs-lookup"><span data-stu-id="e8764-4493">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="e8764-4494">El <xref:System.Reflection.Emit.OpCodes.Unaligned> y `volatile` se pueden combinar en cualquier orden.</span><span class="sxs-lookup"><span data-stu-id="e8764-4494">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="e8764-4495">Debe preceder inmediatamente a un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` instrucción.</span><span class="sxs-lookup"><span data-stu-id="e8764-4495">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="e8764-4496">Solo el `volatile` prefijo está permitido para la <xref:System.Reflection.Emit.OpCodes.Ldsfld> y <xref:System.Reflection.Emit.OpCodes.Stsfld> instrucciones.</span><span class="sxs-lookup"><span data-stu-id="e8764-4496">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="e8764-4497">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `volatile` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4497">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4498">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4498">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e8764-4499">Calcula la operación XOR bit a bit de los dos valores superiores de la pila de evaluación e inserta el resultado en la pila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e8764-4499">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8764-4500">En la tabla siguiente se muestra la instrucción hexadecimal y formato de ensamblado de lenguaje intermedio de Microsoft (MSIL), junto con un breve resumen de referencia:</span><span class="sxs-lookup"><span data-stu-id="e8764-4500">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="e8764-4501">Format</span><span class="sxs-lookup"><span data-stu-id="e8764-4501">Format</span></span>|<span data-ttu-id="e8764-4502">Formato de ensamblado</span><span class="sxs-lookup"><span data-stu-id="e8764-4502">Assembly Format</span></span>|<span data-ttu-id="e8764-4503">Descripción</span><span class="sxs-lookup"><span data-stu-id="e8764-4503">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="e8764-4504">61</span><span class="sxs-lookup"><span data-stu-id="e8764-4504">61</span></span>|<span data-ttu-id="e8764-4505">xor</span><span class="sxs-lookup"><span data-stu-id="e8764-4505">xor</span></span>|<span data-ttu-id="e8764-4506">Calcula la operación XOR bit a bit de dos valores enteros y devuelve un entero.</span><span class="sxs-lookup"><span data-stu-id="e8764-4506">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="e8764-4507">El comportamiento de transición de pila, en orden secuencial, es:</span><span class="sxs-lookup"><span data-stu-id="e8764-4507">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="e8764-4508">`value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4508">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="e8764-4509">`value2` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4509">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="e8764-4510">`value2` y `value1` se extraen de la pila y su bit a bit XOR calculada.</span><span class="sxs-lookup"><span data-stu-id="e8764-4510">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="e8764-4511">La operación XOR bit a bit de `value2` y `value1` se inserta en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4511">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="e8764-4512">El `xor` instrucción calcula la operación XOR bit a bit de los dos primeros valores en la pila y deja el resultado en la pila.</span><span class="sxs-lookup"><span data-stu-id="e8764-4512">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="e8764-4513">`Xor` es una operación específica de valores enteros.</span><span class="sxs-lookup"><span data-stu-id="e8764-4513">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="e8764-4514">El siguiente <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga del método se puede utilizar la `xor` código de operación:</span><span class="sxs-lookup"><span data-stu-id="e8764-4514">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="e8764-4515">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="e8764-4515">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>