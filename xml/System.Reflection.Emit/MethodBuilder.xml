<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c93c1a358d5c177a5835b41cbeaeae252a6af730" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30470779" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define y representa a un método (o constructor) de una clase dinámica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Reflection.Emit.MethodBuilder> clase se utiliza para describir completamente un método en lenguaje intermedio de Microsoft (MSIL), incluido el cuerpo de nombre, atributos, firma y método. Se utiliza junto con la <xref:System.Reflection.Emit.TypeBuilder> clase para crear clases en tiempo de ejecución.  
  
## <a name="global-methods-and-methods-as-type-members"></a>Métodos globales y los métodos como miembros de tipo  
 Puede usar la reflexión emitir para definir métodos globales y para definir métodos como miembros de tipo. Las API que definen métodos devuelven <xref:System.Reflection.Emit.MethodBuilder> objetos.  
  
### <a name="global-methods"></a>Métodos globales  
 Un método global se define mediante la <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> método, que devuelve un **MethodBuilder** objeto.  
  
 Métodos globales deben ser estáticos. Si un módulo dinámico contiene métodos globales, la <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> método debe llamarse antes de guardar el módulo dinámico o el ensamblado dinámico que lo contiene, porque common language runtime pospone la corrección del módulo dinámico hasta que se han definido todas las funciones globales.  
  
 Un método nativo global se define mediante el <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> método. Invocación de plataforma (PInvoke) no se deben declarar métodos abstracto o virtual. Los conjuntos de tiempo de ejecución el <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> atributo para una plataforma de invocación de método.  
  
### <a name="methods-as-members-of-types"></a>Métodos como miembros de tipos  
 Un método se define como un miembro de tipo mediante el <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> método, que devuelve un <xref:System.Reflection.Emit.MethodBuilder> objeto.  
  
 El <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> método se usa para establecer los atributos de parámetro y nombre de un parámetro o del valor devuelto. La <xref:System.Reflection.Emit.ParameterBuilder> objeto devuelto por este método representa un parámetro o el valor devuelto. La <xref:System.Reflection.Emit.ParameterBuilder> objeto puede utilizarse para establecer el cálculo de referencias, establecer el valor constante y aplicar atributos personalizados.  
  
## <a name="attributes"></a>Atributos  
 Los miembros de la <xref:System.Reflection.MethodAttributes> enumeración define el carácter preciso de un método dinámico:  
  
-   Métodos estáticos se especifican utilizando el <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> atributo.  
  
-   Los métodos finales (métodos que no se puede reemplazar) se especifican utilizando el <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> atributo.  
  
-   Métodos virtuales se especifican utilizando el <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> atributo.  
  
-   Métodos abstractos se especifican utilizando el <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> atributo.  
  
-   Varios atributos determinan la visibilidad del método. Vea la descripción de la <xref:System.Reflection.MethodAttributes> enumeración.  
  
-   Los métodos que implementan operadores sobrecargados deben establecer el <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> atributo.  
  
-   Los finalizadores deben establecer el <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> atributo.  
  
## <a name="known-issues"></a>Problemas conocidos  
  
-   Aunque <xref:System.Reflection.Emit.MethodBuilder> se deriva de <xref:System.Reflection.MethodInfo>, algunos de los métodos abstractos definidos en la <xref:System.Reflection.MethodInfo> clase no se implementan totalmente en <xref:System.Reflection.Emit.MethodBuilder>. Estos <xref:System.Reflection.Emit.MethodBuilder> métodos lanzan el <xref:System.NotSupportedException>. Por ejemplo el <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> método no está totalmente implementado. Se puede reflejar en estos métodos al recuperar el tipo envolvente mediante la <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> métodos.  
  
-   Modificadores personalizados se admiten a partir de la versión 2.0 de .NET Framework. No se admiten en versiones anteriores.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza la <xref:System.Reflection.Emit.MethodBuilder> clase para crear un método dentro de un tipo dinámico.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Acción de seguridad que se va a realizar (Demand, Assert, etc.).</param>
        <param name="pset">Conjunto de permisos a los que se aplica la acción.</param>
        <summary>Agrega seguridad declarativa a este método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> se puede llamar varias veces, con cada llamada especifica una acción de seguridad (como `Demand`, `Assert`, y `Deny`) y un conjunto de permisos que se aplica la acción.  
  
> [!NOTE]
>  En las versiones de .NET Framework 1.0, 1.1 y 2.0, los atributos de seguridad declarativa aplicados a un método mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> método se almacenan en el formato de metadatos XML antiguo. Vea emitir atributos de seguridad declarativa.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso contextual de `AddDeclarativeSecurity` a exigir al llamador de un método que tienen permisos ilimitados.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> no es válido (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> y <see langword="RequestRefuse" /> no son válidos).</exception>
        <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 El conjunto de permisos <paramref name="pset" /> contiene una acción que anteriormente agregó <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.  
  
 O bien  
  
 Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera los atributos para este método.</summary>
        <value>Es de solo lectura. Recupera los <see langword="MethodAttributes" /> para este método.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve la convención de llamadas del método.</summary>
        <value>Es de solo lectura. Convención de llamada del método.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>No es compatible con este tipo.</summary>
        <value>No se admite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Reflection.Emit.MethodBuilder> siempre representa una definición de método genérico y, por tanto, no se puede invocar.  
  
 Para obtener más información, vea <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> y <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>. Para obtener información sobre los tipos genéricos, vea <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El método invocado no se admite en la clase base.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">Matriz que contiene instrucciones del MSIL válidas. Si este parámetro es <see langword="null" />, se elimina el cuerpo del método.</param>
        <param name="count">Número de bytes válidos de la matriz de MSIL. Este valor se omite si MSIL es <see langword="null" />.</param>
        <summary>Crea el cuerpo del método mediante una matriz de bytes especificada de las instrucciones máquina del Lenguaje intermedio de Microsoft (MSIL).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea el cuerpo del método de `il`, una matriz que contiene instrucciones de MSIL como códigos de operación. El número de bytes del MSIL válido viene proporcionado por count.  
  
> [!NOTE]
>  Esto actualmente no es totalmente compatible. El usuario no puede proporcionar la ubicación del símbolo (token) de reparaciones y controladores de excepciones.  
  
   
  
## Examples  
 En el ejemplo incluido a continuación, se genera un método simple que suma dos enteros a través de código de operación usando `CreateMethodBody`.  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> no se encuentra dentro del intervalo de índices de la matriz de instrucciones en MSIL proporcionada y <paramref name="il" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se creó anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 A este método se llamó anteriormente en este <see langword="MethodBuilder" /> con un argumento <paramref name="il" /> que no era <see langword="null" />.  
  
 O bien  
  
 Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el tipo que declara este método.</summary>
        <value>Es de solo lectura. Tipo que declara este método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código siguiente muestra el uso de la `Type` propiedad.  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Matriz de cadenas que representan los nombres de los parámetros de tipo genérico.</param>
        <summary>Establece el número de parámetros de tipo genérico del método actual, especifica sus nombres y devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que se pueden utilizar para definir sus restricciones.</summary>
        <returns>Una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo del método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método convierte genérico del método actual. No hay ninguna manera de deshacer este cambio. Al llamar a este método una segunda vez, un <xref:System.InvalidOperationException>.  
  
 Los parámetros de tipo del método genérico pueden recuperarse más adelante mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> método.  
  
 Por convención, un nombre de parámetro de tipo es una sola letra mayúscula.  
  
 Para obtener más información, vea <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> y <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>. Para obtener información sobre los tipos genéricos, vea <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un tipo dinámico, `DemoType`, que contiene el método genérico dinámico `DemoMethod`. Este método tiene dos parámetros de tipo genérico, uno de los cuales se utiliza como un parámetro y el otro como el tipo de valor devuelto.  
  
 Cuando se ejecuta el código, el ensamblado dinámico se guarda como DemoGenericMethod1.dll y se puede examinar con [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
> [!NOTE]
>  Este ejemplo de código genera un cuerpo de método simple que simplemente devuelve una referencia nula. Para obtener un ejemplo de código con un cuerpo de método totalmente desarrollado más que crea y utiliza tipos genéricos, vea [Cómo: definir un método genérico con emisión de reflexión](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los parámetros de tipo genérico ya se han definido para este método.  
  
 O bien  
  
 El método ya ha finalizado.  
  
 O bien  
  
 Se ha llamado al método <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> para el método actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> es <see langword="null" />.  
  
 O bien  
  
 Un elemento de <paramref name="names" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> es una matriz vacía.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Posición del parámetro en la lista de parámetros. Los parámetros se indizan empezando por el número 1 para el primer parámetro; el número 0 representa el valor devuelto del método.</param>
        <param name="attributes">Atributos del parámetro.</param>
        <param name="strParamName">Nombre del parámetro. El nombre puede ser una cadena nula.</param>
        <summary>Establece los atributos y el nombre de un parámetro de este método o del valor devuelto del mismo. Devuelve un objeto ParameterBuilder, que se puede utilizar para aplicar atributos personalizados.</summary>
        <returns>Devuelve un objeto <see langword="ParameterBuilder" /> que representa un parámetro de este método o el valor devuelto del mismo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Reflection.Emit.ParameterBuilder> objeto devuelto por este método puede utilizarse para establecer el valor predeterminado para un parámetro o aplicar atributos personalizados.  
  
 Numeración de los parámetros comienza por 1, por lo que `position` es 1 para el primer parámetro. Si `position` es cero, este método afecta al valor devuelto.  
  
> [!NOTE]
>  En las versiones 1.0 y 1.1 de .NET Framework, se produce una excepción si `position` es cero, por lo que este método no se puede usar para modificar atributos del valor devuelto en esas versiones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El método no tiene parámetros.  
  
 O bien  
  
 <paramref name="position" /> es menor que cero.  
  
 O bien  
  
 <paramref name="position" /> es mayor que el número de los parámetros del método.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se creó anteriormente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con la instancia <see langword="MethodBuilder" />.</param>
        <summary>Determina si el objeto dado es igual a esta instancia.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> es una instancia de <see langword="MethodBuilder" /> y es igual a este objeto; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La igualdad viene determinada por tener el mismo nombre, atributos y firma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la implementación base para un método.</summary>
        <returns>Implementación base de este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto siempre devuelve el valor actual `MethodBuilder` objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los atributos personalizados definidos para este método.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
        <summary>Devuelve los atributos personalizados definidos para este método.</summary>
        <returns>Devuelve una matriz de objetos que representa a todos los atributos personalizados de este método.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo de atributo personalizado.</param>
        <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
        <summary>Devuelve los atributos personalizados identificados por el tipo dado.</summary>
        <returns>Devuelve una matriz de objetos que representan los atributos de este método que son del tipo <paramref name="attributeType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo del método si es genérico.</summary>
        <returns>Una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que representan los parámetros de tipo si el método es genérico, o bien, <see langword="null" /> si el método no es genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además, se devuelven los parámetros de tipo de un método genérico por el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método que se utiliza para definirlos.  
  
 Para obtener más información, vea <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> y <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>. Para obtener información sobre los tipos genéricos, vea <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve este método.</summary>
        <returns>La actual instancia de <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Reflection.Emit.MethodBuilder> no se puede usar para emitir un método genérico construido directamente. El método emitido es una definición de método genérico.  
  
 Para obtener más información, vea <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> y <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>. Para obtener información sobre los tipos genéricos, vea <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método actual no es genérico. Es decir, la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> devuelve <see langword="false" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el código hash para este método.</summary>
        <returns>Código hash para este método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un <see langword="ILGenerator" /> para este método.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un <see langword="ILGenerator" /> para este método con un tamaño predeterminado de secuencia de Lenguaje intermedio de Microsoft (MSIL) de 64 bytes.</summary>
        <returns>Devuelve un objeto <see langword="ILGenerator" /> para este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra el uso contextual de la `GetILGenerator` método, la creación y emisión de un ensamblado dinámico que calcule el producto escalar de dos puntos en un espacio 3D.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método no debe tener un cuerpo debido a sus marcas de <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />; por ejemplo, porque tiene la marca de <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  
  
 O bien  
  
 El método es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Tamaño de la secuencia de MSIL, en bytes.</param>
        <summary>Devuelve un <see langword="ILGenerator" /> para este método con el tamaño de secuencia de Lenguaje intermedio de Microsoft (MSIL) especificado.</summary>
        <returns>Devuelve un objeto <see langword="ILGenerator" /> para este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra el uso contextual de la `GetILGenerator` método, la creación y emisión de un ensamblado dinámico que calcule el producto escalar de dos puntos en un espacio 3D.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método no debe tener un cuerpo debido a sus marcas de <see cref="T:System.Reflection.MethodAttributes" /> o <see cref="T:System.Reflection.MethodImplAttributes" />; por ejemplo, porque tiene la marca de <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" />.  
  
 O bien  
  
 El método es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve las marcas de implementación para el método.</summary>
        <returns>Devuelve las marcas de implementación para el método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una referencia al módulo que contiene este método.</summary>
        <returns>Devuelve una referencia al módulo que contiene este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El código de ejemplo siguiente muestra el uso de la `GetModule` método para recuperar información sobre un módulo generado dinámicamente.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los parámetros de este método.</summary>
        <returns>Matriz de objetos <see langword="ParameterInfo" /> que representa a los parámetros de este método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `GetParameters` para descubrir información sobre los parámetros pasados a un método generado dinámicamente.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see langword="GetParameters" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve <see langword="MethodToken" /> que representa al símbolo (token) para este método.</summary>
        <returns>Devuelve el <see langword="MethodToken" /> de este método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor booleano que especifica si las variables locales de este método se inicializan en cero. El valor predeterminado de esta propiedad es <see langword="true" />.</summary>
        <value>
          Es <see langword="true" /> si las variables locales de este método deben inicializarse en cero; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si esta propiedad se establece en `true`, el código de MSIL emitido incluye la inicialización de variables locales. Si se establece en `false`, no se inicializan las variables locales y el código generado es no comprobable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />. (Get o set.)</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto donde debe invocarse al método especificado. Si el método es estático, se ignora este parámetro.</param>
        <param name="invokeAttr">Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos MemberInfo mediante reflexión. Si el enlazador es <see langword="null" /> se utilizará el enlazador predeterminado. Para obtener más información, vea <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Lista de argumentos. Esta matriz de argumentos tiene el mismo número, orden y tipo que los parámetros del método al que se va a invocar. Si no hay ningún parámetro, este debería ser <see langword="null" />.</param>
        <param name="culture">Instancia de <see cref="T:System.Globalization.CultureInfo" /> por la que se rige la conversión de tipos. Si es null, se utiliza la clase <see cref="T:System.Globalization.CultureInfo" /> para el subproceso actual. (Hay que tener en cuenta que esto es necesario, por ejemplo, a la hora de convertir <see cref="T:System.String" /> que representa a 1000 en un valor <see cref="T:System.Double" />, ya que 1000 aparece representado de forma diferente en distintas referencias culturales).</param>
        <summary>Invoca dinámicamente al método que refleja esta instancia sobre el objeto dado, pasando los parámetros especificados y considerando las restricciones del enlazador dado.</summary>
        <returns>Devuelve un objeto que contiene el valor devuelto del método invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el método es estático, el `obj` parámetro se ignora. Para los métodos no estáticos, `obj` debe ser una instancia de una clase que hereda o declara el método y debe ser del mismo tipo que esta clase. Si el método no tiene parámetros, el valor de `parameters` debe ser `null`. En caso contrario, el número, tipo y orden de los elementos de la matriz de parámetros deben ser idénticos al número, tipo y orden de los parámetros para el método reflejado por esta instancia.  
  
> [!NOTE]
>  Se omiten las restricciones de acceso para el código de plena confianza. Es decir, propiedades, métodos, campos y constructores privados son accesibles y se invocan mediante la reflexión siempre que el código sea de plena confianza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo de atributo personalizado.</param>
        <param name="inherit">Especifica si se debe buscar la cadena de herencia de este miembro con el fin de encontrar los atributos personalizados.</param>
        <summary>Comprueba si se ha definido el tipo de atributo personalizado especificado.</summary>
        <returns>
          <see langword="true" /> si está definido el tipo de atributo personalizado especificado, en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el método es un método genérico.</summary>
        <value>
          Es <see langword="true" /> si el método es genérico; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un método es genérico si tiene parámetros de tipo. Puede hacer que un método genérico mediante una llamada a la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método para agregar parámetros de tipo. No se puede deshacer este cambio.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el estado de un método. Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el actual objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> representa la definición de un método genérico.</summary>
        <value>
          Es <see langword="true" /> si el actual objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> representa la definición de un método genérico; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Reflection.Emit.MethodBuilder> sólo puede utilizarse para crear definiciones de método genérico; no puede usarse para crear directamente un método genérico construido. Sin embargo, una subclase de <xref:System.Reflection.Emit.MethodBuilder> podría representar un método genérico construido.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el estado de un método. Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
        <value>Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar si un método en un ensamblado dinámico es crítico para la seguridad, complete el tipo mediante una llamada a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, llame a la <xref:System.Type.GetMethod%2A> método en el tipo completado y obtener el <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> propiedad resultante <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
        <value>Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar si un método en un ensamblado dinámico es crítico para la seguridad, complete el tipo mediante una llamada a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, llame a la <xref:System.Type.GetMethod%2A> método en el tipo completado y obtener el <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> propiedad resultante <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos</summary>
        <value>Produce una excepción <see cref="T:System.NotSupportedException" /> en todos los casos</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar si un método en un ensamblado dinámico es transparente en seguridad, complete el tipo mediante una llamada a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, llame a la <xref:System.Type.GetMethod%2A> método en el tipo completado y obtener el <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> propiedad resultante <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">En todos los casos. Esta propiedad no se admite en ensamblados dinámicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo del método genérico.</param>
        <summary>Devuelve un método genérico construido a partir de la actual definición de método genérico utilizando los argumentos de tipo genérico especificados.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método genérico construido a partir de la actual definición de método genérico utilizando los argumentos de tipo genérico especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando va a emitir código dinámico, deberá emitir una llamada a un método construido a partir de la definición de método genérico representada por un <xref:System.Reflection.Emit.MethodBuilder>, antes de que se ha completado el tipo envolvente. Puede usar el <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> método para crear un <xref:System.Reflection.MethodInfo> para un método construido, como y use la <xref:System.Reflection.MethodInfo> en la llamada emitida.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un método construido a partir de una definición de método genérico incompleta en un tipo incompleto.  
  
 En el ejemplo se crea un ensamblado transitorio y un módulo con un solo tipo, se agrega un método `M`y se convierte en el método genérico mediante la adición de un tipo de parámetro T usando el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método. El parámetro de tipo se usa como el tipo de parámetro del método así como su tipo de valor devuelto. La definición de método genérico no tiene un cuerpo y no se completa el tipo envolvente. El <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> , a continuación, se utiliza el método para realizar el método construido `M<String>` (`M(Of String)` en Visual Basic). El código de ejemplo no tiene una salida, porque la subclase de <xref:System.Reflection.MethodInfo> devuelto por la <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> método no permita la reflexión sobre sus parámetros.  
  
> [!NOTE]
>  Para obtener otro ejemplo de código que usa <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, consulte <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> También se utiliza mucho al emitir código que utiliza tipos genéricos. Vea [Cómo: definir un método genérico con Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</summary>
        <value>Es de solo lectura. Identificador interno para el método. Utilice este identificador para tener acceso al identificador de metadatos subyacente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible. Recupere el método mediante <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> y llame a <see cref="P:System.Reflection.MethodBase.MethodHandle" /> en el objeto <see cref="T:System.Reflection.MethodInfo" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el módulo en el que se define el método actual.</summary>
        <value>
          <see cref="T:System.Reflection.Module" /> en el que se define el miembro representado por el actual objeto <see cref="T:System.Reflection.MemberInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona por comodidad. Es equivalente a utilizar el <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> propiedad que se va a obtener el tipo en el que se declara el método y, a continuación, llamar a la <xref:System.Type.Module%2A> propiedad del resultante <xref:System.Type> objeto.  
  
 Esta propiedad también es equivalente a llamar a <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el nombre de este método.</summary>
        <value>Es de solo lectura. Recupera una cadena que contiene el nombre sencillo de este método.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera la clase utilizada en la reflexión para obtener este objeto.</summary>
        <value>Es de solo lectura. Tipo utilizado para obtener este método.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto del método como, por ejemplo, cuando el tipo de valor devuelto tiene modificadores personalizados.</summary>
        <value>Un objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden utilizar los diseñadores de compiladores el <xref:System.Reflection.ParameterInfo> objeto devuelto por esta propiedad para detectar si personalizado modificadores, como <xref:Microsoft.VisualC.IsConstModifier>, se aplicaron al tipo de valor devuelto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha creado el tipo que declara.</exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de valor devuelto del método representado por <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
        <value>Tipo de valor devuelto del método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0 y .NET Compact Framework 2.0, este miembro se hereda de la clase base, <xref:System.Reflection.MethodInfo>. Vea <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve los atributos personalizados del tipo de valor devuelto por el método.</summary>
        <value>Es de solo lectura. Atributos personalizados del tipo de valor devuelto por el método.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve siempre `null`. Obtener la <xref:System.Reflection.MethodInfo> después de que la contiene <xref:System.Type> se ha creado y se invoca <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> en el <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece un atributo personalizado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Instancia de una clase de ayuda utilizada para describir el atributo personalizado.</param>
        <summary>Establece un atributo personalizado mediante un generador de atributos personalizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> método puede interactuar con el <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método cuando los dos métodos se utilizan en combinación. Vea la sección Comentarios de la <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método para obtener más información.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Constructor para el atributo personalizado.</param>
        <param name="binaryAttribute">Objeto binario de bytes que representa los atributos.</param>
        <summary>Establece un atributo personalizado mediante un objeto binario de atributo especificado y personalizado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre cómo dar formato a `binaryAttribute`, consulte la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos". La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 El <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> método puede interactuar con el <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método cuando los dos métodos se utilizan en combinación. Vea la sección Comentarios de la <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método para obtener más información.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Marcas de implementación que hay que establecer.</param>
        <summary>Establece las marcas de implementación para este método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método en combinación con la <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> método, tenga en cuenta las posibles interacciones. Por ejemplo, si se usa el <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> método para agregar el <xref:System.Runtime.InteropServices.DllImportAttribute> conjuntos de atributos también el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca. Si se llama posteriormente la <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método, el <xref:System.Reflection.MethodImplAttributes.PreserveSig> marca se sobrescribe. Hay dos formas de evitar esta situación:  
  
-   Llame a la <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método antes de llamar a la <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> método. El <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> método siempre respeta los marcadores de implementación de método existente.  
  
-   Cuando se establecen marcas de implementación, llame a la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> método para recuperar los indicadores existentes, utilice bit a bit o para agregar el marcador y, a continuación, llame a la <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> método.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso contextual de la `SetImplementationFlags` método para describir la implementación de MSIL en un cuerpo de método.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente utilizando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">Información de cálculo de referencias para el tipo de valor devuelto de este método.</param>
        <summary>Establece la información de cálculo de referencias para el tipo de valor devuelto de este método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra el uso contextual de la `SetMarshal` método para calcular las referencias de los resultados de una llamada al método como un tipo diferente.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente utilizando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">Matriz que contiene instrucciones del MSIL válidas.</param>
        <param name="maxStack">Profundidad de evaluación de pila máxima.</param>
        <param name="localSignature">Matriz de bytes que contiene la estructura de variable local serializada. Especifique <see langword="null" /> si el método no tiene ninguna variable local.</param>
        <param name="exceptionHandlers">Colección que contiene los controladores de excepción para el método. Especifique <see langword="null" /> si el método no tiene controladores de excepciones.</param>
        <param name="tokenFixups">Colección de valores que representan desplazamientos de <c>il</c>, cada uno de los cuales especifica el comienzo de un token que se puede modificar. Especifique <see langword="null" /> si el método no tiene ningún token que deba modificarse.</param>
        <summary>Crea el cuerpo del método mediante una matriz de bytes especificada de las instrucciones del Lenguaje intermedio de Microsoft (MSIL).</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="il" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="maxStack" /> es negativo.  
  
 O bien  
  
 Uno de los <paramref name="exceptionHandlers" /> especifica un desplazamiento fuera de <paramref name="il" />.  
  
 O bien  
  
 Uno de los elementos <paramref name="tokenFixups" /> especifica un desplazamiento que está fuera de la matriz <paramref name="il" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente usando el método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Este método se llamó anteriormente en este objeto <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">Matriz de objetos <see cref="T:System.Type" /> que representan los tipos de parámetros.</param>
        <summary>Establece el número y los tipos de parámetros de un método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el número y los tipos de los parámetros se conocen cuando se define el método, se pueden establecer con ninguna sobrecarga de la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> método que acepta una matriz de tipos de parámetro. Sin embargo, un método genérico puede tener parámetros cuyos tipos se especifican mediante uno o varios de sus propios parámetros de tipo genérico, que no se pueden definir hasta después de que el método se ha definido. Utilice este método para establecer los tipos de parámetros en ese caso.  
  
 Si el tipo de valor devuelto tiene modificadores personalizados obligatorios u opcionales, como <xref:System.Runtime.CompilerServices.IsConst>, use el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> sobrecarga del método.  
  
 Al llamar a este método reemplaza cualquier tipo de parámetro que se establecieron con la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método para crear un método genérico. El <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> método se usa para dar al método un parámetro, cuyo tipo será especificada por el primer parámetro de tipo genérico. El <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> método se utiliza para dar al método un tipo de valor devuelto, especificado por el segundo parámetro de tipo genérico.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método actual es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">Objeto <see cref="T:System.Type" /> que representa el tipo de valor devuelto del método.</param>
        <summary>Establece el tipo de valor devuelto del método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para establecer el tipo de valor devuelto de un método genérico, cuando se especifica el tipo de valor devuelto por uno de los parámetros de tipo genérico del método. Si el tipo de valor devuelto tiene modificadores personalizados obligatorios u opcionales, como <xref:System.Runtime.CompilerServices.IsConst>, use el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> sobrecarga del método.  
  
 Llamar a este método reemplaza un tipo de valor devuelto que se establecen utilizando el <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método para crear un método genérico. El <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> método se usa para dar al método un parámetro, cuyo tipo será especificada por el primer parámetro de tipo genérico. El <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> método se utiliza para dar al método un tipo de valor devuelto, especificado por el segundo parámetro de tipo genérico.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método actual es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="returnTypeRequiredCustomModifiers">Matriz de tipos que representa los modificadores personalizados obligatorios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo de valor devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene modificadores personalizados opcionales, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ningún parámetro tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <summary>Establece la firma del método, incluidos el tipo de valor devuelto, los tipos de parámetro así como los modificadores personalizados necesarios y opcionales del tipo de valor devuelto y de los tipos de parámetro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tipo de valor devuelto y el número y los tipos de los parámetros se conocen cuando se define el método, puede establecer con ninguna sobrecarga de la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> método que acepta una matriz de tipos de parámetro. Sin embargo, un método genérico puede tener parámetros cuyos tipos se especifican mediante uno o varios de sus propios parámetros de tipo genérico, que no se pueden definir hasta después de que el método se ha definido. Utilice este método para establecer los tipos de parámetros en ese caso.  
  
 Si el tipo de valor devuelto ni los tipos de parámetros tienen modificadores personalizados obligatorios u opcionales, como <xref:Microsoft.VisualC.IsConstModifier>, puede usar el <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> y <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> métodos.  
  
 Al llamar a este método reemplaza los parámetros y el tipo de valor devuelto establecido mediante el <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada Sample que tiene un parámetro de tipo `T`. La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico `GM` con su propio parámetro de tipo, `U`. Método `GM` crea una instancia de ejemplo, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de Sample y almacena su parámetro de entrada de `Field`. Este código fuente se compila pero no se utiliza; puede ver con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)y compárelo con el código emitido por la clase `Example`.  
  
 El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> método para emitir código genérico. El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample`y utiliza el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`. Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`. Un método `GM` se agrega y se convierte en un método genérico mediante el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método. El parámetro de tipo de `GM` se denomina `U`. Una vez definido el parámetro de tipo, la firma de `GM` se agregan mediante el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> método. No hay ningún tipo de valor devuelto y ningún modificador obligatorio o personalizado, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`, que establece el tipo del único parámetro del método; Esto se establece en el parámetro de tipo del método, `U`. El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`. Define un tipo ficticio, para contener el método de punto de entrada `Main`. En el cuerpo de `Main`, el método estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo de <xref:System.String> sustituye por `U`. El <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> método se utiliza para crear un <xref:System.Reflection.MethodInfo> para el método estático `GM` método del tipo genérico construido `Sample<U>`y el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> , a continuación, se utiliza el método para crear un <xref:System.Reflection.MethodInfo> que pueden emitir en una llamada al método.  
  
 Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe. Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método actual es genérico, pero no es una definición de método genérico. Es decir, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del atributo personalizado simbólico.</param>
        <param name="data">Objeto binario de bytes que representa el valor del atributo personalizado simbólico.</param>
        <summary>Establece un atributo personalizado simbólico mediante un objeto binario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia del atributo personalizado de metadatos, este atributo personalizado está asociado a un escritor de símbolos.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso contextual de la `SetSymCustomAttribute` método para establecer los valores de bytes para el nombre y la clave de un atributo personalizado asociado a un método.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente utilizando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 El módulo que contiene este método no es un módulo de depuración.  
  
 O bien  
  
 Para el método actual, el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> es <see langword="true" />, pero el valor de la propiedad <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera la firma del método.</summary>
        <value>Es de solo lectura. Cadena que contiene la firma del método reflejado por la instancia <see langword="MethodBase" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz que se pasa con los nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede utilizar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de DispID de los argumentos con nombre y recuentos del número de elementos en las matrices.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la instancia <see langword="MethodBuilder" /> como una cadena.</summary>
        <returns>Devuelve una cadena con el nombre, los atributos, la firma del método, las excepciones y la firma local de este método, seguidos de la secuencia actual del lenguaje intermedio de Microsoft (MSIL).</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>