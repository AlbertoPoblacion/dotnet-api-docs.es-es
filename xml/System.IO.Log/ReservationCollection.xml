<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3af3e1a742555f90bf2bf9a58d5acc17efc5ab90" /><Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/09/2018" /><Meta Name="ms.locfileid" Value="51307965" /></Metadata><TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <TypeSignature Language="F#" Value="type ReservationCollection = class&#xA;    interface ICollection&lt;int64&gt;&#xA;    interface seq&lt;int64&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Administra la colección de reservas de espacio realizadas en una secuencia de registro.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase representa un conjunto de áreas de reserva que se realizan en una secuencia de registro. Al agregar elementos a la colección, se asignan nuevas reservas. Al quitar los elementos de la colección, se liberan esas reservas.  
  
 Una aplicación reserva espacio en el registro cuando tiene datos que se escribirán en el registro en el futuro, pero no puede escribir en él de manera inmediata. Las reservas garantizan que los datos se podrán escribir en el registro cuando estén disponibles para su escritura. Al utilizar registros, las aplicaciones reservan a menudo una o más entradas de registro en un área de ordenamiento. Debe reservar los registros antes de anexarlos.  
  
 Las reservas se pueden utilizar para garantizar que se puede completar una operación antes de que se confirmen los datos; de lo contrario, se deshacen los cambios. También se puede utilizar para grabar una "acción de deshacer" en el registro. Durante una operación de reversión, un administrador de recursos transaccional (RM) debe poder recuperar su estado si se interrumpe el RM durante la operación de reversión. Mediante el uso de un área de reserva, un RM puede reservar espacio en un registro antes de utilizarse.  
  
 El método <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> puede reservar espacio o anexar datos, o ambos, en función de los parámetros que se especifiquen al realizar la llamada. A medida que el trabajo progresa en una transacción, una aplicación puede anexar la información de deshacer y reservar espacio para los registros de compensación. Durante una operación de reversión, los registros de compensación que se crean indican lo que se ha deshecho en el disco. Los registros se anexan utilizando espacio que se ha reservado previamente. Esto garantiza que un RM no se quedará sin espacio de registro, lo que es una condición grave, mientras realiza una operación de reversión. Si un registro se rellena durante una transacción, una aplicación puede deshacer una transacción sin ningún riesgo sin dañar los datos durables.  
  
 CLFS es un sistema de registro conforme con ARIES, diseñado para el registro de escritura previa. En el registro de escritura previa, una aplicación escribe un registro de deshacer antes de realizar la operación, reservando la cantidad de espacio que se necesita en el registro para escribir un registro de compensación, que se puede utilizar durante la reversión. Más adelante, se utiliza el espacio reservado cuando se escribe realmente el registro de compensación.  
  
 Las aplicaciones pueden reservar o tener acceso a un gran espacio en cualquier momento dado (son operaciones mutuamente excluyentes). Una vez escrito en el registro un registro de confirmación, una aplicación puede liberar las reservas para los registros de compensación. Esta acción se puede hacer llamando al método <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> o <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>. Llamar al método <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> garantiza que la operación sea atómica, mientras que llamar al método <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> no lo hace.  
  
 Al liberar registros, debe liberar los mismos registros que reservó conjuntamente en una llamada anterior al método <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>.  
  
> [!NOTE]
>  Su implementación de <xref:System.IO.Log.IRecordSequence> debe implementar los métodos <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> y <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> para realizar la asignación y desasignación de la reserva real. Además, su implementación también debe llamar a <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> cuando se escribe un registro en un espacio reservado.  
  
   
  
## Examples  
 Las reservas se pueden realizar de dos maneras como se muestra en los ejemplos siguientes. Puede adoptar los ejercicios de los ejemplos para el procesamiento robusto. Observe que esta tarea sólo se puede realizar al utilizar la clase <xref:System.IO.Log.LogRecordSequence> basada en CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberSignature Language="F#" Value="abstract member Add : int64 -&gt; unit&#xA;override this.Add : int64 -&gt; unit" Usage="reservationCollection.Add size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Tamaño, en bytes, de la reserva solicitada.</param>
        <summary>Asigna una reserva y la agrega a la colección. Este método no puede heredarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo muestra cómo realizar una reserva manualmente. Observe que esta tarea sólo se puede realizar al utilizar la clase <xref:System.IO.Log.LogRecordSequence> basada en CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="size" /> no es válido o supera el tamaño de reserva máximo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al crear la captura del archivo.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="reservationCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todas las reservas de la colección. Este método no puede heredarse.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="size" /> no es válido o supera el tamaño de reserva máximo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al crear la captura del archivo.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberSignature Language="F#" Value="abstract member Contains : int64 -&gt; bool&#xA;override this.Contains : int64 -&gt; bool" Usage="reservationCollection.Contains size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">El tamaño que se va a ubicar en la colección.</param>
        <summary>Determina si se ha realizado una reserva del tamaño especificado. Este método no puede heredarse.</summary>
        <returns><see langword="true" /> si, al menos, se ha realizado una reserva del tamaño especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int64[] * int -&gt; unit&#xA;override this.CopyTo : int64[] * int -&gt; unit" Usage="reservationCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">La matriz que es el destino de la copia.</param>
        <param name="arrayIndex">Índice de base cero de la matriz donde comienza la copia.</param>
        <summary>Copia la colección completa en una matriz unidimensional, comenzando por el índice especificado de la matriz de destino. Este método no puede heredarse.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="arrayIndex" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> es menor que cero, o mayor o igual que la longitud de <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">No hay espacio suficiente en la matriz especificada para copiar los datos.  
  
O bien 
 <paramref name="array" /> no es una matriz unidimensional, que es el único tipo admitido para la acción solicitada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.IO.Log.ReservationCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de reservas de la colección.</summary>
        <value>El número de reservas de la colección.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="reservationCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que el objeto <see cref="T:System.IO.Log.ReservationCollection" /> libere recursos antes de ser destruido por el recolector de elementos no utilizados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member FreeReservation : int64 -&gt; unit" Usage="reservationCollection.FreeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">El tamaño de la reserva que se va a liberar.</param>
        <summary>Cuando se invalida en una clase derivada, libera una reserva del tamaño especificado.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Al heredar de <see cref="T:System.IO.Log.ReservationCollection" />, debe implementar este método para liberar espacio realmente en la secuencia de registro. No debería llamar a <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> cuando este método esté completado; esa lógica se administra para usted.  
  
Al liberar registros, debe liberar los mismos registros que reservó conjuntamente en una llamada anterior al método <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberSignature Language="F#" Value="member this.GetBestMatchingReservation : int64 -&gt; int64" Usage="reservationCollection.GetBestMatchingReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">El tamaño de la reserva que se debe ajustar.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene la mejor reserva correspondiente para un tamaño determinado.</summary>
        <returns>Una reserva de la colección que es mayor que o igual al tamaño especificado, o -1 si no existe reserva alguna de este tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente se llama a este método al anexar un registro del espacio reservado a una secuencia de registro. Al regresar, se ha eliminado de la colección una reserva del tamaño devuelto. Si, por alguna razón, no se tiene acceso al espacio reservado realmente, se debería llamar al método <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> para asegurar que <xref:System.IO.Log.ReservationCollection> representa con precisión la cantidad de espacio reservado en la secuencia de registro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;" Usage="reservationCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que puede recorrer en iteración a través de <see cref="T:System.IO.Log.ReservationCollection" />. Este método no puede heredarse.</summary>
        <returns>Un enumerador que puede recorrer en iteración a través de la <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La operación no es válida por una de estas razones: 
-   La enumeración ha finalizado.  
  
-   Se ha modificado la colección.  
  
-   La enumeración no se ha iniciado. Se debe realizar una llamada a <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la colección es de solo lectura.</summary>
        <value>Esta propiedad devuelve siempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una <xref:System.IO.Log.ReservationCollection> nunca es de solo lectura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member MakeReservation : int64 -&gt; unit" Usage="reservationCollection.MakeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">El tamaño de la reserva que se va a asignar.</param>
        <summary>Cuando se invalida en una clase derivada, asigna una reserva del tamaño especificado.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Al heredar de <see cref="T:System.IO.Log.ReservationCollection" />, debe implementar este método para reservar espacio realmente en la secuencia de registro. No debería llamar a <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> cuando este método esté completado; esa lógica se administra para usted.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : int64 -&gt; bool&#xA;override this.Remove : int64 -&gt; bool" Usage="reservationCollection.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item">El tamaño de la reserva que se va a liberar.</param>
        <summary>Libera una reserva del tamaño especificado, si se ha realizado una. Este método no puede heredarse.</summary>
        <returns><see langword="true" /> si encontró y eliminó una reserva del tamaño especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo muestra cómo realizar una reserva manualmente. Observe que esta tarea sólo se puede realizar al utilizar la clase <xref:System.IO.Log.LogRecordSequence> basada en CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se puede encontrar en la colección de reservas especificada ninguna reserva lo suficientemente grande como para ajustar el registro proporcionado.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al crear la captura del archivo.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationFreed : int64 -&gt; unit" Usage="reservationCollection.ReservationFreed size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">El tamaño de la reserva que se ha liberado.</param>
        <summary>Cuando se invalida en una clase derivada, indica que se ha liberado una reserva.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al heredar de <xref:System.IO.Log.ReservationCollection>, debe llamar a este método cuando se libere una reserva por un motivo que no sea el eliminarla de la colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationMade : int64 -&gt; unit" Usage="reservationCollection.ReservationMade size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">El tamaño de la reserva que se ha realizado.</param>
        <summary>Cuando se invalida en una clase derivada, indica que se ha realizado una reserva.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al heredar de <xref:System.IO.Log.ReservationCollection>, debe llamar a este método cuando se realice una reserva fuera de una llamada a <xref:System.IO.Log.ReservationCollection.Add%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que puede recorrer en iteración a través de <see cref="T:System.IO.Log.ReservationCollection" />. Este método no puede heredarse.</summary>
        <returns>Un enumerador que puede recorrer en iteración a través de la <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La operación no es válida por una de estas razones: 
-   La enumeración ha finalizado.  
  
-   Se ha modificado la colección.  
  
-   La enumeración no se ha iniciado. Se debe realizar una llamada a <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>