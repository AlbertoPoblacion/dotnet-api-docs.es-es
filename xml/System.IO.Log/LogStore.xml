<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37759118" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a log-structured storage.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.IO.Log.LogRecordSequence> proporciona una implementación de la interfaz de secuencia de registro encima de un registro de Sistema de Registro Archivo Común (CLFS). Funciona con la clase <xref:System.IO.Log.LogStore>, que proporciona una interfaz para manipular directamente y administrar un archivo de registro de CLFS. Un almacén de registro proporciona el almacenamiento de sólo anexar por un conjunto de extensiones del disco. La clase <xref:System.IO.Log.LogStore> representa este almacenamiento y proporciona métodos para agregar y quitar contenedores, configurar una directiva y crear archivos. No proporciona los métodos para leer de y escribir en el almacenamiento; la clase <xref:System.IO.Log.LogRecordSequence> proporciona estos métodos.  
  
 La relación entre la clase <xref:System.IO.Log.LogStore> y la clase <xref:System.IO.Log.LogRecordSequence> es similar a la relación entre un archivo de disco y un objeto <xref:System.IO.FileStream>. El archivo de disco proporciona el almacenamiento real y tiene atributos como longitud y último tiempo de acceso, mientras que el objeto <xref:System.IO.FileStream> proporciona una vista en el archivo que se puede utilizar para leer de él y para escribir en él. De igual forma, la clase <xref:System.IO.Log.LogStore> tiene los atributos como una directiva y una colección de extensiones del disco y la clase <xref:System.IO.Log.LogRecordSequence> proporciona un mecanismo orientado a registro para leer y escribir los datos.  
  
 A diferencia de la secuencia de registro de archivo representada por la clase <xref:System.IO.Log.FileRecordSequence>, una instancia <xref:System.IO.Log.LogStore> almacena sus datos en una colección de extensiones del disco, representada por instancias <xref:System.IO.Log.LogExtent>. Las extensiones en una instancia <xref:System.IO.Log.LogStore> determinada son todas de tamaño uniforme y el espacio se agrega a y se quita de una instancia <xref:System.IO.Log.LogStore> en incrementos de la extensión. Para agregar y quitar las extensiones del registro, utilice <xref:System.IO.Log.LogExtentCollection.Add%2A> y los métodos <xref:System.IO.Log.LogExtentCollection.Remove%2A> del objeto <xref:System.IO.Log.LogExtentCollection>, que puede ser devuelto por la propiedad <xref:System.IO.Log.LogStore.Extents%2A>.  
  
 Una instancia <xref:System.IO.Log.LogStore> puede tener las directivas asociadas a él. Éstas están representadas por las instancias <xref:System.IO.Log.LogPolicy> que pueden ser devueltas por la propiedad <xref:System.IO.Log.LogStore.Policy%2A> . Una directiva dicta reglas que el registro intentará seguir, como número máximo de extensiones y tamaño mínimo e instrucciones en crecer o reducir <xref:System.IO.Log.LogStore> bajo ciertas condiciones. Además, puede especificar si una instancia <xref:System.IO.Log.LogStore> puede estar almacenada. Las directivas se establecen para cada registro y son volátiles, lo que significa que una vez se cierra cada controlador del registro, la directiva deja de existir.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo archivar <xref:System.IO.Log.LogStore> en un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">A file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> object encapsulates.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class for the specified handle.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The log handle could not be bound to the thread pool.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path and mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para abrir un almacén de registro con la ruta de acceso y el modo especificados. El almacén se empieza con acceso de lectura y escritura y comparte el acceso de lectura.  
  
 El parámetro `path` debería utilizar la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path, mode, and access.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para empezar un almacén del registro con la ruta de acceso especificada, modo y acceso. El almacén se abre compartiendo el acceso de lectura.  
  
 El parámetro `path` debería utilizar la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.  -or  <paramref name="access" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un nuevo objeto <xref:System.IO.Log.LogStore> que empieza con la ruta de acceso especificada, modo y acceso. El almacén se abre compartiendo el acceso especificado.  
  
 El parámetro `path` debería utilizar la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.  -or  <paramref name="access" /> contains an invalid value.  -or-  <paramref name="share" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</param>
        <param name="fileSecurity">One of the <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un nuevo objeto <xref:System.IO.Log.LogStore> que empieza con la ruta de acceso especificada, modo y acceso. El almacén se abre compartiendo el acceso especificado. El parámetro `path` debería seguir la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The log store file name specified by <paramref name="path" /> is not valid.  -or-  <paramref name="Mode" /> is <see langword="CreateNew" />, which cannot be used without write access.  -or-  <paramref name="Mode" /> is <see langword="OpenOrCreate" />, which cannot be used without write access.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.  -or  <paramref name="access" /> contains an invalid value.  -or-  <paramref name="share" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.  The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.  -or-  The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.  -or-  The log handle could not be bound to the thread pool.  -or-  The specified log file format or version is invalid.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this <see cref="T:System.IO.Log.LogStore" /> instance can be archived.</summary>
        <value>
          <see langword="true" /> si esta instancia de <see cref="T:System.IO.Log.LogStore" /> puede archivarse; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.IO.Log.LogStore> no se puede archivar, las llamadas a los métodos <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> y <xref:System.IO.Log.LogStore.SetArchiveTail%2A> provocan que se inicie una <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the lowest sequence number that corresponds to a valid record in this <see cref="T:System.IO.Log.LogStore" /> instance.</summary>
        <value>El número de secuencia más bajo que corresponde a un registro válido en las instancias <see cref="T:System.IO.Log.LogStore" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Takes a snapshot of the log store state necessary to make a backup.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a snapshot of the log store state for making a backup.</summary>
        <returns>A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo archivar <xref:System.IO.Log.LogStore> en un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The log store is not archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when creating the archive snapshot.</exception>
        <exception cref="T:System.ArgumentException">An argument is not valid.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation has been executed.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">The starting sequence number in the range to archive.</param>
        <param name="last">The ending sequence number in the range to archive.</param>
        <summary>Takes a snapshot of the log store state between the specified sequence numbers for making a backup.</summary>
        <returns>A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La captura del archivo devuelta de este método abarca información o desde el número de secuencia base o desde el número de secuencia del archivo, el que es más bajo, al último número de secuencia. No está incluido para el último número de secuencia, lo cual significa que el archivo sólo incluye los registros hasta el último lugar, sin incluir éste. Además, al utilizar este método,  el SequenceNumber del inicio debe ser igual a BaseSequenceNumber para que el archivo sea coherente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="first" /> or <paramref name="last" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="first" /> is larger than <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation has been executed.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when creating the archive snapshot.</exception>
        <exception cref="T:System.NotSupportedException">The log store is not archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to remove.</param>
        <summary>Removes the log store.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame <xref:System.IO.Log.LogStore.Dispose%2A> cuando haya terminado de utilizar la clase <xref:System.IO.Log.LogStore>. El método <xref:System.IO.Log.LogStore.Dispose%2A> deja el <xref:System.IO.Log.LogStore> en un estado no utilizable. Después de llamar a <xref:System.IO.Log.LogStore.Dispose%2A>, hay que liberar todas las referencias a <xref:System.IO.Log.LogStore> de modo que la memoria ocupada por <xref:System.IO.Log.LogStore> pueda ser reclamada por el recolector de elementos no utilizados.  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.IO.Log.LogStore.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.IO.Log.LogStore>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.IO.Log.LogStore> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of log extents that contain the data for this log store.</summary>
        <value>Una instancia <see cref="T:System.IO.Log.LogExtentCollection" /> que contiene la colección de extensiones del registro que encapsula los datos para este almacén del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia de <xref:System.IO.Log.LogStore> almacena sus datos en una colección de extensiones de disco, que se representa mediante instancias de <xref:System.IO.Log.LogExtent>. Las extensiones en una instancia <xref:System.IO.Log.LogStore> determinada son todas de tamaño uniforme y el espacio se agrega a y se quita de una instancia <xref:System.IO.Log.LogStore> en incrementos de la extensión. Para agregar y quitar las extensiones del registro, utilice <xref:System.IO.Log.LogExtentCollection.Add%2A> y los métodos <xref:System.IO.Log.LogExtentCollection.Remove%2A> del objeto <xref:System.IO.Log.LogExtentCollection> que ha sido devuelto por esta propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes available in the log store.</summary>
        <value>El número de bytes disponible en el almacén del registro</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the operating system file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> instance encapsulates.</summary>
        <value>El identificador de archivo del sistema operativo correspondiente al archivo de registro que la instancia actual <see cref="T:System.IO.Log.LogStore" /> encapsula.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the sequence number of the next record to be appended to the log store.</summary>
        <value>El número de secuencia del registro siguiente que se va a anexar al almacén del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the log store, in bytes.</summary>
        <value>Obtiene el tamaño del almacén de registro en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del almacén del registro es la suma de los tamaños de las extensiones del registro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the policy associated with this log store.</summary>
        <value>Una instancia <see cref="T:System.IO.Log.LogPolicy" /> que representa la directiva asociada a este almacén del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizarse esta instancia <xref:System.IO.Log.LogPolicy> devuelta por esta propiedad para examinar y manipular la directiva de registro asociada con <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">The sequence number of the archive tail.</param>
        <summary>Sets the sequence number of the archive tail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El menor del número de secuencia base y la cola del archivo determina la cola del registro.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo archivar <xref:System.IO.Log.LogStore> en un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="archiveTail" /> is not valid for this sequence.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation has been executed.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when creating the archive snapshot.</exception>
        <exception cref="T:System.NotSupportedException">The log store is not archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of a program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log store is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of log streams in this log store.</summary>
        <value>Número de secuencias de registro de este almacén de registro</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>