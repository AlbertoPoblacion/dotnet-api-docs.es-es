<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7357fc91060fb82ea1c84227020bd77af9eb422f" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64002408" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa un almacenamiento estructurado del registro.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.IO.Log.LogRecordSequence> proporciona una implementación de la interfaz de secuencia de registro encima de un registro de Sistema de Registro Archivo Común (CLFS). Funciona con la clase <xref:System.IO.Log.LogStore>, que proporciona una interfaz para manipular directamente y administrar un archivo de registro de CLFS. Un almacén de registro proporciona el almacenamiento de sólo anexar por un conjunto de extensiones del disco. La clase <xref:System.IO.Log.LogStore> representa este almacenamiento y proporciona métodos para agregar y quitar contenedores, configurar una directiva y crear archivos. No proporciona los métodos para leer de y escribir en el almacenamiento; la clase <xref:System.IO.Log.LogRecordSequence> proporciona estos métodos.  
  
 La relación entre la clase <xref:System.IO.Log.LogStore> y la clase <xref:System.IO.Log.LogRecordSequence> es similar a la relación entre un archivo de disco y un objeto <xref:System.IO.FileStream>. El archivo de disco proporciona el almacenamiento real y tiene atributos como longitud y último tiempo de acceso, mientras que el objeto <xref:System.IO.FileStream> proporciona una vista en el archivo que se puede utilizar para leer de él y para escribir en él. De igual forma, la clase <xref:System.IO.Log.LogStore> tiene los atributos como una directiva y una colección de extensiones del disco y la clase <xref:System.IO.Log.LogRecordSequence> proporciona un mecanismo orientado a registro para leer y escribir los datos.  
  
 A diferencia de la secuencia de registro de archivo representada por la clase <xref:System.IO.Log.FileRecordSequence>, una instancia <xref:System.IO.Log.LogStore> almacena sus datos en una colección de extensiones del disco, representada por instancias <xref:System.IO.Log.LogExtent>. Las extensiones en una instancia <xref:System.IO.Log.LogStore> determinada son todas de tamaño uniforme y el espacio se agrega a y se quita de una instancia <xref:System.IO.Log.LogStore> en incrementos de la extensión. Para agregar y quitar las extensiones del registro, utilice <xref:System.IO.Log.LogExtentCollection.Add%2A> y los métodos <xref:System.IO.Log.LogExtentCollection.Remove%2A> del objeto <xref:System.IO.Log.LogExtentCollection>, que puede ser devuelto por la propiedad <xref:System.IO.Log.LogStore.Extents%2A>.  
  
 Una instancia <xref:System.IO.Log.LogStore> puede tener las directivas asociadas a él. Éstas están representadas por las instancias <xref:System.IO.Log.LogPolicy> que pueden ser devueltas por la propiedad <xref:System.IO.Log.LogStore.Policy%2A> . Una directiva dicta reglas que el registro intentará seguir, como número máximo de extensiones y tamaño mínimo e instrucciones en crecer o reducir <xref:System.IO.Log.LogStore> bajo ciertas condiciones. Además, puede especificar si una instancia <xref:System.IO.Log.LogStore> puede estar almacenada. Las directivas se establecen para cada registro y son volátiles, lo que significa que una vez se cierra cada controlador del registro, la directiva deja de existir.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo archivar <xref:System.IO.Log.LogStore> en un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogStore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Un identificador de archivo para el registro que el objeto actual <see cref="T:System.IO.Log.LogStore" /> encapsula.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogStore" /> para un identificador especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">El identificador del registro no se pudo enlazar al grupo de subprocesos.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogStore" /> con el trazado especificado y el modo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para abrir un almacén de registro con la ruta de acceso y el modo especificados. El almacén se empieza con acceso de lectura y escritura y comparte el acceso de lectura.  
  
 El parámetro `path` debería utilizar la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén de registros.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogStore" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o utilice en su lugar la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Uno de los valores <see cref="T:System.IO.FileAccess" /> que determina cómo <see cref="T:System.IO.Log.LogStore" /> puede tener acceso al archivo.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogStore" /> con el trazado especificado, el modo y el acceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para empezar un almacén del registro con la ruta de acceso especificada, modo y acceso. El almacén se abre compartiendo el acceso de lectura.  
  
 El parámetro `path` debería utilizar la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.  
  
, o 
 <paramref name="access" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén de registros.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogStore" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o utilice en su lugar la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Uno de los valores <see cref="T:System.IO.FileAccess" /> que determina cómo <see cref="T:System.IO.Log.LogStore" /> puede tener acceso al archivo.</param>
        <param name="share">Uno de los valores <see cref="T:System.IO.FileShare" /> que determina cómo se compartirá el almacén de registros entre los procesos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un nuevo objeto <xref:System.IO.Log.LogStore> que empieza con la ruta de acceso especificada, modo y acceso. El almacén se abre compartiendo el acceso especificado.  
  
 El parámetro `path` debería utilizar la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.  
  
, o 
 <paramref name="access" /> contiene un valor no válido.  
  
O bien 
 <paramref name="share" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén de registros.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogStore" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o utilice en su lugar la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Uno de los valores <see cref="T:System.IO.FileAccess" /> que determina cómo <see cref="T:System.IO.Log.LogStore" /> puede tener acceso al archivo.</param>
        <param name="share">Uno de los valores <see cref="T:System.IO.FileShare" /> que determina cómo se compartirá el almacén de registros entre los procesos.</param>
        <param name="fileSecurity">Uno de los valores <see cref="T:System.Security.AccessControl.FileSecurity" /> que especifica la seguridad para activar el almacén recientemente creado si se debe crear el almacén.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un nuevo objeto <xref:System.IO.Log.LogStore> que empieza con la ruta de acceso especificada, modo y acceso. El almacén se abre compartiendo el acceso especificado. El parámetro `path` debería seguir la sintaxis siguiente:  
  
 `log:<physical log name>[::<log client name>]`  
  
 donde `<physical log name>` es una ruta de acceso válida a un archivo de registro, y `<log client name>` es un identificador del cliente único. Un almacén del registro debería ser un almacén del registro físico o un almacén del registro virtual, pero no ambos. Una vez creado un almacén de registro física o virtualmente, permanece así mientras está vigente. Un almacén del registro físico se crea especificando sólo el nombre del registro físico. Un almacén del registro virtual se crea especificando el nombre del registro físico y el nombre de cliente del registro.  
  
 Los clientes que comparten el mismo nombre del registro físico comparten la misma colección de extensiones y directiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del archivo de almacenamiento de registro especificado por <paramref name="path" /> no es válido.  
  
O bien 
 <paramref name="Mode" /> es <see langword="CreateNew" />, que no se puede utilizar sin el acceso de escritura.  
  
O bien 
 <paramref name="Mode" /> es <see langword="OpenOrCreate" />, que no se puede utilizar sin el acceso de escritura.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.  
  
, o 
 <paramref name="access" /> contiene un valor no válido.  
  
O bien 
 <paramref name="share" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén de registros.  
  
No se puede tener acceso al archivo especificado por <paramref name="path" /> porque está siendo usado por otro proceso.  
  
O bien 
No se puede crear el archivo especificado por <paramref name="path" /> porque el archivo o el directorio ya existe.  
  
O bien 
El identificador de registro no se pudo enlazar al grupo de subprocesos.  
  
O bien 
El formato del archivo de registro especificado o la versión no es válida.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogStore" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o utilice en su lugar la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si esta instancia <see cref="T:System.IO.Log.LogStore" /> puede almacenarse.</summary>
        <value><see langword="true" /> si esta instancia de <see cref="T:System.IO.Log.LogStore" /> puede archivarse; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.IO.Log.LogStore> no se puede archivar, las llamadas a los métodos <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> y <xref:System.IO.Log.LogStore.SetArchiveTail%2A> provocan que se inicie una <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia más bajo que corresponde a un registro válido en las instancias<see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>El número de secuencia más bajo que corresponde a un registro válido en las instancias <see cref="T:System.IO.Log.LogStore" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Toma una captura del estado del almacén del registro necesaria para realizar una copia de seguridad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Toma una captura del estado de almacén de registro para realizar una copia de seguridad.</summary>
        <returns>Un objeto<see cref="T:System.IO.Log.LogArchiveSnapshot" /> que contiene el estado necesario para crear un archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo archivar <xref:System.IO.Log.LogStore> en un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El almacén del registro no se puede archivar.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al crear la captura del archivo.</exception>
        <exception cref="T:System.ArgumentException">Un argumento no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha ejecutado una operación no válida.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Número de secuencia inicial del intervalo que se va a archivar.</param>
        <param name="last">Número de secuencia final del intervalo que se va a archivar.</param>
        <summary>Toma una captura del estado de almacén de registro entre los números de secuencia especificados para realizar una copia de seguridad.</summary>
        <returns>Un objeto<see cref="T:System.IO.Log.LogArchiveSnapshot" /> que contiene el estado necesario para crear un archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La captura del archivo devuelta de este método abarca información o desde el número de secuencia base o desde el número de secuencia del archivo, el que es más bajo, al último número de secuencia. No está incluido para el último número de secuencia, lo cual significa que el archivo sólo incluye los registros hasta el último lugar, sin incluir éste. Además, al utilizar este método,  el SequenceNumber del inicio debe ser igual a BaseSequenceNumber para que el archivo sea coherente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="first" /> o de <paramref name="last" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="first" /> es mayor que <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha ejecutado una operación no válida.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al crear la captura del archivo.</exception>
        <exception cref="T:System.NotSupportedException">El almacén del registro no se puede archivar.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro para quitarse.</param>
        <summary>Quita el almacén del registro.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén de registros.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame <xref:System.IO.Log.LogStore.Dispose%2A> cuando haya terminado de utilizar la clase <xref:System.IO.Log.LogStore>. El método <xref:System.IO.Log.LogStore.Dispose%2A> deja el <xref:System.IO.Log.LogStore> en un estado no utilizable. Después de llamar a <xref:System.IO.Log.LogStore.Dispose%2A>, hay que liberar todas las referencias a <xref:System.IO.Log.LogStore> de modo que la memoria ocupada por <xref:System.IO.Log.LogStore> pueda ser reclamada por el recolector de elementos no utilizados.  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.IO.Log.LogStore.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.IO.Log.LogStore>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.IO.Log.LogStore> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de extensiones del registro que contienen los datos para este almacén del registro.</summary>
        <value>Una instancia <see cref="T:System.IO.Log.LogExtentCollection" /> que contiene la colección de extensiones del registro que encapsula los datos para este almacén del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia de <xref:System.IO.Log.LogStore> almacena sus datos en una colección de extensiones de disco, que se representa mediante instancias de <xref:System.IO.Log.LogExtent>. Las extensiones en una instancia <xref:System.IO.Log.LogStore> determinada son todas de tamaño uniforme y el espacio se agrega a y se quita de una instancia <xref:System.IO.Log.LogStore> en incrementos de la extensión. Para agregar y quitar las extensiones del registro, utilice <xref:System.IO.Log.LogExtentCollection.Add%2A> y los métodos <xref:System.IO.Log.LogExtentCollection.Remove%2A> del objeto <xref:System.IO.Log.LogExtentCollection> que ha sido devuelto por esta propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes disponible en el almacén del registro.</summary>
        <value>El número de bytes disponible en el almacén del registro</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de archivo del sistema operativo correspondiente al archivo de registro que la instancia actual <see cref="T:System.IO.Log.LogStore" /> encapsula.</summary>
        <value>El identificador de archivo del sistema operativo correspondiente al archivo de registro que la instancia actual <see cref="T:System.IO.Log.LogStore" /> encapsula.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, consigue anexar el número de secuencia del registro siguiente al almacén del registro.</summary>
        <value>El número de secuencia del registro siguiente que se va a anexar al almacén del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño del almacén de registro en bytes.</summary>
        <value>Obtiene el tamaño del almacén de registro en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del almacén del registro es la suma de los tamaños de las extensiones del registro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la directiva asociada a este almacén del registro.</summary>
        <value>Una instancia <see cref="T:System.IO.Log.LogPolicy" /> que representa la directiva asociada a este almacén del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizarse esta instancia <xref:System.IO.Log.LogPolicy> devuelta por esta propiedad para examinar y manipular la directiva de registro asociada con <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">El número de secuencia de la cola del archivo</param>
        <summary>Establece el número de secuencia de la cola del archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El menor del número de secuencia base y la cola del archivo determina la cola del registro.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo archivar <xref:System.IO.Log.LogStore> en un documento XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="archiveTail" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha ejecutado una operación no válida.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al crear la captura del archivo.</exception>
        <exception cref="T:System.NotSupportedException">El almacén del registro no se puede archivar.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución de un programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencias de registro de este almacén de registro.</summary>
        <value>Número de secuencias de registro de este almacén de registro</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>