<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1f1c78afc776209e87eb703d91df0fb21999318" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57922255" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una secuencia de registro almacenada en un <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.IO.Log.LogRecordSequence> proporciona una implementación de la interfaz de secuencia de registro encima de un registro de Sistema de Registro Archivo Común (CLFS). Además de las características orientadas a registro estándares, proporciona un modelo de directiva para evitar las condiciones registro completo y multiplexar los clientes en el mismo archivo físico. Funciona con la clase <xref:System.IO.Log.LogStore>, que proporciona una interfaz para manipular directamente y administrar un archivo de registro de CLFS. La relación entre la clase <xref:System.IO.Log.LogStore> y la clase <xref:System.IO.Log.LogRecordSequence> es similar a la relación entre un archivo de disco y un objeto <xref:System.IO.FileStream>. El archivo de disco proporciona el almacenamiento concreto y tiene atributos como longitud y último tiempo de acceso, mientras que el objeto <xref:System.IO.FileStream> proporciona una vista en el archivo que se puede utilizar para leer de él y para escribir en él. De igual forma, la clase <xref:System.IO.Log.LogStore> tiene atributos como una directiva y una colección de extensiones de disco; y la clase <xref:System.IO.Log.LogRecordSequence> proporciona un mecanismo orientado al registro para la lectura y escritura de datos.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo utilizar la clase <xref:System.IO.Log.LogRecordSequence>.  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">El <see cref="T:System.IO.Log.LogStore" /> que debería utilizar esta secuencia de registro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" /> con el almacén de registros especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer. En este constructor, se establece un valor predeterminado de 64. El número deseado de búferes se establece en 10.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logStore" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" /> con una ruta de acceso especificada al almacén de registros y el modo de acceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa una nueva <xref:System.IO.Log.LogRecordSequence> en un nuevo objeto <xref:System.IO.Log.LogStore> que abre con la ruta de acceso y el modo especificados. Se proporciona acceso de lectura/escritura al almacén y se abre el almacén compartiendo acceso de lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén del registro.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.NotSupportedException">Esta operación no se admite.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogRecordSequence" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o use la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">El <see cref="T:System.IO.Log.LogStore" /> que debería utilizar esta secuencia de registro.</param>
        <param name="bufferSize">Tamaño deseado del búfer en bytes. El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</param>
        <param name="bufferCount">El número deseado de búferes.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" /> con el almacén de registros, el tamaño de búfer para cada registro y el número de búfer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si desea especificar los valores de `bufferSize` y `bufferCount` y no desea utilizar el valor predeterminado de 64 para `bufferSize` ni de 10 para `bufferCount`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="logStore" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es un valor negativo o es cero.  
  
O bien 
 <paramref name="bufferCount" /> es un valor negativo o es cero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Uno de los valores <see cref="T:System.IO.FileAccess" /> que determina cómo <see cref="T:System.IO.Log.LogStore" /> puede tener acceso al archivo.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" /> con una ruta de acceso especificada al almacén de registros los modos de acceso y de recurso compartido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa una nueva <xref:System.IO.Log.LogRecordSequence> en un nuevo objeto <xref:System.IO.Log.LogStore> que abre con la ruta, modo y acceso especificados. El almacén se abre compartiendo el acceso de lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén del registro.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.NotSupportedException">Esta operación no se admite.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogRecordSequence" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o use la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Uno de los valores <see cref="T:System.IO.FileAccess" /> que determina cómo <see cref="T:System.IO.Log.LogStore" /> puede tener acceso al archivo.</param>
        <param name="share">Uno de los valores <see cref="T:System.IO.FileShare" /> que determina cómo se compartirá el almacén de registros entre los procesos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" /> con una ruta de acceso especificada al almacén de registros y el modo de acceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa una nueva <xref:System.IO.Log.LogRecordSequence> en un nuevo objeto <xref:System.IO.Log.LogStore> que abre con la ruta, modo y acceso especificados. El almacén se abre compartiendo el acceso especificado.  
  
   
  
## Examples  
 Este ejemplo muestra cómo utilizar este constructor de <xref:System.IO.Log.LogRecordSequence>:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén del registro.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.NotSupportedException">Esta operación no se admite.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogRecordSequence" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o use la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Uno de los valores <see cref="T:System.IO.FileAccess" /> que determina cómo <see cref="T:System.IO.Log.LogStore" /> puede tener acceso al archivo.</param>
        <param name="share">Uno de los valores <see cref="T:System.IO.FileShare" /> que determina cómo se compartirá el almacén de registros entre los procesos.</param>
        <param name="bufferSize">Tamaño deseado del búfer en bytes. El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</param>
        <param name="bufferCount">El número deseado de búferes.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" /> con una ruta de acceso especificada al almacén del registro, permiso de archivo, modos de acceso y de recursos compartidos, así como el tamaño y número de búferes de los registros.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa una nueva <xref:System.IO.Log.LogRecordSequence> en un nuevo objeto <xref:System.IO.Log.LogStore> que abre con la ruta, modo y acceso especificados. El almacén se abre compartiendo el acceso especificado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía ("").  
  
O bien 
 <paramref name="path" /> solo contiene espacio en blanco.  
  
O bien 
 <paramref name="path" /> contiene uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S al abrir el almacén del registro.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.NotSupportedException">Esta operación no se admite.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogRecordSequence" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o use la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</param>
        <param name="mode">Un valor válido de <see cref="T:System.IO.FileMode" /> que determina cómo abrir o crear el almacén.</param>
        <param name="access">Un valor válido de <see cref="T:System.IO.FileAccess" /> que determina cómo se puede tener acceso al almacén del registro.</param>
        <param name="share">Un valor válido de <see cref="T:System.IO.FileShare" /> que determina cómo el almacén del registro se compartirá entre los procesos.</param>
        <param name="bufferSize">Tamaño deseado del búfer en bytes. El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</param>
        <param name="bufferCount">El número deseado de búferes.</param>
        <param name="fileSecurity">Un valor válido de  <see cref="T:System.Security.AccessControl.FileSecurity" /> que especifica la seguridad que se ha de establecer en el almacén recientemente creado si se debe crear el almacén.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El archivo especificado por la <paramref name="path" /> no es válido.  
  
O bien 
El nombre del archivo de almacenamiento de registros especificado no es válido.  
  
O bien 
 <paramref name="mode" /> tiene un valor de <see cref="F:System.IO.FileMode.CreateNew" /> y no se puede utilizar sin acceso de escritura.  
  
O bien 
 <paramref name="mode" /> tiene un valor de <see cref="F:System.IO.FileMode.OpenOrCreate" /> y no se puede utilizar sin acceso de escritura.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
No se puede tener acceso al archivo especificado por <paramref name="path" /> porque está siendo usado por otro proceso.  
  
O bien 
No se puede crear el archivo especificado por <paramref name="path" /> porque el archivo o el directorio ya existe.  
  
O bien 
El identificador de registro no se pudo enlazar al grupo de subprocesos.  
  
O bien 
El formato del archivo de registro especificado o la versión no es válida.</exception>
        <exception cref="T:System.NotSupportedException">Esta operación no se admite.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se puede usar <see cref="T:System.IO.Log.LogRecordSequence" /> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado. Instale el componente CLFS si está disponible para su plataforma o use la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Especifica la nueva <see cref="T:System.IO.Log.SequenceNumber" /> base para el registro. Esto debe quedar en el intervalo entre el número de secuencia base actual y el último número de secuencia de registro, ambos incluidos.</param>
        <summary>Avanza el número de secuencia base del registro. Este método no puede heredarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza a menudo con el evento <xref:System.IO.Log.LogRecordSequence.TailPinned> para liberar espacio en un registro. El evento <xref:System.IO.Log.LogRecordSequence.TailPinned> indica que es necesario mover hacia delante la cola de la secuencia (es decir, el número de secuencia base) para liberar espacio. Para liberar espacio se pueden escribir áreas de reinicio mediante el método <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, o mediante el truncado del registro y el uso del método <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> para avanzar el número de secuencia base de un registro hasta el especificado mediante el parámetro `newBaseSequenceNumber`. El ejemplo de código en la sección Ejemplo muestra el segundo enfoque.  
  
 Observe que llamar a este método es igual que establecer un nuevo número de secuencia base mediante el método <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, salvo que no se escribe ninguna entrada de reinicio en el registro.  
  
   
  
## Examples  
 Este ejemplo muestra cómo utilizar el método <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> con el evento <xref:System.IO.Log.LogRecordSequence.TailPinned> para liberar espacio en una secuencia de registro.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una cola de archivo nueva o existente o la base del registro activo no son válidas.  
  
O bien 
 <paramref name="newBaseSequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.InvalidOperationException">El registro especificado no tiene ninguna extensión. Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo muestra cómo utilizar el miembro <xref:System.IO.Log.LogRecordSequence.Append%2A>.  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.LogRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo muestra cómo utilizar este método para anexar una entrada de registro a la secuencia.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="userRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <summary>Anexa una entrada de registro a la <see cref="T:System.IO.Log.IRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <summary>Anexa una entrada de registro a la <see cref="T:System.IO.Log.IRecordSequence" />, utilizando el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="userRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <summary>Anexa una entrada de registro a la <see cref="T:System.IO.Log.IRecordSequence" />, utilizando el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia del primer registro válido en la <see cref="T:System.IO.Log.LogRecordSequence" /> actual.</summary>
        <value>El número de secuencia más bajo que corresponde a un registro válido en <see cref="T:System.IO.Log.LogRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 El valor de esta propiedad se puede modificar llamando al método <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> o <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>.  
  
   
  
## Examples  
 Este ejemplo muestra cómo utilizar el miembro <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> en un bucle.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación de anexado asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="nextUndoRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="userRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="userRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El número de secuencia del último registro que se debe escribir. Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el vaciado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud particular de vaciado asincrónico de otras.</param>
        <summary>Comienza una operación de vaciado asincrónica, utilizando el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa la operación de vaciado asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult>devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> para asegurarse que la operación de vaciado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se produce un error durante el vaciado asincrónico, no se producirá una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> con el <xref:System.IAsyncResult> devuelto por este método.  
  
 Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.LogRecordSequence> se escriben de manera duradera.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de vaciado asincrónica, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se inician cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.InvalidOperationException">El registro especificado no tiene ninguna extensión. Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una reserva asincrónica y una operación de anexado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una reserva asincrónica y una operación de anexado. Este método no puede heredarse.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="userRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="userRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una reserva asincrónica y una operación de anexado. Este método no puede heredarse.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia una operación de escritura de área de reinicio asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Segmentos de la matriz de bytes que se concatenarán y se anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</param>
        <summary>Comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio reservado previamente en la secuencia. Este método no puede heredarse.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente. Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Cuando la operación se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> no es válido para esta secuencia.  
  
O bien 
La secuencia de inicio de enumeración del registro especificada no es válida.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservation" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una cola de archivo nueva o existente o la base del registro activo no son válidas.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservationCollection"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</param>
        <summary>Comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio reservado previamente en la secuencia. Este método no puede heredarse.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente. Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Cuando la operación se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> no es válido para esta secuencia.  
  
O bien 
La secuencia de inicio de enumeración del registro especificada no es válida.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservationCollection" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una cola de archivo nueva o existente o la base del registro activo no son válidas.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.IO.Log.ReservationCollection" />. Este método no puede heredarse.</summary>
        <returns>Colección <see cref="T:System.IO.Log.ReservationCollection" /> creada recientemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Las reservas se pueden realizar de dos maneras como se muestra en los ejemplos siguientes. Puede adoptar los ejercicios de los ejemplos para el procesamiento robusto. Observe que esta tarea sólo se puede realizar al utilizar la clase <xref:System.IO.Log.LogRecordSequence> basada en CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos utilizados por el componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo usar <xref:System.IO.Log.LogRecordSequence.Dispose%2A> para liberar los recursos:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de vaciado asincrónica. Este método no puede heredarse.</summary>
        <returns>El número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que se producen durante una solicitud de vaciado asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una reserva asincrónica y una operación de anexado. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de escritura de área de reinicio asincrónica. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe los registros anexados de manera duradera</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asegúrese de que todos los registros anexados se han escrito. Este método no puede heredarse.</summary>
        <returns>El número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.LogRecordSequence> se han escrito de manera duradera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al vaciar los datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.NotSupportedException">Esta operación no se admite.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.InvalidOperationException">El registro especificado no tiene ninguna extensión. Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El número de secuencia del último registro que se debe escribir. Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</param>
        <summary>Asegura que todos los registros anexados incluyendo el registro con el número de secuencia especificado se han escrito de manera duradera. Este método no puede heredarse.</summary>
        <returns>El número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método garantiza que todos los registros con números de secuencia hasta el especificado, incluido éste, se han escrito de manera duradera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.InvalidOperationException">El registro especificado no tiene ninguna extensión. Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia que es mayor que el último registro anexado.</summary>
        <value>Un número de secuencia que es mayor que el último registro anexado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contiene un número de secuencia con la garantía de ser mayor que el número de secuencia del último registro anexado. Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. El resto de números de secuencia no son válidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.IO.Log.LogStore" /> que contiene los datos de esta secuencia de registro. Este método no puede heredarse.</summary>
        <value>El <see cref="T:System.IO.Log.LogStore" /> que contiene los datos de esta secuencia de registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo muestra cómo utilizar el miembro <xref:System.IO.Log.LogRecordSequence.LogStore%2A> para agregar extensiones.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño máximo de un registro que se puede agregar a esta secuencia de registro.</summary>
        <value>El tamaño máximo de un registro que se puede agregar a esta secuencia de registro.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">El número de secuencia del primer registro donde la lectura se inicia.</param>
        <param name="logRecordEnum">Un valor <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> válido que especifica la manera (es decir, hacia adelante o hacia atrás) en la que los registros se deberían leer de <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Devuelve una colección enumerable de registros en la secuencia. Este método no puede heredarse.</summary>
        <returns>Una colección enumerable de registros en la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una colección enumerable de registros en la secuencia. El orden de los registros enumerados depende del valor del parámetro `logRecordEnum`.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo utilizar <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> en un bucle.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="start" /> no es válido para esta secuencia.  
  
O bien 
 <paramref name="logRecordEnum" /> no es válido.  
  
O bien 
El elemento especificado no se encontró en la colección.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.  
  
O bien 
El tamaño de búfer utilizado para escribir la entrada de registro es mayor que el tamaño de búfer que se utiliza para leerla.  
  
O bien 
La secuencia de registro está dañada.  
  
O bien 
El formato del archivo de registro especificado o la versión no es válida.  
  
O bien 
El registro se escribió con una versión incompatible de la secuencia de registro.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no es válida porque no se ha iniciado la enumeración. Se debe realizar una llamada a <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección enumerable de las áreas de reinicio de la secuencia. Este método no puede heredarse.</summary>
        <returns>Una colección enumerable de las áreas de reinicio de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las áreas de reinicio se enumeran en orden inverso del número de secuencia, es decir, del número de secuencia superior al número de secuencia más bajo. Sólo se enumeran las áreas de reinicio con números de secuencia entre el último número de secuencia y el número de secuencia base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.  
  
O bien 
El tamaño de búfer utilizado para escribir la entrada de registro es mayor que el tamaño de búfer que se utiliza para leerla.  
  
O bien 
La secuencia de registro está dañada.  
  
O bien 
El formato del archivo de registro especificado o la versión no es válida.  
  
O bien 
El registro se escribió con una versión incompatible de la secuencia de registro.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no es válida porque no se ha iniciado la enumeración. Se debe realizar una llamada a <see cref="M:System.Collections.IEnumerator.MoveNext" />.  
  
O bien 
La enumeración ha finalizado.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza automáticamente una reserva única y anexa un registro a la secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection"><see cref="T:System.IO.Log.ReservationCollection" /> en el que se contiene la colección para realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <summary>Realiza automáticamente una reserva única y anexa un registro a la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar este método para realizar reservas. Observe que esta tarea sólo se puede realizar al utilizar la clase <xref:System.IO.Log.LogRecordSequence> basada en CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="nextUndoRecord" /> o <paramref name="previousRecord" /> no es válido para esta secuencia.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="nextUndoRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="userRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <summary>Realiza automáticamente una reserva única y anexa un registro a la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="userRecord" /> o de <paramref name="previousRecord" /> no está entre los números de secuencia base y último de esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo lectura.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número total de bytes que se ha reservado.</summary>
        <value>El tamaño total de todas las reservas realizadas en esta secuencia del registro.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia del área de reinicio más cercano al final del registro.</summary>
        <value>El número de secuencia del área de reinicio más cercano al final del registro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Con el método <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>, puede eliminar el área de reinicio escrita más recientemente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los anexos se reintentan automáticamente en caso de que el registro esté completo.</summary>
        <value><see langword="true" /> si las operaciones de anexado se reintentan automáticamente cuando el registro esté lleno; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de esta propiedad es `true`, y una llamada <xref:System.IO.Log.LogRecordSequence.Append%2A> no puede realizarse porque no hay espacio suficiente en la secuencia, la secuencia de registro intentará liberar espacio y volverá a intentar anexarse.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo utilizar la propiedad <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El nuevo último número de secuencia en <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
Esto debería hacer referencia a un registro válido actual que se encuentre actualmente en el registro.</param>
        <summary>Establece el último registro en <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de secuencia especificado debe ser mayor que el número de secuencia base.  
  
 Cuando este método se completa, todos los registros anexados previamente con números de secuencia mayores que el número de secuencia especificado son inaccesibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una cola de archivo nueva o existente o la base del registro activo no son válidas.  
  
O bien 
 <paramref name="sequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
Se ha llegado al final del registro.  
  
O bien 
El formato del archivo de registro especificado o la versión no es válida.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Señala la necesidad de mover la cola de la secuencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede desencadenar este evento cuando la secuencia del registro se haya quedado sin espacio. Cuando se desencadena este evento, la cola de la secuencia (es decir, el número de secuencia base) avanza para liberar espacio.  
  
 Se puede desencadenar el evento en cualquier momento que la secuencia del registro decida que debe liberar espacio por cualquier razón. Por ejemplo, el motor de directiva de CLFS puede decidir desencadenar el evento cuando determina que las colas de dos clientes del registro que comparten el mismo archivo de registro están demasiado separadas. Se puede liberar espacio escribiendo áreas de reinicio o truncando el registro y utilizando el método <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> para liberar espacio. El ejemplo de código en la sección Ejemplo muestra el segundo enfoque.  
  
 También puede llamar al método <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> fuera del evento <xref:System.IO.Log.LogRecordSequence.TailPinned> para liberar espacio. Una área de reinicio es similar a un punto de control en otros sistemas de procesamiento de registro. Llamar a este método indica que la aplicación considera que todos los registros anteriores antes del área de reinicio están completos y son utilizables para futuros anexos del registro. De modo similar a cualquier otro registro, el registro escrito por este método requiere espacio disponible real en el registro para funcionar.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo utilizar el evento <xref:System.IO.Log.LogRecordSequence.TailPinned>.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe un área de reinicio en <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Un segmento de la matriz que se concatenará y se anexará como el registro.</param>
        <summary>Escribe un área de reinicio en <see cref="T:System.IO.Log.LogRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <summary>Escribe un área de reinicio en <see cref="T:System.IO.Log.LogRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <summary>Escribe un área de reinicio en la <see cref="T:System.IO.Log.LogRecordSequence" /> y actualiza el número de secuencia base. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <summary>Escribe un área de reinicio en la <see cref="T:System.IO.Log.LogRecordSequence" /> y actualiza el número de secuencia base. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservations"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <summary>Escribe un área de reinicio a la <see cref="T:System.IO.Log.LogRecordSequence" /> usando una reserva y actualiza el número de secuencia base. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservationCollection"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <summary>Escribe un área de reinicio a la <see cref="T:System.IO.Log.LogRecordSequence" /> usando una reserva y actualiza el número de secuencia base. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> no es válido para esta secuencia.  
  
O bien 
La secuencia de inicio de enumeración del registro especificada no es válida.  
  
O bien 
 No se pueden anexar <paramref name="data" /> porque es mayor que el tamaño de registro máximo.  
  
O bien 
 Esta secuencia del registro no creó <paramref name="reservationCollection" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una cola de archivo nueva o existente o la base del registro activo no son válidas.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.  
  
O bien 
La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
  </Members>
</Type>