<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LogRecordSequence.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5330d85d921807042238a6dbb6d100c3f96cc1899.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">330d85d921807042238a6dbb6d100c3f96cc1899</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Represents a record sequence stored in a <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">Representa una secuencia de registro almacenada en un <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> proporciona una implementación de la interfaz de secuencia de registro encima de un registro de Sistema de Registro Archivo Común (CLFS).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</source>
          <target state="translated">Además de las características orientadas a registro estándares, proporciona un modelo de directiva para evitar las condiciones registro completo y multiplexar los clientes en el mismo archivo físico.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>It works with the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class, which provides an interface for directly manipulating and managing a CLFS log file.</source>
          <target state="translated">Funciona con la clase <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph>, que proporciona una interfaz para manipular directamente y administrar un archivo de registro de CLFS.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The relationship between the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class and the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class is similar to the relationship between a disk file and a <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">La relación entre la clase <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> y la clase <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> es similar a la relación entre un archivo de disco y un objeto <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The disk file provides the concrete storage, and has attributes such as length and last access time; while the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object provides a view on the file that can be used to read from it and write to it.</source>
          <target state="translated">El archivo de disco proporciona el almacenamiento concreto y tiene atributos como longitud y último tiempo de acceso, mientras que el objeto <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> proporciona una vista en el archivo que se puede utilizar para leer de él y para escribir en él.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class has attributes like a policy and a collection of disk extents; and the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class provides a record-oriented mechanism for reading and writing data.</source>
          <target state="translated">De igual forma, la clase <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> tiene atributos como una directiva y una colección de extensiones de disco; y la clase <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> proporciona un mecanismo orientado al registro para la lectura y escritura de datos.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class:</source>
          <target state="translated">En este ejemplo se muestra cómo utilizar la clase <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that this record sequence should use.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> que debería utilizar esta secuencia de registro.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with the specified log store.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> con el almacén de registros especificado.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>In this constructor, a default value of 64 is set.</source>
          <target state="translated">En este constructor, se establece un valor predeterminado de 64.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The desired number of buffers is set to 10.</source>
          <target state="translated">El número deseado de búferes se establece en 10.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> que determina cómo abrir o crear el almacén.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access mode.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> con una ruta de acceso especificada al almacén de registros y el modo de acceso.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path and mode.</source>
          <target state="translated">Este constructor inicializa una nueva <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> en un nuevo objeto <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> que abre con la ruta de acceso y el modo especificados.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>It is given read/write access to the store, and the store is opened sharing Read access.</source>
          <target state="translated">Se proporciona acceso de lectura/escritura al almacén y se abre el almacén compartiendo acceso de lectura.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía ("").</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> solo contiene espacio en blanco.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>The file cannot be found.</source>
          <target state="translated">No se puede encontrar el archivo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">Se produce un error de E/S al abrir el almacén de registros.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>This operation is not supported.</source>
          <target state="translated">Esta operación no se admite.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">No se puede usar <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Instale el componente CLFS si está disponible para su plataforma o use la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that this record sequence should use.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> que debería utilizar esta secuencia de registro.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">Tamaño deseado del búfer en bytes.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The desired number of buffers.</source>
          <target state="translated">El número deseado de búferes.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with the specified log store, buffer size for each record, and buffer number.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> con el almacén de registros, el tamaño de búfer para cada registro y el número de búfer especificados.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>Use this constructor if you want to specify values for <ph id="ph1">`bufferSize`</ph> and <ph id="ph2">`bufferCount`</ph> and do not want to use the default value of 64 for <ph id="ph3">`bufferSize`</ph> and 10 for <ph id="ph4">`bufferCount`</ph>.</source>
          <target state="translated">Utilice este constructor si desea especificar los valores de <ph id="ph1">`bufferSize`</ph> y <ph id="ph2">`bufferCount`</ph> y no desea utilizar el valor predeterminado de 64 para <ph id="ph3">`bufferSize`</ph> ni de 10 para <ph id="ph4">`bufferCount`</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferCount" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferCount" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> que determina cómo abrir o crear el almacén.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">Uno de los valores <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> que determina cómo <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> puede tener acceso al archivo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access and share modes.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> con una ruta de acceso especificada al almacén de registros los modos de acceso y de recurso compartido.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">Este constructor inicializa una nueva <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> en un nuevo objeto <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> que abre con la ruta, modo y acceso especificados.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The store is opened sharing Read access.</source>
          <target state="translated">El almacén se abre compartiendo el acceso de lectura.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía ("").</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> solo contiene espacio en blanco.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file cannot be found.</source>
          <target state="translated">No se puede encontrar el archivo.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">Se produce un error de E/S al abrir el almacén de registros.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This operation is not supported.</source>
          <target state="translated">Esta operación no se admite.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">No se puede usar <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Instale el componente CLFS si está disponible para su plataforma o use la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> que determina cómo abrir o crear el almacén.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">Uno de los valores <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> que determina cómo <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> puede tener acceso al archivo.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> values that determines how the log store will be shared among processes.</source>
          <target state="translated">Uno de los valores <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> que determina cómo se compartirá el almacén de registros entre los procesos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access mode.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> con una ruta de acceso especificada al almacén de registros y el modo de acceso.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">Este constructor inicializa una nueva <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> en un nuevo objeto <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> que abre con la ruta, modo y acceso especificados.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">El almacén se abre compartiendo el acceso especificado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This example shows how to use this <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> constructor:</source>
          <target state="translated">Este ejemplo muestra cómo utilizar este constructor de <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía ("").</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> solo contiene espacio en blanco.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file cannot be found.</source>
          <target state="translated">No se puede encontrar el archivo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">Se produce un error de E/S al abrir el almacén de registros.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This operation is not supported.</source>
          <target state="translated">Esta operación no se admite.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">No se puede usar <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Instale el componente CLFS si está disponible para su plataforma o use la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> que determina cómo abrir o crear el almacén.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">Uno de los valores <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> que determina cómo <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> puede tener acceso al archivo.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> values that determines how the log store will be shared among processes.</source>
          <target state="translated">Uno de los valores <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> que determina cómo se compartirá el almacén de registros entre los procesos.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">Tamaño deseado del búfer en bytes.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The desired number of buffers.</source>
          <target state="translated">El número deseado de búferes.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> con una ruta de acceso especificada al almacén del registro, permiso de archivo, modos de acceso y de recursos compartidos, así como el tamaño y número de búferes de los registros.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">Este constructor inicializa una nueva <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> en un nuevo objeto <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> que abre con la ruta, modo y acceso especificados.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">El almacén se abre compartiendo el acceso especificado.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía ("").</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> solo contiene espacio en blanco.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contiene uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The file cannot be found.</source>
          <target state="translated">No se puede encontrar el archivo.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">Se produce un error de E/S al abrir el almacén de registros.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>This operation is not supported.</source>
          <target state="translated">Esta operación no se admite.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">No se puede usar <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Instale el componente CLFS si está disponible para su plataforma o use la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">Una ruta de acceso relativa o absoluta para el archivo base del almacén del registro que se va abrir.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> value that determines how to open or create the store.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> que determina cómo abrir o crear el almacén.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> value that determines how the log store can be accessed.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> que determina cómo se puede tener acceso al almacén del registro.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> value that determines how the log store will be shared among processes.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> que determina cómo el almacén del registro se compartirá entre los procesos.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">Tamaño deseado del búfer en bytes.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">El tamaño de búfer determina el tamaño máximo del registro que se puede anexar o leer.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The desired number of buffers.</source>
          <target state="translated">El número deseado de búferes.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> value that specifies the security to set on the newly created store if the store must be created.</source>
          <target state="translated">Un valor válido de  <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> que especifica la seguridad que se ha de establecer en el almacén recientemente creado si se debe crear el almacén.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not valid.</source>
          <target state="translated">El archivo especificado por la <ph id="ph1">&lt;paramref name="path" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The specified log store file name is not valid.</source>
          <target state="translated">El nombre del archivo de almacenamiento de registros especificado no es válido.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> has a value of <ph id="ph2">&lt;see cref="F:System.IO.FileMode.CreateNew" /&gt;</ph>, and cannot be used without write access.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> tiene un valor de <ph id="ph2">&lt;see cref="F:System.IO.FileMode.CreateNew" /&gt;</ph> y no se puede utilizar sin acceso de escritura.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> has a value of <ph id="ph2">&lt;see cref="F:System.IO.FileMode.OpenOrCreate" /&gt;</ph>, and cannot be used without write access.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> tiene un valor de <ph id="ph2">&lt;see cref="F:System.IO.FileMode.OpenOrCreate" /&gt;</ph> y no se puede utilizar sin acceso de escritura.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>One or more of the arguments are out of range.</source>
          <target state="translated">Uno o varios argumentos están fuera del intervalo.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be found.</source>
          <target state="translated">No se encuentra el archivo especificado por <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be accessed because it is in use by another process.</source>
          <target state="translated">No se puede tener acceso al archivo especificado por <ph id="ph1">&lt;paramref name="path" /&gt;</ph> porque está siendo usado por otro proceso.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be created because the file or directory already exists.</source>
          <target state="translated">No se puede crear el archivo especificado por <ph id="ph1">&lt;paramref name="path" /&gt;</ph> porque el archivo o el directorio ya existe.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The log handle could not be bound to the thread pool.</source>
          <target state="translated">El identificador del registro no se pudo enlazar al grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">El formato del archivo de registro especificado o la versión no es válida.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>This operation is not supported.</source>
          <target state="translated">Esta operación no se admite.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">No se puede usar <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> porque el componente del Sistema de archivos de registro comunes (CLFS) no está instalado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">Instale el componente CLFS si está disponible para su plataforma o use la clase <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Specifies the new base <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> for the log.</source>
          <target state="translated">Especifica la nueva <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> base para el registro.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</source>
          <target state="translated">Esto debe quedar en el intervalo entre el número de secuencia base actual y el último número de secuencia de registro, ambos incluidos.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Moves the base sequence number of the log forward.</source>
          <target state="translated">Avanza el número de secuencia base del registro.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This method is often used with the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free up space in a record.</source>
          <target state="translated">Este método se utiliza a menudo con el evento <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> para liberar espacio en un registro.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</source>
          <target state="translated">El evento <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> indica que es necesario mover hacia delante la cola de la secuencia (es decir, el número de secuencia base) para liberar espacio.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Freeing space can be done by either writing restart areas using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method, or truncating the log and using the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method to advance the base sequence number of a log to the one specified by the <ph id="ph3">`newBaseSequenceNumber`</ph> parameter.</source>
          <target state="translated">Para liberar espacio se pueden escribir áreas de reinicio mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph>, o mediante el truncado del registro y el uso del método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> para avanzar el número de secuencia base de un registro hasta el especificado mediante el parámetro <ph id="ph3">`newBaseSequenceNumber`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">El ejemplo de código en la sección Ejemplo muestra el segundo enfoque.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Note that calling this method is the same as setting a new base sequence number using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method, except that no restart record is written to the log.</source>
          <target state="translated">Observe que llamar a este método es igual que establecer un nuevo número de secuencia base mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph>, salvo que no se escribe ninguna entrada de reinicio en el registro.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free up space in a log sequence.</source>
          <target state="translated">Este ejemplo muestra cómo utilizar el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> con el evento <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> para liberar espacio en una secuencia de registro.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">El registro especificado no tiene ninguna extensión.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>One or more extents must be created before a record sequence may be used.</source>
          <target state="translated">Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Escribe una entrada de registro en la <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> member</source>
          <target state="translated">Este ejemplo muestra cómo utilizar el miembro <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Escribe una entrada de registro en la <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The following example demonstrates how to use this method to append a log record to the sequence.</source>
          <target state="translated">El siguiente ejemplo muestra cómo utilizar este método para anexar una entrada de registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Anexa una entrada de registro a la <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">Anexa una entrada de registro a la <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">Anexa una entrada de registro a la <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>Gets the sequence number of the first valid record in the current <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Obtiene el número de secuencia del primer registro válido en la <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The lowest sequence number that corresponds to a valid record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">El número de secuencia más bajo que corresponde a un registro válido en <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">Los números de secuencia válidos son mayores que o iguales a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> y menores que <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The value of this property can be changed by calling the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method.</source>
          <target state="translated">El valor de esta propiedad se puede modificar llamando al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> member in a loop.</source>
          <target state="translated">Este ejemplo muestra cómo utilizar el miembro <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> en un bucle.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">Comienza una operación de anexado asincrónica.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">Comienza una operación de anexado asincrónica.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">Comienza una operación de anexado asincrónica.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">Comienza una operación de anexado asincrónica.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">Comienza una operación de anexado asincrónica.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">El número de secuencia del último registro que se debe escribir.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">Si <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> no es válido, a continuación, se deben escribir todos los registros.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the flush is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el vaciado.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous flush request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud particular de vaciado asincrónico de otras.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous flush operation, using space previously reserved in the sequence.</source>
          <target state="translated">Comienza una operación de vaciado asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous flush operation, which could still be pending.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa la operación de vaciado asincrónica que puede seguir pendiente.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the current method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method to ensure that the flush completes and resources are freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> para asegurarse que la operación de vaciado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If an error occurs during an asynchronous flush, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se produce un error durante el vaciado asincrónico, no se producirá una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> are durably written.</source>
          <target state="translated">Llamar a este método asegura que todos los registros anexados a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> se escriben de manera duradera.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de vaciado asincrónica, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se inician cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">El registro especificado no tiene ninguna extensión.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">Comienza una reserva asincrónica y una operación de anexado.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">La colección de reservas en la que realizar las reservas.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">Comienza una reserva asincrónica y una operación de anexado.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa esta operación asincrónica, que podría estar aún pendiente.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">La colección de reservas en la que realizar las reservas.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">Comienza una reserva asincrónica y una operación de anexado.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa esta operación asincrónica, que podría estar aún pendiente.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous restart area write operation.</source>
          <target state="translated">Inicia una operación de escritura de área de reinicio asincrónica.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Segmentos de la matriz de bytes que se concatenarán y se anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">Comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio reservado previamente en la secuencia.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando la operación se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">La secuencia de inicio de enumeración del registro especificada no es válida.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservation" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservation" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o más de los parámetros tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">Comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio reservado previamente en la secuencia.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando la operación se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">La secuencia de inicio de enumeración del registro especificada no es válida.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o más de los parámetros tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">Crea un nuevo <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>The newly created <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">Colección <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> creada recientemente.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Reservations can be performed in two ways as shown in the following examples.</source>
          <target state="translated">Las reservas se pueden realizar de dos maneras como se muestra en los ejemplos siguientes.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>You can adopt the practices in the samples for robust processing.</source>
          <target state="translated">Puede adoptar los ejercicios de los ejemplos para el procesamiento robusto.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Notice that this task can only be performed when using the CLFS-based <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class.</source>
          <target state="translated">Observe que esta tarea sólo se puede realizar al utilizar la clase <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> basada en CLFS.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>Releases the resources used by the component.</source>
          <target state="translated">Libera los recursos utilizados por el componente.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>This example shows how to use <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Dispose%2A&gt;</ph> to release resources:</source>
          <target state="translated">Este ejemplo muestra cómo utilizar <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Dispose%2A&gt;</ph> para liberar recursos:</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Ends an asynchronous append operation.</source>
          <target state="translated">Finaliza una operación de anexado asincrónica.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">Para esta operación asincrónica ya se ha llamado a <ph id="ph1">&lt;see langword="End" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Ends an asynchronous flush operation.</source>
          <target state="translated">Finaliza una operación de vaciado asincrónica.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">Número de secuencia del último registro escrito.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que se producen durante una solicitud de vaciado asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">Para esta operación asincrónica ya se ha llamado a <ph id="ph1">&lt;see langword="End" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Ends an asynchronous reserve and append operation.</source>
          <target state="translated">Finaliza una reserva asincrónica y una operación de anexado.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">Para esta operación asincrónica ya se ha llamado a <ph id="ph1">&lt;see langword="End" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Ends an asynchronous restart area write operation.</source>
          <target state="translated">Finaliza una operación de escritura de área de reinicio asincrónica.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The sequence number of the written log record.</source>
          <target state="translated">Número de secuencia del registro de entrada escrito.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">Para esta operación asincrónica ya se ha llamado a <ph id="ph1">&lt;see langword="End" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes appended records durably</source>
          <target state="translated">Escribe los registros anexados de manera duradera</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Ensures that all appended records have been written.</source>
          <target state="translated">Asegúrese de que todos los registros anexados se han escrito.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The sequence number of the last record written.</source>
          <target state="translated">Número de secuencia del último registro escrito.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> have been durably written.</source>
          <target state="translated">Llamar a este método asegura que todos los registros anexados a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> se han escrito de manera duradera.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">Un error E/S ha ocurrido durante el vaciado de datos.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>This operation is not supported.</source>
          <target state="translated">Esta operación no se admite.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The specified log does not have any extents.</source>
          <target state="translated">El registro especificado no tiene ninguna extensión.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">El número de secuencia del último registro que se debe escribir.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">Si <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> no es válido, a continuación, se deben escribir todos los registros.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</source>
          <target state="translated">Asegura que todos los registros anexados incluyendo el registro con el número de secuencia especificado se han escrito de manera duradera.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">Número de secuencia del último registro escrito.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</source>
          <target state="translated">Llamar a este método garantiza que todos los registros con números de secuencia hasta el especificado, incluido éste, se han escrito de manera duradera.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">El registro especificado no tiene ninguna extensión.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">Se han de crear una o más extensiones antes de que se pueda utilizar una secuencia de registro.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>Gets the sequence number which is greater than the last record appended</source>
          <target state="translated">Obtiene el número de secuencia que es mayor que el último registro anexado.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>A sequence number which is greater than the last record appended.</source>
          <target state="translated">Un número de secuencia que es mayor que el último registro anexado.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</source>
          <target state="translated">Esta propiedad contiene un número de secuencia con la garantía de ser mayor que el número de secuencia del último registro anexado.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">Los números de secuencia válidos son mayores que o iguales a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> y menores que <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>All other sequence numbers are invalid.</source>
          <target state="translated">El resto de números de secuencia no son válidos.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that contains the data for this record sequence.</source>
          <target state="translated">Obtiene el <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> que contiene los datos de esta secuencia de registro.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that contains the data for this record sequence.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> que contiene los datos de esta secuencia de registro.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.LogStore%2A&gt;</ph> member to add extents.</source>
          <target state="translated">Este ejemplo muestra cómo utilizar el miembro <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.LogStore%2A&gt;</ph> para agregar extensiones.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.MaximumRecordLength">
          <source>Gets the maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">Obtiene el tamaño máximo de un registro que se puede agregar a esta secuencia de registro.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.MaximumRecordLength">
          <source>The maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">El tamaño máximo de un registro que se puede agregar a esta secuencia de registro.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The sequence number of the first record where the reading starts.</source>
          <target state="translated">El número de secuencia del primer registro donde la lectura se inicia.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> value that specifies the manner (that is, forward or backward) in which records should be read from a <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Un valor <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> válido que especifica la manera (es decir, hacia adelante o hacia atrás) en la que los registros se deberían leer de <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>Returns an enumerable collection of records in the sequence.</source>
          <target state="translated">Devuelve una colección enumerable de registros en la secuencia.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>An enumerable collection of records in the sequence.</source>
          <target state="translated">Una colección enumerable de registros en la secuencia.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This method returns an enumerable collection of records in the sequence.</source>
          <target state="translated">Este método devuelve una colección enumerable de registros en la secuencia.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The order of the enumerated records depends on the value of the <ph id="ph1">`logRecordEnum`</ph> parameter.</source>
          <target state="translated">El orden de los registros enumerados depende del valor del parámetro <ph id="ph1">`logRecordEnum`</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This example shows how to use <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A&gt;</ph> in a loop.</source>
          <target state="translated">En este ejemplo se muestra cómo utilizar <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A&gt;</ph> en un bucle.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="logRecordEnum" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logRecordEnum" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The specified element was not found in the collection.</source>
          <target state="translated">El elemento especificado no se encontró en la colección.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or</source>
          <target state="translated">, o</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">El tamaño de búfer utilizado para escribir la entrada de registro es mayor que el tamaño de búfer que se utiliza para leerla.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The record sequence is corrupted.</source>
          <target state="translated">La secuencia de registro está dañada.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">El formato del archivo de registro especificado o la versión no es válida.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">El registro se escribió con una versión incompatible de la secuencia de registro.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">La operación no es válida porque no se ha iniciado la enumeración.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A call to <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph> must be made.</source>
          <target state="translated">Se debe realizar una llamada a <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Returns an enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">Devuelve una colección enumerable de las áreas de reinicio de la secuencia.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>An enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">Una colección enumerable de las áreas de reinicio en la secuencia.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</source>
          <target state="translated">Las áreas de reinicio se enumeran en orden inverso del número de secuencia, es decir, del número de secuencia superior al número de secuencia más bajo.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</source>
          <target state="translated">Sólo se enumeran las áreas de reinicio con números de secuencia entre el último número de secuencia y el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or</source>
          <target state="translated">, o</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">El tamaño de búfer utilizado para escribir la entrada de registro es mayor que el tamaño de búfer que se utiliza para leerla.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The record sequence is corrupted.</source>
          <target state="translated">La secuencia de registro está dañada.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">El formato del archivo de registro especificado o la versión no es válida.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">El registro se escribió con una versión incompatible de la secuencia de registro.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">La operación no es válida porque no se ha iniciado la enumeración.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>A call to <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph> must be made.</source>
          <target state="translated">Se debe realizar una llamada a <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or</source>
          <target state="translated">, o</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The enumeration has ended.</source>
          <target state="translated">La enumeración ha finalizado.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">Realiza automáticamente una reserva única y anexa un registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the collection to make reservations in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> en el que se contiene la colección para realizar las reservas.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">Realiza automáticamente una reserva única y anexa un registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The following example shows how to use this method to make reservations.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar este método para realizar reservas.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Notice that this task can only be performed when using the CLFS-based <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class.</source>
          <target state="translated">Observe que esta tarea sólo se puede realizar al utilizar la clase <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> basada en CLFS.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> o <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">La colección de reservas en la que realizar las reservas.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">Realiza automáticamente una reserva única y anexa un registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> o de <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> no está entre los números de secuencia base y último de esta secuencia.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">No se puede encontrar en <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ninguna reserva lo suficientemente grande para ajustar <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>Gets the total number of bytes that have been reserved.</source>
          <target state="translated">Obtiene el número total de bytes que se ha reservado.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>The total size of all reservations made in this record sequence.</source>
          <target state="translated">El tamaño total de todas las reservas realizadas en esta secuencia del registro.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>Gets the sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">Obtiene el número de secuencia del área de reinicio más cercano al final del registro.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">El número de secuencia del área de reinicio más cercano al final del registro.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>Using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</ph> method, you can remove the most recently written restart area.</source>
          <target state="translated">Con el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</ph>, puede eliminar el área de reinicio escrita más recientemente.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</source>
          <target state="translated">Obtiene o establece un valor que indica si los anexos se reintentan automáticamente en caso de que el registro esté completo.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if appends are automatically retried if the log is full; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si las operaciones de anexado se reintentan automáticamente cuando el registro esté lleno; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>If the value of this property is <ph id="ph1">`true`</ph>, and an <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</source>
          <target state="translated">Si el valor de esta propiedad es <ph id="ph1">`true`</ph>, y una llamada <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> no puede realizarse porque no hay espacio suficiente en la secuencia, la secuencia de registro intentará liberar espacio y volverá a intentar anexarse.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.RetryAppend%2A&gt;</ph> property.</source>
          <target state="translated">En este ejemplo se muestra cómo utilizar la propiedad <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.RetryAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The new last sequence number in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">El nuevo último número de secuencia en <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>This should refer to a current valid record   currently in the log.</source>
          <target state="translated">Esto debería hacer referencia a un registro válido actual que se encuentre actualmente en el registro.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>Sets the last record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Establece el último registro en <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be larger than the base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</source>
          <target state="translated">Cuando este método se completa, todos los registros anexados previamente con números de secuencia mayores que el número de secuencia especificado son inaccesibles.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The end of the log has been reached.</source>
          <target state="translated">Se ha llegado al final del registro.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">El formato del archivo de registro especificado o la versión no es válida.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Signals the need to move the tail of the sequence.</source>
          <target state="translated">Señala la necesidad de mover la cola de la secuencia.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>You can fire this event when the record sequence has run out of space.</source>
          <target state="translated">Puede desencadenar este evento cuando la secuencia del registro se haya quedado sin espacio.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</source>
          <target state="translated">Cuando se desencadena este evento, la cola de la secuencia (es decir, el número de secuencia base) avanza para liberar espacio.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</source>
          <target state="translated">Se puede desencadenar el evento en cualquier momento que la secuencia del registro decida que debe liberar espacio por cualquier razón.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</source>
          <target state="translated">Por ejemplo, el motor de directiva de CLFS puede decidir desencadenar el evento cuando determina que las colas de dos clientes del registro que comparten el mismo archivo de registro están demasiado separadas.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Freeing space can be done by either writing restart areas, or truncating the log and using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method to clear space.</source>
          <target state="translated">Se puede liberar espacio escribiendo áreas de reinicio o truncando el registro y utilizando el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> para liberar espacio.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">El ejemplo de código en la sección Ejemplo muestra el segundo enfoque.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>You can also call the <ph id="ph1">&lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</ph> method outside of the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free space.</source>
          <target state="translated">También puede llamar al método <ph id="ph1">&lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</ph> fuera del evento <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> para liberar espacio.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>A restart area is similar to a checkpoint in other log processing systems.</source>
          <target state="translated">Una área de reinicio es similar a un punto de control en otros sistemas de procesamiento de registro.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</source>
          <target state="translated">Llamar a este método indica que la aplicación considera que todos los registros anteriores antes del área de reinicio están completos y son utilizables para futuros anexos del registro.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Similar to any other records, the record written by this method requires actual free space in the log to function.</source>
          <target state="translated">De modo similar a cualquier otro registro, el registro escrito por este método requiere espacio disponible real en el registro para funcionar.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event.</source>
          <target state="translated">En este ejemplo se muestra cómo utilizar el evento <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Escribe una área de reinicio en <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An array segment that will be concatenated and appended as the record.</source>
          <target state="translated">Un segmento de la matriz que se concatenará y se anexará como el registro.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Escribe una área de reinicio en <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Escribe una área de reinicio en <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o varios argumentos tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">Escribe un área de reinicio en la <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> y actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">Escribe un área de reinicio en la <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> y actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">Escribe un área de reinicio a la <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> usando una reserva y actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">Escribe un área de reinicio a la <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> usando una reserva y actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">Este método no puede heredarse.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> no es válido para esta secuencia.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">La secuencia de inicio de enumeración del registro especificada no es válida.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">No se pueden anexar <ph id="ph1">&lt;paramref name="data" /&gt;</ph> porque es mayor que el tamaño de registro máximo.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated">Esta secuencia del registro no creó <ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno o más de los parámetros tienen el valor <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">Una cola de archivo nueva o existente o la base del registro activo no son válidas.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> no está entre la base y últimos números de secuencia de esta secuencia.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">La solicitud no se pudo realizar debido a un error de dispositivo de E/S.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">No hay bastante memoria para continuar la ejecución del programa.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">El sistema operativo ha denegado el acceso a la secuencia de registro especificado.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>