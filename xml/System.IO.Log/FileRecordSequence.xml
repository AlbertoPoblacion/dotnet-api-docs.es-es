<Type Name="FileRecordSequence" FullName="System.IO.Log.FileRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c853a66a932592421edbe6cd06c3f5073c2580e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37654523" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.FileRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type FileRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementa una <see cref="T:System.IO.Log.IRecordSequence" /> sobre un archivo. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.FileRecordSequence> es una secuencia de registro basada en un archivo de registro único del sistema de archivos. Es una implementación simple de la interfaz <xref:System.IO.Log.IRecordSequence> sobre un registro basado en archivos simple.  
  
 Para manipular un registro basado en archivos, la cuenta en la que se ejecuta su aplicación debe tener los privilegios suficientes, tal y como lo dicta la seguridad del sistema de archivos en el momento que se construye <xref:System.IO.Log.FileRecordSequence>. Además, en el momento de la construcción se realiza una petición de FullTrust. Los resultados de la comprobación del permiso se almacenan después en memoria caché siguiendo el modelo de seguridad de Windows. Debería asegurarse que no expone accidentalmente el contenido de la secuencia del registro a un usuario sin autorización.  
  
   
  
## Examples  
 El siguiente ejemplo crea una secuencia de registro, anexa el registro a ella y finalmente lee los registros.  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta relativa o absoluta del archivo que va a encapsular esta instancia de <see cref="T:System.IO.Log.FileRecordSequence" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.FileRecordSequence" /> con un archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea el acceso de lectura y escritura al archivo y abre el archivo con acceso de lectura del recurso compartido. Esto significa que las solicitudes que este u otro proceso realicen para abrir el archivo para su escritura producen un error hasta que se haya eliminado esta instancia de <xref:System.IO.Log.FileRecordSequence>, pero los intentos de lectura se realizarán con éxito. Si no se encuentra `path`, se crea un nuevo archivo con un tamaño de 0 bytes.  
  
   
  
## Examples  
 El siguiente ejemplo crea una secuencia de registro, anexa el registro a ella, lee los registros y finalmente elimina la secuencia.  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El archivo especificado por la <paramref name="path" /> no es válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ruta relativa o absoluta del archivo que va a encapsular esta instancia de <see cref="T:System.IO.Log.FileRecordSequence" />.</param>
        <param name="access">Un valor de <see cref="T:System.IO.FileAccess" /> válido que controla el tipo de acceso que tienen los usuarios a un archivo de registro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.FileRecordSequence" /> con un archivo especificado y un modo de acceso.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El archivo especificado por la <paramref name="path" /> no es válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access, int size);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess * int -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access, size)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ruta relativa o absoluta del archivo que va a encapsular esta instancia de <see cref="T:System.IO.Log.FileRecordSequence" />.</param>
        <param name="access">Un valor de <see cref="T:System.IO.FileAccess" /> válido que controla el tipo de acceso que tienen los usuarios a un archivo de registro.</param>
        <param name="size">El tamaño del archivo de registro que se va a abrir.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Log.FileRecordSequence" /> con un archivo especificado, un modo de acceso y un tamaño de archivo.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios parámetros están fuera del intervalo válido.</exception>
        <exception cref="T:System.ArgumentException">El archivo especificado por la <paramref name="path" /> no es válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso al almacén del registro especificado ha sido denegado por el sistema operativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="fileRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base de la secuencia del registro.</param>
        <summary>Avanza el número de secuencia base del registro. Este método no puede heredarse.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> no es válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al modificar la secuencia.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo crea una secuencia de registro, anexa el registro a ella y finalmente lee los registros.  
  
 [!code-csharp[IRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#0)]
 [!code-vb[IRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo crea una secuencia de registro, anexa el registro a ella y finalmente lee los registros.  
  
 [!code-csharp[FileRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/filerecordsequence/cs/filerecordsequence.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo muestra cómo crear una secuencia del registro con este método.  
  
 [!code-csharp[IRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#3)] 
 [!code-vb[IRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#3)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.FileRecordSequence" />, utilizando el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <summary>Escribe una entrada de registro en la <see cref="T:System.IO.Log.FileRecordSequence" />, utilizando el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia del primer registro válido en la <see cref="T:System.IO.Log.FileRecordSequence" /> actual.</summary>
        <value>El número de secuencia más bajo que corresponde a un registro válido en <see cref="T:System.IO.Log.FileRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. El resto de números de secuencia no son válidos.  
  
 El valor de esta propiedad se puede modificar llamando a <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> o al método <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> .  
  
   
  
## Examples  
 El siguiente ejemplo muestra cómo utilizar <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> en un bucle:  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación de anexado asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar el <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> para asegurarse de que la operación de anexado ha finalizado y de que se pueden liberar los recursos de manera adecuada. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar el <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> para asegurarse de que la operación de anexado ha finalizado y de que se pueden liberar los recursos de manera adecuada. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica que utiliza el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar el <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> para asegurarse de que la operación de anexado ha finalizado y de que se pueden liberar los recursos de manera adecuada. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una operación de anexado asincrónica que utiliza el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar el <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> para asegurarse de que la operación de anexado ha finalizado y de que se pueden liberar los recursos de manera adecuada. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El número de secuencia del último registro que se debe escribir. Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, se deben escribir todos los registros.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el vaciado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud particular de vaciado asincrónico de otras.</param>
        <summary>Comienza una operación de vaciado asincrónica, utilizando el espacio previamente reservado en la secuencia. Este método no puede heredarse.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa la operación de vaciado asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult>devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> para asegurarse que la operación de vaciado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se produce un error durante el vaciado asincrónico, no se producirá una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> con el <xref:System.IAsyncResult> devuelto por este método.  
  
 Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.FileRecordSequence> se escriben de manera duradera.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de vaciado asincrónica, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se inician cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.  
  
 <paramref name="sequenceNumber" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">Un error E/S ha ocurrido durante el vaciado de datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una reserva asincrónica y una operación de anexado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una reserva asincrónica y una operación de anexado. Este método no puede heredarse.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica, que podría estar aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar el <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> para asegurarse de que la operación de anexado ha finalizado y de que se pueden liberar los recursos de manera adecuada. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Comienza una reserva asincrónica y una operación de anexado. Este método no puede heredarse.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica, que podría estar aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar el <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> para asegurarse de que la operación de anexado ha finalizado y de que se pueden liberar los recursos de manera adecuada. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia una operación de escritura de área de reinicio asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation">
          <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</param>
        <summary>Comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio reservado previamente en la secuencia. Este método no puede heredarse.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> para asegurarse de que la operación de escritura de área de reinicio ha finalizado y de que se pueden liberar los recursos apropiadamente. Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Cuando la operación se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.  
  
O bien 
Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation">
          <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</param>
        <summary>Comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio reservado previamente en la secuencia. Este método no puede heredarse.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> para asegurarse de que la operación de escritura de área de reinicio ha finalizado y de que se pueden liberar los recursos apropiadamente. Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Cuando la operación se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.  
  
O bien 
Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="fileRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.IO.Log.ReservationCollection" />. Este método no puede heredarse.</summary>
        <returns>Colección <see cref="T:System.IO.Log.ReservationCollection" /> creada recientemente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inmediatamente libera los recursos no administrados utilizados por un objeto.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Un error E/S ha ocurrido durante el vaciado de datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de anexado asincrónica. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de vaciado asincrónica. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que se producen durante una solicitud de vaciado asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una reserva asincrónica y una operación de anexado. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de escritura de área de reinicio asincrónica. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Para esta operación asincrónica ya se ha llamado a <see langword="End" />.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Provoca que los registros anexados se escriban de manera duradera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asegúrese de que todos los registros anexados se han escrito. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.FileRecordSequence> se han escrito de manera duradera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Un error E/S ha ocurrido durante el vaciado de datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El número de secuencia del último registro que se debe escribir. Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</param>
        <summary>Asegúrese de que todos los registros anexados se han escrito. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método garantiza que todos los registros con números de secuencia hasta el especificado, incluido éste, se han escrito de manera duradera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> no está entre la base y últimos números de secuencia de esta secuencia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.IO.IOException">Un error E/S ha ocurrido durante el vaciado de datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia que es mayor que el último registro anexado.</summary>
        <value>Un número de secuencia que es mayor que el último registro anexado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contiene un número de secuencia con la garantía de ser mayor que el número de secuencia del último registro anexado. Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. El resto de números de secuencia no son válidos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño del mayor registro que se puede anexar a o leerse desde esta secuencia, en bytes.</summary>
        <value>El tamaño del registro más grande que se puede anexar a o que puede leerse de esta secuencia, en bytes.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">El número de secuencia del primer registro donde la lectura se inicia.</param>
        <param name="logRecordEnum">Un valor <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> válido que especifica la manera (es decir, hacia adelante o hacia atrás) en la que los registros se deberían leer de <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Devuelve una colección enumerable de registros en la secuencia. Este método no puede heredarse.</summary>
        <returns>Una colección enumerable de registros en la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una colección enumerable de registros en la secuencia. El orden de los registros enumerados depende del valor del parámetro `logRecordEnum`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo se puede utilizar este método para leer los registros en una secuencia del registro.  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo escritura.</exception>
        <exception cref="T:System.IO.IOException">La secuencia de registro está dañada.  
  
O bien 
El registro se escribió con una versión incompatible de la secuencia de registro.</exception>
        <exception cref="T:System.InvalidOperationException">La enumeración ha finalizado.  
  
O bien 
La enumeración no se ha iniciado. Se debe realizar una llamada a <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección enumerable de las áreas de reinicio de la secuencia. Este método no puede heredarse.</summary>
        <returns>Una colección enumerable de las áreas de reinicio en la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las áreas de reinicio se enumeran en orden inverso del número de secuencia, es decir, del número de secuencia superior al número de secuencia más bajo. Sólo se enumeran las áreas de reinicio con números de secuencia entre el último número de secuencia y el número de secuencia base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de sólo escritura.</exception>
        <exception cref="T:System.IO.IOException">La secuencia de registro está dañada.  
  
O bien 
El registro se escribió con una versión incompatible de la secuencia de registro.</exception>
        <exception cref="T:System.InvalidOperationException">La enumeración ha finalizado.  
  
O bien 
La enumeración no se ha iniciado. Se debe realizar una llamada a <see cref="M:System.Collections.IEnumerator.MoveNext" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza automáticamente una reserva única y anexa un registro a la secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">
          <see cref="T:System.IO.Log.ReservationCollection" /> en el que se contiene la colección para realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <summary>Realiza automáticamente una reserva única y anexa un registro a la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <summary>Realiza automáticamente una reserva única y anexa un registro a la secuencia. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.FileRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios argumentos están fuera del intervalo.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se pudo realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número total de bytes que se ha reservado.</summary>
        <value>El tamaño total de todas las reservas realizadas en esta secuencia del registro.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia del área de reinicio recientemente escrita.</summary>
        <value>El número de secuencia del área de reinicio recientemente escrita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los anexos se reintentan automáticamente en caso de que el registro esté completo.</summary>
        <value>
          <see langword="true" /> si las operaciones de anexado se reintentan automáticamente cuando el registro esté lleno; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de esta propiedad es `true`, y una llamada <xref:System.IO.Log.FileRecordSequence.Append%2A> no puede realizarse porque no hay espacio suficiente en la secuencia, la secuencia de registro intentará liberar espacio y volverá a intentar anexarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.FileRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la secuencia del registro determina que se debe avanzar la cola. Este método no puede heredarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede desencadenar este evento cuando la secuencia del registro se haya quedado sin espacio. Cuando se desencadena este evento, la cola de la secuencia (es decir, el número de secuencia base) avanza para liberar espacio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.  
  
O bien 
Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.  
  
O bien 
Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.  
  
O bien 
Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSeqNum">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <summary>Escribe una área de reinicio en <see cref="T:System.IO.Log.FileRecordSequence" />. Este método no puede heredarse.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se puede usar para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede leer un área de reinicio y recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios argumentos tienen el valor <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> no está entre la base y últimos números de secuencia de esta secuencia.  
  
O bien 
Una cola de archivo nueva o existente o la base del registro activo no son válidas.</exception>
        <exception cref="T:System.ArgumentException">Esta secuencia del registro no creó <paramref name="reservations" />.  
  
O bien 
 <paramref name="newBaseSeqNum" /> no es válido para esta secuencia.</exception>
        <exception cref="T:System.NotSupportedException">La operación no se puede realizar porque la secuencia del registro se abrió con acceso de solo lectura.</exception>
        <exception cref="T:System.IO.IOException">La solicitud no se puede realizar debido a una excepción de E/S inesperada.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay bastante memoria para continuar la ejecución del programa.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No se puede encontrar en <paramref name="data" /> ninguna reserva lo suficientemente grande para ajustar <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>