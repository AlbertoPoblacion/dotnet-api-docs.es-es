<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="55071e6e771f10cc96e2985b37bd85ac9623b58a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="eb8ef-101">Proporciona una interfaz genérica a una secuencia de registros.</span>
      <span class="sxs-lookup">
        <span data-stu-id="eb8ef-101">Provides a generic interface to a sequence of records.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-102">La interfaz <xref:System.IO.Log.IRecordSequence> proporciona una interfaz abstracta a una secuencia orientada a registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-102">The <xref:System.IO.Log.IRecordSequence> interface provides an abstract interface to a record-oriented stream.</span></span> <span data-ttu-id="eb8ef-103">Una instancia <xref:System.IO.Log.IRecordSequence> se puede utilizar para leer y escribir las entradas de registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-103">A <xref:System.IO.Log.IRecordSequence> instance can be used to read and write log records.</span></span>  
  
 <span data-ttu-id="eb8ef-104">La interfaz <xref:System.IO.Log.IRecordSequence> proporciona las siguientes capacidades:</span><span class="sxs-lookup"><span data-stu-id="eb8ef-104">The <xref:System.IO.Log.IRecordSequence> interface provides the following capabilities,</span></span>  
  
-   <span data-ttu-id="eb8ef-105">Anexe entradas de registro mediante los métodos <xref:System.IO.Log.IRecordSequence.Append%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-105">Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods.</span></span>  
  
-   <span data-ttu-id="eb8ef-106">Lea los registros anexados mediante el método <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-106">Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
-   <span data-ttu-id="eb8ef-107">Escriba un registro del reinicio especial mediante el método <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-107">Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
-   <span data-ttu-id="eb8ef-108">Lea los registros del reinicio del registro del reinicio recientemente escrito utilizando el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-108">Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
-   <span data-ttu-id="eb8ef-109">Vacíe los registros al almacén duradero utilizando el método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-109">Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
-   <span data-ttu-id="eb8ef-110">Reserve el espacio para anexar los registros.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-110">Reserve space for appending records.</span></span>  
  
-   <span data-ttu-id="eb8ef-111">Espacio del registro libre al avanzar la base del registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-111">Free log space by advancing the base of the log.</span></span>  
  
-   <span data-ttu-id="eb8ef-112">Reciba las notificaciones de eventos <xref:System.IO.Log.IRecordSequence.TailPinned> para mover la base del registro al espacio disponible.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-112">Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space.</span></span>  
  
 <span data-ttu-id="eb8ef-113">Las entradas de registro se anexan a una instancia <xref:System.IO.Log.IRecordSequence> y a cada entrada de registro se le proporciona un número de secuencia único.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-113">Log records are appended to a <xref:System.IO.Log.IRecordSequence> instance, and each log record is given a unique sequence number.</span></span> <span data-ttu-id="eb8ef-114">Los números de la secuencia son estricta y monótonamente crecientes dentro de una secuencia de registros determinada.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-114">Sequence numbers are strictly monotonically increasing within a given record sequence.</span></span> <span data-ttu-id="eb8ef-115">Una entrada de registro está compuesta de datos opacos, que se proporcionan a la instancia de <xref:System.IO.Log.IRecordSequence> en una <xref:System.Collections.IList> de ArraySegments de bytes.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-115">A log record consists of opaque data, supplied to the <xref:System.IO.Log.IRecordSequence> instance in an <xref:System.Collections.IList> of ArraySegments of bytes.</span></span>  
  
 <span data-ttu-id="eb8ef-116">La interfaz <xref:System.IO.Log.IRecordSequence> también expone algunas propiedades básicas que proporcionan información sobre los límites del registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-116">The <xref:System.IO.Log.IRecordSequence> interface also exposes a few basic properties which provides information about log boundaries.</span></span>  
  
-   <span data-ttu-id="eb8ef-117">La propiedad <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> contiene el número de secuencia del primer registro válido en la secuencia del registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-117">The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence.</span></span>  
  
-   <span data-ttu-id="eb8ef-118">La propiedad <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> contiene un número de secuencia que se garantiza para ser mayor que el número de secuencia del último registro anexado.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-118">The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span>  
  
-   <span data-ttu-id="eb8ef-119">La propiedad <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> contiene el número de secuencia del último área de reinicio escrita.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-119">The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area.</span></span>  
  
-   <span data-ttu-id="eb8ef-120">La propiedad <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> contiene el tamaño del mayor registro al que se puede anexar o lee de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-120">The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence.</span></span>  
  
-   <span data-ttu-id="eb8ef-121">La propiedad <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> contiene el tamaño total de todas las reservas realizadas en esta secuencia del registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-121">The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence.</span></span>  
  
-   <span data-ttu-id="eb8ef-122">Si la propiedad <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> está establecida en `true`, y una operación <xref:System.IO.Log.IRecordSequence.Append%2A> no puede realizarse porque no hay ningún espacio en la secuencia, la secuencia del registro intentará liberar espacio y reintentará la operación de anexado.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-122">If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-123">El nuevo número de secuencia base de la secuencia del registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-123">The new base sequence number of the record sequence.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-124">Avanza el número de secuencia base del registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-124">Moves the base sequence number of the log forward.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-125">Al utilizar una instancia <xref:System.IO.Log.LogRecordSequence> e intentar avanzar el número de secuencia para liberar espacio en el registro, el nuevo número de secuencia base debe residir en una extensión del registro diferente para que la extensión anterior se marque como vacía.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-125">When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty.</span></span> <span data-ttu-id="eb8ef-126">No permite liberar parcialmente las extensiones.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-126">Freeing extents partially is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-127">
            <paramref name="newBaseSequenceNumber" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-127">
              <paramref name="newBaseSequenceNumber" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="eb8ef-128">
            <paramref name="newBaseSequenceNumber" /> no está activo en el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-128">
              <paramref name="newBaseSequenceNumber" /> is not active in the log.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-129">Se ha producido un error de E/S al modificar la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-129">An I/O error occurred while modifying the sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-130">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-130">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-131">La secuencia del registro está completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-131">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-132">Cuando se invalida en una clase derivada, escribe una entrada de registro en <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-132">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-133">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-133">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-134">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-134">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-135">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-135">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-136">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-136">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-137">Cuando se invalida en una clase derivada, escribe una entrada de registro en <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-137">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-138">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-138">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-139">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-139">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-140">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-140">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-141">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-141">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-142">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-142">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-143">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-143">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-144">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-144">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-145">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-145">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-146">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-146">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-147">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-147">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-148">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-148">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-149">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-149">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-150">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-150">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-151">Cuando se invalida en una clase derivada, anexa una entrada de registro en <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-151">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-152">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-152">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-153">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-153">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-154">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-154">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-155">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-155">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-156">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-156">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-157">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-157">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-158">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-158">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-159">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-159">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-160">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-160">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-161">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-161">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-162">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-162">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-163">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-163">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-164">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-164">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-165">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-165">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-166">Cuando se invalida en una clase derivada, anexa una entrada de registro a <see cref="T:System.IO.Log.IRecordSequence" />, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-166">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-167">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-167">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-168">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-168">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-169">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-169">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-170">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-170">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="eb8ef-171">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-171">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-172">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-172">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-173">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-173">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-174">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-174">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-175">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-175">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-176">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-176">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-177">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-177">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-178">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-178">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-179">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-179">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-180">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-180">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-181">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-181">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-182">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-182">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-183">Cuando se invalida en una clase derivada, anexa una entrada de registro a <see cref="T:System.IO.Log.IRecordSequence" />, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-183">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-184">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-184">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-185">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-185">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-186">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-186">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-187">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-187">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="eb8ef-188">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-188">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-189">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-189">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-190">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-190">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-191">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-191">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-192">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-192">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-193">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-193">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-194">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-194">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-195">Cuando se invalida en una clase derivada, obtiene el número de secuencia del primer registro válido en el <see cref="T:System.IO.Log.IRecordSequence" />actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-195">When overridden in a derived class, gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eb8ef-196">El número de secuencia más bajo que corresponde a un registro válido en <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-196">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-197">Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-197">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="eb8ef-198">El valor de esta propiedad se puede modificar llamando a <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> o al método <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> .</span><span class="sxs-lookup"><span data-stu-id="eb8ef-198">The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-199">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-199">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-200">Cuando se invalida en una clase derivada, comienza una operación de anexo asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-200">When overridden in a derived class, begins an asynchronous append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-201">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-201">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-202">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-202">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-203">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-203">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-204">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-204">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-205">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-205">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-206">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-206">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-207">Cuando se invalida en una clase derivada, comienza una operación de anexo asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-207">When overridden in a derived class, begins an asynchronous append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-208">Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-208">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-209">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-209">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-210">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-210">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-211">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-211">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-212">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-212">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-213">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-213">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-214">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-214">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-215">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-215">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-216">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-216">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-217">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-217">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-218">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-218">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-219">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-219">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-220">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-220">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-221">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-221">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-222">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-222">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-223">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-223">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-224">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-224">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-225">Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-225">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-226">Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-226">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-227">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-227">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-228">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-228">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-229">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-229">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-230">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-230">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-231">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-231">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-232">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-232">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-233">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-233">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-234">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-234">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-235">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-235">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-236">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-236">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-237">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-237">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-238">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-238">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-239">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-239">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-240">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-240">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-241">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-241">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-242">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-242">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-243">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-243">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-244">Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-244">When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-245">Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-245">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-246">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-246">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-247">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-247">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-248">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-248">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-249">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-249">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-250">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-250">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="eb8ef-251">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-251">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-252">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-252">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-253">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-253">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-254">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-254">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-255">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-255">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-256">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-256">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-257">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-257">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-258">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-258">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-259">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-259">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousUndoRecord">
          <span data-ttu-id="eb8ef-260">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-260">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-261">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-261">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-262">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-262">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-263">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-263">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-264">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-264">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-265">Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-265">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-266">Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-266">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-267">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-267">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-268">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-268">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-269">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-269">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-270">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-270">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-271">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-271">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="eb8ef-272">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-272">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-273">Normalmente, este método se completa antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-273">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="eb8ef-274">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-274">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-275">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-275">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-276">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-276">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-277">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-277">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-278">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-278">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="eb8ef-279">El número de secuencia del último registro que se debe escribir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-279">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="eb8ef-280">Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-280">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-281">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el vaciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-281">An optional asynchronous callback, to be called when the flush is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-282">Objeto proporcionado por el usuario que distingue esta solicitud particular de vaciado asincrónico de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-282">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-283">Cuando se invalida en una clase derivada, comienza una operación de vaciado asincrónica, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-283">When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-284">Un <see cref="T:System.IAsyncResult" /> que representa la operación de vaciado asincrónica que puede seguir pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-284">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-285">Debería pasar <xref:System.IAsyncResult>devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndFlush%2A> para asegurarse que la operación de vaciado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-285">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="eb8ef-286">Si se produce un error durante el vaciado asincrónico, no se producirá una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndFlush%2A> con el <xref:System.IAsyncResult> devuelto por este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-286">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-287">Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.IRecordSequence> se escriben de manera duradera.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-287">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="eb8ef-288">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-288">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-289">Los errores que se produjeron durante una solicitud de vaciado asincrónica, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se inician cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-289">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-290">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-290">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-291">Un error E/S ha ocurrido durante el vaciado de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-291">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-292">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-292">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-293">Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-293">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-294">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-294">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-295">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-295">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-296">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-296">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-297">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-297">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="eb8ef-298">La colección de reservas en la que realizar las reservas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-298">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-299">Las reservas que se han de realizar, en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-299">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-300">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-300">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-301">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-301">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-302">Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-302">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-303">Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica, que podría estar aún pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-303">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-304">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-304">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-305">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-305">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-306">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-306">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-307">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-307">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-308">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-308">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="eb8ef-309">Si no se produce el anexado, no se reserva ningún espacio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-309">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="eb8ef-310">Normalmente, este método puede completarse antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-310">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="eb8ef-311">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-311">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-312">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-312">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-313">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-313">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-314">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-314">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-315">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-315">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-316">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-316">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-317">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-317">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-318">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-318">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-319">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-319">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-320">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-320">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-321">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-321">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="eb8ef-322">La colección de reservas en la que realizar las reservas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-322">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-323">Las reservas que se han de realizar, en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-323">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-324">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-324">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-325">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-325">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-326">Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-326">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-327">Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica, que podría estar aún pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-327">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-328">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-328">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-329">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-329">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-330">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-330">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-331">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-331">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-332">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-332">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="eb8ef-333">Si no se produce el anexado, no se reserva ningún espacio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-333">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="eb8ef-334">Normalmente, este método puede completarse antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-334">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="eb8ef-335">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-335">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-336">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-336">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-337">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-337">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-338">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-338">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-339">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-339">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-340">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-340">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-341">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-341">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-342">Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-342">When overridden in a derived class, begins an asynchronous restart area write operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-343">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-343">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-344">El nuevo número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-344">The new base sequence number.</span>
          </span>
          <span data-ttu-id="eb8ef-345">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-345">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="eb8ef-346">
            <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-346">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-347">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-347">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-348">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-348">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-349">Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-349">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-350">
            <see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-350">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-351">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> para asegurarse de que la operación de escritura de área de reinicio ha finalizado y de que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-351">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-352">Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-352">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-353">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-353">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-354">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-354">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-355">Cuando la operación se completa correctamente, el número de secuencia base se actualiza.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-355">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="eb8ef-356">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-356">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="eb8ef-357">Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-357">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="eb8ef-358">Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-358">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-359">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-359">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-360">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-360">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-361">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-361">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-362">El nuevo número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-362">The new base sequence number.</span>
          </span>
          <span data-ttu-id="eb8ef-363">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-363">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="eb8ef-364">
            <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-364">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="eb8ef-365">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-365">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="eb8ef-366">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-366">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-367">Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio previamente reservado en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-367">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-368">
            <see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-368">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-369">Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-369">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="eb8ef-370">Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-370">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="eb8ef-371">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-371">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-372">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-372">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-373">Cuando la operación se completa correctamente, el número de secuencia base se actualiza.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-373">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="eb8ef-374">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-374">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="eb8ef-375">Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-375">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="eb8ef-376">Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-376">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-377">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-377">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-378">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-378">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-379">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-379">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-380">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-380">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-381">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-381">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-382">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-382">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-383">Cuando se reemplaza en una clase derivada, se crea un nuevo objeto <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-383">When overridden in a derived class, creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-384">Colección <see cref="T:System.IO.Log.ReservationCollection" /> creada recientemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-384">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-385">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-385">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="eb8ef-386">Referencia a la solicitud de E/S asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-386">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-387">Cuando se invalida en una clase derivada, finaliza una operación de anexo asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-387">When overridden in a derived class, ends an asynchronous append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-388">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-388">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-389">Este método se bloquea hasta que se haya completado la operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-389">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="eb8ef-390">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-390">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="eb8ef-391">Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-391">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-392">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-392">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-393">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-393">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="eb8ef-394">Referencia a la solicitud de E/S asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-394">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-395">Cuando se invalida en una clase derivada, finaliza una operación de vaciado asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-395">When overridden in a derived class, ends an asynchronous flush operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-396">Número de secuencia del último registro escrito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-396">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-397">Este método se bloquea hasta que se haya completado la operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-397">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="eb8ef-398">Errores que se producen durante una solicitud de vaciado asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-398">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="eb8ef-399">Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-399">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-400">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-400">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-401">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-401">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="eb8ef-402">Referencia a la solicitud de E/S asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-402">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-403">Cuando se invalida en una clase derivada, finaliza una operación de reserva asincrónica y de anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-403">When overridden in a derived class, ends an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-404">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-404">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-405">Este método se bloquea hasta que se haya completado la operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-405">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="eb8ef-406">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-406">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="eb8ef-407">Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-407">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-408">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-408">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-409">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-409">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="eb8ef-410">Referencia a la solicitud de E/S asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-410">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-411">Cuando se invalida en una clase derivada, finaliza una operación de escritura de área de reinicio asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-411">When overridden in a derived class, ends an asynchronous restart area write operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-412">Número de secuencia del registro de entrada escrito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-412">The sequence number of the written log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-413">Este método se bloquea hasta que se haya completado la operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-413">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="eb8ef-414">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-414">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="eb8ef-415">Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-415">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-416">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-416">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-417">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-417">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-418">Cuando se invalida en una clase derivada, hace que se escriban los registros anexados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-418">When overridden in a derived class, causes appended records to be written.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-419">Cuando se invalida en una clase derivada, asegura que todos los registros anexados se han escrito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-419">When overridden in a derived class, ensures that all appended records have been written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-420">Número de secuencia del último registro escrito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-420">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-421">Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.IRecordSequence> se han escrito de manera duradera.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-421">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-422">Un error E/S ha ocurrido durante el vaciado de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-422">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-423">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-423">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="eb8ef-424">El número de secuencia del último registro que se debe escribir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-424">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="eb8ef-425">Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-425">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-426">Cuando se invalida en una clase derivada, garantiza que todos los registros anexados hasta el registro con el número de secuencia especificado, incluido éste, se han escrito de manera duradera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-426">When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-427">Número de secuencia del último registro escrito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-427">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-428">Llamar a este método garantiza que todos los registros con números de secuencia hasta el especificado, incluido éste, se han escrito de manera duradera.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-428">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-429">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-429">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-430">Un error E/S ha ocurrido durante el vaciado de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-430">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-431">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-431">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-432">Cuando se invalida en una clase derivada, obtiene el número de secuencia que es mayor que el último registro que se anexó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-432">When overridden in a derived class, gets the sequence number which is greater than the last record appended.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eb8ef-433">Un número de secuencia que es mayor que el último registro anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-433">A sequence number which is greater than the last record appended.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-434">Esta propiedad contiene un número de secuencia con la garantía de ser mayor que el número de secuencia del último registro anexado.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-434">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="eb8ef-435">Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-435">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb8ef-436">Al utilizar una instancia <xref:System.IO.Log.LogRecordSequence>, el valor <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> se puede volver anticuado hasta que los registros se vacíen al registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-436">When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log.</span></span> <span data-ttu-id="eb8ef-437">Vea <xref:System.IO.Log.IRecordSequence.Flush%2A> y <xref:System.IO.Log.RecordAppendOptions> para obtener más información sobre cómo vaciar los registros.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-437">See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records..</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-438">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-438">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-439">Cuando se invalida en una clase derivada, obtiene el tamaño del registro más grande que se puede anexar a, o que puede leerse de esta secuencia, en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-439">When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eb8ef-440">El tamaño del registro más grande que se puede anexar a o que puede leerse de esta secuencia, en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-440">The size of the largest record that can be appended to or read from this sequence, in bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-441">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-441">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="eb8ef-442">El número de secuencia del primer registro donde la lectura se inicia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-442">The sequence number of the first record where the reading starts.</span>
          </span>
        </param>
        <param name="logRecordEnum">
          <span data-ttu-id="eb8ef-443">Un valor <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> válido que especifica la manera (es decir, hacia adelante o hacia atrás) en la que los registros se deberían leer de <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-443">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-444">Cuando se invalida en una clase derivada, devuelve una colección enumerable de registros en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-444">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-445">Una colección enumerable de registros en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-445">An enumerable collection of records in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-446">Cuando se invalida en una clase derivada, devuelve una colección enumerable de registros en la secuencia.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-446">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="eb8ef-447">El orden de los registros enumerados depende del valor del parámetro `logRecordEnum`.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-447">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eb8ef-448">Este ejemplo muestra el uso del método <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> .</span><span class="sxs-lookup"><span data-stu-id="eb8ef-448">This sample demonstrates the use of the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-449">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-449">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-450">Ha ocurrido un error de E/S al leer un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-450">An I/O error occurred while reading the record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-451">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-451">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-452">Cuando se invalida en una clase derivada, devuelve una colección enumerable de las áreas de reinicio en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-452">When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-453">Una colección enumerable de las áreas de reinicio en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-453">An enumerable collection of the restart areas in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-454">Las áreas de reinicio se enumeran en orden inverso del número de secuencia, es decir, del número de secuencia superior al número de secuencia más bajo.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-454">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="eb8ef-455">Sólo se enumeran las áreas de reinicio con números de secuencia entre el último número de secuencia y el número de secuencia base.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-455">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eb8ef-456">Si se daña la extensión del registro que contiene <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>, este método puede iniciar <xref:System.IO.IOException> con el mensaje de error que "La solicitud no se pudo realizar debido a una excepción E/S inesperada.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-456">If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message "The request could not be performed because of an unexpected I/O exception.</span></span> <span data-ttu-id="eb8ef-457">Se ha devuelto el siguiente código erróneo: '80070026'".</span><span class="sxs-lookup"><span data-stu-id="eb8ef-457">The following error code was returned: '80070026'".</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-458">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-458">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-459">Ha ocurrido un error de E/S al leer un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-459">An I/O error occurred while reading the record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-460">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-460">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-461">Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-461">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-462">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-462">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-463">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-463">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-464">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-464">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-465">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-465">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="eb8ef-466">
            <see cref="T:System.IO.Log.ReservationCollection" /> en el que se contiene la colección para realizar las reservas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-466">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-467">Las reservas que se han de realizar, en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-467">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-468">Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-468">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-469">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-469">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-470">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-470">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-471">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-471">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-472">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-472">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="eb8ef-473">Si no se produce el anexado, no se reserva ningún espacio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-473">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="eb8ef-474">Normalmente, este método puede completarse antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-474">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="eb8ef-475">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-475">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-476">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-476">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-477">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-477">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-478">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-478">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-479">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-479">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-480">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-480">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="eb8ef-481">El número de secuencia del registro siguiente en el orden especificado por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-481">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="eb8ef-482">El número de secuencia del registro siguiente en orden anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-482">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="eb8ef-483">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-483">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="eb8ef-484">La colección de reservas en la que realizar las reservas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-484">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="eb8ef-485">Las reservas que se han de realizar, en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-485">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-486">Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-486">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-487">Número de secuencia del registro de entrada anexado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-487">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-488">Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-488">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-489">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-489">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="eb8ef-490">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-490">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="eb8ef-491">Si no se produce el anexado, no se reserva ningún espacio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-491">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="eb8ef-492">Normalmente, este método puede completarse antes de que se haya escrito el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-492">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="eb8ef-493">Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-493">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-494">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-494">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-495">Ha ocurrido un error de E/S al anexar un registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-495">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-496">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-496">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-497">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-497">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-498">Cuando se invalida en una clase derivada, obtiene el número total de bytes que se han reservado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-498">When overridden in a derived class, gets the total number of bytes that have been reserved.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eb8ef-499">El tamaño total de todas las reservas realizadas en esta secuencia del registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-499">The total size of all reservations made in this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-500">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-500">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-501">Cuando se invalida en una clase derivada, obtiene el número de secuencia del área de reinicio recientemente escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-501">When overridden in a derived class, gets the sequence number of the most recently written restart area.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eb8ef-502">El número de secuencia del área de reinicio recientemente escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-502">The sequence number of the most recently written restart area.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-503">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-503">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-504">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-504">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-505">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-505">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-506">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-506">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-507">Obtiene o establece un valor que indica si los anexos se reintentan automáticamente en caso de que el registro esté completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-507">Gets or sets a value indicating whether appends are automatically retried if the log is full.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eb8ef-508">
            <see langword="true" /> si las operaciones de anexado se reintentan automáticamente cuando el registro esté lleno; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-508">
              <see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="eb8ef-509">El valor predeterminado es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-509">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-510">Si el valor de esta propiedad es `true`, y una llamada <xref:System.IO.Log.IRecordSequence.Append%2A> no puede realizarse porque no hay espacio suficiente en la secuencia, la secuencia de registro intentará liberar espacio y volverá a intentar anexarse.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-510">If the value of this property is `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-511">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-511">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-512">Se produce cuando la secuencia del registro determina que se debe avanzar la cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-512">Occurs when the record sequence determines that the tail must be moved forward.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-513">Puede desencadenar este evento cuando la secuencia del registro se haya quedado sin espacio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-513">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="eb8ef-514">Cuando se desencadena este evento, la cola de la secuencia (es decir, el número de secuencia base) avanza para liberar espacio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-514">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eb8ef-515">Cuando se invalida en una clase derivada, escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-515">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-516">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-516">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-517">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-517">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-518">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-518">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="eb8ef-519">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-519">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-520">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-520">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-521">Cuando se invalida en una clase derivada, escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-521">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-522">Número de secuencia del área de reinicio escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-522">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-523">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-523">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-524">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-524">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="eb8ef-525">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-525">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-526">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-526">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="eb8ef-527">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-527">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-528">Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-528">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-529">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-529">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-530">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-530">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-531">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-531">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-532">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-532">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-533">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-533">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-534">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-534">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-535">Cuando se invalida en una clase derivada, escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-535">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-536">Número de secuencia del área de reinicio escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-536">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-537">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-537">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-538">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-538">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-539">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-539">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="eb8ef-540">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-540">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-541">Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-541">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-542">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-542">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-543">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-543">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-544">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-544">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-545">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-545">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-546">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-546">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-547">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-547">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-548">El nuevo número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-548">The new base sequence number.</span>
          </span>
          <span data-ttu-id="eb8ef-549">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-549">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-550">Cuando se invalida en una clase derivada, se escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" /> y se actualiza el número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-550">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-551">Número de secuencia del área de reinicio escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-551">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-552">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-552">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-553">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-553">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-554">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-554">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="eb8ef-555">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-555">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-556">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-556">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-557">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-557">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="eb8ef-558">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-558">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="eb8ef-559">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-559">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-560">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-560">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-561">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-561">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-562">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-562">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-563">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-563">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-564">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-564">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-565">El nuevo número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-565">The new base sequence number.</span>
          </span>
          <span data-ttu-id="eb8ef-566">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-566">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-567">Cuando se invalida en una clase derivada, escribe un área de reinicio en <see cref="T:System.IO.Log.IRecordSequence" /> y actualiza el número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-567">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-568">Número de secuencia del área de reinicio escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-568">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-569">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-569">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-570">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-570">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-571">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-571">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="eb8ef-572">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-572">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-573">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-573">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-574">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-574">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="eb8ef-575">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-575">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="eb8ef-576">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-576">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-577">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-577">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-578">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-578">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-579">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-579">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-580">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-580">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-581">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-581">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-582">El nuevo número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-582">The new base sequence number.</span>
          </span>
          <span data-ttu-id="eb8ef-583">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-583">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="eb8ef-584">
            <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-584">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-585">Cuando se invalida en una clase derivada, escribe un área de reinicio en <see cref="T:System.IO.Log.IRecordSequence" /> mediante una reserva, y actualiza el número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-585">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-586">Número de secuencia del área de reinicio escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-586">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-587">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-587">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-588">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-588">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-589">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-589">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="eb8ef-590">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-590">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-591">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-591">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-592">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-592">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="eb8ef-593">Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-593">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="eb8ef-594">Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-594">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-595">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-595">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="eb8ef-596">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-596">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="eb8ef-597">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-597">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-598">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-598">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-599">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-599">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-600">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-600">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-601">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-601">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-602">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-602">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="eb8ef-603">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-603">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="eb8ef-604">El nuevo número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-604">The new base sequence number.</span>
          </span>
          <span data-ttu-id="eb8ef-605">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-605">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="eb8ef-606">
            <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-606">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eb8ef-607">Cuando se invalida en una clase derivada, escribe un área de reinicio en <see cref="T:System.IO.Log.IRecordSequence" /> mediante una reserva y se actualiza el número de secuencia base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-607">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eb8ef-608">Número de secuencia del área de reinicio escrita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-608">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb8ef-609">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-609">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-610">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-610">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="eb8ef-611">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-611">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="eb8ef-612">Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-612">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="eb8ef-613">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-613">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="eb8ef-614">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-614">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="eb8ef-615">Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-615">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="eb8ef-616">Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-616">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="eb8ef-617">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-617">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="eb8ef-618">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-618">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="eb8ef-619">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-619">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="eb8ef-620">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb8ef-620">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eb8ef-621">Uno o varios argumentos no son válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-621">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eb8ef-622">Se produjo un error de E/S al escribir el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-622">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="eb8ef-623">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-623">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eb8ef-624">Se llamó al método una vez eliminada la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eb8ef-624">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>