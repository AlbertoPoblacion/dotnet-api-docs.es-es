<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ffdfe5ac704327420d0d6e8650da73efc0cde964" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57931355" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona una interfaz genérica a una secuencia de registros.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La interfaz <xref:System.IO.Log.IRecordSequence> proporciona una interfaz abstracta a una secuencia orientada a registro. Una instancia <xref:System.IO.Log.IRecordSequence> se puede utilizar para leer y escribir las entradas de registro.  
  
 La interfaz <xref:System.IO.Log.IRecordSequence> proporciona las siguientes capacidades:  
  
-   Anexe entradas de registro mediante los métodos <xref:System.IO.Log.IRecordSequence.Append%2A>.  
  
-   Lea los registros anexados mediante el método <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
-   Escriba un registro del reinicio especial mediante el método <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
-   Lea los registros del reinicio del registro del reinicio recientemente escrito utilizando el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
-   Vacíe los registros al almacén duradero utilizando el método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
-   Reserve el espacio para anexar los registros.  
  
-   Espacio del registro libre al avanzar la base del registro.  
  
-   Reciba las notificaciones de eventos <xref:System.IO.Log.IRecordSequence.TailPinned> para mover la base del registro al espacio disponible.  
  
 Las entradas de registro se anexan a una instancia <xref:System.IO.Log.IRecordSequence> y a cada entrada de registro se le proporciona un número de secuencia único. Los números de la secuencia son estricta y monótonamente crecientes dentro de una secuencia de registros determinada. Una entrada de registro está compuesta de datos opacos, que se proporcionan a la instancia de <xref:System.IO.Log.IRecordSequence> en una <xref:System.Collections.IList> de ArraySegments de bytes.  
  
 La interfaz <xref:System.IO.Log.IRecordSequence> también expone algunas propiedades básicas que proporcionan información sobre los límites del registro.  
  
-   La propiedad <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> contiene el número de secuencia del primer registro válido en la secuencia del registro.  
  
-   La propiedad <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> contiene un número de secuencia que se garantiza para ser mayor que el número de secuencia del último registro anexado.  
  
-   La propiedad <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> contiene el número de secuencia del último área de reinicio escrita.  
  
-   La propiedad <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> contiene el tamaño del mayor registro al que se puede anexar o lee de la secuencia.  
  
-   La propiedad <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> contiene el tamaño total de todas las reservas realizadas en esta secuencia del registro.  
  
-   Si la propiedad <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> está establecida en `true`, y una operación <xref:System.IO.Log.IRecordSequence.Append%2A> no puede realizarse porque no hay ningún espacio en la secuencia, la secuencia del registro intentará liberar espacio y reintentará la operación de anexado.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base de la secuencia del registro.</param>
        <summary>Avanza el número de secuencia base del registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al utilizar una instancia <xref:System.IO.Log.LogRecordSequence> e intentar avanzar el número de secuencia para liberar espacio en el registro, el nuevo número de secuencia base debe residir en una extensión del registro diferente para que la extensión anterior se marque como vacía. No permite liberar parcialmente las extensiones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> no es válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> no está activo en el registro.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al modificar la secuencia.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro está completa.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, escribe una entrada de registro en <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <summary>Cuando se invalida en una clase derivada, escribe una entrada de registro en <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <summary>Cuando se invalida en una clase derivada, anexa una entrada de registro en <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <summary>Cuando se invalida en una clase derivada, anexa una entrada de registro a <see cref="T:System.IO.Log.IRecordSequence" />, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <summary>Cuando se invalida en una clase derivada, anexa una entrada de registro a <see cref="T:System.IO.Log.IRecordSequence" />, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el número de secuencia del primer registro válido en el <see cref="T:System.IO.Log.IRecordSequence" />actual.</summary>
        <value>El número de secuencia más bajo que corresponde a un registro válido en <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 El valor de esta propiedad se puede modificar llamando a <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> o al método <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de anexo asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de anexo asincrónica.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousUndoRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservations">Una <see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este registro.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el anexado asincrónico, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro `reservations`. Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.  
  
 Normalmente, este método se completa antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El número de secuencia del último registro que se debe escribir. Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el vaciado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud particular de vaciado asincrónico de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de vaciado asincrónica, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa la operación de vaciado asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult>devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndFlush%2A> para asegurarse que la operación de vaciado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se produce un error durante el vaciado asincrónico, no se producirá una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndFlush%2A> con el <xref:System.IAsyncResult> devuelto por este método.  
  
 Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.IRecordSequence> se escriben de manera duradera.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de vaciado asincrónica, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se inician cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al vaciar los datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> que representa esta operación asincrónica que puede seguir pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente. Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> para asegurarse de que la operación de escritura de área de reinicio ha finalizado y de que se pueden liberar los recursos apropiadamente. Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Cuando la operación se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio previamente reservado en la secuencia.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debería pasar <xref:System.IAsyncResult> devuelto por este método al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente. Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> con el <xref:System.IAsyncResult> que devuelve este método.  
  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Cuando la operación se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si se especifica una <xref:System.IO.Log.ReservationCollection>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, se crea un nuevo objeto <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>Colección <see cref="T:System.IO.Log.ReservationCollection" /> creada recientemente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Cuando se invalida en una clase derivada, finaliza una operación de anexo asincrónica.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndAppend%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Cuando se invalida en una clase derivada, finaliza una operación de vaciado asincrónica.</summary>
        <returns>El número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que se producen durante una solicitud de vaciado asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndFlush%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Cuando se invalida en una clase derivada, finaliza una operación de reserva asincrónica y de anexado.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Cuando se invalida en una clase derivada, finaliza una operación de escritura de área de reinicio asincrónica.</summary>
        <returns>Número de secuencia del registro de entrada escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se haya completado la operación de E/S. Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>.  
  
 Se debe llamar a este método exactamente una vez en <xref:System.IAsyncResult> devuelto por el método <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, hace que se escriban los registros anexados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, asegura que todos los registros anexados se han escrito.</summary>
        <returns>El número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método asegura que todos los registros anexados a <xref:System.IO.Log.IRecordSequence> se han escrito de manera duradera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al vaciar los datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">El número de secuencia del último registro que se debe escribir. Si <see cref="T:System.IO.Log.SequenceNumber" /> no es válido, a continuación, se deben escribir todos los registros.</param>
        <summary>Cuando se invalida en una clase derivada, garantiza que todos los registros anexados hasta el registro con el número de secuencia especificado, incluido éste, se han escrito de manera duradera.</summary>
        <returns>El número de secuencia del último registro escrito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método garantiza que todos los registros con números de secuencia hasta el especificado, incluido éste, se han escrito de manera duradera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al vaciar los datos.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el número de secuencia que es mayor que el último registro que se anexó.</summary>
        <value>Un número de secuencia que es mayor que el último registro anexado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contiene un número de secuencia con la garantía de ser mayor que el número de secuencia del último registro anexado. Los números de secuencia válidos son mayores que o iguales a <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> y menores que <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  Al utilizar una instancia <xref:System.IO.Log.LogRecordSequence>, el valor <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> se puede volver anticuado hasta que los registros se vacíen al registro. Consulte <xref:System.IO.Log.IRecordSequence.Flush%2A> y <xref:System.IO.Log.RecordAppendOptions> para obtener más información sobre cómo vaciar los registros. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el tamaño del registro más grande que se puede anexar a, o que puede leerse de esta secuencia, en bytes.</summary>
        <value>El tamaño del registro más grande que se puede anexar a o que puede leerse de esta secuencia, en bytes.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">El número de secuencia del primer registro donde la lectura se inicia.</param>
        <param name="logRecordEnum">Un valor <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> válido que especifica la manera (es decir, hacia adelante o hacia atrás) en la que los registros se deberían leer de <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Cuando se invalida en una clase derivada, devuelve una colección enumerable de registros en la secuencia.</summary>
        <returns>Una colección enumerable de registros en la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se invalida en una clase derivada, devuelve una colección enumerable de registros en la secuencia. El orden de los registros enumerados depende del valor del parámetro `logRecordEnum`.  
  
   
  
## Examples  
 Este ejemplo muestra el uso del método <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> .  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al leer un registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, devuelve una colección enumerable de las áreas de reinicio en la secuencia.</summary>
        <returns>Una colección enumerable de las áreas de reinicio de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las áreas de reinicio se enumeran en orden inverso del número de secuencia, es decir, del número de secuencia superior al número de secuencia más bajo. Sólo se enumeran las áreas de reinicio con números de secuencia entre el último número de secuencia y el número de secuencia base.  
  
> [!NOTE]
>  Si se daña la extensión del registro que contiene <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>, este método puede iniciar <xref:System.IO.IOException> con el mensaje de error que "La solicitud no se pudo realizar debido a una excepción E/S inesperada. Se devolvió el código de error siguiente: '80070026'".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al leer un registro.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection"><see cref="T:System.IO.Log.ReservationCollection" /> en el que se contiene la colección para realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <summary>Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="nextUndoRecord">El número de secuencia del registro siguiente en el orden especificado por el usuario.</param>
        <param name="previousRecord">El número de secuencia del registro siguiente en orden anterior.</param>
        <param name="recordAppendOptions">Un valor válido de <see cref="T:System.IO.Log.RecordAppendOptions" /> que especifica cómo se deberían escribir los datos.</param>
        <param name="reservationCollection">La colección de reservas en la que realizar las reservas.</param>
        <param name="reservations">Las reservas que se han de realizar, en bytes.</param>
        <summary>Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</summary>
        <returns>Número de secuencia del registro de entrada anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos contenidos en el parámetro `data` se concatenarán en una matriz de bytes única para anexarlos como el registro. Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.  
  
 Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro. Si no se produce el anexado, no se reserva ningún espacio.  
  
 Normalmente, este método puede completarse antes de que se haya escrito el registro. Para asegurarse de que se ha escrito un registro, especifique la marca <xref:System.IO.Log.RecordAppendOptions.ForceFlush> utilizando el parámetro `recordAppendOptions` o llame al método <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Ha ocurrido un error de E/S al anexar un registro.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el número total de bytes que se han reservado.</summary>
        <value>El tamaño total de todas las reservas realizadas en esta secuencia del registro.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el número de secuencia del área de reinicio recientemente escrita.</summary>
        <value>El número de secuencia del área de reinicio recientemente escrita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los anexos se reintentan automáticamente en caso de que el registro esté completo.</summary>
        <value><see langword="true" /> si las operaciones de anexado se reintentan automáticamente cuando el registro esté lleno; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de esta propiedad es `true`, y una llamada <xref:System.IO.Log.IRecordSequence.Append%2A> no puede realizarse porque no hay espacio suficiente en la secuencia, la secuencia de registro intentará liberar espacio y volverá a intentar anexarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la secuencia del registro determina que se debe avanzar la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede desencadenar este evento cuando la secuencia del registro se haya quedado sin espacio. Cuando se desencadena este evento, la cola de la secuencia (es decir, el número de secuencia base) avanza para liberar espacio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación. Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible. Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.  
  
 Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación. Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <summary>Cuando se invalida en una clase derivada, se escribe un área de reinicio a<see cref="T:System.IO.Log.IRecordSequence" /> y se actualiza el número de secuencia base.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación. Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un área de reinicio en <see cref="T:System.IO.Log.IRecordSequence" /> y actualiza el número de secuencia base.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación. Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un área de reinicio en <see cref="T:System.IO.Log.IRecordSequence" /> mediante una reserva, y actualiza el número de secuencia base.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación. Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</param>
        <param name="newBaseSequenceNumber">El nuevo número de secuencia base. El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> que contiene la reserva que se debería utilizar para este área de reinicio.</param>
        <summary>Cuando se invalida en una clase derivada, escribe un área de reinicio en <see cref="T:System.IO.Log.IRecordSequence" /> mediante una reserva y se actualiza el número de secuencia base.</summary>
        <returns>Número de secuencia del área de reinicio escrita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente. Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control. Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación. Un área de reinicio puede leerse mediante el método <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro. No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.  
  
 Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección. Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.  
  
 Cuando el método se completa correctamente, el número de secuencia base se actualiza. Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.  
  
 Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación. Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o varios argumentos no son válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al escribir el área de reinicio.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La secuencia de registro no pudo liberar espacio suficiente para contener la nueva área de reinicio.</exception>
        <exception cref="T:System.ObjectDisposedException">Se llamó al método una vez eliminada la secuencia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>