<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IRecordSequence.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac555071e6e771f10cc96e2985b37bd85ac9623b58a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">55071e6e771f10cc96e2985b37bd85ac9623b58a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>Provides a generic interface to a sequence of records.</source>
          <target state="translated">Proporciona una interfaz genérica a una secuencia de registros.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> interface provides an abstract interface to a record-oriented stream.</source>
          <target state="translated">La interfaz <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> proporciona una interfaz abstracta a una secuencia orientada a registro.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>A <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> instance can be used to read and write log records.</source>
          <target state="translated">Una instancia <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> se puede utilizar para leer y escribir las entradas de registro.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> interface provides the following capabilities,</source>
          <target state="translated">La interfaz <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> proporciona las siguientes capacidades:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Append log records using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt;</ph> methods.</source>
          <target state="translated">Anexe entradas de registro mediante los métodos <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Read the appended records using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A&gt;</ph> method.</source>
          <target state="translated">Lea los registros anexados mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Write a special restart record using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A&gt;</ph> method.</source>
          <target state="translated">Escriba un registro del reinicio especial mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Read restart records from the most recently written restart record using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Lea los registros del reinicio del registro del reinicio recientemente escrito utilizando el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Flush the records to durable store using the  <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Vacíe los registros al almacén duradero utilizando el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Reserve space for appending records.</source>
          <target state="translated">Reserve el espacio para anexar los registros.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Free log space by advancing the base of the log.</source>
          <target state="translated">Espacio del registro libre al avanzar la base del registro.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Receive <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.TailPinned&gt;</ph> event notifications to move the base of the log to free space.</source>
          <target state="translated">Reciba las notificaciones de eventos <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.TailPinned&gt;</ph> para mover la base del registro al espacio disponible.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Log records are appended to a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> instance, and each log record is given a unique sequence number.</source>
          <target state="translated">Las entradas de registro se anexan a una instancia <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> y a cada entrada de registro se le proporciona un número de secuencia único.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>Sequence numbers are strictly monotonically increasing within a given record sequence.</source>
          <target state="translated">Los números de la secuencia son estricta y monótonamente crecientes dentro de una secuencia de registros determinada.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>A log record consists of opaque data, supplied to the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> instance in an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> of ArraySegments of bytes.</source>
          <target state="translated">Una entrada de registro está compuesta de datos opacos, que se proporcionan a la instancia de <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> en una <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> de ArraySegments de bytes.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> interface also exposes a few basic properties which provides information about log boundaries.</source>
          <target state="translated">La interfaz <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> también expone algunas propiedades básicas que proporcionan información sobre los límites del registro.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> property contains the sequence number of the first valid record in the record sequence.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> contiene el número de secuencia del primer registro válido en la secuencia del registro.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;</ph> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;</ph> contiene un número de secuencia que se garantiza para ser mayor que el número de secuencia del último registro anexado.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A&gt;</ph> property contains the sequence number of the last written restart area.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A&gt;</ph> contiene el número de secuencia del último área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A&gt;</ph> property contains the size of the largest record that can be appended to, or read from the sequence.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A&gt;</ph> contiene el tamaño del mayor registro al que se puede anexar o lee de la secuencia.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReservedBytes%2A&gt;</ph> property contains the total size of all reservations made in this record sequence.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReservedBytes%2A&gt;</ph> contiene el tamaño total de todas las reservas realizadas en esta secuencia del registro.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>If the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.RetryAppend%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph>, and an <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt;</ph> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.</source>
          <target state="translated">Si la propiedad <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.RetryAppend%2A&gt;</ph> está establecida en <ph id="ph2">`true`</ph>, y una operación <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt;</ph> no puede realizarse porque no hay ningún espacio en la secuencia, la secuencia del registro intentará liberar espacio y reintentará la operación de anexado.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The new base sequence number of the record sequence.</source>
          <target state="translated">El nuevo número de secuencia base de la secuencia del registro.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Moves the base sequence number of the log forward.</source>
          <target state="translated">Avanza el número de secuencia base del registro.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>When you use a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty.</source>
          <target state="translated">Al utilizar una instancia <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> e intentar avanzar el número de secuencia para liberar espacio en el registro, el nuevo número de secuencia base debe residir en una extensión del registro diferente para que la extensión anterior se marque como vacía.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Freeing extents partially is not supported.</source>
          <target state="translated">No permite liberar parcialmente las extensiones.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not active in the log.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> no está activo en el registro.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while modifying the sequence.</source>
          <target state="translated">Se ha producido un error de E/S al modificar la secuencia.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">La secuencia del registro está completa.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe una entrada de registro en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>When overridden in a derived class, writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe una entrada de registro en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>When overridden in a derived class, appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, anexa una entrada de registro en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>When overridden in a derived class, appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, anexa una entrada de registro a <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>When overridden in a derived class, appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, anexa una entrada de registro a <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.BaseSequenceNumber">
          <source>When overridden in a derived class, gets the sequence number of the first valid record in the current <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el número de secuencia del primer registro válido en el <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>actual.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.BaseSequenceNumber">
          <source>The lowest sequence number that corresponds to a valid record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">El número de secuencia más bajo que corresponde a un registro válido en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.BaseSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">Los números de secuencia válidos son mayores que o iguales a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> y menores que <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.BaseSequenceNumber">
          <source>The value of this property can be changed by calling the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A&gt;</ph> method.</source>
          <target state="translated">El valor de esta propiedad se puede modificar llamando a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> o al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.BaseSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, begins an asynchronous append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de anexo asincrónica.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de anexo asincrónica.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este registro.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de anexado asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa el anexado asincrónico, que puede hallarse aún pendiente.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">El registro anexado utilizará el espacio que se ha reservado previamente, utilizando una reserva especificada por el parámetro <ph id="ph1">`reservations`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">Si el anexado tiene éxito, utilizará el área de reserva menor posible que pueda contener los datos y esa área de reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">Normalmente, este método se completa antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">El número de secuencia del último registro que se debe escribir.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">Si <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> no es válido, a continuación, se deben escribir todos los registros.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the flush is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el vaciado.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous flush request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud particular de vaciado asincrónico de otras.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de vaciado asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous flush operation, which could still be pending.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa la operación de vaciado asincrónica que puede seguir pendiente.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the current method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph> method to ensure that the flush completes and resources are freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph> para asegurarse que la operación de vaciado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If an error occurs during an asynchronous flush, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se produce un error durante el vaciado asincrónico, no se producirá una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> are durably written.</source>
          <target state="translated">Llamar a este método asegura que todos los registros anexados a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> se escriben de manera duradera.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de vaciado asincrónica, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se inician cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">Un error E/S ha ocurrido durante el vaciado de datos.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, begins an asynchronous reserve and append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">La colección de reservas en la que realizar las reservas.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous reserve and append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa esta operación asincrónica, que podría estar aún pendiente.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">La colección de reservas en la que realizar las reservas.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado el anexado.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de anexado asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous reserve and append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de reserva asincrónica y de anexado.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa esta operación asincrónica, que podría estar aún pendiente.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> para asegurarse que la operación de anexado ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se ha producido un error durante el anexado asincrónico, no se produce una excepción hasta que se llame al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, begins an asynchronous restart area write operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> method, to assure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> para asegurarse de que la operación de escritura de área de reinicio ha finalizado y de que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando la operación se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura del área de reinicio.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de área de reinicio asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, comienza una operación de escritura de área de reinicio asincrónica, utilizando el espacio previamente reservado en la secuencia.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa la operación de escritura de área de reinicio asincrónica, que todavía podría estar pendiente.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">Debería pasar <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por este método al método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> para asegurarse que la operación de escritura de área de reinicio ha finalizado y que se pueden liberar los recursos apropiadamente.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">Si se produce un error durante la escritura asincrónica, no se producirá una excepción hasta que se llame a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> con el <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> que devuelve este método.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando la operación se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>, el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la reserva de menor tamaño que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.CreateReservationCollection">
          <source>When overridden in a derived class, creates a new <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">Cuando se reemplaza en una clase derivada, se crea un nuevo objeto <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.CreateReservationCollection">
          <source>The newly created <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">Colección <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> creada recientemente.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.CreateReservationCollection">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>When overridden in a derived class, ends an asynchronous append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, finaliza una operación de anexo asincrónica.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginAppend%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>When overridden in a derived class, ends an asynchronous flush operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, finaliza una operación de vaciado asincrónica.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">Número de secuencia del último registro escrito.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que se producen durante una solicitud de vaciado asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginFlush%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginFlush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>When overridden in a derived class, ends an asynchronous reserve and append operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, finaliza una operación de reserva asincrónica y de anexado.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">Referencia a la solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>When overridden in a derived class, ends an asynchronous restart area write operation.</source>
          <target state="translated">Cuando se invalida en una clase derivada, finaliza una operación de escritura de área de reinicio asincrónica.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The sequence number of the written log record.</source>
          <target state="translated">Número de secuencia del registro de entrada escrito.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">Este método se bloquea hasta que se haya completado la operación de E/S.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph> is called.</source>
          <target state="translated">Errores que producen durante una solicitud de lectura asincrónica, como un error de disco durante la petición de E/S, se vuelve visible cuando se llama <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A&gt;</ph> method.</source>
          <target state="translated">Se debe llamar a este método exactamente una vez en <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> devuelto por el método <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, causes appended records to be written.</source>
          <target state="translated">Cuando se invalida en una clase derivada, hace que se escriban los registros anexados.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush">
          <source>When overridden in a derived class, ensures that all appended records have been written.</source>
          <target state="translated">Cuando se invalida en una clase derivada, asegura que todos los registros anexados se han escrito.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush">
          <source>The sequence number of the last record written.</source>
          <target state="translated">Número de secuencia del último registro escrito.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Flush">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> have been durably written.</source>
          <target state="translated">Llamar a este método asegura que todos los registros anexados a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence&gt;</ph> se han escrito de manera duradera.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">Un error E/S ha ocurrido durante el vaciado de datos.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">El número de secuencia del último registro que se debe escribir.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">Si <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> no es válido, a continuación, se deben escribir todos los registros.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.</source>
          <target state="translated">Cuando se invalida en una clase derivada, garantiza que todos los registros anexados hasta el registro con el número de secuencia especificado, incluido éste, se han escrito de manera duradera.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">Número de secuencia del último registro escrito.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</source>
          <target state="translated">Llamar a este método garantiza que todos los registros con números de secuencia hasta el especificado, incluido éste, se han escrito de manera duradera.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">Un error E/S ha ocurrido durante el vaciado de datos.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>When overridden in a derived class, gets the sequence number which is greater than the last record appended.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el número de secuencia que es mayor que el último registro que se anexó.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>A sequence number which is greater than the last record appended.</source>
          <target state="translated">Un número de secuencia que es mayor que el último registro anexado.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</source>
          <target state="translated">Esta propiedad contiene un número de secuencia con la garantía de ser mayor que el número de secuencia del último registro anexado.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">Los números de secuencia válidos son mayores que o iguales a <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> y menores que <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>When using a <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> instance, the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph> value can become out of date until records are flushed to the log.</source>
          <target state="translated">Al utilizar una instancia <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph>, el valor <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph> se puede volver anticuado hasta que los registros se vacíen al registro.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>See <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Log.RecordAppendOptions&gt;</ph> for more information on flushing records..</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.Log.RecordAppendOptions&gt;</ph> para obtener más información sobre cómo vaciar los registros.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.LastSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.MaximumRecordLength">
          <source>When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el tamaño del registro más grande que se puede anexar a, o que puede leerse de esta secuencia, en bytes.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.MaximumRecordLength">
          <source>The size of the largest record that can be appended to or read from this sequence, in bytes.</source>
          <target state="translated">El tamaño del registro más grande que se puede anexar a o que puede leerse de esta secuencia, en bytes.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.MaximumRecordLength">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The sequence number of the first record where the reading starts.</source>
          <target state="translated">El número de secuencia del primer registro donde la lectura se inicia.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> value that specifies the manner (that is, forward or backward) in which records should be read from a <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Un valor <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> válido que especifica la manera (es decir, hacia adelante o hacia atrás) en la que los registros se deberían leer de <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>When overridden in a derived class, returns an enumerable collection of records in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, devuelve una colección enumerable de registros en la secuencia.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>An enumerable collection of records in the sequence.</source>
          <target state="translated">Una colección enumerable de registros en la secuencia.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>When overridden in a derived class, returns an enumerable collection of records in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, devuelve una colección enumerable de registros en la secuencia.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The order of the enumerated records depends on the value of the <ph id="ph1">`logRecordEnum`</ph> parameter.</source>
          <target state="translated">El orden de los registros enumerados depende del valor del parámetro <ph id="ph1">`logRecordEnum`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This sample demonstrates the use of the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A&gt;</ph> method.</source>
          <target state="translated">Este ejemplo muestra el uso del método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>An I/O error occurred while reading the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al leer un registro.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, devuelve una colección enumerable de las áreas de reinicio en la secuencia.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>An enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">Una colección enumerable de las áreas de reinicio en la secuencia.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</source>
          <target state="translated">Las áreas de reinicio se enumeran en orden inverso del número de secuencia, es decir, del número de secuencia superior al número de secuencia más bajo.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</source>
          <target state="translated">Sólo se enumeran las áreas de reinicio con números de secuencia entre el último número de secuencia y el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>If the log extent containing the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph> becomes corrupted, this method can throw an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> with the error message "The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">Si se daña la extensión del registro que contiene <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt;</ph>, este método puede iniciar <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> con el mensaje de error que "La solicitud no se pudo realizar debido a una excepción E/S inesperada.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>The following error code was returned: '80070026'".</source>
          <target state="translated">Se ha devuelto el siguiente código erróneo: '80070026'".</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>An I/O error occurred while reading the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al leer un registro.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReadRestartAreas">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the collection to make reservations in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> en el que se contiene la colección para realizar las reservas.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">El número de secuencia del registro siguiente en el orden especificado por el usuario.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">El número de secuencia del registro siguiente en orden anterior.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated">Un valor válido de <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> que especifica cómo se deberían escribir los datos.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">La colección de reservas en la que realizar las reservas.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">Las reservas que se han de realizar, en bytes.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">Cuando se invalida en una clase derivada, automáticamente realiza una reserva única y anexa un registro a la secuencia.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">Número de secuencia del registro de entrada anexado.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en el parámetro <ph id="ph1">`data`</ph> se concatenarán en una matriz de bytes única para anexarlos como el registro.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">Sin embargo, no se ha realizado ninguna disposición para dividir los datode nuevo en los segmentos de la matriz cuando se lee el registro.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">Las reservas especificadas se agregan a la colección de reservas proporcionada en una operación atómica con una operación de anexado de registro.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">Si no se produce el anexado, no se reserva ningún espacio.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">Normalmente, este método puede completarse antes de que se haya escrito el registro.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">Para asegurarse de que se ha escrito un registro, especifique la marca <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> utilizando el parámetro <ph id="ph2">`recordAppendOptions`</ph> o llame al método <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">Ha ocurrido un error de E/S al anexar un registro.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el nuevo registro o para hacer la reserva.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.ReservedBytes">
          <source>When overridden in a derived class, gets the total number of bytes that have been reserved.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el número total de bytes que se han reservado.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.ReservedBytes">
          <source>The total size of all reservations made in this record sequence.</source>
          <target state="translated">El tamaño total de todas las reservas realizadas en esta secuencia del registro.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.ReservedBytes">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.RestartSequenceNumber">
          <source>When overridden in a derived class, gets the sequence number of the most recently written restart area.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el número de secuencia del área de reinicio recientemente escrita.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RestartSequenceNumber">
          <source>The sequence number of the most recently written restart area.</source>
          <target state="translated">El número de secuencia del área de reinicio recientemente escrita.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RestartSequenceNumber">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RestartSequenceNumber">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RestartSequenceNumber">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.RestartSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.RetryAppend">
          <source>Gets or sets a value indicating whether appends are automatically retried if the log is full.</source>
          <target state="translated">Obtiene o establece un valor que indica si los anexos se reintentan automáticamente en caso de que el registro esté completo.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RetryAppend">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if appends are automatically retried if the log is full; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si las operaciones de anexado se reintentan automáticamente cuando el registro esté lleno; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RetryAppend">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.IRecordSequence.RetryAppend">
          <source>If the value of this property is <ph id="ph1">`true`</ph>, and an <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt;</ph> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</source>
          <target state="translated">Si el valor de esta propiedad es <ph id="ph1">`true`</ph>, y una llamada <ph id="ph2">&lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt;</ph> no puede realizarse porque no hay espacio suficiente en la secuencia, la secuencia de registro intentará liberar espacio y volverá a intentar anexarse.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="P:System.IO.Log.IRecordSequence.RetryAppend">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">Se tuvo acceso a la propiedad después de haber eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="E:System.IO.Log.IRecordSequence.TailPinned">
          <source>Occurs when the record sequence determines that the tail must be moved forward.</source>
          <target state="translated">Se produce cuando la secuencia del registro determina que se debe avanzar la cola.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.IRecordSequence.TailPinned">
          <source>You can fire this event when the record sequence has run out of space.</source>
          <target state="translated">Puede desencadenar este evento cuando la secuencia del registro se haya quedado sin espacio.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.IRecordSequence.TailPinned">
          <source>When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</source>
          <target state="translated">Cuando se desencadena este evento, la cola de la secuencia (es decir, el número de secuencia base) avanza para liberar espacio.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="T:System.IO.Log.IRecordSequence">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe un área de reinicio a<ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.IRecordSequence">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe un área de reinicio a<ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">El Sistema de Registro de Archivo Común (CLFS) mantiene dos áreas de reinicio para garantizar por lo menos que un área válida esté siempre disponible.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, CLFS lee su área de reinicio y todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe un área de reinicio a<ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Los datos contenidos en los segmentos de la matriz de bytes se concatenarán en una matriz de bytes única para anexarse como el registro.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> and updates the base sequence number</source>
          <target state="translated">Cuando se invalida en una clase derivada, se escribe un área de reinicio a<ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> y se actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe un área de reinicio en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> y actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe un área de reinicio en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> mediante una reserva, y actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">Una lista de segmentos de la matriz de bytes que se concatenarán y anexarán como el registro.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">El nuevo número de secuencia base.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">El número de secuencia especificado debe ser mayor que o igual al número de secuencia base actual.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> que contiene la reserva que se debería utilizar para este área de reinicio.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When overridden in a derived class, writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">Cuando se invalida en una clase derivada, escribe un área de reinicio en <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph> mediante una reserva y se actualiza el número de secuencia base.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">Número de secuencia del área de reinicio escrita.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">Un área de reinicio se utiliza para almacenar temporalmente información que contiene la última operación de punto de control de un cliente.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</source>
          <target state="translated">Cuando una recuperación es necesaria, puede analizar el área de reinicio para recuperar todos los datos de la última operación de punto de control.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">Estos datos inicializan la tabla de transacciones, la tabla de páginas desfasadas y la tabla de archivos abiertos para que se puedan utilizar en el proceso de recuperación.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">Un área de reinicio puede leerse mediante el método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">Cuando se escribe un área de reinicio, los datos en los segmentos de la matriz de bytes se concatenan en una matriz de bytes única para anexar como el registro.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">No se ha realizado ninguna disposición para dividir los datos de nuevo en segmentos de matriz cuando se lee el área de reinicio.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">Si se especifica una reserva , el área de reinicio escrita utilizará el espacio que se ha reservado previamente, utilizando una reserva contenida en la colección.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">Si el método tiene éxito, utilizará la menor reserva que pueda contener los datos y esa reserva se quitará de la colección.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">Cuando el método se completa correctamente, el número de secuencia base se actualiza.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">Todas las entradas de registro con números de secuencia menores que el nuevo número de secuencia base son inaccesibles.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">Si una secuencia del registro se ha eliminado, o si se pasa un argumento no válido, las excepciones se producen inmediatamente en esta operación.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">Los errores que se produjeron durante una solicitud de anexado asincrónica, como, por ejemplo, un error de disco durante la petición de E/S, producirá excepciones que se producen cuando se llama al método <ph id="ph1">&lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">Uno o varios argumentos no son válidos.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">Se produjo un error de E/S al escribir el área de reinicio.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">La secuencia del registro no pudo liberar espacio suficiente para contener el área de reinicio.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">Se llamó al método una vez eliminada la secuencia.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>