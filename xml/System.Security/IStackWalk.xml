<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b37ff083eff27618aa07c0a744562f3f8a613708" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30499169" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Administra el recorrido de pila que determina si todos los autores de llamada de la pila de llamadas tienen los permisos necesarios para tener acceso a un recurso protegido.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Código de confianza parcial siempre representa un riesgo de seguridad. A veces se puede manipular para realizar acciones en nombre de código malintencionado que no tiene permiso para tener acceso a un recurso. De esta manera, el código malintencionado puede lograr mayor seguridad de acceso que se debe permitir.  
  
 Common language runtime ayuda a proteger el código administrado contra estos ataques ejecutando un recorrido de pila en todas las llamadas. El recorrido de pila requiere que todo el código en la pila de llamadas tenga permiso para tener acceso a un recurso protegido. Dado que el código intenta realizar el ataque siempre estará en alguna parte en la pila de llamadas, no podrá superar sus propios permisos de seguridad.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Afirma que el código de llamada puede tener acceso al recurso identificado por el objeto de permiso actual, incluso si los autores de la llamada situados en una posición más alta de la pila no tienen permiso para tener acceso al recurso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Security.IStackWalk.Assert%2A> se detiene la comprobación de permisos en los llamadores situados en la pila de llamadas. Por lo tanto, incluso si estos llamadores no tiene los permisos necesarios, pueden acceder a recursos. Una aserción es efectiva sólo si el código que llama <xref:System.Security.IStackWalk.Assert%2A> pasa la comprobación de seguridad para el permiso que está validando.  
  
 Una llamada a <xref:System.Security.IStackWalk.Assert%2A> es efectivo hasta que el código de llamada devuelve al llamador o hasta que una llamada subsiguiente a <xref:System.Security.IStackWalk.Assert%2A> representa la aserción anterior ineficaces. Además, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> quita una pendiente <xref:System.Security.IStackWalk.Assert%2A>.  
  
 <xref:System.Security.IStackWalk.Assert%2A> se omite para un permiso no concedido ya que no se realizará correctamente una demanda para ese permiso. Sin embargo, si el código situado más abajo en la pila de llamadas llama <xref:System.Security.IStackWalk.Demand%2A> para ese permiso, un <xref:System.Security.SecurityException> se produce cuando el recorrido de pila alcanza el código que intentó llamar a <xref:System.Security.IStackWalk.Assert%2A>. Esto sucede porque el código que llamó <xref:System.Security.IStackWalk.Assert%2A> no dispone del permiso, aunque intentó <xref:System.Security.IStackWalk.Assert%2A> lo.  
  
> [!CAUTION]
>  Dado que una llamada a <xref:System.Security.IStackWalk.Assert%2A> quita el requisito de que todo el código en la cadena de llamadas debe disponer de permiso para tener acceso al recurso especificado, lo cual puede provocar vulnerabilidades de seguridad si utiliza incorrectamente o incorrectamente. Por lo tanto, debe usarse con mucha precaución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El código de llamada no tiene <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina en tiempo de ejecución si a todos los autores de llamada de la pila de llamadas se les ha concedido el permiso especificado por el objeto de permiso actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa normalmente por las bibliotecas seguras para garantizar que los llamadores tienen permiso para tener acceso a un recurso. Por ejemplo, llama a una clase de archivo en una biblioteca de clases seguras <xref:System.Security.IStackWalk.Demand%2A> para necesaria <xref:System.Security.Permissions.FileIOPermission> antes de realizar una operación de archivo solicitada por el llamador.  
  
 Los permisos del código que llama a este método no se examinan; la comprobación comienza desde el llamador inmediato de dicho código y continúa hacia arriba en la pila. <xref:System.Security.IStackWalk.Demand%2A> se realiza correctamente sólo si no hay <xref:System.Security.SecurityException> se genera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un autor de llamada situado más arriba en la pila de llamadas no tiene el permiso especificado por el objeto de permiso actual.  
  
 O bien  
  
 Un autor de llamada de la pila de llamadas ha llamado a <see cref="M:System.Security.IStackWalk.Deny" /> en el objeto de permiso actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que cada <see cref="M:System.Security.IStackWalk.Demand" /> del objeto actual que pase por el código de llamada produzca un error.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método evita que los llamadores situados en la pila de llamadas de acceso al recurso protegido a través del código que llama a este método, incluso si los llamadores tienen permiso para tener acceso a él. La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.  
  
 <xref:System.Security.IStackWalk.Deny%2A> puede limitar la responsabilidad del programador o ayudar a evitar vulnerabilidades de seguridad accidental porque ayuda a evitar que el método que llama a <xref:System.Security.IStackWalk.Deny%2A> desde que se va a utilizar para tener acceso al recurso protegido por el permiso denegado. Si llama a un método <xref:System.Security.IStackWalk.Deny%2A> en un permiso y si un <xref:System.Security.IStackWalk.Demand%2A> para ese permiso lo invoque un llamante hacia abajo en la pila de llamadas, dicha comprobación de seguridad se producirá un error cuando alcanza el <xref:System.Security.IStackWalk.Deny%2A>.  
  
 <xref:System.Security.IStackWalk.Deny%2A> se omite para un permiso no concedido ya que no se realizará correctamente una demanda para ese permiso.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>No se puede invalidar este método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que devuelva error cada método <see cref="M:System.Security.IStackWalk.Demand" /> de todos los objetos excepto del objeto actual que pase a través del código de llamada, incluso si el código situado más arriba en la pila de llamadas dispone de permiso para obtener acceso a otros recursos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> es similar a <xref:System.Security.IStackWalk.Deny%2A>, ya que ambos originan recorridos de pila se producirá un error cuando se realizarían correctamente en caso contrario. La diferencia es que <xref:System.Security.IStackWalk.Deny%2A> especifica permisos que hará que el recorrido de pila producirá un error, pero <xref:System.Security.IStackWalk.PermitOnly%2A> especifica los permisos que hacen que el recorrido de pila producirá un error. Llamar a este método para asegurarse de que el código puede utilizarse para tener acceso solo a los recursos especificados.  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> se omite para un permiso no concedido ya que no se realizará correctamente una demanda para ese permiso. Sin embargo, si el código situado más abajo en la llamada de la pila más adelante llamadas <xref:System.Security.IStackWalk.Demand%2A> para ese permiso, un <xref:System.Security.SecurityException> se produce cuando el recorrido de pila alcanza el código que intentó llamar a <xref:System.Security.IStackWalk.PermitOnly%2A>. Esto es porque el código que llamó <xref:System.Security.IStackWalk.PermitOnly%2A> no dispone del permiso, aunque haya llamado a <xref:System.Security.IStackWalk.PermitOnly%2A> para ese permiso. La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>