<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b0b7de9608a2e3cabb49879ca8a3a3d7c242e07b" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55386024" /></Metadata><TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <TypeSignature Language="F#" Value="type HostSecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite el control y la personalización del comportamiento de la seguridad para los dominios de aplicaciones.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea un nuevo <xref:System.AppDomain>, las consultas en tiempo de ejecución de lenguaje común el <xref:System.AppDomainManager> la presencia de un <xref:System.Security.HostSecurityManager>, que participa en decisiones de seguridad el <xref:System.AppDomain>.  Los proveedores de host deben implementar un administrador de seguridad de host que se hereda de la <xref:System.Security.HostSecurityManager> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una implementación muy sencilla de un <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Esta clase no se puede usar código de confianza parcial o transparente.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para plena confianza para los herederos. No se puede heredar esta clase por código de confianza parcial.</permission>
    <block subset="none" type="overrides"><para>Algunos miembros de un <see cref="T:System.Security.HostSecurityManager" /> se llama siempre que un ensamblado se carga, de forma implícita o explícita. El <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> y <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> métodos no deben cargar los ensamblados, ya que esto dará lugar a los miembros de la <see cref="T:System.Security.HostSecurityManager" /> que se va a llamar de forma recursiva. Para evitar referencias circulares, debe crear nuevas instancias de clases que pueden causar cargar ensamblados, implícita o explícitamente, en el constructor de una clase que deriva de <see cref="T:System.Security.HostSecurityManager" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.HostSecurityManager" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para plena confianza para los herederos. Este miembro no puede heredarse mediante código de confianza parcial.</permission>
        <block subset="none" type="overrides"><para>Crear instancias de clases que pueden causar los ensamblados que va a cargar, ya sea explícitamente o implícitamente, en este constructor.  El descriptor de acceso get de la <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> propiedad y el <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> y <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> se denominan métodos cada vez que se carga un ensamblado y su posterior carga de ensamblados hará que las referencias circulares.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust&#xA;override this.DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust" Usage="hostSecurityManager.DetermineApplicationTrust (applicationEvidence, activatorEvidence, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Evidencia para la aplicación que se va a activar.</param>
        <param name="activatorEvidence">Opcionalmente, evidencia para el dominio de aplicación que realiza la activación.</param>
        <param name="context">Contexto de confianza.</param>
        <summary>Determina si se debe ejecutar una aplicación.</summary>
        <returns>Objeto que contiene información de confianza sobre la aplicación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. El Administrador de seguridad de la aplicación para determinar si se debe ejecutar la aplicación llama a la implementación base.  
  
 La implementación base no utiliza la evidencia del activador. Sin embargo, una implementación invalidada podría utilizar la evidencia del activador para determinar la evidencia de seguridad para el dominio de aplicación al intentar activar la aplicación.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invalidar el <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> método para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="applicationEvidence" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">No se pudo encontrar un objeto <see cref="T:System.Runtime.Hosting.ActivationArguments" /> en la evidencia de la aplicación.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> de los argumentos de activación es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El conjunto de permisos <see cref="T:System.Security.Policy.ApplicationTrust" /> concedido no contiene el conjunto de solicitudes mínimo especificado por <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainPolicy : System.Security.Policy.PolicyLevel" Usage="System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si se reemplaza en una clase derivada, obtiene la directiva de seguridad para el dominio de aplicación actual.</summary>
        <value>Directiva de seguridad para el dominio de aplicación actual. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se puede invalidar en una clase derivada. La implementación base siempre devuelve `null`.  
  
 Esta propiedad se llama al <xref:System.AppDomain> hora de creación. Permite a un host proporcionar una directiva actual <xref:System.AppDomain>.  Un nivel de directiva consta de las siguientes acciones:  
  
-   Un conjunto de grupos de código se organiza en un único árbol raíz.  
  
-   Un conjunto de conjuntos de permisos con nombre que hace referencia a los grupos de código para especificar permisos para concederse al código perteneciente al grupo de código.  
  
-   Una lista de ensamblados de plena confianza.  
  
> [!IMPORTANT]
>  Vea las notas para los herederos para el <xref:System.Security.HostSecurityManager> clase para obtener información de implementación crítica.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método utiliza la directiva de seguridad de acceso del código (CAS), que está obsoleta en [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar la directiva CAS para compatibilidad con versiones anteriores de .NET Framework, use el [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Security.HostSecurityManagerOptions" Usage="System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el marcador que representa los componentes de directiva de seguridad de interés para el host.</summary>
        <value>Uno de los valores de enumeración que especifica componentes de la directiva de seguridad. De manera predeterminada, es <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se puede invalidar en una clase derivada. La implementación base siempre devuelve <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 El host derivado puede cambiar el valor de esta propiedad cuando solo un subconjunto de la <xref:System.Security.HostSecurityManagerOptions> es de interés.  Los posibles subconjuntos son none, el conjunto rechazado, el nivel de directiva y evidencia de ensamblado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invalidar el <xref:System.Security.HostSecurityManager.Flags%2A> propiedad para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAppDomainEvidence evidenceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Tipo de evidencia.</param>
        <summary>Solicita un tipo de evidencia concreto para el dominio de aplicación.</summary>
        <returns>Evidencia del dominio de aplicación solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Common language runtime llama a este método cuando se necesita la evidencia del tipo especificado para el actual <xref:System.AppDomain>. El valor devuelto se utiliza como la evidencia proporcionada por el host y se almacena en el <xref:System.AppDomain.Evidence%2A> colección de los <xref:System.AppDomain.CurrentDomain%2A> propiedad. Puede usar el <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> método para obtener la prueba generada desde la colección.  
  
 Para obtener una devolución de llamada a este método, deben especificar hosts el <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> marca en el <xref:System.Security.HostSecurityManager.Flags%2A> propiedad.  
  
 Este método de generación de pruebas permite a los hosts retrasar la generación de pruebas para un <xref:System.AppDomain> hasta que se necesita la evidencia. En la versión de .NET Framework 3.5 y versiones anteriores, era necesario proporcionar <xref:System.AppDomain> evidencia en tiempo de carga invalidando el <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> método. Se recomienda que use <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> para proporcionar evidencia, en lugar de reemplazar <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 El <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> se llama al método nuevo en únicamente para tipos de evidencia de que el host ha especificado en el reemplazo del <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> método.  
  
 Un valor devuelto de `null` indica que el host no puede generar pruebas de este tipo específico.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invalidar el <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> método para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAssemblyEvidence (evidenceType, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Tipo de evidencia.</param>
        <param name="assembly">Ensamblado de destino.</param>
        <summary>Solicita un tipo de evidencia concreto para el ensamblado.</summary>
        <returns>Evidencia de ensamblado solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Common language runtime llama a este método cuando se necesita la evidencia del tipo especificado para el ensamblado actual. El valor devuelto se utiliza como la evidencia proporcionada por el host y se almacena en el <xref:System.Reflection.Assembly.Evidence%2A> propiedad. Puede usar el <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> método para obtener la prueba generada desde el <xref:System.Reflection.Assembly.Evidence%2A> propiedad.  
  
 Para obtener una devolución de llamada a este método, deben especificar hosts el <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> marca en el <xref:System.Security.HostSecurityManager.Flags%2A> propiedad.  
  
 Este método de generación de pruebas permite a los hosts retrasar la generación de pruebas para un <xref:System.AppDomain> hasta que se necesita la evidencia. En .NET Framework 3.5 y versiones anteriores, era necesario proporcionar <xref:System.AppDomain> evidencia en tiempo de carga invalidando el <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> método. Se recomienda que use <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> para proporcionar evidencia, en lugar de reemplazar <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 El <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> se llama al método nuevo en únicamente para tipos de evidencia de que el host ha especificado en el reemplazo del <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> método.  
  
 Un valor devuelto de `null` indica que el host no puede generar pruebas de este tipo específico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]&#xA;override this.GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina qué tipos de evidencia puede proporcionar el host para el dominio de aplicación, si se solicita.</summary>
        <returns>Matriz de tipos de evidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Determinarán los tipos devueltos por este método si el <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> método se vuelve a llamar. La presencia de un tipo en esta lista no significa que el host debe ser capaz de generar este tipo de prueba, pero que puede ser capaz de. Por ese motivo, es mejor especificar exceso en lugar de en especificar los tipos de esta lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]&#xA;override this.GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="assembly">Ensamblado de destino.</param>
        <summary>Determina qué tipos de evidencia puede proporcionar el host para el ensamblado, si se solicita.</summary>
        <returns>Matriz de tipos de evidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Determinarán los tipos devueltos por este método si el <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> método se vuelve a llamar. La presencia de un tipo en esta lista no significa que el host debe ser capaz de generar este tipo de prueba, pero que puede ser capaz de. Por ese motivo, es mejor especificar exceso en lugar de en especificar los tipos de esta lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAppDomainEvidence inputEvidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Evidencia adicional que se va a agregar a la evidencia <see cref="T:System.AppDomain" />.</param>
        <summary>Proporciona la evidencia del dominio de aplicación para un ensamblado que se está cargando.</summary>
        <returns>Evidencia que se va a usar para <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede invalidarse en una clase derivada.  
  
 Este método se llama cada vez que un <xref:System.AppDomain> se crea el objeto. El `inputEvidence` parámetro es la evidencia calculada desde common language runtime. La implementación del host puede ampliar o reducir la evidencia. El valor devuelto es la evidencia que se usará para el dominio de aplicación.  La implementación base siempre devuelve el objeto de evidencia que se pasa como el `inputEvidence` parámetro.  
  
> [!IMPORTANT]
>  Vea las notas para los herederos para el <xref:System.Security.HostSecurityManager> clase para obtener información de implementación crítica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAssemblyEvidence (loadedAssembly, inputEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Ensamblado cargado.</param>
        <param name="inputEvidence">Evidencia adicional que se va a agregar a la evidencia de ensamblado.</param>
        <summary>Proporciona la evidencia de ensamblado para un ensamblado que se está cargado.</summary>
        <returns>Evidencia que se va a usar para el ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede invalidarse en una clase derivada.  
  
 Este método se llama cada vez que un ensamblado se carga, de forma implícita o explícita. Los parámetros pasados son el ensamblado que se está cargando y la evidencia calculada desde common language runtime. La implementación del host puede ampliar o reducir la evidencia. El valor devuelto es la evidencia que se usará para el ensamblado.  La implementación base siempre devuelve el objeto de evidencia que se pasa como el `inputEvidence` parámetro.  
  
> [!IMPORTANT]
>  Vea las notas para los herederos para el <xref:System.Security.HostSecurityManager> clase para obtener información de implementación crítica.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invalidar el <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> método para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet&#xA;override this.ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="hostSecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Conjunto de evidencias utilizado para evaluar la directiva.</param>
        <summary>Determina qué permisos se conceden al código según la evidencia especificada.</summary>
        <returns>Conjunto de permisos que puede conceder el sistema de seguridad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invoca el motor de directiva de seguridad, proporcionándole la evidencia especificada. El resultado viene determinada por la directiva de seguridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="evidence" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>