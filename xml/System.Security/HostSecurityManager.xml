<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ff48fa5df967caba5aed9ae2ba2fef1a119992f4" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500649" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite el control y la personalización del comportamiento de la seguridad para los dominios de aplicaciones.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea un nuevo <xref:System.AppDomain>, las consultas en tiempo de ejecución de lenguaje común el <xref:System.AppDomainManager> la presencia de un <xref:System.Security.HostSecurityManager>, que participa en tomar decisiones de seguridad el <xref:System.AppDomain>.  Los proveedores de host deben implementar un administrador de seguridad de host que herede de la <xref:System.Security.HostSecurityManager> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra una implementación muy simple de un <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Esta clase no puede ser usada por código de confianza parcial o transparente.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Esta clase no puede heredarse mediante código de confianza parcial.</permission>
    <block subset="none" type="overrides">
      <para>Algunos miembros de un <see cref="T:System.Security.HostSecurityManager" /> se llama cada vez que un ensamblado se carga, ya sea de forma implícita o explícita. El <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> y <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> métodos no deben cargar los ensamblados, ya que esto dará lugar a los miembros de la <see cref="T:System.Security.HostSecurityManager" /> que se va a llamar de forma recursiva. Para evitar referencias circulares, debe crear nuevas instancias de clases que pueden causar cargar ensamblados, ya sea implícita o explícitamente, en el constructor de una clase que deriva de <see cref="T:System.Security.HostSecurityManager" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.HostSecurityManager" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
        <block subset="none" type="overrides">
          <para>Crear instancias de clases que pueden provocar ensamblados que va a cargar, ya sea explícita o implícitamente, en este constructor.  El descriptor de acceso get de la <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> propiedad y el <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> y <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> se denominan métodos cada vez que se carga un ensamblado y la carga subsiguiente de ensamblados producirá referencias circulares.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Evidencia para la aplicación que se va a activar.</param>
        <param name="activatorEvidence">Opcionalmente, evidencia para el dominio de aplicación que realiza la activación.</param>
        <param name="context">Contexto de confianza.</param>
        <summary>Determina si se debe ejecutar una aplicación.</summary>
        <returns>Objeto que contiene información de confianza sobre la aplicación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base llama al administrador de seguridad de la aplicación para determinar si se debe ejecutar la aplicación.  
  
 La implementación base no utiliza la evidencia del activador. Sin embargo, una implementación invalidada podría utilizar la evidencia del activador para determinar la evidencia de seguridad para el dominio de aplicación que intenta activar la aplicación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> método para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationEvidence" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">No se pudo encontrar un objeto <see cref="T:System.Runtime.Hosting.ActivationArguments" /> en la evidencia de la aplicación.  
  
 O bien  
  
 La propiedad <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> de los argumentos de activación es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El conjunto de permisos <see cref="T:System.Security.Policy.ApplicationTrust" /> concedido no contiene el conjunto de solicitudes mínimo especificado por <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si se reemplaza en una clase derivada, obtiene la directiva de seguridad para el dominio de aplicación actual.</summary>
        <value>Directiva de seguridad para el dominio de aplicación actual. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se puede invalidar en una clase derivada. La implementación base siempre devuelve `null`.  
  
 Se llama a esta propiedad en <xref:System.AppDomain> hora de creación. Permite a un host proporcionar una directiva para el actual <xref:System.AppDomain>.  Un nivel de directiva consta de las siguientes acciones:  
  
-   Un conjunto de grupos de código se organiza en un único árbol de raíz.  
  
-   Un conjunto de conjuntos de permisos con nombre que hace referencia a los grupos de código para especificar los permisos que se conceden al código que pertenecen al grupo de código.  
  
-   Una lista de ensamblados de plena confianza.  
  
> [!IMPORTANT]
>  Vea las notas para los herederos de la <xref:System.Security.HostSecurityManager> clase para obtener información de implementación crítica.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método utiliza la directiva de seguridad de acceso del código (CAS), que está obsoleta en [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]. Para habilitar la directiva CAS para compatibilidad con versiones anteriores de .NET Framework, use el [elemento &lt;legacyCasPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el marcador que representa los componentes de directiva de seguridad de interés para el host.</summary>
        <value>Uno de los valores de enumeración que especifica componentes de la directiva de seguridad. El valor predeterminado es <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se puede invalidar en una clase derivada. La implementación base siempre devuelve <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 El host derivado puede cambiar el valor de esta propiedad cuando sólo un subconjunto de la <xref:System.Security.HostSecurityManagerOptions> es de interés.  Los posibles subconjuntos son none, el conjunto rechazado, el nivel de directiva y evidencia del ensamblado.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Security.HostSecurityManager.Flags%2A> propiedad para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Tipo de evidencia.</param>
        <summary>Solicita un tipo de evidencia concreto para el dominio de aplicación.</summary>
        <returns>Evidencia del dominio de aplicación solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Common language runtime llama a este método cuando la prueba del tipo especificado se necesita para el actual <xref:System.AppDomain>. El valor devuelto se utiliza como la evidencia proporcionada por el host y se almacena en la <xref:System.AppDomain.Evidence%2A> colección de la <xref:System.AppDomain.CurrentDomain%2A> propiedad. Puede usar el <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> método para obtener la evidencia generada de la colección.  
  
 Para obtener una devolución de llamada a este método, los hosts deben especificar la <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> se marcan en el <xref:System.Security.HostSecurityManager.Flags%2A> propiedad.  
  
 Este método de generación de pruebas permite a los hosts retrasar la generación de la prueba para un <xref:System.AppDomain> hasta que sea necesaria la evidencia. En la versión de .NET Framework 3.5 y versiones anteriores, era necesario proporcionar <xref:System.AppDomain> evidencia en tiempo de carga invalidando el <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> método. Se recomienda que use <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> para proporcionar evidencia en lugar de reemplazar <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 El <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> método se vuelve a llamar únicamente para tipos de evidencia de que el host ha especificado en el reemplazo de la <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> método.  
  
 Un valor devuelto de `null` indica que el host no puede generar pruebas de este tipo específico.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> método para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Tipo de evidencia.</param>
        <param name="assembly">Ensamblado de destino.</param>
        <summary>Solicita un tipo de evidencia concreto para el ensamblado.</summary>
        <returns>Evidencia de ensamblado solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Common language runtime llama a este método cuando la prueba del tipo especificado se necesita para el ensamblado actual. El valor devuelto se utiliza como la evidencia proporcionada por el host y se almacena en la <xref:System.Reflection.Assembly.Evidence%2A> propiedad. Puede usar el <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> método para obtener la prueba generada desde el <xref:System.Reflection.Assembly.Evidence%2A> propiedad.  
  
 Para obtener una devolución de llamada a este método, los hosts deben especificar la <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> se marcan en el <xref:System.Security.HostSecurityManager.Flags%2A> propiedad.  
  
 Este método de generación de pruebas permite a los hosts retrasar la generación de la prueba para un <xref:System.AppDomain> hasta que sea necesaria la evidencia. .NET Framework 3.5 y versiones anteriores, era necesario proporcionar <xref:System.AppDomain> evidencia en tiempo de carga invalidando el <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> método. Se recomienda que use <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> para proporcionar evidencia en lugar de reemplazar <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 El <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> método se vuelve a llamar únicamente para tipos de evidencia de que el host ha especificado en el reemplazo de la <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> método.  
  
 Un valor devuelto de `null` indica que el host no puede generar pruebas de este tipo específico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina qué tipos de evidencia puede proporcionar el host para el dominio de aplicación, si se solicita.</summary>
        <returns>Matriz de tipos de evidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Determinarán los tipos devueltos por este método si el <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> método de devolución de llamada en. La presencia de un tipo en esta lista no significa que el host debe ser capaz de generar este tipo de prueba, pero que podrán. Por esta razón, es mejor especificar excesiva en lugar de en especificar los tipos en esta lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Ensamblado de destino.</param>
        <summary>Determina qué tipos de evidencia puede proporcionar el host para el ensamblado, si se solicita.</summary>
        <returns>Matriz de tipos de evidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede reemplazarse por una clase derivada. La implementación base devuelve `null`.  
  
 Determinarán los tipos devueltos por este método si el <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> método de devolución de llamada en. La presencia de un tipo en esta lista no significa que el host debe ser capaz de generar este tipo de prueba, pero que podrán. Por esta razón, es mejor especificar excesiva en lugar de en especificar los tipos en esta lista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Evidencia adicional que se va a agregar a la evidencia <see cref="T:System.AppDomain" />.</param>
        <summary>Proporciona la evidencia del dominio de aplicación para un ensamblado que se está cargando.</summary>
        <returns>Evidencia que se va a usar para <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede invalidarse en una clase derivada.  
  
 Se llama a este método cada vez que un <xref:System.AppDomain> se crea el objeto. El `inputEvidence` parámetro es la evidencia calculada desde common language runtime. La implementación del host puede elegir ampliar o reducir la evidencia. El valor devuelto es la evidencia que se usará para el dominio de aplicación.  La implementación base siempre devuelve el objeto de evidencia que se pasa como el `inputEvidence` parámetro.  
  
> [!IMPORTANT]
>  Vea las notas para los herederos de la <xref:System.Security.HostSecurityManager> clase para obtener información de implementación crítica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Ensamblado cargado.</param>
        <param name="inputEvidence">Evidencia adicional que se va a agregar a la evidencia de ensamblado.</param>
        <summary>Proporciona la evidencia de ensamblado para un ensamblado que se está cargado.</summary>
        <returns>Evidencia que se va a usar para el ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede invalidarse en una clase derivada.  
  
 Este método se llama cada vez que un ensamblado se carga, ya sea de forma implícita o explícita. Los parámetros pasados en son el ensamblado que se está cargando y la evidencia calculada desde common language runtime. La implementación del host puede elegir ampliar o reducir la evidencia. El valor devuelto es la evidencia que se usará para el ensamblado.  La implementación base siempre devuelve el objeto de evidencia que se pasa como el `inputEvidence` parámetro.  
  
> [!IMPORTANT]
>  Vea las notas para los herederos de la <xref:System.Security.HostSecurityManager> clase para obtener información de implementación crítica.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo invalidar el <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> método para un administrador de seguridad de host personalizado. Este ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.Security.HostSecurityManager> clase.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Conjunto de evidencias utilizado para evaluar la directiva.</param>
        <summary>Determina qué permisos se conceden al código según la evidencia especificada.</summary>
        <returns>Conjunto de permisos que puede conceder el sistema de seguridad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invoca al motor de directiva de seguridad y proporcionar con la evidencia especificada. El resultado está determinado por la directiva de seguridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>