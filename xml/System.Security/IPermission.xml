<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IPermission.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ab62c8d43e0ca696a66655b37755ebe3e68e56e6.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ab62c8d43e0ca696a66655b37755ebe3e68e56e6</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.IPermission">
          <source>Defines methods implemented by permission types.</source>
          <target state="translated">Define métodos implementados por tipos de permiso.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>Permissions in the common language runtime are objects that describe sets of operations that can be secured for specified resources.</source>
          <target state="translated">Los permisos de common language runtime son objetos que describen conjuntos de operaciones que se pueden proteger para determinados recursos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>A permission object describes operations or access that is subject to security control; it does not represent access or a right to perform operations.</source>
          <target state="translated">Un objeto de permiso describe operaciones o access que está sujeta a control de seguridad; no representa el acceso o el derecho a realizar operaciones.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>Permissions are used by both application code and the .NET Framework security system in the following ways.</source>
          <target state="translated">Código de la aplicación y el sistema de seguridad de .NET Framework utilizan los permisos de las maneras siguientes.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>Code requests the permissions it needs in order to run.</source>
          <target state="translated">Código solicite los permisos que necesita para funcionar.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>The security system policy grants permissions to code in order for it to run.</source>
          <target state="translated">La directiva de sistema de seguridad concede permisos al código en el orden de ejecución para él.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>Code demands that calling code has a permission.</source>
          <target state="translated">El código solicita que el código de llamada tenga un permiso.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>Code overrides the security stack using assert/deny/permit-only.</source>
          <target state="translated">Código invalida la pila de seguridad mediante assert/deny/solo permiso.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>If you write a new permission, you must implement this interface in your class.</source>
          <target state="translated">Si crea un nuevo permiso, debe implementar esta interfaz en su clase.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>A permission can be accessed by multiple threads.</source>
          <target state="translated">Puede tener acceso a un permiso de varios subprocesos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>When implementing this interface, you must guarantee that the <ph id="ph1">&lt;xref:System.Security.IPermission.IsSubsetOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.IPermission.Intersect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.IPermission.Copy%2A&gt;</ph> method implementations are thread safe.</source>
          <target state="translated">Al implementar esta interfaz, debe garantizar que la <ph id="ph1">&lt;xref:System.Security.IPermission.IsSubsetOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.IPermission.Intersect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Security.IPermission.Copy%2A&gt;</ph> las implementaciones de método son seguros para subprocesos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>This example shows how to define a permission class for use with code access security.</source>
          <target state="translated">Este ejemplo muestra cómo definir una clase de permiso para su uso con la seguridad de acceso del código.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IPermission">
          <source>All of the necessary permission interfaces are implemented.</source>
          <target state="translated">Se implementan todas las interfaces de permiso necesarias.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Copy">
          <source>Creates and returns an identical copy of the current permission.</source>
          <target state="translated">Crea y devuelve una copia idéntica del permiso actual.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Copy">
          <source>A copy of the current permission.</source>
          <target state="translated">Copia del permiso actual.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Copy">
          <source>A copy of a permission represents the same access to resources as the original permission.</source>
          <target state="translated">Una copia de un permiso representa el mismo acceso a los recursos que el permiso original.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Copy">
          <source>The following code example demonstrates implementing the <ph id="ph1">&lt;xref:System.Security.IPermission.Copy%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo implementar el <ph id="ph1">&lt;xref:System.Security.IPermission.Copy%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Copy">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Demand">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> at run time if the security requirement is not met.</source>
          <target state="translated">Produce una <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> en tiempo de ejecución si no se cumple el requisito de seguridad.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Este método se usa normalmente por las bibliotecas seguras para garantizar que los llamadores tienen permiso para tener acceso a un recurso.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">Por ejemplo, llama a una clase de archivo en una biblioteca de clases seguras <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> para necesaria <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> antes de realizar una operación de archivo solicitada por el llamador.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source>Although the majority of the classes that implement this interface method satisfy the security criteria by performing a full stack walk, a stack walk is not necessarily performed.</source>
          <target state="translated">Aunque la mayoría de las clases que implementan este método de interfaz cumplen los criterios de seguridad mediante la realización de un recorrido de pila completo, no se realiza necesariamente un recorrido de pila.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source>An example of an implementation that does not perform a stack walk is <ph id="ph1">&lt;xref:System.Security.Permissions.PrincipalPermission.Demand%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un ejemplo de una implementación que no realiza un recorrido de pila es <ph id="ph1">&lt;xref:System.Security.Permissions.PrincipalPermission.Demand%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source>When a stack walk is performed, the permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">Cuando se realiza un recorrido de pila, los permisos del código que llama a este método no se examinan; la comprobación comienza desde el llamador inmediato de dicho código y continúa hacia arriba en la pila.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> se realiza correctamente sólo si no hay <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> se genera.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">Permiso para formar intersección con el permiso actual.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Debe ser del mismo tipo que el permiso actual.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>Creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">Crea y devuelve un permiso que es la intersección del permiso actual y el permiso especificado.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">Nuevo permiso que representa la intersección del permiso actual y del permiso especificado.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>This new permission is <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the intersection is empty.</source>
          <target state="translated">Este nuevo permiso es <ph id="ph1">&lt;see langword="null" /&gt;</ph> si la intersección está vacía.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">La intersección de dos permisos es un permiso que describe el conjunto de operaciones descritas en ambos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">Solo una petición que pase ambos permisos originales aprobará la intersección.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>The following statements are required to be true for all implementations of the <ph id="ph1">&lt;xref:System.Security.IPermission.Intersect%2A&gt;</ph> method.</source>
          <target state="translated">Las instrucciones siguientes deben ser true para todas las implementaciones de la <ph id="ph1">&lt;xref:System.Security.IPermission.Intersect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph> and <ph id="ph2">`Y`</ph> represent <ph id="ph3">&lt;xref:System.Security.IPermission&gt;</ph> object references that are not <ph id="ph4">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph> y <ph id="ph2">`Y`</ph> representan <ph id="ph3">&lt;xref:System.Security.IPermission&gt;</ph> referencias de objeto que no sean <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.Intersect(<ph id="ph2">`X`</ph>) returns a value equal to <ph id="ph3">`X`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph>. Intersect (<ph id="ph2">`X`</ph>) devuelve un valor igual a <ph id="ph3">`X`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.Intersect(<ph id="ph2">`Y`</ph>) returns the same value as <ph id="ph3">`Y`</ph>.Intersect(<ph id="ph4">`X`</ph>).</source>
          <target state="translated"><ph id="ph1">`X`</ph>. Intersect (<ph id="ph2">`Y`</ph>) devuelve el mismo valor que <ph id="ph3">`Y`</ph>. Intersect (<ph id="ph4">`X`</ph>).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.Intersect(<ph id="ph2">`null`</ph>) returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph>. Intersect (<ph id="ph2">`null`</ph>) devuelve <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>The following code example demonstrates implementing the <ph id="ph1">&lt;xref:System.Security.IPermission.Intersect%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo implementar el <ph id="ph1">&lt;xref:System.Security.IPermission.Intersect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Intersect(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not an instance of the same class as the current permission.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="target" /&gt;</ph> no es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y tampoco es una instancia de la misma clase que el permiso actual.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">Permiso que se va a probar para la relación de subconjunto.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">Este permiso debe ser del mismo tipo que el permiso actual.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>Determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">Determina si el permiso actual es un subconjunto del permiso especificado.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current permission is a subset of the specified permission; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el permiso actual es un subconjunto del permiso especificado; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</source>
          <target state="translated">El permiso actual es un subconjunto del permiso especificado si el permiso actual especifica un conjunto de operaciones que se encuentra totalmente por el permiso especificado.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:<ph id="ph1">\\</ph>.</source>
          <target state="translated">Por ejemplo, un permiso que representa el acceso a C:\example.txt es un subconjunto de un permiso que representa el acceso a C:<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If this method returns <ph id="ph1">`true`</ph>, the current permission represents no more access to the protected resource than does the specified permission.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">`true`</ph>, el permiso actual no representa ningún grado de acceso al recurso protegido que el permiso especificado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following statements are required to be true for all implementations of the <ph id="ph1">&lt;xref:System.Security.IPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">Las instrucciones siguientes deben ser true para todas las implementaciones de la <ph id="ph1">&lt;xref:System.Security.IPermission.IsSubsetOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>, <ph id="ph2">`Y`</ph>, and <ph id="ph3">`Z`</ph> represent <ph id="ph4">&lt;xref:System.Security.IPermission&gt;</ph> objects that are not <ph id="ph5">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph>, <ph id="ph2">`Y`</ph>, y <ph id="ph3">`Z`</ph> representan <ph id="ph4">&lt;xref:System.Security.IPermission&gt;</ph> objetos que no son <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.IsSubsetOf(<ph id="ph2">`X`</ph>) returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph>. IsSubsetOf (<ph id="ph2">`X`</ph>) devuelve <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.IsSubsetOf(<ph id="ph2">`Y`</ph>) returns the same value as <ph id="ph3">`Y`</ph>.IsSubsetOf(<ph id="ph4">`X`</ph>) if and only if <ph id="ph5">`X`</ph> and <ph id="ph6">`Y`</ph> represent the same set of permissions.</source>
          <target state="translated"><ph id="ph1">`X`</ph>. IsSubsetOf (<ph id="ph2">`Y`</ph>) devuelve el mismo valor que <ph id="ph3">`Y`</ph>. IsSubsetOf (<ph id="ph4">`X`</ph>) si y solo si <ph id="ph5">`X`</ph> y <ph id="ph6">`Y`</ph> representan el mismo conjunto de permisos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <ph id="ph1">`X`</ph>.IsSubsetOf(<ph id="ph2">`Y`</ph>) and <ph id="ph3">`Y`</ph>.IsSubsetOf(<ph id="ph4">`Z`</ph>) both return <ph id="ph5">`true`</ph>, <ph id="ph6">`X`</ph>.IsSubsetOf(<ph id="ph7">`Z`</ph>) returns <ph id="ph8">`true`</ph>.</source>
          <target state="translated">If <ph id="ph1">`X`</ph>. IsSubsetOf (<ph id="ph2">`Y`</ph>) y <ph id="ph3">`Y`</ph>. IsSubsetOf (<ph id="ph4">`Z`</ph>) ambos devuelven <ph id="ph5">`true`</ph>, <ph id="ph6">`X`</ph>. IsSubsetOf (<ph id="ph7">`Z`</ph>) devuelve <ph id="ph8">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <ph id="ph1">`X`</ph> represents an empty <ph id="ph2">&lt;xref:System.Security.IPermission&gt;</ph> object with a permission state of <ph id="ph3">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph> and <ph id="ph4">`Y`</ph> represents an <ph id="ph5">&lt;xref:System.Security.IPermission&gt;</ph> object that is <ph id="ph6">`null`</ph>, <ph id="ph7">`X`</ph>.IsSubsetOf(<ph id="ph8">`Y`</ph>) returns <ph id="ph9">`true`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`X`</ph> representa vacío <ph id="ph2">&lt;xref:System.Security.IPermission&gt;</ph> objeto con un estado de permiso <ph id="ph3">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph> y <ph id="ph4">`Y`</ph> representa un <ph id="ph5">&lt;xref:System.Security.IPermission&gt;</ph> objeto que se <ph id="ph6">`null`</ph>, <ph id="ph7">`X`</ph>. IsSubsetOf (<ph id="ph8">`Y`</ph>) devuelve <ph id="ph9">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <ph id="ph1">`Z`</ph> is also an empty permission, the compound set operation <ph id="ph2">`X`</ph>.Union(Z).IsSubsetOf(Y) also returns <ph id="ph3">`true`</ph> because the union of two empty permissions is an empty permission.</source>
          <target state="translated">Si <ph id="ph1">`Z`</ph> también es un permiso vacío, la operación de conjunto compuesta <ph id="ph2">`X`</ph>. Union(Z). También devuelve IsSubsetOf <ph id="ph3">`true`</ph> porque la unión de dos permisos vacíos es un permiso vacío.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following code example demonstrates implementing the <ph id="ph1">&lt;xref:System.Security.IPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo implementar el <ph id="ph1">&lt;xref:System.Security.IPermission.IsSubsetOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not of the same type as the current permission.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="target" /&gt;</ph> no es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y tampoco es del mismo tipo que el permiso actual.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">Permiso para combinar con el permiso actual.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Debe ser del mismo tipo que el permiso actual.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>Creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">Crea un permiso que es la unión del permiso actual y el permiso especificado.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">Nuevo permiso que representa la unión del permiso actual y el especificado.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>The result of a call to <ph id="ph1">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph> is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">El resultado de una llamada a <ph id="ph1">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph> es un permiso que representa todas las operaciones representadas por el permiso actual y el permiso especificado.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">Cualquier solicitud que pase alguno de estos permisos pasa también su unión.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>The following statements are required to be true for all implementations of the <ph id="ph1">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph> method.</source>
          <target state="translated">Las instrucciones siguientes deben ser true para todas las implementaciones de la <ph id="ph1">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph> and <ph id="ph2">`Y`</ph> represent <ph id="ph3">&lt;xref:System.Security.IPermission&gt;</ph> objects that are not <ph id="ph4">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph> y <ph id="ph2">`Y`</ph> representan <ph id="ph3">&lt;xref:System.Security.IPermission&gt;</ph> objetos que no son <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.Union(<ph id="ph2">`X`</ph>) returns an object that has the same value as <ph id="ph3">`X`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph>. Union (<ph id="ph2">`X`</ph>) devuelve un objeto que tiene el mismo valor que <ph id="ph3">`X`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.Union(<ph id="ph2">`Y`</ph>) returns an object that has the same value as the object returned by <ph id="ph3">`Y`</ph>.Union(<ph id="ph4">`X`</ph>).</source>
          <target state="translated"><ph id="ph1">`X`</ph>. Union (<ph id="ph2">`Y`</ph>) devuelve un objeto que tiene el mismo valor que el objeto devuelto por <ph id="ph3">`Y`</ph>. Union (<ph id="ph4">`X`</ph>).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source><ph id="ph1">`X`</ph>.Union(<ph id="ph2">`null`</ph>) returns an object that has the same value as <ph id="ph3">`X`</ph>.</source>
          <target state="translated"><ph id="ph1">`X`</ph>. Union (<ph id="ph2">`null`</ph>) devuelve un objeto que tiene el mismo valor que <ph id="ph3">`X`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>The following code example demonstrates implementing the <ph id="ph1">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo implementar el <ph id="ph1">&lt;xref:System.Security.IPermission.Union%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.IPermission&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Security.IPermission.Union(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not of the same type as the current permission.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="target" /&gt;</ph> no es <ph id="ph2">&lt;see langword="null" /&gt;</ph> y tampoco es del mismo tipo que el permiso actual.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>