<Type Name="ArrayPool&lt;T&gt;" FullName="System.Buffers.ArrayPool&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c365ab2f2412036b41ba89388ab6a1187f6696d2" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36647254" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ArrayPool&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ArrayPool`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.ArrayPool`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ArrayPool(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ArrayPool abstract" />
  <TypeSignature Language="F#" Value="type ArrayPool&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Buffers</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="T">El tipo de los objetos que se encuentran en el grupo de recursos.</typeparam>
    <summary>Proporciona un grupo de recursos que permite volver a usar instancias de tipo <see cref="T:T[]" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Mediante el <xref:System.Buffers.ArrayPool%601> clase alquilar y devolver búferes (mediante el <xref:System.Buffers.ArrayPool%601.Rent%2A> y <xref:System.Buffers.ArrayPool%601.Return%2A> métodos) puede mejorar el rendimiento en situaciones donde las matrices se crean y destruyen con frecuencia, lo que produce presión de memoria significativa en la basura Recopilador.
  
 ]]></format>
    </remarks>
    <threadsafe>Esta clase es segura para subprocesos. Todos los miembros se pueden usar varios subprocesos simultáneamente.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ArrayPool ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ArrayPool();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Tenga en cuenta que este constructor está protegido; solo se puede llamar mediante las clases derivadas de la <xref:System.Buffers.ArrayPool%601> clase. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <returns>Nueva instancia de la clase <see cref="T:System.Buffers.ArrayPool`1" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create (int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create(int32 maxArrayLength, int32 maxArraysPerBucket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (maxArrayLength As Integer, maxArraysPerBucket As Integer) As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create(int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="F#" Value="static member Create : int * int -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create (maxArrayLength, maxArraysPerBucket)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxArrayLength" Type="System.Int32" />
        <Parameter Name="maxArraysPerBucket" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxArrayLength">Longitud máxima de una instancia de matriz que se puede almacenar en el grupo.</param>
        <param name="maxArraysPerBucket">Número máximo de instancias de matriz que se pueden almacenar en cada depósito del grupo. El grupo agrupa matrices de longitudes similares en depósitos para acelerar el acceso.</param>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Buffers.ArrayPool`1" /> con la condición especificada.</summary>
        <returns>Nueva instancia de la clase <see cref="T:System.Buffers.ArrayPool`1" /> con la configuración especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
La instancia de la <xref:System.Buffers.ArrayPool%601> creado por este método de clase agrupará las matrices en depósitos, con no más de `maxArraysPerBucket` en cada depósito y con esas matrices no superior a `maxArrayLength` de longitud.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rent">
      <MemberSignature Language="C#" Value="public abstract T[] Rent (int minimumLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] Rent(int32 minimumLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Rent (minimumLength As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;T&gt; ^ Rent(int minimumLength);" />
      <MemberSignature Language="F#" Value="abstract member Rent : int -&gt; 'T[]" Usage="arrayPool.Rent minimumLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minimumLength">Longitud mínima de la matriz.</param>
        <summary>Recupera un búfer que tiene al menos la longitud solicitada.</summary>
        <returns>Matriz de tipo <see cref="T:T[]" /> que tiene al menos <paramref name="minimumLength" /> de longitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Este búfer se presta al autor de llamada y se deben devolver en el mismo grupo mediante la <xref:System.Buffers.ArrayPool%601.Return%2A> método, por lo que TI se puede reutilizar en las llamadas posteriores a la <xref:System.Buffers.ArrayPool%601.Rent%2A> método. Error al devolver un búfer alquilado no es un error irrecuperable. Sin embargo, puede causar que una aplicación una disminución de rendimiento, como el grupo que tenga que crear un búfer nuevo para reemplazar el perdido.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public abstract void Return (T[] array, bool clearArray = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Return(!T[] array, bool clearArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Return (array As T(), Optional clearArray As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member Return : 'T[] * bool -&gt; unit" Usage="arrayPool.Return (array, clearArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="clearArray" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="array">Búfer que se va a devolver al grupo que se ha obtenido anteriormente con el método <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />.</param>
        <param name="clearArray">Indica si se debe borrar el contenido del búfer antes de volver a usarlo. Si <paramref name="clearArray" /> está establecido en <see langword="true" /> y el grupo va a almacenar el búfer para permitir su reutilización posterior, el método <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" /> borra el contenido de <paramref name="array" /> para que un autor de llamada posterior que use el método <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" /> no vea el contenido del autor de llamada anterior. Si <paramref name="clearArray" /> está establecido en <see langword="false" /> o si el grupo va a liberar el búfer, el contenido de la matriz no se cambia.</param>
        <summary>Devuelve una matriz al grupo que se ha obtenido anteriormente al usar el método <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" /> en la misma instancia de <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Una vez que haya obtenido un búfer para el grupo, el llamador ofrece todas las propiedad del búfer y no debe usar. Devuelve la referencia de una determinada llamada a la <xref:System.Buffers.ArrayPool%601.Rent%2A> solo se debe devolver el método mediante el <xref:System.Buffers.ArrayPool%601.Return%2A> método una vez. El valor predeterminado <xref:System.Buffers.ArrayPool%601> puede almacenar en búfer devuelto con el fin de alquilar nuevo, o bien puede liberar el búfer devuelto si se determina que el grupo ya tiene suficientes búferes almacenados.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shared">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Shared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Buffers.ArrayPool`1&lt;!T&gt; Shared" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.ArrayPool`1.Shared" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Shared As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Buffers::ArrayPool&lt;T&gt; ^ Shared { System::Buffers::ArrayPool&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Shared : System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Shared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una instancia compartida de <see cref="T:System.Buffers.ArrayPool`1" />.</summary>
        <value>Un compartido <see cref="T:System.Buffers.ArrayPool`1" /> instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

El grupo compartido proporciona una implementación predeterminada de la <xref:System.Buffers.ArrayPool%601> clase que está pensado para la aplicación general. Una clase compartida mantiene las matrices de varios tamaños y es posible que nos devolverá una matriz más grande que realmente se ha solicitado, pero nunca entregará una matriz más pequeña que se ha solicitado. Alquilar un búfer de una clase compartida mediante la <xref:System.Buffers.ArrayPool%601.Rent%2A> método dará como resultado en un búfer existente que se toma de la sección si hay un búfer adecuado o en un búfer nuevo que se asignan si uno no está disponible.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>