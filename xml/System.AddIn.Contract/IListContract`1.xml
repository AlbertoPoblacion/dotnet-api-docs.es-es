<Type Name="IListContract&lt;T&gt;" FullName="System.AddIn.Contract.IListContract&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b93185b7c929c6518a44c9d831307f70820de03b" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52251966" /></Metadata><TypeSignature Language="C#" Value="public interface IListContract&lt;T&gt; : System.AddIn.Contract.IContract" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IListContract`1&lt;T&gt; implements class System.AddIn.Contract.IContract" />
  <TypeSignature Language="DocId" Value="T:System.AddIn.Contract.IListContract`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IListContract(Of T)&#xA;Implements IContract" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public interface class IListContract : System::AddIn::Contract::IContract" />
  <TypeSignature Language="F#" Value="type IListContract&lt;'T&gt; = interface&#xA;    interface IContract" />
  <AssemblyInfo>
    <AssemblyName>System.AddIn.Contract</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.AddIn.Contract.IContract</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Tipo de contrato de los objetos de la lista.</typeparam>
    <summary>Representa una lista genérica de tipos que son definidos por un contrato y se utilizan para pasar colecciones de ese tipo de contrato entre un host y un complemento.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AddIn.Pipeline.CollectionAdapters> clase utiliza un <xref:System.AddIn.Contract.IListContract%601> interfaz para pasar colecciones, en ambas direcciones entre el host y el complemento. Se recomienda que utilice el <xref:System.AddIn.Pipeline.CollectionAdapters> clase en lugar de usar esta clase directamente en el código. Para obtener un ejemplo, vea [Tutorial: pasar colecciones entre Hosts y complementos](https://msdn.microsoft.com/library/b532c604-548e-4fab-b11c-377257dd0ee5).  
  
 Esta clase puede utilizarse para pasar objetos por referencia entre dominios de aplicación porque no se serializan los objetos.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit" Usage="iListContract.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <summary>Agrega un objeto a una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `item` parámetro debe ser de un tipo definido por el contrato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit" Usage="iListContract.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los objetos de una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool" Usage="iListContract.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en la colección.</param>
        <summary>Determina si un elemento concreto está en una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns><see langword="true" /> si <paramref name="item" /> está en la colección; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public int GetCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetCount" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCount () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCount();" />
      <MemberSignature Language="F#" Value="abstract member GetCount : unit -&gt; int" Usage="iListContract.GetCount " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número de elementos de una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns>Número de elementos de la colección.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumeratorContract">
      <MemberSignature Language="C#" Value="public System.AddIn.Contract.IEnumeratorContract&lt;T&gt; GetEnumeratorContract ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.AddIn.Contract.IEnumeratorContract`1&lt;!T&gt; GetEnumeratorContract() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetEnumeratorContract" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumeratorContract () As IEnumeratorContract(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::AddIn::Contract::IEnumeratorContract&lt;T&gt; ^ GetEnumeratorContract();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumeratorContract : unit -&gt; System.AddIn.Contract.IEnumeratorContract&lt;'T&gt;" Usage="iListContract.GetEnumeratorContract " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AddIn.Contract.IEnumeratorContract&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns>Enumerador <see cref="T:System.AddIn.Contract.IEnumeratorContract`1" /> que va a recorrer en iteración la colección.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsReadOnly">
      <MemberSignature Language="C#" Value="public bool GetIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member GetIsReadOnly : unit -&gt; bool" Usage="iListContract.GetIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si una colección <see cref="T:System.AddIn.Contract.IListContract`1" /> es de sólo lectura.</summary>
        <returns><see langword="true" /> si la colección es de solo lectura; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItem">
      <MemberSignature Language="C#" Value="public T GetItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T GetItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItem (index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T GetItem(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetItem : int -&gt; 'T" Usage="iListContract.GetItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener.</param>
        <summary>Devuelve el elemento en el índice especificado de una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns>Elemento que se encuentra en el índice especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AddIn.Contract.IListContract%601.GetItem%2A> método no quita el elemento en el índice especificado. Para quitar un elemento de la <xref:System.AddIn.Contract.IListContract%601> recopilación, uso el <xref:System.AddIn.Contract.IListContract%601.RemoveAt%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que el valor devuelto de <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int" Usage="iListContract.IndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento de la colección.</param>
        <summary>Devuelve el índice de un elemento concreto en una colección <see cref="T:System.AddIn.Contract.Collections.IListContract`1" />.</summary>
        <returns>Índice del elemento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay varios objetos del mismo tipo en la colección, este método identifica el índice del elemento que es la primera aparición del tipo especificado en la colección.  
  
 El <xref:System.AddIn.Contract.IListContract%601.GetItem%2A> método no quita el elemento en el índice especificado. Para quitar un elemento de la <xref:System.AddIn.Contract.IListContract%601> recopilación, uso el <xref:System.AddIn.Contract.IListContract%601.RemoveAt%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que el valor devuelto del método <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit" Usage="iListContract.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero en el que se va a insertar <paramref name="item" />.</param>
        <param name="item">Objeto <see cref="T:System.AddIn.Contract.IContract" /> que se va a insertar en la colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</param>
        <summary>Inserta un elemento en el índice especificado de una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a la <xref:System.AddIn.Contract.IListContract%601.Insert%2A> mover de método, los elementos que siguen al punto de inserción alojar el nuevo elemento. También se actualizan los índices de los elementos que se han movido. Para reemplazar un elemento en el índice especificado, use el <xref:System.AddIn.Contract.IListContract%601.SetItem%2A> método.  
  
 Para determinar si un <xref:System.AddIn.Contract.IListContract%601> colección es de solo lectura, llame a la <xref:System.AddIn.Contract.IListContract%601.GetIsReadOnly%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que el valor devuelto de <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
        <exception cref="T:System.NotSupportedException">La colección <see cref="T:System.AddIn.Contract.IListContract`1" /> es de sólo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool" Usage="iListContract.Remove item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a quitar de la colección.</param>
        <summary>Quita un elemento de una colección <see cref="T:System.AddIn.Contract.IListContract`1" /> de un tipo especificado.</summary>
        <returns>Es <see langword="true" /> si se quita un elemento; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe repetir este método para cada objeto de un tipo determinado en la colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit" Usage="iListContract.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">El índice del elemento que se va a quitar.</param>
        <summary>Quita el elemento situado en el índice especificado de una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a <xref:System.AddIn.Contract.IListContract%601.RemoveAt%2A>, los elementos que siguen al elemento quitado se mueve ocupar el hueco. También se actualizan los índices de los elementos que se han movido.  
  
 Para determinar si un <xref:System.AddIn.Contract.IListContract%601> colección es de solo lectura, llame a la <xref:System.AddIn.Contract.IListContract%601.GetIsReadOnly%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que el valor devuelto del método <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
        <exception cref="T:System.NotSupportedException">La colección <see cref="T:System.AddIn.Contract.IListContract`1" /> es de sólo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="public void SetItem (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetItem(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.SetItem(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetItem (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetItem(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member SetItem : int * 'T -&gt; unit" Usage="iListContract.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero donde se establece el elemento.</param>
        <param name="item">Elemento que se va a establecer en el índice especificado.</param>
        <summary>Establece el elemento en el índice especificado de una colección <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AddIn.Contract.IListContract%601.SetItem%2A> método establece el elemento en el índice especificado. Para agregar un elemento a la <xref:System.AddIn.Contract.IListContract%601> recopilación, uso el <xref:System.AddIn.Contract.IListContract%601.Insert%2A> método.  
  
 Para determinar si un <xref:System.AddIn.Contract.IListContract%601> colección es de solo lectura, llame a la <xref:System.AddIn.Contract.IListContract%601.GetIsReadOnly%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que el valor devuelto del método <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
        <exception cref="T:System.NotSupportedException">La colección <see cref="T:System.AddIn.Contract.IListContract`1" /> es de sólo lectura.</exception>
      </Docs>
    </Member>
  </Members>
</Type>