<Type Name="X509Certificate2" FullName="System.Security.Cryptography.X509Certificates.X509Certificate2">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="96cca76185ce48985a2bbb73af6d26ead1375f1a" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/04/2018" />
    <Meta Name="ms.locfileid" Value="34568199" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit X509Certificate2 extends System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  <TypeSignature Language="VB.NET" Value="Public Class X509Certificate2&#xA;Inherits X509Certificate" />
  <TypeSignature Language="C++ CLI" Value="public ref class X509Certificate2 : System::Security::Cryptography::X509Certificates::X509Certificate" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.X509Certificates.X509Certificate</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa un certificado X.509.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La estructura X.509 que se haya originado en la organización internacional de grupos de trabajo de normalización (ISO). Esta estructura se puede utilizar para representar distintos tipos de información, incluidos los atributos de identidad, los derechos y titular (permisos, edad, sexo, ubicación, afiliación etc.). Aunque las especificaciones de ISO son muy informativas en la propia estructura, la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> clase está diseñada para modelar los escenarios de uso definidos en las especificaciones emitidas por la infraestructura de clave pública en Internet Engineering Task Force (IETF), grupo de trabajo X.509 (PKIX). La más informativa de estas especificaciones es la RFC 3280, "[certificado y Certificate Revocation List (CRL) Profile](http://go.microsoft.com/fwlink/?LinkId=45286)."  
  
> [!IMPORTANT]
>  A partir de la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
>   
>  Para las aplicaciones que tienen como destino el [!INCLUDE[net_v452](~/includes/net-v452-md.md)] y versiones anteriores, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> clase no implementa la <xref:System.IDisposable> de interfaz y, por tanto, no tiene un `Dispose` método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto para cifrar y descifrar un archivo.  
  
 [!code-csharp[X509Certificate2#1](~/samples/snippets/csharp/VS_Snippets_CLR/x509certificate2/cs/program.cs#1)]
 [!code-vb[X509Certificate2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/x509certificate2/vb/program.vb#1)]  
  
 En el ejemplo siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea vacío <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto, a diferencia de los otros constructores para esta clase que usan la información de certificado de una matriz de bytes, un puntero o un archivo de certificado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando información de una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto utilizando la información de certificado de una matriz de bytes. La matriz de bytes puede ser (DER) codifica datos binarios o X.509 codificado base 64. La matriz de bytes también puede ser un PKCS7 (Authenticode) firmado archivo; el certificado del firmante se utiliza para crear el objeto.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `rawData`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(IntPtr handle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Puntero a un contexto de certificado en código no administrado. La estructura C se llama <see langword="PCCERT_CONTEXT" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando un identificador no administrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto usando un identificador para el contexto de certificado de la API criptográfica de Microsoft, `PCCERT_CONTEXT`. Tenga en cuenta que el llamador inmediato de este constructor requiere el permiso de código no administrado.  
  
> [!IMPORTANT]
>  El constructor crea una copia del contexto del certificado. No se da por supuesto que la estructura de contexto que pasó al constructor es válida; que se han liberado. Puede obtener una copia del elemento actual `PCCERT_CONTEXT` de la estructura de la <xref:System.Security.Cryptography.X509Certificates.X509Certificate.Handle%2A> propiedad, pero solo es válido durante la duración de la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (System.Security.Cryptography.X509Certificates.X509Certificate certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::Security::Cryptography::X509Certificates::X509Certificate ^ certificate);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="certificate">Un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> mediante un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una nueva instancia de la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> clase mediante un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando el nombre de un archivo de certificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto con un nombre de archivo de certificado. Admite la codificación binaria de (DER) o codificación Base64.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `fileName`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando una matriz de bytes y una contraseña.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor se utiliza con archivos PKCS12 (PFX) que contienen la clave privada del certificado. Llamar a este constructor con la contraseña correcta descifra la clave privada y guarda en un contenedor de claves.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `rawData`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando una matriz de bytes y una contraseña.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto mediante una matriz de bytes y una contraseña que se necesita para tener acceso a los datos del certificado. Se utiliza con archivos PKCS12 (PFX) que contienen la clave privada del certificado. Llamar a este constructor con la contraseña correcta descifra la clave privada y guarda en un contenedor de claves.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `rawData`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected X509Certificate2 (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; X509Certificate2(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Información de serialización necesaria para deserializar la nueva clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</param>
        <param name="context">Información contextual sobre el origen de la secuencia que se va a deserializar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando la información de serialización y el contexto de secuencia especificados.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando el nombre de un archivo de certificado y una contraseña.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor se utiliza con archivos PKCS12 (PFX) que contienen la clave privada del certificado. Llamar a este constructor con la contraseña correcta descifra la clave privada y guarda en un contenedor de claves.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `fileName`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando el nombre de un archivo de certificado y una contraseña para obtener acceso al certificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto mediante un nombre de archivo de certificado y una contraseña necesaria para tener acceso al certificado. Se utiliza con archivos PKCS12 (PFX) que contienen la clave privada del certificado. Llamar a este constructor con la contraseña correcta descifra la clave privada y guarda en un contenedor de claves.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `fileName`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando una matriz de bytes, una contraseña y una marca de almacenamiento de claves.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor se utiliza con archivos PKCS12 (PFX) que contienen la clave privada del certificado. Llamar a este constructor con la contraseña correcta descifra la clave privada y guarda para un Microsoft criptográficos API criptográfica proveedor de servicios (CSP).  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `rawData`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando una matriz de bytes, una contraseña y una marca de almacenamiento de claves.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> usando un byte del objeto de matriz, una contraseña que se necesita para tener acceso a los datos del certificado y una marca de almacenamiento de claves. Se utiliza con archivos PKCS12 (PFX) que contienen la clave privada del certificado. Llamar a este constructor con la contraseña correcta descifra la clave privada y guarda para un Microsoft criptográficos API criptográfica proveedor de servicios (CSP).  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `rawData`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando el nombre de un archivo de certificado, una contraseña y una marca de almacenamiento de claves.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `fileName`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando el nombre de un archivo de certificado, una contraseña para obtener acceso al certificado y una marca de almacenamiento claves.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> nombre de objeto mediante un archivo de certificado, una contraseña necesaria para tener acceso el certificado y una marca de almacenamiento de claves.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 Si crea un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certificado mediante la especificación de un almacén de archivo firmado PKCS7 para `fileName`, el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> se crea para el certificado que firmó el almacén en lugar de cualquiera de los certificados en el almacén.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Se genera un error con el certificado. Por ejemplo: - El archivo de certificado no existe.  - El certificado no es válido.  - La contraseña del certificado es incorrecta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para tener acceso a código no administrado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Archived">
      <MemberSignature Language="C#" Value="public bool Archived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archived" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived" />
      <MemberSignature Language="VB.NET" Value="Public Property Archived As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archived { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica que se almacena un certificado X.509.</summary>
        <value>Es <see langword="true" /> si se almacena el certificado y <see langword="false" /> si no se almacena el certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se establece únicamente en un certificado que está asociado a un almacén. Si se establece la propiedad y el certificado se agrega a un almacén de certificados, se conserva el valor. Si la propiedad se establece en un certificado que se recuperan de un almacén, inmediatamente se conserva el valor.  
  
 En un almacén X.509, los certificados archivados no se incluyen en el valor devuelto <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> objeto a menos que la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> propiedad está establecida en `true`. No hay ninguna actividad de archivo física se produce cuando el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> valor está establecido o.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Export">
      <MemberSignature Language="C#" Value="public override byte[] Export (System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Export(valuetype System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Export (contentType As X509ContentType, password As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ Export(System::Security::Cryptography::X509Certificates::X509ContentType contentType, System::String ^ password);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("X509ContentType.SerializedCert is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.Security.Cryptography.X509Certificates.X509ContentType" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As X509ExtensionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ Extensions { System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ExtensionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de objetos <see cref="T:System.Security.Cryptography.X509Certificates.X509Extension" />.</summary>
        <value>Un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las extensiones definidas en el formato del certificado X.509 v3 permiten datos adicionales que se incluirá en el certificado. Un número de extensiones se define por ISO en la definición de X.509 v3, así como PKIX en RFC 3280, "[certificado y Certificate Revocation List (CRL) Profile](http://go.microsoft.com/fwlink/?LinkId=45286)." Las extensiones comunes incluyen información sobre el uso de claves (<xref:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension>), identificadores de clave (<xref:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension>), las directivas, la información de revocación (extensión de punto de distribución CRL) y otros usos de certificados.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alias asociado de un certificado.</summary>
        <value>Nombre descriptivo del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nombres descriptivos son propiedades en el almacén de certificados X.509 que se pueden establecer. Se utilizan para permitirle al usuario asociar los alias a certificados de forma que pueden identificar fácilmente.  
  
 Si no existe ningún nombre descriptivo para el certificado, una cadena vacía ("") se devuelve.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCertContentType">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica el tipo de certificado que contiene una matriz de bytes o un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (rawData As Byte()) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12, Pkcs7 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <summary>Indica el tipo de certificado que contiene una matriz de bytes.</summary>
        <returns>Un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite detectar el tipo de certificado en un archivo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rawData" /> tiene longitud cero o es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (fileName As String) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <summary>Indica el tipo de certificado que contiene un archivo.</summary>
        <returns>Un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite detectar el tipo de certificado en un archivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el certificado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.IO.FileAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetNameInfo">
      <MemberSignature Language="C#" Value="public string GetNameInfo (System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetNameInfo(valuetype System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNameInfo (nameType As X509NameType, forIssuer As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetNameInfo(System::Security::Cryptography::X509Certificates::X509NameType nameType, bool forIssuer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("always return String.Empty for UpnName, DnsFromAlternativeName and UrlName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameType" Type="System.Security.Cryptography.X509Certificates.X509NameType" />
        <Parameter Name="forIssuer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nameType">Valor de <see cref="T:System.Security.Cryptography.X509Certificates.X509NameType" /> para el sujeto.</param>
        <param name="forIssuer">Es <see langword="true" /> si se va a incluir el nombre del emisor; en caso contrario, es <see langword="false" />.</param>
        <summary>Obtiene el sujeto y los nombres del emisor de un certificado.</summary>
        <returns>Nombre del certificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método siempre debe utilizarse en lugar de analizar el certificado, ya que muchos de los valores de nombre pueden encontrarse en varias ubicaciones. Con este método garantiza que se devuelve el nombre adecuado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrivateKey">
      <MemberSignature Language="C#" Value="public bool HasPrivateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasPrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasPrivateKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasPrivateKey { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> contiene una clave privada.</summary>
        <value>Es <see langword="true" /> si el objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> contiene una clave privada; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El contexto de certificado no es válido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Import">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> con la información proporcionada del certificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> con datos de una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para tomar una matriz de bytes sin procesar de un certificado X.509 y rellenar el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto con sus valores asociados.  
  
 Puesto que este método acepta una matriz de bytes, se puede utilizar únicamente para los tipos de certificado que no requieren una contraseña, incluido un certificado X.509 codificado base 64 o codificado mediante DER o los certificados PFX/PKCS12. Tenga en cuenta que los certificados PFX/PKCS12 pueden contener más de un certificado. En ese caso, se utiliza el primer certificado asociado con una clave privada o, si no se encuentra ninguna clave privada, se utiliza el primer certificado.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un certificado.</param>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> con información de un archivo de certificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa un archivo de certificado, como un archivo con una extensión .cer, que representa un certificado X.509 y rellena el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto con el certificado que contiene el archivo.  
  
 Este método puede utilizarse con varios tipos de certificados, incluidos los certificados X.509 codificado base 64 o codificado mediante DER, los certificados PFX/PKCS12 y certificados de firmante, como Authenticode. Tenga en cuenta que los certificados PFX/PKCS12 pueden contener más de un certificado. En ese caso, se utiliza el primer certificado asociado con una clave privada o, si no se encuentra ninguna clave privada, se utiliza el primer certificado.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando los datos de una matriz de bytes, una contraseña y una marca de almacenamiento de claves.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para tipos de certificado como los certificados X.509 codificado base 64 o codificado mediante DER o los certificados PFX/PKCS12. Tenga en cuenta que los certificados PFX/PKCS12 pueden contener más de un certificado. En ese caso, se utiliza el primer certificado asociado con una clave privada o, si no se encuentra ninguna clave privada, se utiliza el primer certificado.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Matriz de bytes que contiene los datos de un certificado X.509.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> utilizando los datos de una matriz de bytes, una contraseña y los marcadores para determinar cómo importar la clave privada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para rellenar un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> utilizando una contraseña para el certificado representado por la matriz de bytes del objeto. El <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> valor puede usarse para controlar dónde y cómo importar la clave privada.  
  
 Este método acepta una matriz de bytes y puede usarse para los tipos de certificado como los certificados X.509 codificado base 64 o codificado mediante DER o los certificados PFX/PKCS12. Tenga en cuenta que los certificados PFX/PKCS12 pueden contener más de un certificado. En ese caso, se utiliza el primer certificado asociado con una clave privada o, si no se encuentra ninguna clave privada, se utiliza el primer certificado.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> con información de un archivo de certificado, una contraseña y una marca de almacenamiento de claves.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Nota de seguridad** codificar nunca una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de certificado.</param>
        <param name="password">Contraseña requerida para obtener acceso a los datos del certificado X.509.</param>
        <param name="keyStorageFlags">Combinación bit a bit de los valores de enumeración que controlan dónde y cómo importar el certificado.</param>
        <summary>Rellena un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> con información de un archivo de certificado, una contraseña y un valor de <see cref="T:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar rellenar un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto con la información de un archivo de certificado, una contraseña y un <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> valor.  
  
> [!IMPORTANT]
>  Nunca codificar una contraseña en el código fuente.  Contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), un editor hexadecimal, o sencillamente abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="IssuerName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.IssuerName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IssuerName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ IssuerName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre distintivo del emisor de certificados.</summary>
        <value>Objeto <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" /> que contiene el nombre del emisor del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contiene el nombre de la entidad de certificación (CA) que emitió el certificado. Para obtener el nombre de un certificado, use el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo%2A> método.  
  
 El nombre completo del certificado es una representación textual del sujeto o emisor del certificado. Esta representación está compuesta de los atributos de nombre (por ejemplo, "CN = MyName, OU = miUnidadOrg, C = US").  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El contexto de certificado no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotAfter">
      <MemberSignature Language="C#" Value="public DateTime NotAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotAfter" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotAfter As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotAfter { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la fecha en hora local después de la cual un certificado ya no es válido.</summary>
        <value>Objeto <see cref="T:System.DateTime" /> que representa la fecha de expiración del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica una fecha de expiración en el que el certificado deja de ser válido.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotBefore">
      <MemberSignature Language="C#" Value="public DateTime NotBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotBefore" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotBefore As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotBefore { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la fecha en hora local en la que un certificado entra en vigor.</summary>
        <value>Objeto <see cref="T:System.DateTime" /> que representa la fecha efectiva del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica la fecha en que el certificado empieza a ser válido.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="PrivateKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.AsymmetricAlgorithm PrivateKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.AsymmetricAlgorithm PrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateKey As AsymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::AsymmetricAlgorithm ^ PrivateKey { System::Security::Cryptography::AsymmetricAlgorithm ^ get(); void set(System::Security::Cryptography::AsymmetricAlgorithm ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.AsymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> que representa la clave privada asociada a un certificado.</summary>
        <value>Objeto <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> que es un proveedor de servicios criptográficos RSA o DSA.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actualmente esta propiedad admite sólo claves RSA o DSA, por lo que devuelve un <xref:System.Security.Cryptography.RSACryptoServiceProvider> o un <xref:System.Security.Cryptography.DSACryptoServiceProvider> objeto. Si ninguna clave privada asociada al certificado, devuelve `null`.  
  
> [!WARNING]
>  Si establece esta propiedad en `null` o a otra clave sin eliminarla primero, se deja un archivo de clave privada en el disco.  
  
 Para eliminar correctamente la clave privada asociada con esta propiedad, establezca `PersistKeyInCsp` a `false`y, a continuación, llame a la <xref:System.Security.Cryptography.AsymmetricAlgorithm.Clear%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El valor de la clave no es RSA ni DSA o la clave es ilegible.</exception>
        <exception cref="T:System.ArgumentNullException">El valor que se establece para esta propiedad es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite el algoritmo de clave para esta clave privada.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Las claves X.509 no coinciden.</exception>
        <exception cref="T:System.ArgumentException">La clave del proveedor de servicios criptográficos es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.PublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.PublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PublicKey As PublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::PublicKey ^ PublicKey { System::Security::Cryptography::X509Certificates::PublicKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.PublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" /> asociado a un certificado.</summary>
        <value>Un objeto <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve un <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> objeto, que contiene el identificador de objeto (<xref:System.Security.Cryptography.Oid>) que representa el algoritmo de clave pública, los parámetros codificados ASN.1 y el valor de clave codificado ASN.1.  
  
 También puede obtener la clave como un <xref:System.Security.Cryptography.AsymmetricAlgorithm> objeto haciendo referencia a la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> propiedad. Esta propiedad admite sólo claves RSA o DSA, por lo que devuelve un <xref:System.Security.Cryptography.RSACryptoServiceProvider> o un <xref:System.Security.Cryptography.DSACryptoServiceProvider> objeto que representa la clave pública.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El valor de la clave no es RSA ni DSA o la clave es ilegible.</exception>
      </Docs>
    </Member>
    <Member MemberName="RawData">
      <MemberSignature Language="C#" Value="public byte[] RawData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] RawData" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.RawData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawData As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ RawData { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los datos sin procesar de un certificado.</summary>
        <value>Datos sin procesar del certificado en forma de matriz de bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el estado de un objeto <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para restablecer el estado del certificado. También libera todos los recursos asociados con el certificado.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="SerialNumber">
      <MemberSignature Language="C#" Value="public string SerialNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SerialNumber" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SerialNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerialNumber As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SerialNumber { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de serie de un certificado en forma de cadena hexadecimal big-endian.</summary>
        <value>El número de serie del certificado como una cadena hexadecimal de big-endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de serie del certificado forma parte del protocolo X.509 original. El número de serie es un número único emitido por el emisor del certificado, conocida también como la entidad de certificación (CA).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignatureAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ SignatureAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el algoritmo utilizado para crear la firma de un certificado.</summary>
        <value>Devuelve el identificador de objeto (<see cref="T:System.Security.Cryptography.Oid" />) del algoritmo de firma.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El identificador de objeto (<xref:System.Security.Cryptography.Oid>) identifica el tipo de algoritmo de firma utilizado por el certificado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubjectName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SubjectName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubjectName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ SubjectName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre distintivo del sujeto de un certificado.</summary>
        <value>Objeto <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" /> que representa el nombre del sujeto del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre distintivo del sujeto es el nombre del usuario del certificado. El nombre distintivo del certificado es una representación textual del sujeto o emisor del certificado. Esta representación está compuesta de los atributos de nombre, por ejemplo, "CN = MyName, OU = miUnidadOrg, C = US".  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El contexto de certificado no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Thumbprint">
      <MemberSignature Language="C#" Value="public string Thumbprint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Thumbprint" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Thumbprint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thumbprint As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Thumbprint { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la huella digital de un certificado.</summary>
        <value>Huella digital del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La huella digital se genera dinámicamente utilizando el algoritmo SHA1 y no existe físicamente en el certificado. Puesto que la huella digital es un valor único para el certificado, normalmente se utiliza para buscar un certificado concreto en un almacén de certificados.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Muestra un certificado X.509 en formato de texto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Muestra un certificado X.509 en formato de texto.</summary>
        <returns>Información del certificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que con todos los `ToString` métodos, los resultados podrían no ser coherentes en las versiones de .NET Framework, por lo que no se deben analizar los resultados del método para el contenido. Utilice las propiedades de la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto para obtener información precisa sobre el contenido o usar el <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString%2A> método para obtener información sobre el certificado.  
  
 Este método muestra el certificado en formato de texto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString (bool verbose);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString(bool verbose) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString (verbose As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString(bool verbose);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verbose" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="verbose">Es <see langword="true" /> para mostrar la clave pública, clave privada, extensiones, etc.; es <see langword="false" /> para mostrar información que es similar a la clase <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />, incluso la huella digital, el número de serie, el sujeto y los nombres del emisor, etc.</param>
        <summary>Muestra un certificado X.509 en formato de texto.</summary>
        <returns>Información del certificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que con todos los `ToString` métodos, los resultados podrían no ser coherentes en las versiones de .NET Framework, por lo que no se deben analizar los resultados del método para el contenido. Utilice las propiedades de la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> objeto que se va a obtener información precisa.  
  
 Este método muestra el certificado en formato de texto. Si el `verbose` parámetro se establece en `true`, la presentación del texto incluye la clave pública, clave privada y extensiones. Si `verbose` se establece en `false`, la presentación del texto incluye aquellos campos disponibles desde el certificado X.509, incluidos la huella digital, número de serie, los nombres de asunto y emisor y la información de fecha de validez.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Verify">
      <MemberSignature Language="C#" Value="public bool Verify ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Verify() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Verify" />
      <MemberSignature Language="VB.NET" Value="Public Function Verify () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Verify();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("by default this depends on the incomplete X509Chain")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Realiza una validación de la cadena X.509 mediante la directiva de la validación básica.</summary>
        <returns>Es <see langword="true" /> si la validación se realiza correctamente; es <see langword="false" /> si en la validación se produce un error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método construye una cadena simple para el certificado y aplica la directiva base a esa cadena. Si necesita más información sobre un error, validar el certificado utilizando directamente la <xref:System.Security.Cryptography.X509Certificates.X509Chain> objeto.  
  
 Tenga en cuenta que el motor del encadenamiento predeterminado se puede invalidar mediante la <xref:System.Security.Cryptography.CryptoConfig> clase. En Microsoft Windows Server 2003, el motor predeterminado se ajusta a la especificación descrita en RFC3280 "[certificado y Certificate Revocation List (CRL) Profile](http://go.microsoft.com/fwlink/?LinkId=45286)."  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre el almacén de certificados del usuario actual, selecciona sólo los certificados activos y permite al usuario seleccionar uno o varios certificados. En el ejemplo, a continuación, escribe la información del certificado en la consola.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la versión del formato X.509 de un certificado.</summary>
        <value>Formato del certificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hay varias versiones de los certificados X.509. Esta propiedad identifica qué formato utiliza el certificado. Por ejemplo, "3" se devuelve para un certificado de la versión 3.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo ejecutable de línea de comandos que toma un archivo de certificado como argumento e imprime diversas propiedades del certificado en la consola.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">No se puede leer el certificado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>