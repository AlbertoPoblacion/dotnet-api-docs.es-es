<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="60e83f9b9882129bcc346f7ccc99547faee526b2" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33682943" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPatternRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPatternRange" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa un tramo de texto continuo en un contenedor <see cref="T:System.Windows.Automation.TextPattern" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Automation.Text.TextPatternRange> puede representar un punto de inserción, un subconjunto o todo el texto en un <xref:System.Windows.Automation.TextPattern> contenedor.  
  
 A <xref:System.Windows.Automation.Text.TextPatternRange> ya no serán válidos si se produce alguno de los siguientes valores: el texto en el <xref:System.Windows.Automation.TextPattern> cambios en el contenedor debido a alguna actividad del usuario, o la <xref:System.Windows.Automation.ValuePattern.SetValue%2A> método de <xref:System.Windows.Automation.ValuePattern> se utiliza para cambiar mediante programación el valor del texto en el <xref:System.Windows.Automation.TextPattern> contenedor.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Agrega a la colección de texto resaltado en un contenedor de texto que admite varias selecciones discontinuas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El punto de inserción de texto se mueve al área de la nueva selección.  
  
 Proporciona un intervalo de texto degenerado, mueve el punto de inserción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si el proveedor de texto no admite varias selecciones discontinuas (por ejemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> tiene un valor de <see langword="Multiple" />).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera una <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> nueva idéntica a la <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> original y hereda todas sus propiedades.</summary>
        <returns>Intervalo de texto nuevo. Nunca se devuelve una referencia nula (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como alternativa, cree un nuevo <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> desde el <xref:System.Windows.Automation.TextPattern> y mover los dos extremos para que se correspondan con los extremos del intervalo de texto original.  
  
 El nuevo intervalo se puede manipular independientemente del original.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromChild(System.Windows.Automation.AutomationElement)" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromPoint(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As TextPatternRange) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Text::TextPatternRange ^ range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">Intervalo de texto que se debe comparar.</param>
        <summary>Devuelve un valor <see cref="T:System.Boolean" /> que indica si el tramo (del extremo <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> al extremo <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) de un intervalo de texto es igual que otro intervalo de texto.</summary>
        <returns>
          <see langword="true" /> si el tramo de ambos intervalos de texto es idéntico; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si el intervalo que se compara no proviene del mismo proveedor de texto.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Extremo <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> del llamador.</param>
        <param name="targetRange">Intervalo de destino para la comparación.</param>
        <param name="targetEndpoint">Extremo <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> o <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> del destino.</param>
        <summary>Devuelve un <see cref="T:System.Int32" /> que indica si dos intervalos de texto tienen los extremos idénticos.</summary>
        <returns>Devuelve un valor negativo si el punto de conexión del llamador se produce en el texto antes que en el punto de conexión de destino.  
  
 Devuelve cero si el extremo del llamador está en la misma ubicación que el extremo de destino.  
  
 Devuelve un valor positivo si el punto de conexión del llamador se produce en el texto después que en el punto de conexión de destino.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comparando los extremos inicial y finales del mismo intervalo de texto puede identificar si un intervalo de texto degenerado o si los extremos están en el orden de flujo de texto lógico.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Si el rango es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">Si el intervalo es de otro contenedor.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Unidad textual.</param>
        <summary>Expande el intervalo de texto a la <see cref="T:System.Windows.Automation.Text.TextUnit" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el intervalo ya es una cantidad exacta de las unidades especificadas permanece sin cambios.  
  
 En orden para el <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> método se ejecute correctamente, se lleva a cabo una secuencia de acciones en segundo plano.  
  
1.  El intervalo de texto se normaliza; es decir, se contrae, el intervalo de texto en un intervalo degenerado en el <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> punto de conexión, que realiza el <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> extremo superfluo. Este paso es necesario para evitar la ambigüedad en situaciones donde se extiende por un intervalo de texto `unit` límites; por ejemplo, "{la U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) está incrustada en el texto" donde "{" y "}" es extremos del intervalo de texto.  
  
2.  El intervalo resultante se mueve hacia atrás en <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>, al principio del límite `unit` solicitado.  
  
3.  El intervalo resultante se mueve hacia delante o hacia atrás en <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>, en función del número solicitado de límites `unit`.  
  
4.  A continuación, el intervalo se expande desde un estado de intervalo degenerado moviendo el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> en función de un límite `unit` solicitado.  
  
 ![Ajustes de intervalo mediante Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo mediante Move & ExpandToEnclosingUnit")  
Ejemplos de cómo se ajusta un intervalo de texto para Move() y ExpandToEnclosingUnit()  
  
> [!NOTE]
>  Estos pasos son necesarios, ya que es común para un lector de pantalla leer una palabra completa, una frase o un párrafo completo en el punto de inserción o en cualquier posición del cursor virtual.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> respeta el texto oculto y visible. El cliente de automatización de la interfaz de usuario pueda comprobar la <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidad del texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> aplaza al siguiente mayor <xref:System.Windows.Automation.Text.TextUnit> if compatible el determinado <xref:System.Windows.Automation.Text.TextUnit> no es compatible con el control.  
  
 El orden, de unidad de menor a mayor, se muestra a continuación.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As AutomationTextAttribute, value As Object, backward As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindAttribute(System::Windows::Automation::AutomationTextAttribute ^ attribute, System::Object ^ value, bool backward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">Atributo que se debe buscar.</param>
        <param name="value">Valor del atributo que se debe buscar. Este valor debe coincidir con el tipo especificado para el atributo.</param>
        <param name="backward">
          <see langword="true" /> si debe devolverse el último intervalo de texto en lugar del primero; en caso contrario, <see langword="false" />.</param>
        <summary>Devuelve un subconjunto del intervalo de texto que tiene el valor de atributo especificado.</summary>
        <returns>Intervalo de texto que tiene un atributo y un valor de atributo correspondiente; en caso contrario, null (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ningún diferenciación entre texto oculto y visible. Pueden usar los clientes de automatización de interfaz de usuario <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para comprobar la visibilidad del texto.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para buscar en todo el documento.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">Cadena de texto que se debe buscar.</param>
        <param name="backward">
          <see langword="true" /> si debe devolverse el último intervalo de texto en lugar del primero; en caso contrario, <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> si no se debe distinguir entre mayúsculas y minúsculas; en caso contrario, <see langword="false" />.</param>
        <summary>Devuelve un subconjunto del intervalo de texto que contiene el texto especificado.</summary>
        <returns>Intervalo de texto que coincide con el texto especificado; en caso contrario, null (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ningún diferenciación entre texto oculto y visible. Pueden usar los clientes de automatización de interfaz de usuario <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para comprobar la visibilidad del texto.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para buscar en todo el documento.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As AutomationTextAttribute) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(System::Windows::Automation::AutomationTextAttribute ^ attribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Atributo de texto.</param>
        <summary>Devuelve el valor del atributo especificado en todo el intervalo de texto.</summary>
        <returns>Devuelve el valor del atributo especificado. Por ejemplo, GetAttributeValue (TextPattern.FontNameAttribute) devolvería una cadena que representa el nombre de la fuente, si es único, del intervalo de texto, mientras que GetAttributeValue (TextPattern.IsItalicAttribute) devolvería un valor booleano.  
  
 Devuelve <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> si el valor del atributo especificado varía respecto al intervalo de texto.  
  
 Devuelve <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> si el proveedor o el control no admiten el atributo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ningún diferenciación entre texto oculto y visible. Pueden usar los clientes de automatización de interfaz de usuario <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para comprobar la visibilidad del texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si el atributo especificado no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Rect()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Rect&gt; ^ GetBoundingRectangles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera una colección de rectángulos delimitadores para cada línea de texto total o parcialmente visible en un intervalo de texto.</summary>
        <returns>Matriz de rectángulos delimitadores para cada línea de texto completa o parcial en un intervalo de texto.  
  
 Matriz vacía para un intervalo de texto degenerado.  
  
 Matriz vacía para un intervalo de texto cuyas coordenadas de pantalla lo colocan completamente fuera de la pantalla, lo desplazan fuera de la vista o lo ocultan con una ventana superpuesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As AutomationElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::AutomationElement ^&gt; ^ GetChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera una colección de todos los objetos incrustados que se encuentran en el intervalo de texto.</summary>
        <returns>Colección de todos los objetos secundarios que se encuentran dentro del intervalo. Los elementos secundarios superpuestos en el intervalo que este no enmarca completamente también se incluyen en la colección.  
  
 Devuelve una colección vacía si no hay ningún objeto secundario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As AutomationElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::AutomationElement ^ GetEnclosingElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el <see cref="T:System.Windows.Automation.AutomationElement" /> más interno que enmarca el intervalo de texto.</summary>
        <returns>Elemento más interno que enmarca el llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Incluye <xref:System.Windows.Automation.AutomationElement>, que suele ser el proveedor de texto que proporciona el intervalo de texto. Sin embargo, si el proveedor de texto admite elementos secundarios como tablas o hipervínculos, el elemento envolvente podría ser un descendiente del proveedor de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">Longitud máxima de la cadena que se debe devolver. Use <c>-1</c> si no se requiere ningún límite.</param>
        <summary>Devuelve el texto sin formato del intervalo de texto.</summary>
        <returns>Texto sin formato del intervalo de texto, posiblemente truncado según el <paramref name="maxLength" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> respeta el texto oculto y visible. El cliente de automatización de la interfaz de usuario pueda comprobar la <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidad del texto.  
  
 Si `maxLength` es mayor que la longitud del intervalo de texto del llamador, la cadena devuelta será el texto sin formato del intervalo de texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> no se verán afectados por el orden de los puntos de conexión en el flujo de texto; siempre devolverá el texto entre los extremos de inicio y finalización del intervalo de texto en el orden de flujo de texto lógico.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si <paramref name="maxLength" /> es menor que -1.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">Límite de la unidad de texto.</param>
        <param name="count">Número de unidades de texto que se deben mover. Un valor positivo mueve el intervalo de texto hacia adelante, un valor negativo mueve el intervalo de texto hacia atrás y 0 no tiene ningún efecto.</param>
        <summary>Mueve el intervalo de texto el número especificado de unidades de texto.</summary>
        <returns>Número de unidades que se movieron realmente. Puede ser menor que el número solicitado si cualquiera de los nuevos extremos del intervalo de texto es mayor o menor que los extremos de <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando es necesario atravesar el contenido de un intervalo de texto, se realizan en segundo plano una serie de pasos para que el método <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> pueda ejecutarse correctamente.  
  
1.  El intervalo de texto se normaliza, es decir, se contrae, en un intervalo degenerado en el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , y el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> queda superfluo. Este paso es necesario para evitar la ambigüedad en situaciones donde se extiende por un intervalo de texto `unit` límites; por ejemplo, "{la U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) está incrustada en el texto" donde "{" y "}" es extremos del intervalo de texto.  
  
2.  El intervalo resultante se mueve hacia atrás en <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>, al principio del límite `unit` solicitado.  
  
3.  El intervalo resultante se mueve hacia delante o hacia atrás en <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>, en función del número solicitado de límites `unit`.  
  
4.  A continuación, el intervalo se expande desde un estado de intervalo degenerado moviendo el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> en función de un límite `unit` solicitado.  
  
 ![Ajustes de intervalo mediante Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo mediante Move & ExpandToEnclosingUnit")  
Ejemplos de cómo se ajusta un intervalo de texto para Move() y ExpandToEnclosingUnit()  
  
 El contenido textual (o texto interno) de un contenedor de texto y un objeto incrustado, como un hipervínculo o una celda de tabla, se expone como una secuencia de texto continua única en las vistas de control y contenido del árbol de [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]. Los límites del objeto se ignoran. Si un cliente de Automatización de la interfaz de usuario recupera el texto con el objetivo de realizar alguna declaración, interpretarlo o analizarlo de alguna manera, el intervalo de texto se debe comprobar en los casos especiales (por ejemplo, una tabla con contenido textual u otros objetos incrustados). Esto puede realizarse mediante una llamada a <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> para obtener un <xref:System.Windows.Automation.AutomationElement> para cada objeto incrustado y, a continuación, llamar a <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> para obtener un intervalo de texto para cada elemento; Esto se realiza de forma recursiva hasta que se ha recuperado todo el contenido textual.  
  
 ![Intervalos de texto ocupados por objetos incrustados. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto ocupados por objetos incrustados.")  
Ejemplo de una secuencia de texto con objetos incrustados y sus intervalos  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> respeta el texto oculto y visible. El cliente de automatización de la interfaz de usuario pueda comprobar la <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidad del texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> aplaza al siguiente mayor <xref:System.Windows.Automation.Text.TextUnit> if compatible el determinado <xref:System.Windows.Automation.Text.TextUnit> no es compatible con el control.  
  
 El orden, de unidad de menor a mayor, se muestra a continuación.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  El texto no se modifica de alguna forma, como el intervalo de texto apenas abarca una parte distinta del texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">punto de conexión que se debe mover.</param>
        <param name="targetRange">Otro intervalo del mismo proveedor de texto.</param>
        <param name="targetEndpoint">Extremo en el otro intervalo.</param>
        <summary>Mueve un punto de conexión de un intervalo de texto al punto de conexión especificado de un segundo intervalo de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el punto de conexión que se va a mover cruza el otro extremo del mismo intervalo de texto, a continuación, ese otro punto de conexión se mueve también, lo que en un intervalo degenerado y se garantiza el orden correcto de los puntos de conexión (es decir, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> siempre es menor o igual que <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">punto de conexión que se debe mover.</param>
        <param name="unit">Unidad textual que se debe mover.</param>
        <param name="count">Número de unidades para mover. Un recuento positivo mueve el extremo hacia delante. Un recuento negativo lo mueve hacia atrás. Un recuento de 0 no tiene ningún efecto.</param>
        <summary>Mueve un extremo del intervalo de texto el número especificado de <see cref="T:System.Windows.Automation.Text.TextUnit" /> dentro del intervalo del documento.</summary>
        <returns>Número de unidades que realmente se mueven. Puede ser menor que el número solicitado si al mover el punto de conexión se pasa por el principio o el final del documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando es necesario atravesar el contenido de un intervalo de texto, se realizan en segundo plano una serie de pasos para que el método <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> pueda ejecutarse correctamente.  
  
1.  El intervalo de texto se normaliza, es decir, se contrae, en un intervalo degenerado en el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , y el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> queda superfluo. Este paso es necesario para evitar la ambigüedad en situaciones donde se extiende por un intervalo de texto `unit` límites; por ejemplo, "{la U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) está incrustada en el texto" donde "{" y "}" es extremos del intervalo de texto.  
  
2.  El intervalo resultante se mueve hacia atrás en <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>, al principio del límite `unit` solicitado.  
  
3.  A continuación, el intervalo se expande desde un estado de intervalo degenerado moviendo el extremo <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> en función de un límite `unit` solicitado.  
  
 ![Ajustes de intervalo mediante Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo mediante Move & ExpandToEnclosingUnit")  
Ejemplos de cómo se ajusta un intervalo de texto para Move() y ExpandToEnclosingUnit()  
  
 El contenido textual (o texto interno) de un contenedor de texto y un objeto incrustado, como un hipervínculo o una celda de tabla, se expone como una secuencia de texto continua única en las vistas de control y contenido del árbol de [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]. Los límites del objeto se ignoran. Si un cliente de Automatización de la interfaz de usuario recupera el texto con el objetivo de realizar alguna declaración, interpretarlo o analizarlo de alguna manera, el intervalo de texto se debe comprobar en los casos especiales (por ejemplo, una tabla con contenido textual u otros objetos incrustados). Esto puede realizarse mediante una llamada a <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> para obtener un <xref:System.Windows.Automation.AutomationElement> para cada objeto incrustado y, a continuación, llamar a <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> para obtener un intervalo de texto para cada elemento; Esto se realiza de forma recursiva hasta que se ha recuperado todo el contenido textual.  
  
 ![Intervalos de texto ocupados por objetos incrustados. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto ocupados por objetos incrustados.")  
Ejemplo de una secuencia de texto con objetos incrustados y sus intervalos  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A> aplaza al siguiente mayor <xref:System.Windows.Automation.Text.TextUnit> if compatible el determinado <xref:System.Windows.Automation.Text.TextUnit> no es compatible con el control.  
  
 El orden, de unidad de menor a mayor, se muestra a continuación.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita una sección resaltada de texto, que corresponde a los extremos <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> y <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> del intervalo de texto que realiza la llamada, de una colección de texto resaltado existente en un contenedor de texto que admite varias selecciones discontinuas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El punto de inserción de texto se moverá al área del resaltado quitado.  
  
 Proporciona un intervalo de texto degenerado se moverá el punto de inserción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si el proveedor de texto no admite varias selecciones discontinuas (por ejemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> tiene un valor de <see langword="Multiple" />).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" /> si el control de texto se debe desplazar de forma que el intervalo de texto quede alineado con la parte superior de la ventanilla; <see langword="false" /> si debe alinearse con la parte inferior de la ventanilla.</param>
        <summary>Hace que el control de texto se desplace verticalmente hasta que el intervalo de texto esté visible en la ventanilla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A> respeta el texto oculto y visible. El cliente de automatización de la interfaz de usuario pueda comprobar la <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> de visibilidad del texto. Si el intervalo de texto está oculto, se desplazará el control de texto sólo si el texto oculto tiene un anclaje en la ventanilla.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si el control no admite el desplazamiento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resalta el texto en el control de texto que corresponde a los extremos <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> y <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> del intervalo de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se proporciona un intervalo de texto degenerado, el punto de inserción de texto se moverá a la <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> extremo del intervalo de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se produce cuando la selección de texto no es compatible con el control de texto.</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="M:System.Windows.Automation.SelectionItemPattern.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TextPattern As TextPattern" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::TextPattern ^ TextPattern { System::Windows::Automation::TextPattern ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Windows.Automation.TextPattern" /> asociado al intervalo de texto.</summary>
        <value>Proveedor del texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>