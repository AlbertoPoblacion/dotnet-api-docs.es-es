<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7864ee93fd1509c39ec215c7525d2b430580d936" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55341525" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Ofrece un cursor de solo avance para enumerar los mensajes de una cola de mensajes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageEnumerator> para la interacción dinámica con los mensajes en una cola. Métodos disponibles a través de la <xref:System.Messaging.MessageQueue> clase puede devolver un <xref:System.Messaging.MessageEnumerator> señalando a una lista dinámica de los mensajes en la cola o una matriz que contiene una copia en un momento dado (una instantánea) de la cola en el momento en el método especificado se llamó.  
  
 A diferencia de una instantánea estática, un enumerador permite modificar la colección. Mediante un <xref:System.Messaging.MessageEnumerator>, puede quitar los mensajes de la cola y el cambio se refleja inmediatamente en la cola.  
  
 Un enumerador no elimina los mensajes de la cola cuando consulta la cola. Devuelve información sobre el mensaje en la posición actual del cursor, pero deja el mensaje en la cola.  
  
 Un <xref:System.Messaging.MessageEnumerator> es un cursor, inicializado en el encabezado de una lista dinámica. El orden de lista es el mismo que el orden de los mensajes en la cola, según la prioridad del mensaje. Puede mover el cursor hasta el primer mensaje en la cola mediante una llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Una vez inicializado el enumerador, puede usar <xref:System.Messaging.MessageEnumerator.MoveNext%2A> para avanzar paso a paso a través de los mensajes restantes. Puede especificar si se debe esperar un mensaje esté disponible pasando un tiempo de espera en el <xref:System.Messaging.MessageEnumerator.MoveNext%2A> método.  
  
 Dado que el enumerador es dinámico, el enumerador puede tener acceso a un mensaje que se anexa más allá de la posición del cursor actual (por ejemplo, debido a la prioridad baja). Un mensaje que se inserta antes de que no se puede tener acceso a la posición del cursor actual. No es posible ir hacia atrás con un <xref:System.Messaging.MessageEnumerator>. Un cursor permite el movimiento de solo avance. El <xref:System.Messaging.MessageEnumerator.Reset%2A> método le permite colocar el cursor al principio de la cola.  
  
 Las instancias de <xref:System.Messaging.MessageEnumerator> para una cola determinada trabajar de forma independiente. Puede crear dos <xref:System.Messaging.MessageEnumerator> instancias que se aplican a la misma cola. Los cambios que otro <xref:System.Messaging.MessageEnumerator> facilita a los mensajes en la cola se reflejarán inmediatamente en un segundo enumerador si el segundo enumerador se coloca antes de la primera. Sin embargo, si dos enumeradores tienen la misma posición y uno de ellos quita el mensaje en esa posición, se produce una excepción si el otro enumerador intenta obtener el valor de la <xref:System.Messaging.MessageEnumerator.Current%2A> propiedad en el mensaje eliminado ahora.  
  
> [!NOTE]
>  Si crea una instancia de <xref:System.Messaging.MessageQueue> con <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> establecido en `true`, ninguna otra aplicación puede modificar los mensajes del enumerador mientras tenga la conexión a la cola.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene una lista dinámica de los mensajes en una cola y cuenta todos los mensajes con el <xref:System.Messaging.Message.Priority%2A> propiedad establecida en <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos asociados al enumerador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema operativo retiene un identificador abierto en la cola durante la vigencia del cursor. Cuando haya terminado de trabajar con el enumerador, llame a <xref:System.Messaging.MessageEnumerator.Close%2A> para liberar los recursos asociados con el identificador.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Messaging.Message" /> actual al que apunta este enumerador.</summary>
        <value>Mensaje actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea el enumerador, apunta al principio de la cola, en una ubicación delante del primer mensaje. En este caso, <xref:System.Messaging.MessageEnumerator.Current%2A> no es válido y se iniciará una excepción si se tiene acceso a. Debe llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> para colocar el cursor en el primer mensaje de la cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Llamó a <see cref="P:System.Messaging.MessageEnumerator.Current" /> antes de la primera llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. El cursor se encuentra ubicado delante del primer elemento de la enumeración del mensaje.  
  
O bien 
Llamó a <see cref="P:System.Messaging.MessageEnumerator.Current" /> después de que una llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> devolviera <see langword="false" /> (lo que indicaba que el cursor está situado después del último elemento de la enumeración del mensaje).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El mensaje al que está apuntando actualmente el enumerador ya no existe. Puede que se hayan eliminado.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el indicador de cursor de Message Queuing nativo que se utiliza para explorar los mensajes de la cola.</summary>
        <value>Indicador de cursor nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contiene el identificador nativo de la enumeración. Cuando haya terminado de trabajar con el enumerador, llame a <xref:System.Messaging.MessageEnumerator.Close%2A> para liberar este recurso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">El indicador no existe.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera los recursos que usa <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Messaging.MessageEnumerator.Dispose%2A> permite a los recursos utilizados por el <xref:System.Messaging.MessageEnumerator> que reasignarse para otros fines. Para obtener más información acerca de <xref:System.Messaging.MessageEnumerator.Dispose%2A>, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Limpiar recursos no administrados</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.Messaging.MessageEnumerator" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público <xref:System.Messaging.MessageEnumerator.Dispose%2A> método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Messaging.MessageEnumerator> hace referencia. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see langword="Dispose(Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see langword="Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementar un método Dispose</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Limpiar recursos no administrados</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos mantenidos por el enumerador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Este método invalida <xref:System.Object.Finalize>. Código de la aplicación no debe llamar a este método; método Finalize de un objeto se invoca automáticamente durante la recolección de elementos no utilizados, a menos que se ha deshabilitado la finalización por el recolector de elementos no utilizados mediante una llamada a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.

Para obtener más información, consulte [métodos de finalización y destructores](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md), y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desplaza el enumerador al siguiente mensaje de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el enumerador al siguiente mensaje de la cola si hay alguno disponible.</summary>
        <returns><see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente mensaje; <see langword="false" /> si el enumerador alcanzó el final de la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga vuelve inmediatamente si no hay ningún mensaje en la cola. Hay otra sobrecarga que espera un determinado <xref:System.TimeSpan> para que llegue un mensaje.  
  
 Si un mensaje no está disponible actualmente porque la cola está vacía o porque se ha movido más allá del último elemento de la colección, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> devuelve `false` al método de llamada.  
  
 Tras su creación, un enumerador conceptualmente se coloca delante del primer mensaje de la cola y la primera llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pone el primer mensaje de la cola a la vista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se ha producido una excepción específica para Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> que se va a esperar hasta que un mensaje se encuentre disponible si el enumerador se coloca al final de la cola.</param>
        <summary>Desplaza el enumerador al siguiente mensaje de la cola. Si el enumerador se coloca al final de la cola, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> espera hasta que haya un mensaje disponible o expire el tiempo de espera.</summary>
        <returns><see langword="true" /> si el enumerador avanzó satisfactoriamente hasta el siguiente mensaje; <see langword="false" /> si el enumerador llegó al final de la cola y un mensaje no pasa a estar disponible en el plazo de tiempo especificado por el parámetro <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espera a que esta sobrecarga si no hay ningún mensaje en la cola o si el cursor ha llegado al final de la cola. Si un mensaje no está disponible actualmente porque la cola está vacía o porque se ha movido más allá del último elemento de la colección, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> espera el tiempo de espera especificado.  
  
 Si el cursor ya está al final de la cola, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> sólo devuelve `true` si el nuevo mensaje llega en el intervalo de tiempo especificado, tiene una prioridad menor que todos los mensajes actualmente en la cola y se coloca al final de la cola. Una sobrecarga sin parámetros devuelve inmediatamente si no hay más mensajes están en la cola.  
  
 Tras su creación, un enumerador conceptualmente se coloca delante del primer mensaje de la enumeración y la primera llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aporta el primer mensaje de la enumeración en la vista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro de tiempo de espera no es válido. Podría representar un número negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se ha producido una excepción específica para Message Queuing.  
  
O bien 
El tiempo de espera ha expirado.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita el mensaje actual de la cola y lo devuelve a la aplicación que realiza la llamada. Al quitar el mensaje, éste se elimina de la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento descrito para estas sobrecargas es aplicable solo si el <xref:System.Messaging.MessageEnumerator> instancia se recupera utilizando la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. No use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> para recuperar una instancia de <xref:System.Messaging.MessageEnumerator> como este método está desusado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita el mensaje actual de una cola transaccional o no transaccional y lo devuelve a la aplicación que realiza la llamada. No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual.  
  
 Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si se llama a esta sobrecarga en una cola transaccional, Message Queue Server crea una sola transacción interna.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" /> que especifica la transacción de la que se quitará el mensaje.</param>
        <summary>Quita el mensaje actual de una cola transaccional y devuelve el mensaje a la aplicación que realiza la llamada. No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, utilizando el contexto de transacción interna definido por el `transaction` parámetro.  
  
 Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Quita el mensaje actual de una cola y lo devuelve a la aplicación que realiza la llamada. No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, mediante un contexto de transacción definido por el `transactionType` parámetro.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo que hay que esperar a que un mensaje llegue a la cola.</param>
        <summary>Quita el mensaje actual de la cola y lo devuelve a la aplicación que realiza la llamada. Si hay un mensaje que quitar, el método lo devuelve inmediatamente. En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual. Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.  
  
 Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si se llama a esta sobrecarga en una cola transaccional, Message Queue Server crea una sola transacción interna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El tiempo de espera ha expirado.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo que hay que esperar hasta que se quite el mensaje.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" /> que especifica el contexto de transacción para el mensaje.</param>
        <summary>Quita el mensaje actual de una cola transaccional y devuelve el mensaje a la aplicación que realiza la llamada. Si hay un mensaje que quitar, el método lo devuelve inmediatamente. En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual. Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.  
  
 Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El tiempo de espera ha expirado.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo que hay que esperar hasta que se quite el mensaje.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Quita el mensaje actual de una cola y lo devuelve a la aplicación que realiza la llamada. Si hay un mensaje que quitar, el método lo devuelve inmediatamente. En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, mediante un contexto de transacción definido por el `transactionType` parámetro. Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El tiempo de espera ha expirado.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el enumerador actual de forma que señale al encabezado de la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un enumerador sólo puede mover hacia delante. Utilice este método para volver a empezar al principio de la cola.  
  
 Después de llamar a <xref:System.Messaging.MessageEnumerator.Reset%2A>, el cursor señala al primer mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.Reset%2A> para mover el cursor hacia delante hasta el primer mensaje en la cola.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una <see cref="T:System.Messaging.Message" /> que hace referencia al mensaje de la posición actual del cursor.</summary>
        <value>Una clase <see cref="T:System.Messaging.Message" /> que hace referencia al mensaje de la posición actual del cursor.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Tuvo acceso a esta propiedad antes de la primera llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. El cursor se encuentra antes del primer elemento de la enumeración del mensaje, o bien ha accedido a esta propiedad después de que una llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> devolviera "false" (lo que indica que el cursor está situado después del último elemento de la enumeración del mensaje).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El mensaje al que está apuntando actualmente el enumerador ya no existe. Puede que se hayan eliminado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>