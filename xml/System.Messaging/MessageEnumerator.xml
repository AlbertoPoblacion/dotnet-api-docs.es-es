<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a3039a11d941cd3db611cb997eb17835525e4da" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona un cursor de tipo sólo hacia delante con el fin de enumerar mensajes en una cola de mensajes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageEnumerator> para la interacción dinámica con los mensajes de una cola. Métodos disponibles a través de la <xref:System.Messaging.MessageQueue> clase puede devolver un <xref:System.Messaging.MessageEnumerator> que apunta a una lista dinámica de mensajes en la cola o una matriz que contiene una copia en un momento dado (una instantánea) de la cola en el momento en el método especificado se llamó.  
  
 A diferencia de una instantánea estática, un enumerador permite modificar la colección. Mediante un <xref:System.Messaging.MessageEnumerator>, puede quitar los mensajes de la cola y el cambio se reflejará inmediatamente en la cola.  
  
 Un enumerador no elimina los mensajes de la cola cuando consulta la cola. Devuelve información sobre el mensaje en la posición actual del cursor, pero deja el mensaje en la cola.  
  
 A <xref:System.Messaging.MessageEnumerator> es un cursor, inicializado en el encabezado de una lista dinámica. El orden de la lista es el mismo que el orden de los mensajes en la cola, según la prioridad del mensaje. Puede mover el cursor hasta el primer mensaje de la cola mediante una llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Una vez inicializado el enumerador, puede utilizar <xref:System.Messaging.MessageEnumerator.MoveNext%2A> para desplazarse hacia delante por los mensajes restantes. Puede especificar si se debe esperar un mensaje esté disponible pasando un tiempo de espera en el <xref:System.Messaging.MessageEnumerator.MoveNext%2A> método.  
  
 Dado que el enumerador es dinámico, un mensaje que se anexa más allá de la posición del cursor actual (por ejemplo, debido a una prioridad baja), puede tener acceso por el enumerador. Un mensaje que se inserta antes de que no se puede tener acceso a la posición del cursor actual. No es posible ir hacia atrás con un <xref:System.Messaging.MessageEnumerator>. Un cursor permite el movimiento de solo avance. El <xref:System.Messaging.MessageEnumerator.Reset%2A> método le permite colocar el cursor volver al principio de la cola.  
  
 Instancias de <xref:System.Messaging.MessageEnumerator> para una cola determinada trabajar de forma independiente. Puede crear dos <xref:System.Messaging.MessageEnumerator> instancias que se aplican a la misma cola. Los cambios que otro <xref:System.Messaging.MessageEnumerator> facilita a los mensajes en la cola se reflejarán inmediatamente en un segundo enumerador si el segundo enumerador se coloca antes del primer. Sin embargo, si dos enumeradores tienen la misma posición y uno de ellos quita el mensaje en esa posición, se produce una excepción si el otro enumerador intenta obtener el valor de la <xref:System.Messaging.MessageEnumerator.Current%2A> propiedad en el mensaje que se elimina ahora.  
  
> [!NOTE]
>  Si crea una instancia de <xref:System.Messaging.MessageQueue> con <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> establecido en `true`, ninguna otra aplicación puede modificar los mensajes del enumerador mientras se mantenga la conexión a la cola.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene una lista dinámica de mensajes en una cola y se cuentan todos los mensajes con el <xref:System.Messaging.Message.Priority%2A> propiedad establecida en <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos asociados al enumerador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema operativo retiene un identificador abierto en la cola durante la duración del cursor. Cuando termine de trabajar con el enumerador, llame a <xref:System.Messaging.MessageEnumerator.Close%2A> para liberar los recursos asociados al identificador.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Messaging.Message" /> actual al que apunta este enumerador.</summary>
        <value>Mensaje actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea el enumerador, apunte al encabezado de la cola, en una ubicación delante del primer mensaje. En este caso, <xref:System.Messaging.MessageEnumerator.Current%2A> no es válida y producirá una excepción si se tiene acceso. Debe llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> para colocar el cursor en el primer mensaje de la cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó a <see cref="P:System.Messaging.MessageEnumerator.Current" /> antes de la primera llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. El cursor se encuentra ubicado delante del primer elemento de la enumeración del mensaje.  
  
 O bien  
  
 Se llamó a <see cref="P:System.Messaging.MessageEnumerator.Current" /> después de que una llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> devolviera <see langword="false" /> (lo que indicaba que el cursor está situado después del último elemento de la enumeración del mensaje).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El mensaje al que está apuntando actualmente el enumerador ya no existe. Puede que se hayan eliminado.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el indicador de cursor de Message Queuing nativo que se utiliza para explorar los mensajes de la cola.</summary>
        <value>Indicador de cursor nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contiene el identificador nativo de la enumeración. Cuando termine de trabajar con el enumerador, llame a <xref:System.Messaging.MessageEnumerator.Close%2A> para liberar este recurso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">El indicador no existe.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera los recursos utilizados por <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al llamar a <xref:System.Messaging.MessageEnumerator.Dispose%2A> permite que los recursos utilizados por el <xref:System.Messaging.MessageEnumerator> se reasignen para otros fines. Para obtener más información acerca de <xref:System.Messaging.MessageEnumerator.Dispose%2A>, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que utiliza <see cref="T:System.Messaging.MessageEnumerator" /> y libera los recursos administrados de forma opcional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público <xref:System.Messaging.MessageEnumerator.Dispose%2A> método y <xref:System.Object.Finalize%2A> método. `Dispose()` se invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Messaging.MessageEnumerator> hace referencia. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see langword="Dispose(Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see langword="Dispose" /> y <see langword="Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desplaza el enumerador al siguiente mensaje de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el enumerador al siguiente mensaje de la cola si hay alguno disponible.</summary>
        <returns>
          <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente mensaje; <see langword="false" /> si el enumerador alcanzó el final de la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga vuelve inmediatamente si no hay ningún mensaje en la cola. Hay otra sobrecarga que espera un determinado <xref:System.TimeSpan> a que llegue un mensaje.  
  
 Si un mensaje no está disponible actualmente porque la cola está vacía o porque ha movido más allá del último elemento de la colección, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> devuelve `false` al método de llamada.  
  
 Tras su creación, un enumerador se coloca conceptualmente delante del primer mensaje de la cola y la primera llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> incorpora el primer mensaje de la cola en la vista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se ha producido una excepción específica para Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que se va a esperar hasta que un mensaje se encuentre disponible si el enumerador se coloca al final de la cola.</param>
        <summary>Desplaza el enumerador al siguiente mensaje de la cola. Si el enumerador se coloca al final de la cola, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> espera hasta que haya un mensaje disponible o expire el tiempo de espera.</summary>
        <returns>
          <see langword="true" /> si el enumerador avanzó satisfactoriamente hasta el siguiente mensaje; <see langword="false" /> si el enumerador llegó al final de la cola y un mensaje no pasa a estar disponible en el plazo de tiempo especificado por el parámetro <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espera a que esta sobrecarga si no hay ningún mensaje en la cola o si el cursor ha alcanzado el final de la cola. Si un mensaje no está disponible actualmente porque la cola está vacía o porque ha movido más allá del último elemento de la colección, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> espera a que el tiempo de espera especificado.  
  
 Si el cursor está al final de la cola, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> sólo devuelve `true` si el nuevo mensaje llega en el intervalo de tiempo especificado, tiene una prioridad menor que todos los mensajes actualmente en la cola y se coloca al final de la cola. Una sobrecarga sin parámetros devuelve inmediatamente si no hay más mensajes están en la cola.  
  
 Tras su creación, un enumerador se coloca conceptualmente delante del primer mensaje de la enumeración y la primera llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pone el primer mensaje de la enumeración en la vista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro de tiempo de espera no es válido. Podría representar un número negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se ha producido una excepción específica para Message Queuing.  
  
 O bien  
  
 El tiempo de espera ha expirado.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita el mensaje actual de la cola y lo devuelve a la aplicación que realiza la llamada. Al quitar el mensaje, éste se elimina de la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento descrito para estas sobrecargas es aplicable solo si la <xref:System.Messaging.MessageEnumerator> instancia se recupera utilizando la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. No utilice <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> para recuperar una instancia de <xref:System.Messaging.MessageEnumerator> como este método está en desuso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita el mensaje actual de una cola transaccional o no transaccional y lo devuelve a la aplicación que realiza la llamada. No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual.  
  
 Si usas colas del diario, eliminar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si se llama a esta sobrecarga en una cola transaccional, Message Queue Server crea una sola transacción interna.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" /> que especifica la transacción de la que se quitará el mensaje.</param>
        <summary>Quita el mensaje actual de una cola transaccional y devuelve el mensaje a la aplicación que realiza la llamada. No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, utilizando el contexto de transacción interna definido por el `transaction` parámetro.  
  
 Si usas colas del diario, eliminar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Al trabajar con colas transaccionales, una reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> que se devolverá a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Quita el mensaje actual de una cola y lo devuelve a la aplicación que realiza la llamada. No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, usando un contexto de transacción definido por el `transactionType` parámetro.  
  
 Especifique `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especifique `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si usas colas del diario, eliminar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Al trabajar con colas transaccionales, una reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> que se devolverá a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo que hay que esperar a que un mensaje llegue a la cola.</param>
        <summary>Quita el mensaje actual de la cola y lo devuelve a la aplicación que realiza la llamada. Si hay un mensaje que quitar, el método lo devuelve inmediatamente. En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual. Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.  
  
 Si usas colas del diario, eliminar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Si se llama a esta sobrecarga en una cola transaccional, Message Queue Server crea una sola transacción interna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El tiempo de espera ha expirado.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo que hay que esperar hasta que se quite el mensaje.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" /> que especifica el contexto de transacción para el mensaje.</param>
        <summary>Quita el mensaje actual de una cola transaccional y devuelve el mensaje a la aplicación que realiza la llamada. Si hay un mensaje que quitar, el método lo devuelve inmediatamente. En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual. Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.  
  
 Al trabajar con colas transaccionales, una reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> que se devolverá a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Si usas colas del diario, eliminar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El tiempo de espera ha expirado.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo que hay que esperar hasta que se quite el mensaje.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Quita el mensaje actual de una cola y lo devuelve a la aplicación que realiza la llamada. Si hay un mensaje que quitar, el método lo devuelve inmediatamente. En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, usando un contexto de transacción definido por el `transactionType` parámetro. Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.  
  
 Especifique `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especifique `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si usas colas del diario, eliminar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Al trabajar con colas transaccionales, una reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> que se devolverá a la cola. La eliminación no es irreversible hasta que se confirma la transacción.  
  
 Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El tiempo de espera ha expirado.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el enumerador actual de forma que señale al encabezado de la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sólo puede mover un enumerador en una dirección hacia delante. Utilice este método para volver a empezar al principio de la cola.  
  
 Después de llamar a <xref:System.Messaging.MessageEnumerator.Reset%2A>, el cursor señala al primer mensaje. No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.Reset%2A> para mover el cursor hacia delante hasta el primer mensaje de la cola.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una <see cref="T:System.Messaging.Message" /> que hace referencia al mensaje de la posición actual del cursor.</summary>
        <value>Una clase <see cref="T:System.Messaging.Message" /> que hace referencia al mensaje de la posición actual del cursor.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>