<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a9a1931c75db76f56c20e9b7b0a8567e6d17609" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48590757" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializa y deserializa objetos del cuerpo de un mensaje, utilizando el formato XML basado en la definición de esquemas XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.XmlMessageFormatter> es el formateador predeterminado que una instancia de <xref:System.Messaging.MessageQueue> utiliza para serializar los mensajes enviados a la cola. Cuando se crea una instancia de <xref:System.Messaging.MessageQueue>, una instancia de <xref:System.Messaging.XmlMessageFormatter> se crea automáticamente y asociado con el <xref:System.Messaging.MessageQueue>. Puede especificar un formateador distinto, crearlo en el código y asígnela a la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad de su <xref:System.Messaging.MessageQueue>.  
  
 Predeterminada de una cola <xref:System.Messaging.XmlMessageFormatter> instancia puede utilizarse para escribir en la cola, pero no se puede usar para leer la cola hasta que se establece la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propiedad en el formateador. Se pueden establecer uno o ambos de estos valores en la instancia del formateador de forma predeterminada, o puede crear una nueva instancia del formateador y establecer los valores automáticamente al pasar como argumentos en el <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.  
  
 Al especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> lugar <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo existencia se comprueba en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de errores. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requiere que cada entrada estén completos, especificando su nombre de ensamblado. Además, cuando se trabaja con varias versiones simultáneas, también se debe anexar el número de versión para el nombre de tipo de destino.  
  
 El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican el formateador los esquemas que intentan conciliar al deserializar un mensaje. Esto permite al formateador interpretar el cuerpo del mensaje.  
  
 La instancia serializada en el cuerpo del mensaje debe cumplir uno de los esquemas que representan en la matriz de tipos. Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.  
  
 Solo una de las dos propiedades debe establecerse cuando se leen de la cola, pero se pueden establecer ambas. El conjunto de tipos es el conjunto combinado de las dos propiedades. La decisión de la propiedad que es específica de la aplicación. Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con cualquiera de los tipos de la matriz de cualquiera de las propiedades, se producirá una excepción cuando se lee el mensaje.  
  
 El <xref:System.Messaging.XmlMessageFormatter> es un componente fundamental de acoplamiento flexible de mensajería basado en XML. La utilidad XSD.exe emplea que el formato XML se usa para generar el esquema XML, como cuando se utiliza la utilidad para serializar una clase usada por la aplicación. La clase debe tener un constructor predeterminado.  
  
 Se utiliza el formato nuevo en el proceso inverso cuando la utilidad genera una clase basada en el esquema se distribuye para describir los datos de clase. El uso de la utilidad y el esquema XML que genera permite evitar redistribuir archivos cada vez que vuelva a compilar una clase después de la implementación de la clase ha cambiado. No se modifica el esquema en el cliente o el servidor, siempre que otros cambios en cualquier lado no afecten a la otra.  
  
   
  
## Examples  
 El siguiente ejemplo de código incluye tres fragmentos de código: un componente de servidor, una clase order y el código de cliente. La clase order se puede usar la utilidad XSD.exe para generar el esquema que el servidor reconoce dentro de los mensajes entrantes. El esquema es un archivo con formato XML que describe la "forma" de la clase. Este esquema se puede usar, a continuación, en el lado cliente para generar una clase de órdenes específica del cliente que comparte el mismo esquema que la clase de servidor.  
  
 El siguiente ejemplo de código representa un componente de servidor que recibe pedidos a través de una cola de mensajes. El cuerpo del mensaje debe ser un objeto de pedido cuyo esquema coincide con la clase Order.cs siguiente. El proceso de servidor o la aplicación deserializa el orden.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 El ejemplo de código siguiente representa la clase order que proporciona un esquema para los objetos de pedido que recibe la aplicación en el servidor y los deserializa.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Cualquier aplicación cliente que interactúa con la aplicación en el servidor debe enviar mensajes al servidor serializando la información en una clase de orden definido localmente en el cuerpo del mensaje. La clase order definida localmente debe tener el mismo esquema que la clase de orden definido por el servidor en el que la aplicación en el servidor intentará deserializar el cuerpo del mensaje. La utilidad XSD.exe permite el Administrador de la aplicación en el servidor, crear y distribuir el esquema que el cliente debe utilizar para serializar los mensajes dirigidos al servidor.  
  
 Cuando el Administrador de la aplicación cliente recibe el esquema para la clase order, la utilidad XSD.exe se utiliza de nuevo para generar una clase de órdenes específica del cliente desde el esquema. Es la clase que se usa en el ejemplo de código de cliente a continuación, no la clase de orden del servidor (la utilidad XSD.exe hace que la clase generados por esquema tengan el mismo nombre que la clase original). Esta nueva clase order se utiliza para serializar el orden en el cuerpo del mensaje.  
  
 El siguiente ejemplo de código es el cliente de procesamiento, utilizado para serializar un pedido y enviar la información asociada con el orden en una cola. El código asocia información de elemento, la cantidad y la dirección a los elementos del esquema que se generaron para la clase Order.cs por la utilidad XSD.exe. Se envía un pedido a la cola de pedidos en el equipo local.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Una vez generado el esquema de la clase order en el servidor, puede modificar la clase. A menos que los cambios de esquema, no es necesario redistribuir el esquema. Después de haber distribuido el esquema y genera una clase de pedido de cliente, también puede modificarse esa clase de cliente independientemente de la clase del servidor orden, siempre que no se modifica el propio esquema. Las dos clases se han convertido en imprecisa.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" /> sin los tipos de destino establecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del constructor se usa con más frecuencia cuando se escribe en la cola, como tipos de destino no son necesarios cuando se escribe.  
  
 Para leer un mensaje de una cola utilizando una instancia de <xref:System.Messaging.XmlMessageFormatter> creado mediante este constructor, debe establecer el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades para que el formateador sepa qué tipos debe para intentar deserializar.  
  
 Cuando se crea un nuevo <xref:System.Messaging.MessageQueue>, valor predeterminado es <xref:System.Messaging.XmlMessageFormatter> se crea la instancia, sin el conjunto de tipos de destino. Al igual que con un formateador que se creó con este constructor, debe establecer tipos de destino para esa instancia del formateador si desea leer de la cola.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Matriz de tipo <see cref="T:System.String" /> que especifica el conjunto de tipos posibles que deserializará el formateador a partir del mensaje proporcionado. Estos valores tienen que ser completos, por ejemplo, "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" />, estableciendo los tipos de destino pasados en forma de matriz de valores de cadena completos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los constructores con parámetros de tipo de destino se usan con más frecuencia cuando se leen de la cola. Al escribir, no es necesario especificar los tipos de destino.  
  
 Esta sobrecarga de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor establece el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propiedad a los valores de matriz que se pasa a través de la `targetTypeNames` parámetro. Al establecer esta propiedad, un <xref:System.Messaging.MessageQueue> mediante este <xref:System.Messaging.XmlMessageFormatter> instancia para leer los mensajes que contienen objetos de tipos especificados.  
  
 Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican el formateador los esquemas que intentan conciliar al deserializar un mensaje. Esto permite al formateador interpretar el cuerpo del mensaje.  
  
 La instancia serializada en el cuerpo del mensaje debe cumplir uno de los esquemas que representan en la matriz de tipos. Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.  
  
 Solo una de las dos propiedades debe establecerse cuando se leen de la cola, pero se pueden establecer ambas. El conjunto de tipos es el conjunto combinado de las dos propiedades. La decisión que debe usarse es específico para su aplicación. Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con cualquiera de los tipos de la matriz de cualquiera de las propiedades, se producirá una excepción en tiempo de lectura.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="targetTypeNames" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Matriz de tipo <see cref="T:System.Type" /> que especifica el conjunto de tipos posibles que deserializará el formateador a partir del mensaje proporcionado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" />, estableciendo los tipos de destino pasados en forma matriz de tipos de objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los constructores con parámetros de tipo de destino se usan con más frecuencia cuando se leen de la cola. Al escribir, no es necesario especificar los tipos de destino.  
  
 Esta sobrecarga de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor establece el <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedad a los valores de matriz que se pasa a través de la `targetTypes` parámetro. Al establecer esta propiedad, un <xref:System.Messaging.MessageQueue> mediante este <xref:System.Messaging.XmlMessageFormatter> instancia para leer los mensajes que contienen objetos de los tipos especificados.  
  
 Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican el formateador los esquemas que intentan conciliar al deserializar un mensaje. Esto permite al formateador interpretar el cuerpo del mensaje.  
  
 La instancia serializada en el cuerpo del mensaje debe cumplir uno de los esquemas que representan en la matriz de tipos. Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.  
  
 Solo una de las dos propiedades debe establecerse cuando se leen de la cola, pero se pueden establecer ambas. El conjunto de tipos es el conjunto combinado de las dos propiedades. La decisión que debe usarse es específico para su aplicación. Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con cualquiera de los tipos de la matriz de cualquiera de las propiedades, se producirá una excepción en tiempo de lectura.  
  
 Al especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> lugar <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo existencia se comprueba en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de errores. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requiere que cada entrada estén completos, especificando su nombre de ensamblado. Además, cuando se trabaja con varias versiones simultáneas, también se debe anexar el número de versión para el nombre de tipo de destino.  
  
 Cuando se usa <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, puede agregar cada objeto (por ejemplo, `MyClass`) a la lista de forma que se muestra en el siguiente código de C#.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="targetTypes" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> que se va a inspeccionar.</param>
        <summary>Determina si el formateador puede deserializar el mensaje.</summary>
        <returns>Es <see langword="true" /> si el formateador XML puede deserializar el mensaje; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> se llama, el formateador intenta determinar si el contenido del mensaje es algo que se puede deserializar. El formateador sólo puede deserializar el mensaje si el tipo en el cuerpo del mensaje tiene el mismo esquema que uno de los tipos de la matriz representada por la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Devuelve `false` en los dos casos siguientes:  
  
-   El mensaje no se formateó con el <xref:System.Messaging.XmlMessageFormatter>.  
  
-   El esquema del cuerpo del mensaje no está entre aquellos aparecen en la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedad.  
  
 El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador qué tipos de objetos debe ser capaz de deserializar. Si no se encuentra en la lista de cualquier tipo, aún se encuentra dentro del mensaje, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> devuelve `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha establecido la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ni la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="message" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" /> cuyas propiedades de lectura y escritura (los conjuntos de tipos de destino) son las mismas que las de la instancia de <see cref="T:System.Messaging.XmlMessageFormatter" /> actual.</summary>
        <returns>Objeto cuyas propiedades son idénticas a las de esta instancia de <see cref="T:System.Messaging.XmlMessageFormatter" />, pero cuyos metadatos no especifican que sea una instancia de la clase de formateador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una copia del formateador e inicializa todas sus propiedades en los valores de esta <xref:System.Messaging.XmlMessageFormatter> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" />, en formato XML, que se va a deserializar.</param>
        <summary>Lee el contenido del mensaje especificado y crea un objeto que contiene el mensaje deserializado.</summary>
        <returns>El mensaje deserializado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican el formateador los esquemas que intentan conciliar al deserializar un mensaje. Una de estas propiedades se debe establecer antes de que se puede deserializar el mensaje.  
  
 La instancia serializada en el cuerpo del mensaje debe cumplir uno de los esquemas que representan en la matriz de tipos. Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.  
  
 Los tipos de destino no tiene que especificarse con el fin de escribir en la cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha establecido la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ni la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.  
  
O bien 
La instancia serializada en el cuerpo del mensaje no sigue ninguno de los esquemas que representan los tipos de las propiedades <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> y <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="message" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica el conjunto de tipos posibles que el formateador deserializará a partir del mensaje proporcionado.</summary>
        <value>Matriz de tipo <see cref="T:System.String" /> que especifica los tipos de objetos que se van a deserializar del cuerpo del mensaje cuando se lea el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican el formateador los esquemas que intentan conciliar al deserializar un mensaje. Esto permite al formateador interpretar el cuerpo del mensaje.  
  
 La instancia serializada en el cuerpo del mensaje debe cumplir uno de los esquemas que representan en la matriz de tipos. Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.  
  
 Solo una de las dos propiedades debe establecerse cuando se leen de la cola, pero se pueden establecer ambas. El conjunto de tipos es el conjunto combinado de las dos propiedades. La decisión de la propiedad que es específica de la aplicación. Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con cualquiera de los tipos de la matriz de cualquiera de las propiedades, se producirá una excepción cuando se lee el mensaje.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requiere que cada entrada estén completos, especificando su nombre de ensamblado. Además, cuando se trabaja con varias versiones simultáneas, también se debe anexar el número de versión para el nombre de tipo de destino.  
  
 Los tipos de destino sólo son necesarios cuando se lee de la cola. El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades no deben establecerse para escribir en la cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica el conjunto de tipos posibles que el formateador deserializará a partir del mensaje proporcionado.</summary>
        <value>Matriz de tipo <see cref="T:System.Type" /> que especifica los tipos de objetos que se van a deserializar del cuerpo del mensaje cuando se lea el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican el formateador los esquemas que intentan conciliar al deserializar un mensaje. Esto permite al formateador interpretar el cuerpo del mensaje.  
  
 La instancia serializada en el cuerpo del mensaje debe cumplir uno de los esquemas que representan en la matriz de tipos. Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.  
  
 Solo una de las dos propiedades debe establecerse cuando se leen de la cola, pero se pueden establecer ambas. El conjunto de tipos es el conjunto combinado de las dos propiedades. La decisión de la propiedad que es específica de la aplicación. Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con cualquiera de los tipos de la matriz de cualquiera de las propiedades, se producirá una excepción cuando se lee el mensaje.  
  
 Los tipos de destino sólo son necesarios cuando se lee de la cola. El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades no deben establecerse para escribir en la cola.  
  
 Al especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> lugar <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo existencia se comprueba en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de errores.  
  
 Cuando se usa <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, puede agregar cada objeto (por ejemplo, `MyClass`) a la lista de forma que se muestra el código de C# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> cuya propiedad <see cref="P:System.Messaging.Message.Body" /> contendrá el objeto serializado.</param>
        <param name="obj">
          <see cref="T:System.Object" /> que se va a serializar en el cuerpo del mensaje.</param>
        <summary>Serializa un objeto en el cuerpo del mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No es necesario especificar los tipos de destino para escribir en la cola, ya que deben estar al leer. El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedad se utiliza el formateador únicamente al deserializar un mensaje.  
  
 El <xref:System.Messaging.XmlMessageFormatter> hace uso de la <xref:System.Xml.Serialization.XmlSerializer> (clase), que define lo que se puede serializar. Solo se pueden serializar campos públicos y propiedades públicas. Estructuras, las estructuras con matrices y matrices de estructuras se pueden serializar, siempre y cuando no use el estilo codificado con el protocolo SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="message" /> es <see langword="null" />.  
  
O bien 
El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>