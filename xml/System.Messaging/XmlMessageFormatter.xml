<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XmlMessageFormatter.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5563e678b40760a20036da2630095cb8b05f461de.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">563e678b40760a20036da2630095cb8b05f461de</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</source>
          <target state="translated">Serializa y deserializa objetos del cuerpo de un mensaje, utilizando el formato XML basado en la definición de esquemas XSD.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is the default formatter that an instance of <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> uses to serialize messages written to the queue.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> es el formateador predeterminado que una instancia de <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> usa para serializar los mensajes enviados a la cola.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When you create an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, an instance of <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is created for you and associated with the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">Cuando se crea una instancia de <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, una instancia de <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> se crea automáticamente y asociado con el <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>You can specify a different formatter by creating it in your code and assigning it to the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property of your <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">Puede especificar un formateador distinto mediante la creación en el código y asígneselo a la <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> propiedad de su <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>A queue's default <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> property on the formatter.</source>
          <target state="translated">Valor predeterminado de la cola <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instancia se puede usar para escribir en la cola, pero no puede usarse para leer la cola hasta que se establece la <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> propiedad en el formateador.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Se pueden establecer uno o ambos de estos valores en la instancia del formateador predeterminado, o puede crear una nueva instancia del formateador y establecer los valores automáticamente pasándolos como argumentos en la correspondiente <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When specifying <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, type existence is checked at compile time rather than read time, reducing possibility for error.</source>
          <target state="translated">Al especificar <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> en lugar de <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, se comprueba la existencia de tipo en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de error.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requires every entry to be fully qualified, specifying its assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requiere que cada entrada estén completos, especificando su nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</source>
          <target state="translated">Además, cuando se trabaja con varias versiones simultáneas, el número de versión también debe agregarse en el nombre de tipo de destino.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Esto permite al formateador interpretar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Cuando se lee el mensaje utilizando el <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">El conjunto de tipos es el conjunto combinado de las dos propiedades.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The decision of which property to use is specific to your application.</source>
          <target state="translated">La decisión de qué propiedad que se va a usar es específica de la aplicación.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</source>
          <target state="translated">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción cuando se lee el mensaje.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is a crucial component of loosely coupled XML-based messaging.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> es un componente fundamental de los mensajes con acoplamiento flexible basado en XML.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application.</source>
          <target state="translated">La utilidad XSD.exe emplea que el formato XML se usa para generar el esquema XML, como cuando se usa la utilidad para serializar una clase usada por la aplicación.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The class must have a default constructor.</source>
          <target state="translated">La clase debe tener un constructor predeterminado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data.</source>
          <target state="translated">Se utiliza el formato nuevo en el proceso inverso cuando la utilidad genera una clase basada en el esquema se distribuye para describir los datos de la clase.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed.</source>
          <target state="translated">El uso de la utilidad y el esquema XML que genera permite evitar redistribuir archivos cada vez que vuelve a compilar una clase después de la implementación de la clase ha cambiado.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>As long as the schema does not change on the client or the server, other changes on either side do not affect the other.</source>
          <target state="translated">Siempre y cuando no se modifica el esquema en el cliente o el servidor, las modificaciones realizadas en cualquier lado no afecta a los demás.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example includes three pieces of code: a server component, an order class, and client code.</source>
          <target state="translated">En el ejemplo de código siguiente se incluye tres fragmentos de código: un componente de servidor, una clase order y el código de cliente.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages.</source>
          <target state="translated">La clase order se puede utilizar la utilidad XSD.exe para generar un esquema que el servidor reconoce en los mensajes entrantes.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The schema is an XML formatted file that describes the "shape" of the class.</source>
          <target state="translated">El esquema es un archivo con formato XML que describe la "forma" de la clase.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.</source>
          <target state="translated">Este esquema se puede utilizar a continuación, en el lado del cliente para generar una clase de órdenes específica del cliente que comparte el mismo esquema que la clase de servidor.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example represents a server component that receives orders through a message queue.</source>
          <target state="translated">En el ejemplo de código siguiente se representa un componente de servidor que recibe pedidos a través de una cola de mensajes.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The body of the message should be an order object whose schema matches the Order.cs class below.</source>
          <target state="translated">El cuerpo del mensaje debe ser un objeto de pedido cuyo esquema coincide con la clase Order.cs incluida a continuación.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The server process or application deserializes the order.</source>
          <target state="translated">El proceso de servidor o la aplicación deserializa el orden.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.</source>
          <target state="translated">En el ejemplo de código siguiente se representa la clase que proporciona un esquema para los objetos de orden que la aplicación en el servidor recibe y deserializa.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body.</source>
          <target state="translated">Cualquier aplicación cliente que interactúa con la aplicación en el servidor debe enviar mensajes al servidor serializando la información en una clase de órdenes definida localmente en el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body.</source>
          <target state="translated">La clase de órdenes definida localmente debe tener el mismo esquema que la clase de orden definido por el servidor en el que la aplicación en el servidor intentará deserializar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.</source>
          <target state="translated">La utilidad XSD.exe permite al administrador de la aplicación en el servidor de crear y distribuir el esquema que el cliente debe utilizar para serializar los mensajes dirigidos al servidor.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema.</source>
          <target state="translated">Cuando el Administrador de la aplicación cliente recibe el esquema para la clase order, se usa la utilidad XSD.exe de nuevo, para generar una clase de órdenes específica del cliente desde el esquema.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class).</source>
          <target state="translated">Es la clase que se utiliza en el ejemplo de código de cliente a continuación, no la clase de órdenes del servidor (la utilidad XSD.exe hace que la clase generada por el esquema tenga el mismo nombre que la clase original).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>This new order class is used to serialize the order into the message body.</source>
          <target state="translated">Esta nueva clase de orden se usa para serializar el orden en el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue.</source>
          <target state="translated">El ejemplo de código siguiente es el lado del cliente de procesamiento, utilizado para serializar una orden y enviar la información asociada con el orden en una cola.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility.</source>
          <target state="translated">El código asocia información de elemento, la cantidad y la dirección a elementos del esquema que se generaron para la clase Order.cs por la utilidad XSD.exe.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>An order is sent to the Orders queue on the local computer.</source>
          <target state="translated">Un pedido se envía a la cola de pedidos en el equipo local.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>After the schema is generated from the order class on the server, you can modify the class.</source>
          <target state="translated">Una vez generado el esquema de la clase order en el servidor, puede modificar la clase.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Unless the schema changes, you do not need to redistribute the schema.</source>
          <target state="translated">A menos que los cambios de esquema, no es necesario redistribuir el esquema.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified.</source>
          <target state="translated">Después de haber distribuido el esquema y genera una clase de pedido de cliente, esa clase de cliente también es posible modificar independientemente de la clase del servidor orden, siempre y cuando no se modifique el propio esquema.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The two classes have become loosely coupled.</source>
          <target state="translated">Las dos clases se han convertido en imprecisa.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class, without target types set.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> sin los tipos de destino establecidos.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.</source>
          <target state="translated">Esta sobrecarga del constructor se usa con más frecuencia cuando se escribe en la cola, como tipos de destino no son necesarios cuando se escribe.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>To read a message from a queue using an instance of <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> created using this constructor, you must set the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties so the formatter knows what types to attempt to deserialize.</source>
          <target state="translated">Para leer un mensaje de una cola utilizando una instancia de <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> creada mediante este constructor, debe establecer el <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades para que el formateador sepa qué tipos debe para intentar deserializar.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>When you create a new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, a default <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance is created, without the target types set.</source>
          <target state="translated">Cuando se crea un nuevo <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, valor predeterminado es <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> se crea la instancia, sin el conjunto de tipos de destino.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.</source>
          <target state="translated">Al igual que con el formateador creado mediante este constructor, debe establecer tipos de destino para esa instancia del formateador si desea leer de la cola.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que especifica el conjunto de tipos posibles que deserializará el formateador a partir del mensaje proporcionado.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</source>
          <target state="translated">Estos valores tienen que ser completos, por ejemplo, "MyNamespace.MyOrders, MyOrdersAssemblyName".</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class, setting target types passed in as an array of (fully qualified) string values.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph>, estableciendo los tipos de destino pasados en forma de matriz de valores de cadena completos.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The constructors with target type parameters are most frequently used when reading from the queue.</source>
          <target state="translated">Los constructores con parámetros de tipo de destino se utilizan con más frecuencia cuando se leen de la cola.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>When writing, it is not necessary to specify target types.</source>
          <target state="translated">Al escribir, no es necesario especificar los tipos de destino.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor sets the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> property to the array values passed in through the <ph id="ph3">`targetTypeNames`</ph> parameter.</source>
          <target state="translated">Esta sobrecarga de la <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor establece la <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> propiedad a los valores de matriz que se pasa a través de la <ph id="ph3">`targetTypeNames`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Setting this property enables a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> using this <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance to read messages containing objects of given types.</source>
          <target state="translated">Si establece esta propiedad, permitirá un <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> mediante este <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instancia para leer los mensajes que contienen objetos de tipos.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Tanto el <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Esto permite al formateador interpretar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Cuando se lee el mensaje utilizando el <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">El conjunto de tipos es el conjunto combinado de las dos propiedades.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The decision of which one to use is specific to your application.</source>
          <target state="translated">La decisión de los cuales uno para usarlo es específica para su aplicación.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</source>
          <target state="translated">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción en tiempo de lectura.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The <ph id="ph1">&lt;paramref name="targetTypeNames" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="targetTypeNames" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que especifica el conjunto de tipos posibles que deserializará el formateador a partir del mensaje proporcionado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class, setting target types passed in as an array of object types.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph>, estableciendo los tipos de destino pasados en forma matriz de tipos de objetos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The constructors with target type parameters are most frequently used when reading from the queue.</source>
          <target state="translated">Los constructores con parámetros de tipo de destino se utilizan con más frecuencia cuando se leen de la cola.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When writing, it is not necessary to specify target types.</source>
          <target state="translated">Al escribir, no es necesario especificar los tipos de destino.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor sets the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> property to the array values passed in through the <ph id="ph3">`targetTypes`</ph> parameter.</source>
          <target state="translated">Esta sobrecarga de la <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor establece la <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedad a los valores de matriz que se pasa a través de la <ph id="ph3">`targetTypes`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Setting this property enables a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> using this <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance to read messages containing objects of the given types.</source>
          <target state="translated">Si establece esta propiedad, permitirá un <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> mediante este <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instancia para leer los mensajes que contienen objetos de los tipos especificados.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Tanto el <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Esto permite al formateador interpretar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Cuando se lee el mensaje utilizando el <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">El conjunto de tipos es el conjunto combinado de las dos propiedades.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The decision of which one to use is specific to your application.</source>
          <target state="translated">La decisión de los cuales uno para usarlo es específica para su aplicación.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</source>
          <target state="translated">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción en tiempo de lectura.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When specifying <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, type existence is checked at compile time rather than read time, reducing possibility for error.</source>
          <target state="translated">Al especificar <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> en lugar de <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, se comprueba la existencia de tipo en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de error.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requires every entry to be fully qualified, specifying its assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requiere que cada entrada estén completos, especificando su nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</source>
          <target state="translated">Además, cuando se trabaja con varias versiones simultáneas, el número de versión también debe agregarse en el nombre de tipo de destino.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When using <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, you can add each object (for example, <ph id="ph2">`MyClass`</ph>) to the list in a way demonstrated by the following C# code.</source>
          <target state="translated">Cuando se usa <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, puede agregar cada objeto (por ejemplo, <ph id="ph2">`MyClass`</ph>) a la lista de forma que se muestra en el siguiente código de C#.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The <ph id="ph1">&lt;paramref name="targetTypes" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="targetTypes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> to inspect.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> que se va a inspeccionar.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>Determines whether the formatter can deserialize the message.</source>
          <target state="translated">Determina si el formateador puede deserializar el mensaje.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the XML formatter can deserialize the message; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el formateador XML puede deserializar el mensaje; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>When <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> is called, the formatter attempts to determine if the contents of the message are something it can deserialize.</source>
          <target state="translated">Cuando <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> se llama, el formateador intenta determinar si el contenido del mensaje es algo que se pueda deserializar.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties.</source>
          <target state="translated">El formateador sólo puede deserializar el mensaje si el tipo en el cuerpo del mensaje tiene el mismo esquema que uno de los tipos de la matriz representada por la <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> returns <ph id="ph2">`false`</ph> under the following two circumstances:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> Devuelve <ph id="ph2">`false`</ph> en los dos casos siguientes:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The message was not formatted using the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">El mensaje no se formateó utilizando el <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The schema of the message body is not among those listed in either the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> property.</source>
          <target state="translated">El esquema del cuerpo del mensaje no está entre los que figuran en la vista la <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what types of objects it must be able to deserialize.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los tipos de objetos debe ser capaz de deserializar.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>If any type is missing from the list, yet is found within the message, <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Si no está en la lista de cualquier tipo, aún se encuentra dentro del mensaje, <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>Neither the <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> nor <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> property has been set.</source>
          <target state="translated">No se ha establecido la propiedad <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> ni la propiedad <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;paramref name="message" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="message" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Clone">
          <source>Creates an instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class whose read/write properties (the sets of target types) are the same as the current <ph id="ph2">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> instance.</source>
          <target state="translated">Crea una instancia de la clase <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> cuyas propiedades de lectura y escritura (los conjuntos de tipos de destino) son las mismas que las de la instancia de <ph id="ph2">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Clone">
          <source>An object whose properties are identical to those of this <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> instance, but whose metadata does not specify it to be a formatter class instance.</source>
          <target state="translated">Objeto cuyas propiedades son idénticas a las de esta instancia de <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph>, pero cuyos metadatos no especifican que sea una instancia de la clase de formateador.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Clone">
          <source>This method creates a copy of the formatter and initializes all its properties to the values of this <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> object.</source>
          <target state="translated">Este método crea una copia del formateador e inicializa todas sus propiedades en los valores de este <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>, in XML format, to deserialize.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>, en formato XML, que se va a deserializar.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>Reads the contents from the given message and creates an object that contains the deserialized message.</source>
          <target state="translated">Lee el contenido del mensaje especificado y crea un objeto que contiene el mensaje deserializado.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The deserialized message.</source>
          <target state="translated">El mensaje deserializado.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Tanto el <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>One of these properties must be set before the message can be deserialized.</source>
          <target state="translated">Una de estas propiedades debe establecerse antes de que se puede deserializar el mensaje.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Cuando se lee el mensaje utilizando el <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The target types do not have to be specified in order to write to the queue.</source>
          <target state="translated">Los tipos de destino no tienen que especificarse con el fin de escribir en la cola.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>Neither the <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> nor <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> property has been set.</source>
          <target state="translated">No se ha establecido la propiedad <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> ni la propiedad <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The instance serialized in the message body does not comply with any of the schemas represented by the types in the <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> properties.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje no sigue ninguno de los esquemas que representan los tipos de las propiedades <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;paramref name="message" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="message" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          <target state="translated">Especifica el conjunto de tipos posibles que el formateador deserializará a partir del mensaje proporcionado.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that specifies the types of objects to deserialize from the message body when reading the message.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que especifica los tipos de objetos que se van a deserializar del cuerpo del mensaje cuando se lea el mensaje.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Tanto el <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Esto permite al formateador interpretar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Cuando se lee el mensaje utilizando el <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">El conjunto de tipos es el conjunto combinado de las dos propiedades.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The decision of which property to use is specific to your application.</source>
          <target state="translated">La decisión de qué propiedad que se va a usar es específica de la aplicación.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</source>
          <target state="translated">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción cuando se lee el mensaje.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requires every entry to be fully qualified, specifying its assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requiere que cada entrada estén completos, especificando su nombre de ensamblado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</source>
          <target state="translated">Además, cuando se trabaja con varias versiones simultáneas, el número de versión también debe agregarse en el nombre de tipo de destino.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The target types are only required when reading from the queue.</source>
          <target state="translated">Los tipos de destino sólo son necesarios cuando se lee de la cola.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties do not need to be set to write to the queue.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> no deben establecerse para escribir en la cola de propiedades.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> property is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          <target state="translated">Especifica el conjunto de tipos posibles que el formateador deserializará a partir del mensaje proporcionado.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that specifies the types of objects to deserialize from the message body when reading the message.</source>
          <target state="translated">Matriz de tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que especifica los tipos de objetos que se van a deserializar del cuerpo del mensaje cuando se lea el mensaje.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Tanto el <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Esto permite al formateador interpretar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Cuando se lee el mensaje utilizando el <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">El conjunto de tipos es el conjunto combinado de las dos propiedades.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The decision of which property to use is specific to your application.</source>
          <target state="translated">La decisión de qué propiedad que se va a usar es específica de la aplicación.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</source>
          <target state="translated">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción cuando se lee el mensaje.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The target types are only required when reading from the queue.</source>
          <target state="translated">Los tipos de destino sólo son necesarios cuando se lee de la cola.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties do not need to be set to write to the queue.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> no deben establecerse para escribir en la cola de propiedades.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>When specifying <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, type existence is checked at compile time rather than read time, reducing possibility for error.</source>
          <target state="translated">Al especificar <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> en lugar de <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, se comprueba la existencia de tipo en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de error.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>When using <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, you can add each object (for example, <ph id="ph2">`MyClass`</ph>) to the list in a way demonstrated by the C# code <ph id="ph3">`TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`</ph>.</source>
          <target state="translated">Cuando se usa <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, puede agregar cada objeto (por ejemplo, <ph id="ph2">`MyClass`</ph>) a la lista de forma que se muestra en el código de C# <ph id="ph3">`TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The following code example sends and receives a message that contains an order to and from a queue.</source>
          <target state="translated">En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido a y desde una cola.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> property is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Body" /&gt;</ph> property will contain the serialized object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> cuya propiedad <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Body" /&gt;</ph> contendrá el objeto serializado.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to be serialized into the message body.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a serializar en el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>Serializes an object into the body of the message.</source>
          <target state="translated">Serializa un objeto en el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The target types need not be specified to write to the queue as they must be when reading.</source>
          <target state="translated">No es necesitan especificar los tipos de destino para escribir en la cola como deben ser cuando se leen.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> property is used by the formatter only when deserializing a message.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> propiedad es utilizada por el formateador solo al deserializar un mensaje.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> makes use of the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class, which defines what can be serialized.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> hace uso de la <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> (clase), que define lo que se puede serializar.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>Only public fields and public properties can be serialized.</source>
          <target state="translated">Solo se pueden serializar propiedades públicas y campos públicos.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.</source>
          <target state="translated">Estructuras, las estructuras con matrices y las matrices de estructuras se pueden serializar, siempre y cuando no use el estilo codificado con el protocolo SOAP.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="message" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="message" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>