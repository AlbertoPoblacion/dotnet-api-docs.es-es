<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="88e2a-101">Serializa y deserializa objetos del cuerpo de un mensaje, utilizando el formato XML basado en la definición de esquemas XSD.</span><span class="sxs-lookup"><span data-stu-id="88e2a-101">Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-102">El <xref:System.Messaging.XmlMessageFormatter> es el formateador predeterminado que una instancia de <xref:System.Messaging.MessageQueue> usa para serializar los mensajes enviados a la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-102">The <xref:System.Messaging.XmlMessageFormatter> is the default formatter that an instance of <xref:System.Messaging.MessageQueue> uses to serialize messages written to the queue.</span></span> <span data-ttu-id="88e2a-103">Cuando se crea una instancia de <xref:System.Messaging.MessageQueue>, una instancia de <xref:System.Messaging.XmlMessageFormatter> se crea automáticamente y asociado con el <xref:System.Messaging.MessageQueue>.</span><span class="sxs-lookup"><span data-stu-id="88e2a-103">When you create an instance of <xref:System.Messaging.MessageQueue>, an instance of <xref:System.Messaging.XmlMessageFormatter> is created for you and associated with the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="88e2a-104">Puede especificar un formateador distinto mediante la creación en el código y asígneselo a la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad de su <xref:System.Messaging.MessageQueue>.</span><span class="sxs-lookup"><span data-stu-id="88e2a-104">You can specify a different formatter by creating it in your code and assigning it to the <xref:System.Messaging.MessageQueue.Formatter%2A> property of your <xref:System.Messaging.MessageQueue>.</span></span>  
  
 <span data-ttu-id="88e2a-105">Valor predeterminado de la cola <xref:System.Messaging.XmlMessageFormatter> instancia se puede usar para escribir en la cola, pero no puede usarse para leer la cola hasta que se establece la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propiedad en el formateador.</span><span class="sxs-lookup"><span data-stu-id="88e2a-105">A queue's default <xref:System.Messaging.XmlMessageFormatter> instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property on the formatter.</span></span> <span data-ttu-id="88e2a-106">Se pueden establecer uno o ambos de estos valores en la instancia del formateador predeterminado, o puede crear una nueva instancia del formateador y establecer los valores automáticamente pasándolos como argumentos en la correspondiente <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.</span><span class="sxs-lookup"><span data-stu-id="88e2a-106">You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="88e2a-107">Al especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> en lugar de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, se comprueba la existencia de tipo en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de error.</span><span class="sxs-lookup"><span data-stu-id="88e2a-107">When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.</span></span> <span data-ttu-id="88e2a-108"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requiere que cada entrada estén completos, especificando su nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-108"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name.</span></span> <span data-ttu-id="88e2a-109">Además, cuando se trabaja con varias versiones simultáneas, el número de versión también debe agregarse en el nombre de tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="88e2a-109">Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</span></span>  
  
 <span data-ttu-id="88e2a-110">El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-110">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="88e2a-111">Esto permite al formateador interpretar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-111">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="88e2a-112">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-112">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="88e2a-113">Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</span><span class="sxs-lookup"><span data-stu-id="88e2a-113">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="88e2a-114">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</span><span class="sxs-lookup"><span data-stu-id="88e2a-114">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="88e2a-115">El conjunto de tipos es el conjunto combinado de las dos propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-115">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="88e2a-116">La decisión de qué propiedad que se va a usar es específica de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-116">The decision of which property to use is specific to your application.</span></span> <span data-ttu-id="88e2a-117">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción cuando se lee el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-117">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</span></span>  
  
 <span data-ttu-id="88e2a-118">El <xref:System.Messaging.XmlMessageFormatter> es un componente fundamental de los mensajes con acoplamiento flexible basado en XML.</span><span class="sxs-lookup"><span data-stu-id="88e2a-118">The <xref:System.Messaging.XmlMessageFormatter> is a crucial component of loosely coupled XML-based messaging.</span></span> <span data-ttu-id="88e2a-119">La utilidad XSD.exe emplea que el formato XML se usa para generar el esquema XML, como cuando se usa la utilidad para serializar una clase usada por la aplicación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-119">The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application.</span></span> <span data-ttu-id="88e2a-120">La clase debe tener un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-120">The class must have a default constructor.</span></span>  
  
 <span data-ttu-id="88e2a-121">Se utiliza el formato nuevo en el proceso inverso cuando la utilidad genera una clase basada en el esquema se distribuye para describir los datos de la clase.</span><span class="sxs-lookup"><span data-stu-id="88e2a-121">The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data.</span></span> <span data-ttu-id="88e2a-122">El uso de la utilidad y el esquema XML que genera permite evitar redistribuir archivos cada vez que vuelve a compilar una clase después de la implementación de la clase ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-122">The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed.</span></span> <span data-ttu-id="88e2a-123">Siempre y cuando no se modifica el esquema en el cliente o el servidor, las modificaciones realizadas en cualquier lado no afecta a los demás.</span><span class="sxs-lookup"><span data-stu-id="88e2a-123">As long as the schema does not change on the client or the server, other changes on either side do not affect the other.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="88e2a-124">En el ejemplo de código siguiente se incluye tres fragmentos de código: un componente de servidor, una clase order y el código de cliente.</span><span class="sxs-lookup"><span data-stu-id="88e2a-124">The following code example includes three pieces of code: a server component, an order class, and client code.</span></span> <span data-ttu-id="88e2a-125">La clase order se puede utilizar la utilidad XSD.exe para generar un esquema que el servidor reconoce en los mensajes entrantes.</span><span class="sxs-lookup"><span data-stu-id="88e2a-125">The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages.</span></span> <span data-ttu-id="88e2a-126">El esquema es un archivo con formato XML que describe la "forma" de la clase.</span><span class="sxs-lookup"><span data-stu-id="88e2a-126">The schema is an XML formatted file that describes the "shape" of the class.</span></span> <span data-ttu-id="88e2a-127">Este esquema se puede utilizar a continuación, en el lado del cliente para generar una clase de órdenes específica del cliente que comparte el mismo esquema que la clase de servidor.</span><span class="sxs-lookup"><span data-stu-id="88e2a-127">This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.</span></span>  
  
 <span data-ttu-id="88e2a-128">En el ejemplo de código siguiente se representa un componente de servidor que recibe pedidos a través de una cola de mensajes.</span><span class="sxs-lookup"><span data-stu-id="88e2a-128">The following code example represents a server component that receives orders through a message queue.</span></span> <span data-ttu-id="88e2a-129">El cuerpo del mensaje debe ser un objeto de pedido cuyo esquema coincide con la clase Order.cs incluida a continuación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-129">The body of the message should be an order object whose schema matches the Order.cs class below.</span></span> <span data-ttu-id="88e2a-130">El proceso de servidor o la aplicación deserializa el orden.</span><span class="sxs-lookup"><span data-stu-id="88e2a-130">The server process or application deserializes the order.</span></span>  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 <span data-ttu-id="88e2a-131">En el ejemplo de código siguiente se representa la clase que proporciona un esquema para los objetos de orden que la aplicación en el servidor recibe y deserializa.</span><span class="sxs-lookup"><span data-stu-id="88e2a-131">The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.</span></span>  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="88e2a-132">Cualquier aplicación cliente que interactúa con la aplicación en el servidor debe enviar mensajes al servidor serializando la información en una clase de órdenes definida localmente en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-132">Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body.</span></span> <span data-ttu-id="88e2a-133">La clase de órdenes definida localmente debe tener el mismo esquema que la clase de orden definido por el servidor en el que la aplicación en el servidor intentará deserializar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-133">The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body.</span></span> <span data-ttu-id="88e2a-134">La utilidad XSD.exe permite al administrador de la aplicación en el servidor de crear y distribuir el esquema que el cliente debe utilizar para serializar los mensajes dirigidos al servidor.</span><span class="sxs-lookup"><span data-stu-id="88e2a-134">The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.</span></span>  
  
 <span data-ttu-id="88e2a-135">Cuando el Administrador de la aplicación cliente recibe el esquema para la clase order, se usa la utilidad XSD.exe de nuevo, para generar una clase de órdenes específica del cliente desde el esquema.</span><span class="sxs-lookup"><span data-stu-id="88e2a-135">When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema.</span></span> <span data-ttu-id="88e2a-136">Es la clase que se utiliza en el ejemplo de código de cliente a continuación, no la clase de órdenes del servidor (la utilidad XSD.exe hace que la clase generada por el esquema tenga el mismo nombre que la clase original).</span><span class="sxs-lookup"><span data-stu-id="88e2a-136">It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class).</span></span> <span data-ttu-id="88e2a-137">Esta nueva clase de orden se usa para serializar el orden en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-137">This new order class is used to serialize the order into the message body.</span></span>  
  
 <span data-ttu-id="88e2a-138">El ejemplo de código siguiente es el lado del cliente de procesamiento, utilizado para serializar una orden y enviar la información asociada con el orden en una cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-138">The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue.</span></span> <span data-ttu-id="88e2a-139">El código asocia información de elemento, la cantidad y la dirección a elementos del esquema que se generaron para la clase Order.cs por la utilidad XSD.exe.</span><span class="sxs-lookup"><span data-stu-id="88e2a-139">The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility.</span></span> <span data-ttu-id="88e2a-140">Un pedido se envía a la cola de pedidos en el equipo local.</span><span class="sxs-lookup"><span data-stu-id="88e2a-140">An order is sent to the Orders queue on the local computer.</span></span>  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 <span data-ttu-id="88e2a-141">Una vez generado el esquema de la clase order en el servidor, puede modificar la clase.</span><span class="sxs-lookup"><span data-stu-id="88e2a-141">After the schema is generated from the order class on the server, you can modify the class.</span></span> <span data-ttu-id="88e2a-142">A menos que los cambios de esquema, no es necesario redistribuir el esquema.</span><span class="sxs-lookup"><span data-stu-id="88e2a-142">Unless the schema changes, you do not need to redistribute the schema.</span></span> <span data-ttu-id="88e2a-143">Después de haber distribuido el esquema y genera una clase de pedido de cliente, esa clase de cliente también es posible modificar independientemente de la clase del servidor orden, siempre y cuando no se modifique el propio esquema.</span><span class="sxs-lookup"><span data-stu-id="88e2a-143">After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified.</span></span> <span data-ttu-id="88e2a-144">Las dos clases se han convertido en imprecisa.</span><span class="sxs-lookup"><span data-stu-id="88e2a-144">The two classes have become loosely coupled.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="88e2a-145">Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-145">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="88e2a-146">Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" /> sin los tipos de destino establecidos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-146">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, without target types set.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-147">Esta sobrecarga del constructor se usa con más frecuencia cuando se escribe en la cola, como tipos de destino no son necesarios cuando se escribe.</span><span class="sxs-lookup"><span data-stu-id="88e2a-147">This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.</span></span>  
  
 <span data-ttu-id="88e2a-148">Para leer un mensaje de una cola utilizando una instancia de <xref:System.Messaging.XmlMessageFormatter> creada mediante este constructor, debe establecer el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades para que el formateador sepa qué tipos debe para intentar deserializar.</span><span class="sxs-lookup"><span data-stu-id="88e2a-148">To read a message from a queue using an instance of <xref:System.Messaging.XmlMessageFormatter> created using this constructor, you must set the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties so the formatter knows what types to attempt to deserialize.</span></span>  
  
 <span data-ttu-id="88e2a-149">Cuando se crea un nuevo <xref:System.Messaging.MessageQueue>, valor predeterminado es <xref:System.Messaging.XmlMessageFormatter> se crea la instancia, sin el conjunto de tipos de destino.</span><span class="sxs-lookup"><span data-stu-id="88e2a-149">When you create a new <xref:System.Messaging.MessageQueue>, a default <xref:System.Messaging.XmlMessageFormatter> instance is created, without the target types set.</span></span> <span data-ttu-id="88e2a-150">Al igual que con el formateador creado mediante este constructor, debe establecer tipos de destino para esa instancia del formateador si desea leer de la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-150">As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames"><span data-ttu-id="88e2a-151">Matriz de tipo <see cref="T:System.String" /> que especifica el conjunto de tipos posibles que deserializará el formateador a partir del mensaje proporcionado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-151">An array of type <see cref="T:System.String" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</span></span> <span data-ttu-id="88e2a-152">Estos valores tienen que ser completos, por ejemplo, "MyNamespace.MyOrders, MyOrdersAssemblyName".</span><span class="sxs-lookup"><span data-stu-id="88e2a-152">These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</span></span></param>
        <summary><span data-ttu-id="88e2a-153">Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" />, estableciendo los tipos de destino pasados en forma de matriz de valores de cadena completos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-153">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of (fully qualified) string values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-154">Los constructores con parámetros de tipo de destino se utilizan con más frecuencia cuando se leen de la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-154">The constructors with target type parameters are most frequently used when reading from the queue.</span></span> <span data-ttu-id="88e2a-155">Al escribir, no es necesario especificar los tipos de destino.</span><span class="sxs-lookup"><span data-stu-id="88e2a-155">When writing, it is not necessary to specify target types.</span></span>  
  
 <span data-ttu-id="88e2a-156">Esta sobrecarga de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor establece la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propiedad a los valores de matriz que se pasa a través de la `targetTypeNames` parámetro.</span><span class="sxs-lookup"><span data-stu-id="88e2a-156">This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property to the array values passed in through the `targetTypeNames` parameter.</span></span> <span data-ttu-id="88e2a-157">Si establece esta propiedad, permitirá un <xref:System.Messaging.MessageQueue> mediante este <xref:System.Messaging.XmlMessageFormatter> instancia para leer los mensajes que contienen objetos de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-157">Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of given types.</span></span>  
  
 <span data-ttu-id="88e2a-158">Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-158">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="88e2a-159">Esto permite al formateador interpretar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-159">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="88e2a-160">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-160">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="88e2a-161">Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</span><span class="sxs-lookup"><span data-stu-id="88e2a-161">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="88e2a-162">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</span><span class="sxs-lookup"><span data-stu-id="88e2a-162">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="88e2a-163">El conjunto de tipos es el conjunto combinado de las dos propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-163">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="88e2a-164">La decisión de los cuales uno para usarlo es específica para su aplicación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-164">The decision of which one to use is specific to your application.</span></span> <span data-ttu-id="88e2a-165">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción en tiempo de lectura.</span><span class="sxs-lookup"><span data-stu-id="88e2a-165">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-166">El valor del parámetro <paramref name="targetTypeNames" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-166">The <paramref name="targetTypeNames" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes"><span data-ttu-id="88e2a-167">Matriz de tipo <see cref="T:System.Type" /> que especifica el conjunto de tipos posibles que deserializará el formateador a partir del mensaje proporcionado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-167">An array of type <see cref="T:System.Type" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</span></span></param>
        <summary><span data-ttu-id="88e2a-168">Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" />, estableciendo los tipos de destino pasados en forma matriz de tipos de objetos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-168">Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of object types.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-169">Los constructores con parámetros de tipo de destino se utilizan con más frecuencia cuando se leen de la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-169">The constructors with target type parameters are most frequently used when reading from the queue.</span></span> <span data-ttu-id="88e2a-170">Al escribir, no es necesario especificar los tipos de destino.</span><span class="sxs-lookup"><span data-stu-id="88e2a-170">When writing, it is not necessary to specify target types.</span></span>  
  
 <span data-ttu-id="88e2a-171">Esta sobrecarga de la <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor establece la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedad a los valores de matriz que se pasa a través de la `targetTypes` parámetro.</span><span class="sxs-lookup"><span data-stu-id="88e2a-171">This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property to the array values passed in through the `targetTypes` parameter.</span></span> <span data-ttu-id="88e2a-172">Si establece esta propiedad, permitirá un <xref:System.Messaging.MessageQueue> mediante este <xref:System.Messaging.XmlMessageFormatter> instancia para leer los mensajes que contienen objetos de los tipos especificados.</span><span class="sxs-lookup"><span data-stu-id="88e2a-172">Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of the given types.</span></span>  
  
 <span data-ttu-id="88e2a-173">Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-173">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="88e2a-174">Esto permite al formateador interpretar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-174">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="88e2a-175">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-175">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="88e2a-176">Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</span><span class="sxs-lookup"><span data-stu-id="88e2a-176">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="88e2a-177">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</span><span class="sxs-lookup"><span data-stu-id="88e2a-177">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="88e2a-178">El conjunto de tipos es el conjunto combinado de las dos propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-178">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="88e2a-179">La decisión de los cuales uno para usarlo es específica para su aplicación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-179">The decision of which one to use is specific to your application.</span></span> <span data-ttu-id="88e2a-180">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción en tiempo de lectura.</span><span class="sxs-lookup"><span data-stu-id="88e2a-180">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</span></span>  
  
 <span data-ttu-id="88e2a-181">Al especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> en lugar de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, se comprueba la existencia de tipo en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de error.</span><span class="sxs-lookup"><span data-stu-id="88e2a-181">When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.</span></span> <span data-ttu-id="88e2a-182"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requiere que cada entrada estén completos, especificando su nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-182"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name.</span></span> <span data-ttu-id="88e2a-183">Además, cuando se trabaja con varias versiones simultáneas, el número de versión también debe agregarse en el nombre de tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="88e2a-183">Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</span></span>  
  
 <span data-ttu-id="88e2a-184">Cuando se usa <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, puede agregar cada objeto (por ejemplo, `MyClass`) a la lista de forma que se muestra en el siguiente código de C#.</span><span class="sxs-lookup"><span data-stu-id="88e2a-184">When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the following C# code.</span></span>  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-185">El valor del parámetro <paramref name="targetTypes" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-185">The <paramref name="targetTypes" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="88e2a-186"><see cref="T:System.Messaging.Message" /> que se va a inspeccionar.</span><span class="sxs-lookup"><span data-stu-id="88e2a-186">The <see cref="T:System.Messaging.Message" /> to inspect.</span></span></param>
        <summary><span data-ttu-id="88e2a-187">Determina si el formateador puede deserializar el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-187">Determines whether the formatter can deserialize the message.</span></span></summary>
        <returns>
          <span data-ttu-id="88e2a-188">Es <see langword="true" /> si el formateador XML puede deserializar el mensaje; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-188"><see langword="true" /> if the XML formatter can deserialize the message; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-189">Cuando <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> se llama, el formateador intenta determinar si el contenido del mensaje es algo que se pueda deserializar.</span><span class="sxs-lookup"><span data-stu-id="88e2a-189">When <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> is called, the formatter attempts to determine if the contents of the message are something it can deserialize.</span></span> <span data-ttu-id="88e2a-190">El formateador sólo puede deserializar el mensaje si el tipo en el cuerpo del mensaje tiene el mismo esquema que uno de los tipos de la matriz representada por la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-190">The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties.</span></span> <span data-ttu-id="88e2a-191"><xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Devuelve `false` en los dos casos siguientes:</span><span class="sxs-lookup"><span data-stu-id="88e2a-191"><xref:System.Messaging.XmlMessageFormatter.CanRead%2A> returns `false` under the following two circumstances:</span></span>  
  
-   <span data-ttu-id="88e2a-192">El mensaje no se formateó utilizando el <xref:System.Messaging.XmlMessageFormatter>.</span><span class="sxs-lookup"><span data-stu-id="88e2a-192">The message was not formatted using the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
-   <span data-ttu-id="88e2a-193">El esquema del cuerpo del mensaje no está entre los que figuran en la vista la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="88e2a-193">The schema of the message body is not among those listed in either the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property.</span></span>  
  
 <span data-ttu-id="88e2a-194">El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los tipos de objetos debe ser capaz de deserializar.</span><span class="sxs-lookup"><span data-stu-id="88e2a-194">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what types of objects it must be able to deserialize.</span></span> <span data-ttu-id="88e2a-195">Si no está en la lista de cualquier tipo, aún se encuentra dentro del mensaje, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="88e2a-195">If any type is missing from the list, yet is found within the message, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="88e2a-196">No se ha establecido la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ni la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-196">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-197">El valor del parámetro <paramref name="message" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-197">The <paramref name="message" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="88e2a-198">Crea una instancia de la clase <see cref="T:System.Messaging.XmlMessageFormatter" /> cuyas propiedades de lectura y escritura (los conjuntos de tipos de destino) son las mismas que las de la instancia de <see cref="T:System.Messaging.XmlMessageFormatter" /> actual.</span><span class="sxs-lookup"><span data-stu-id="88e2a-198">Creates an instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class whose read/write properties (the sets of target types) are the same as the current <see cref="T:System.Messaging.XmlMessageFormatter" /> instance.</span></span></summary>
        <returns><span data-ttu-id="88e2a-199">Objeto cuyas propiedades son idénticas a las de esta instancia de <see cref="T:System.Messaging.XmlMessageFormatter" />, pero cuyos metadatos no especifican que sea una instancia de la clase de formateador.</span><span class="sxs-lookup"><span data-stu-id="88e2a-199">An object whose properties are identical to those of this <see cref="T:System.Messaging.XmlMessageFormatter" /> instance, but whose metadata does not specify it to be a formatter class instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-200">Este método crea una copia del formateador e inicializa todas sus propiedades en los valores de este <xref:System.Messaging.XmlMessageFormatter> objeto.</span><span class="sxs-lookup"><span data-stu-id="88e2a-200">This method creates a copy of the formatter and initializes all its properties to the values of this <xref:System.Messaging.XmlMessageFormatter> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="88e2a-201"><see cref="T:System.Messaging.Message" />, en formato XML, que se va a deserializar.</span><span class="sxs-lookup"><span data-stu-id="88e2a-201">The <see cref="T:System.Messaging.Message" />, in XML format, to deserialize.</span></span></param>
        <summary><span data-ttu-id="88e2a-202">Lee el contenido del mensaje especificado y crea un objeto que contiene el mensaje deserializado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-202">Reads the contents from the given message and creates an object that contains the deserialized message.</span></span></summary>
        <returns><span data-ttu-id="88e2a-203">El mensaje deserializado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-203">The deserialized message.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-204">Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-204">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="88e2a-205">Una de estas propiedades debe establecerse antes de que se puede deserializar el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-205">One of these properties must be set before the message can be deserialized.</span></span>  
  
 <span data-ttu-id="88e2a-206">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-206">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="88e2a-207">Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</span><span class="sxs-lookup"><span data-stu-id="88e2a-207">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="88e2a-208">Los tipos de destino no tienen que especificarse con el fin de escribir en la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-208">The target types do not have to be specified in order to write to the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="88e2a-209">No se ha establecido la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ni la propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-209">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</span></span>  
  
 <span data-ttu-id="88e2a-210">O bien</span><span class="sxs-lookup"><span data-stu-id="88e2a-210">-or-</span></span>  
  
 <span data-ttu-id="88e2a-211">La instancia serializada en el cuerpo del mensaje no sigue ninguno de los esquemas que representan los tipos de las propiedades <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> y <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-211">The instance serialized in the message body does not comply with any of the schemas represented by the types in the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> and <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> properties.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-212">El valor del parámetro <paramref name="message" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-212">The <paramref name="message" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="88e2a-213">Especifica el conjunto de tipos posibles que el formateador deserializará a partir del mensaje proporcionado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-213">Specifies the set of possible types that will be deserialized by the formatter from the message provided.</span></span></summary>
        <value><span data-ttu-id="88e2a-214">Matriz de tipo <see cref="T:System.String" /> que especifica los tipos de objetos que se van a deserializar del cuerpo del mensaje cuando se lea el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-214">An array of type <see cref="T:System.String" /> that specifies the types of objects to deserialize from the message body when reading the message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-215">Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-215">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="88e2a-216">Esto permite al formateador interpretar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-216">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="88e2a-217">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-217">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="88e2a-218">Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</span><span class="sxs-lookup"><span data-stu-id="88e2a-218">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="88e2a-219">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</span><span class="sxs-lookup"><span data-stu-id="88e2a-219">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="88e2a-220">El conjunto de tipos es el conjunto combinado de las dos propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-220">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="88e2a-221">La decisión de qué propiedad que se va a usar es específica de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-221">The decision of which property to use is specific to your application.</span></span> <span data-ttu-id="88e2a-222">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción cuando se lee el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-222">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</span></span>  
  
 <span data-ttu-id="88e2a-223"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requiere que cada entrada estén completos, especificando su nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-223"><xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name.</span></span> <span data-ttu-id="88e2a-224">Además, cuando se trabaja con varias versiones simultáneas, el número de versión también debe agregarse en el nombre de tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="88e2a-224">Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</span></span>  
  
 <span data-ttu-id="88e2a-225">Los tipos de destino sólo son necesarios cuando se lee de la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-225">The target types are only required when reading from the queue.</span></span> <span data-ttu-id="88e2a-226">El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> no deben establecerse para escribir en la cola de propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-226">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-227">La propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-227">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> property is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="88e2a-228">Especifica el conjunto de tipos posibles que el formateador deserializará a partir del mensaje proporcionado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-228">Specifies the set of possible types that will be deserialized by the formatter from the message provided.</span></span></summary>
        <value><span data-ttu-id="88e2a-229">Matriz de tipo <see cref="T:System.Type" /> que especifica los tipos de objetos que se van a deserializar del cuerpo del mensaje cuando se lea el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-229">An array of type <see cref="T:System.Type" /> that specifies the types of objects to deserialize from the message body when reading the message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-230">Tanto el <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedades indican al formateador los esquemas que trate de hacer coincidir al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-230">Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message.</span></span> <span data-ttu-id="88e2a-231">Esto permite al formateador interpretar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-231">This allows the formatter to interpret the message body.</span></span>  
  
 <span data-ttu-id="88e2a-232">La instancia serializada en el cuerpo del mensaje debe cumplir con uno de los esquemas representados en la matriz de tipos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-232">The instance serialized in the message body must comply with one of the schemas represented in the type array.</span></span> <span data-ttu-id="88e2a-233">Cuando se lee el mensaje utilizando el <xref:System.Messaging.MessageQueue.Receive%2A> método, el método crea un objeto del tipo que corresponde al esquema identificado y lee el cuerpo del mensaje en él.</span><span class="sxs-lookup"><span data-stu-id="88e2a-233">When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</span></span>  
  
 <span data-ttu-id="88e2a-234">Solo una de las dos propiedades debe establecerse al leer de la cola, pero se pueden establecer ambas.</span><span class="sxs-lookup"><span data-stu-id="88e2a-234">Only one of the two properties needs to be set when reading from the queue, but you can set both.</span></span> <span data-ttu-id="88e2a-235">El conjunto de tipos es el conjunto combinado de las dos propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-235">The set of types is the combined set from the two properties.</span></span> <span data-ttu-id="88e2a-236">La decisión de qué propiedad que se va a usar es específica de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="88e2a-236">The decision of which property to use is specific to your application.</span></span> <span data-ttu-id="88e2a-237">Si el cuerpo del mensaje contiene un tipo cuyo esquema no coincide con ninguno de los tipos de la matriz para cualquiera de estas propiedades, se producirá una excepción cuando se lee el mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-237">If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</span></span>  
  
 <span data-ttu-id="88e2a-238">Los tipos de destino sólo son necesarios cuando se lee de la cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-238">The target types are only required when reading from the queue.</span></span> <span data-ttu-id="88e2a-239">El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> y <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> no deben establecerse para escribir en la cola de propiedades.</span><span class="sxs-lookup"><span data-stu-id="88e2a-239">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.</span></span>  
  
 <span data-ttu-id="88e2a-240">Al especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> en lugar de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, se comprueba la existencia de tipo en tiempo de compilación en lugar de tiempo de lectura, lo que reduce la posibilidad de error.</span><span class="sxs-lookup"><span data-stu-id="88e2a-240">When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.</span></span>  
  
 <span data-ttu-id="88e2a-241">Cuando se usa <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, puede agregar cada objeto (por ejemplo, `MyClass`) a la lista de forma que se muestra en el código de C# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.</span><span class="sxs-lookup"><span data-stu-id="88e2a-241">When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the C# code `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="88e2a-242">En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido a y desde una cola.</span><span class="sxs-lookup"><span data-stu-id="88e2a-242">The following code example sends and receives a message that contains an order to and from a queue.</span></span>  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-243">La propiedad <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-243">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="88e2a-244"><see cref="T:System.Messaging.Message" /> cuya propiedad <see cref="P:System.Messaging.Message.Body" /> contendrá el objeto serializado.</span><span class="sxs-lookup"><span data-stu-id="88e2a-244">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Body" /> property will contain the serialized object.</span></span></param>
        <param name="obj"><span data-ttu-id="88e2a-245"><see cref="T:System.Object" /> que se va a serializar en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-245">The <see cref="T:System.Object" /> to be serialized into the message body.</span></span></param>
        <summary><span data-ttu-id="88e2a-246">Serializa un objeto en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-246">Serializes an object into the body of the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="88e2a-247">No es necesitan especificar los tipos de destino para escribir en la cola como deben ser cuando se leen.</span><span class="sxs-lookup"><span data-stu-id="88e2a-247">The target types need not be specified to write to the queue as they must be when reading.</span></span> <span data-ttu-id="88e2a-248">El <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propiedad es utilizada por el formateador solo al deserializar un mensaje.</span><span class="sxs-lookup"><span data-stu-id="88e2a-248">The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property is used by the formatter only when deserializing a message.</span></span>  
  
 <span data-ttu-id="88e2a-249">El <xref:System.Messaging.XmlMessageFormatter> hace uso de la <xref:System.Xml.Serialization.XmlSerializer> (clase), que define lo que se puede serializar.</span><span class="sxs-lookup"><span data-stu-id="88e2a-249">The <xref:System.Messaging.XmlMessageFormatter> makes use of the <xref:System.Xml.Serialization.XmlSerializer> class, which defines what can be serialized.</span></span> <span data-ttu-id="88e2a-250">Solo se pueden serializar propiedades públicas y campos públicos.</span><span class="sxs-lookup"><span data-stu-id="88e2a-250">Only public fields and public properties can be serialized.</span></span> <span data-ttu-id="88e2a-251">Estructuras, las estructuras con matrices y las matrices de estructuras se pueden serializar, siempre y cuando no use el estilo codificado con el protocolo SOAP.</span><span class="sxs-lookup"><span data-stu-id="88e2a-251">Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="88e2a-252">El valor del parámetro <paramref name="message" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-252">The <paramref name="message" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="88e2a-253">O bien</span><span class="sxs-lookup"><span data-stu-id="88e2a-253">-or-</span></span>  
  
 <span data-ttu-id="88e2a-254">El valor del parámetro <paramref name="obj" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="88e2a-254">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>