<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0c27a71c6abe02c5089f5ec2a8428924b3b50db6" /><Meta Name="ms.sourcegitcommit" Value="5ebd9691c6f7d50c4730e997fba69e54bdd7cc0c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/17/2019" /><Meta Name="ms.locfileid" Value="65829731" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona acceso a una cola de Message Queue server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tecnología de Message Queue Server permite que aplicaciones que se ejecutan en distintos momentos se comuniquen a través de redes heterogéneas y sistemas que pueden estar temporalmente sin conexión. Las aplicaciones enviarán, recepción o leer (peek sin quitar) mensajes de las colas. Message Queue Server es un componente opcional de [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] y Windows NT y deben instalarse por separado.  
  
 La <xref:System.Messaging.MessageQueue> clase es un contenedor alrededor de Message Queue Server. Hay varias versiones de Message Queue Server y el uso del <xref:System.Messaging.MessageQueue> clase puede provocar un comportamiento ligeramente diferente, dependiendo del sistema operativo que esté utilizando. Para obtener información sobre características específicas de cada versión de Message Queue Server, vea el tema "Novedades de Message Queue Server" en Platform SDK en MSDN.  
  
 La <xref:System.Messaging.MessageQueue> clase proporciona una referencia a una cola de Message Queue Server. Puede especificar una ruta de acceso en el <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor para conectarse a un recurso existente, o bien puede crear una nueva cola en el servidor. Antes de llamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, o <xref:System.Messaging.MessageQueue.Receive%2A>, debe asociar la nueva instancia de la <xref:System.Messaging.MessageQueue> clase con una cola existente. En ese momento, puede manipular las propiedades de cola como <xref:System.Messaging.MessageQueue.Category%2A> y <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> admite dos tipos de recuperación de mensajes: sincrónica y asincrónica. Los métodos sincrónicos, <xref:System.Messaging.MessageQueue.Peek%2A> y <xref:System.Messaging.MessageQueue.Receive%2A>, el subproceso debe esperar un intervalo de tiempo especificado para un nuevo mensaje llegue a la cola. Los métodos asincrónicos, <xref:System.Messaging.MessageQueue.BeginPeek%2A> y <xref:System.Messaging.MessageQueue.BeginReceive%2A>, permiten que las tareas de la aplicación principal continuar en un subproceso independiente hasta que llegue un mensaje en la cola. Estos métodos funcionan con objetos de devolución de llamada y objetos de estado para comunicar información entre los subprocesos.  
  
 Cuando se crea una nueva instancia de la <xref:System.Messaging.MessageQueue> (clase), no está creando una nueva cola de Message Queue Server. En su lugar, puede usar el <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, y <xref:System.Messaging.MessageQueue.Purge%2A> métodos para administrar colas en el servidor.  
  
 A diferencia de <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> y <xref:System.Messaging.MessageQueue.Delete%28System.String%29> son `static` miembros, para que pueda llamar sin crear una nueva instancia de la <xref:System.Messaging.MessageQueue> clase.  
  
 Puede establecer el <xref:System.Messaging.MessageQueue> del objeto <xref:System.Messaging.MessageQueue.Path%2A> propiedad con uno de estos tres nombres: el nombre descriptivo, el <xref:System.Messaging.MessageQueue.FormatName%2A>, o el <xref:System.Messaging.MessageQueue.Label%2A>. El nombre descriptivo, que se define por la cola <xref:System.Messaging.MessageQueue.MachineName%2A> y <xref:System.Messaging.MessageQueue.QueueName%2A> propiedades, es <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para una cola pública, y <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para una cola privada. El <xref:System.Messaging.MessageQueue.FormatName%2A> propiedad permite el acceso sin conexión a las colas de mensajes. Por último, puede usar la cola <xref:System.Messaging.MessageQueue.Label%2A> propiedad para establecer la cola <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Para obtener una lista de valores de propiedad iniciales de una instancia de <xref:System.Messaging.MessageQueue>, consulte el <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo <xref:System.Messaging.MessageQueue> objetos utilizando varios tipos de sintaxis de nombre de ruta de acceso. En cada caso, envía un mensaje a la cola cuya ruta de acceso se define en el constructor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 En el ejemplo de código siguiente se envía un mensaje a una cola y recibe un mensaje de una cola, mediante una clase específica de la aplicación llamada `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Solo el <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> método es seguro para subprocesos.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.MessageQueue" />. Después de que el constructor predeterminado inicializa la nueva instancia, debe establecer la instancia <see cref="P:System.Messaging.MessageQueue.Path" /> propiedad antes de poder usar la instancia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear una nueva instancia de la <xref:System.Messaging.MessageQueue> clase que no esté inmediatamente enlazada a una cola de Message Queue server. Antes de usar esta instancia, debe conectarla a una cola de Message Queue Server existente estableciendo el <xref:System.Messaging.MessageQueue.Path%2A> propiedad. Como alternativa, puede establecer el <xref:System.Messaging.MessageQueue> hacen referencia a la <xref:System.Messaging.MessageQueue.Create%28System.String%29> valor devuelto del método, con lo que se crea una nueva cola de Message Queue Server.  
  
 El <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor crea una nueva instancia de la <xref:System.Messaging.MessageQueue> clase; no crea una nueva cola de Message Queue Server.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Messaging.MessageQueue>.  
  
|Propiedad|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Los valores establecidos por el constructor predeterminado de la <xref:System.Messaging.DefaultPropertiesToSend> clase.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Los valores establecidos por el constructor predeterminado de la <xref:System.Messaging.MessagePropertyFilter> clase. Todos los valores de filtro se establecen en `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.Messaging.MessageQueue" /> clase que hace referencia a la cola de Message Queue Server en la ruta especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga cuando desea asociar la nueva <xref:System.Messaging.MessageQueue> instancia a una cola de Message Queue Server determinada, para la que conozca la ruta de acceso, nombre de formato o etiqueta. Si desea conceder acceso exclusivo a la primera aplicación que hace referencia a la cola, debe establecer el <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propiedad `true` o use el constructor que pasa un parámetro de restricción de acceso de lectura.  
  
 El <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor crea una nueva instancia de la <xref:System.Messaging.MessageQueue> clase; no crea una nueva cola de Message Queue Server. Para crear una nueva cola en Message Queue Server, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintaxis de la `path` parámetro depende del tipo de cola que hace referencia, como se muestra en la tabla siguiente.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
|Cola de diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Cola de diario del equipo|`MachineName`\\`Journal$`|  
|Cola de mensajes no enviados del equipo|`MachineName`\\`Deadletter$`|  
|Cola de mensajes no enviados transaccional del equipo|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, puede usar el <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> para describir la ruta de acceso de la cola, como se muestra en la tabla siguiente.  
  
|Referencia|Sintaxis|Ejemplo|  
|---------------|------------|-------------|  
|Nombre de formato|`FormatName:` [ *nombre de formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etiqueta|`Label:` [ *etiqueta* ]|`Label:` Etiqueta|  
  
 Para trabajar sin conexión, debe usar la sintaxis del nombre de formato, no en la sintaxis del nombre de ruta de acceso para el constructor. En caso contrario, se produce una excepción porque el controlador de dominio principal no está disponible para resolver la ruta de acceso en el nombre de formato.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Messaging.MessageQueue>. Estos valores se basan en las propiedades de la cola de Message Queue Server con la ruta de acceso especificada por el `path` parámetro.  
  
|Propiedad|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Los valores establecidos por el constructor predeterminado de la <xref:System.Messaging.DefaultPropertiesToSend> clase.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, si la configuración de nivel de privacidad de la cola de Message Queue Server es "Body"; en caso contrario, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|El valor de propiedad de nombre de equipo de la cola de Message Queue Server.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Los valores establecidos por el constructor predeterminado de la <xref:System.Messaging.MessagePropertyFilter> clase.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, si no se establece mediante el constructor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, si no se establece mediante el constructor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, si está habilitada la opción de diario del objeto de Message Queue Server; en caso contrario, `false`.|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo <xref:System.Messaging.MessageQueue> objetos utilizando varios tipos de sintaxis de nombre de ruta de acceso. En cada caso, envía un mensaje a la cola cuya ruta de acceso se define en el constructor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="P:System.Messaging.MessageQueue.Path" /> propiedad no es válida, posiblemente porque no se estableció.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />, que puede ser "." para el equipo local.</param>
        <param name="sharedModeDenyReceive"><see langword="true" /> Para conceder acceso de lectura exclusivo a la primera aplicación que tiene acceso a la cola; en caso contrario, <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.Messaging.MessageQueue" /> clase que hace referencia a la cola de Message Queue Server en la ruta de acceso especificada y con la restricción de acceso de lectura especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga cuando desea asociar la nueva <xref:System.Messaging.MessageQueue> a una cola de Message Queue Server determinada, para la que conozca la ruta de acceso, nombre de formato o etiqueta. Si desea conceder acceso exclusivo a la primera aplicación que hace referencia a la cola, establezca la `sharedModeDenyReceive` parámetro `true`. De lo contrario, establézcalo `sharedModeDenyReceive` a `false` o use el constructor que tiene solo un `path` parámetro.  
  
 Establecer `sharedModeDenyReceive` a `true` afecta a todos los objetos que tienen acceso a la cola de Message Queue Server, incluidas otras aplicaciones. Los efectos del parámetro no se limitan a esta aplicación.  
  
 El <xref:System.Messaging.MessageQueue.%23ctor%2A> el constructor crea una nueva instancia de la <xref:System.Messaging.MessageQueue> clase; no crea una nueva cola de Message Queue Server. Para crear una nueva cola en Message Queue Server, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintaxis de la `path` parámetro depende del tipo de cola.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
|Cola de diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Cola de diario del equipo|`MachineName`\\`Journal$`|  
|Cola de mensajes no enviados del equipo|`MachineName`\\`Deadletter$`|  
|Cola de mensajes no enviados transaccional del equipo|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, puede usar el nombre de formato o la etiqueta de una cola de Message Queue Server para describir la ruta de acceso de la cola.  
  
|Referencia|Sintaxis|Ejemplo|  
|---------------|------------|-------------|  
|Nombre de formato|`FormatName:` [ *nombre de formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etiqueta|`Label:` [ *etiqueta* ]|`Label:` Etiqueta|  
  
 Para trabajar sin conexión, debe usar la sintaxis del nombre de formato, en lugar de la sintaxis del nombre descriptivo. En caso contrario, se produce una excepción porque el controlador de dominio principal (en el que reside Active Directory) no está disponible para resolver la ruta de acceso en el nombre de formato.  
  
 Si un <xref:System.Messaging.MessageQueue> abre una cola con el `sharedModeDenyReceive` parámetro establecido en `true`, cualquier <xref:System.Messaging.MessageQueue> que posteriormente intente leer de la cola genera un <xref:System.Messaging.MessageQueueException> debido a una infracción de uso compartido. Un <xref:System.Messaging.MessageQueueException> también se produce si un <xref:System.Messaging.MessageQueue> intenta tener acceso a la cola en modo exclusivo y otro <xref:System.Messaging.MessageQueue> ya tiene acceso no exclusivo a la cola.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Messaging.MessageQueue>. Estos valores se basan en las propiedades de la cola de Message Queue Server, con la ruta de acceso especificada por el `path` parámetro.  
  
|Propiedad|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Los valores establecidos por el constructor predeterminado de la <xref:System.Messaging.DefaultPropertiesToSend> clase.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, si la configuración de nivel de privacidad de la cola de Message Queue Server es "Body"; en caso contrario, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|El valor de propiedad de nombre de equipo de la cola de Message Queue Server.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Los valores establecidos por el constructor predeterminado de la <xref:System.Messaging.MessagePropertyFilter> clase.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, si no se establece mediante el constructor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, si no se establece mediante el constructor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Valor del parámetro `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, si está habilitada la opción de diario del objeto de Message Queue Server; en caso contrario, `false`.|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo <xref:System.Messaging.MessageQueue> con acceso exclusivo, establece su ruta de acceso y envía un mensaje a la cola.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="P:System.Messaging.MessageQueue.Path" /> propiedad no es válida, posiblemente porque no se estableció.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />, que puede ser "." para el equipo local.</param>
        <param name="accessMode">Uno de los valores de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />, que puede ser "." para el equipo local.</param>
        <param name="sharedModeDenyReceive"><see langword="true" /> Para conceder acceso de lectura exclusivo a la primera aplicación que tiene acceso a la cola; en caso contrario, <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" /> Para crear y utilizar una caché de conexión; en caso contrario, <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo <xref:System.Messaging.MessageQueue> con acceso de lectura exclusivo y con conexión de almacenamiento en caché habilitado.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />, que puede ser "." para el equipo local.</param>
        <param name="sharedModeDenyReceive"><see langword="true" /> Para conceder acceso de lectura exclusivo a la primera aplicación que tiene acceso a la cola; en caso contrario, <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" /> Para crear y utilizar una caché de conexión; en caso contrario, <see langword="false" />.</param>
        <param name="accessMode">Uno de los valores de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el modo de acceso para la cola.</summary>
        <value>Uno de los valores de <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de acceso predeterminado para una cola es `QueueAccessMode.SendAndReceive`, a menos que se especifique lo contrario al llamar al constructor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la cola acepta sólo mensajes autenticados.</summary>
        <value><see langword="true" /> Si la cola acepta sólo mensajes autenticados; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autenticación de mensajes proporciona una forma de garantizar la integridad del mensaje y para comprobar quién envió el mensaje. Para solicitar la autenticación, la aplicación de envío establece el nivel de autenticación del mensaje.  
  
 Al establecer <xref:System.Messaging.MessageQueue.Authenticate%2A> a `true`, restringe el acceso a la cola en el servidor, no solo a esta <xref:System.Messaging.MessageQueue> instancia. Trabajar con la misma cola de Message Queue Server de todos los clientes se verán afectados.  
  
 Una cola que acepta sólo mensajes autenticados rechaza un mensaje no autenticado. Para solicitar notificación de rechazo de mensaje, puede establecer una aplicación emisora el <xref:System.Messaging.Message.AcknowledgeType%2A> propiedad del mensaje. Porque no existe ninguna otra indicación de rechazo de mensaje, la aplicación de envío puede perder el mensaje a menos que la solicitud que se enviarán a la cola de mensajes no enviados.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.Authenticate%2A> propiedad.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la prioridad básica que Message Queuing utiliza para enrutar los mensajes de una cola pública a través de la red.</summary>
        <value>La prioridad básica única para todos los mensajes enviados a la cola (pública). El valor predeterminado es cero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prioridad básica de una cola de mensajes especifica cómo un mensaje en la ruta a la cola se trata como viajan a través de la red. Puede establecer el <xref:System.Messaging.MessageQueue.BasePriority%2A> propiedad que se va a conceder a todos los mensajes enviados a la cola especificada de los enviados a otras colas una prioridad superior o inferior. Al establecer esta propiedad modifica la cola de Message Queue Server. Por lo tanto, cualquier otro <xref:System.Messaging.MessageQueue> instancias se ven afectadas por el cambio.  
  
 Una cola de mensajes <xref:System.Messaging.MessageQueue.BasePriority%2A> no está relacionado con el <xref:System.Messaging.Message.Priority%2A> propiedad de un mensaje, que especifica el orden en el que se coloca un mensaje entrante en la cola.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> se aplica a las colas solo para el acceso público cuyas rutas de acceso se especifican utilizando el nombre de formato. La prioridad básica de una cola privada siempre es cero (0).  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.BasePriority%2A> propiedad.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La prioridad básica se estableció en un valor no válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <summary>Inicia una operación de búsqueda peek asincrónica al indicar a Message Queuing que empiece a leer un mensaje y lo notifique al controlador de eventos cuando termine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia una operación de búsqueda peek asincrónica sin tiempo de espera. La operación no está completa hasta que haya un mensaje disponible en la cola.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el procesamiento asincrónico, usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para generar el <xref:System.Messaging.MessageQueue.PeekCompleted> evento cuando un mensaje disponible en la cola.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia una operación de búsqueda peek asincrónica; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.PeekCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o puede recuperar el resultado mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginPeek%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginPeek%2A> es asincrónico, se puede llamar para buscar la cola sin bloquear el subproceso de ejecución actual. Para buscar la cola de forma sincrónica, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> es `false`, se provoca el evento de finalización, pero se producirá una excepción al llamar a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un controlador de eventos denominado `MyPeekCompleted`, lo asocia a la <xref:System.Messaging.MessageQueue.PeekCompleted> delegado controlador de eventos y llamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar una operación de búsqueda peek asincrónica en la cola que se encuentra en la ruta de acceso ". \myQueue". Cuando un <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento, el ejemplo busca el mensaje y escribe el cuerpo en la pantalla. El ejemplo llama a <xref:System.Messaging.MessageQueue.BeginPeek%2A> nuevo para iniciar una nueva operación de búsqueda peek asincrónica.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <summary>Inicia una operación de búsqueda peek asincrónica que tiene un tiempo de espera especificado. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el procesamiento asincrónico, usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para generar el <xref:System.Messaging.MessageQueue.PeekCompleted> evento cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia una operación de búsqueda peek asincrónica; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.PeekCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o puede recuperar el resultado mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginPeek%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginPeek%2A> es asincrónico, se puede llamar para buscar la cola sin bloquear el subproceso de ejecución actual. Para buscar la cola de forma sincrónica, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 Esta sobrecarga especifica un tiempo de espera. Si el intervalo especificado por el `timeout` parámetro caduca, este componente genera el <xref:System.Messaging.MessageQueue.PeekCompleted> eventos. Dado que no existe ningún mensaje, una llamada subsiguiente a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se iniciará una excepción.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> es `false`, se provoca el evento de finalización, pero se producirá una excepción al llamar a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una operación de búsqueda peek asincrónica, utilizando la ruta de cola ". \myQueue". Crea un controlador de eventos, `MyPeekCompleted`y lo asocia a la <xref:System.Messaging.MessageQueue.PeekCompleted> delegado controlador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> se llama con un tiempo de espera de un minuto, para iniciar la operación de búsqueda peek asincrónica. Cuando un <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento o expira el tiempo de espera, se recupera el mensaje si existe uno, y el cuerpo se escribe en la pantalla. A continuación, <xref:System.Messaging.MessageQueue.BeginPeek%2A> se vuelve a llamar para iniciar una nueva operación de búsqueda peek asincrónica con el mismo tiempo de espera.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <param name="stateObject">Un objeto de estado, especificado por la aplicación, que contiene información asociada con la operación asincrónica.</param>
        <summary>Inicia una operación de búsqueda peek asincrónica que tiene un tiempo de espera especificado y un objeto de estado especificado, que proporciona información relacionada durante toda la operación. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el procesamiento asincrónico, usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para generar el <xref:System.Messaging.MessageQueue.PeekCompleted> evento cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Utilice esta sobrecarga para asociar información con la operación que se conservará durante el ciclo de vida de la operación. El controlador de eventos puede tener acceso a esta información si examina el <xref:System.IAsyncResult.AsyncState%2A> propiedad de la <xref:System.IAsyncResult> que está asociado con la operación.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia una operación de búsqueda peek asincrónica; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.PeekCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o puede recuperar el resultado mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginPeek%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginPeek%2A> es asincrónico, se puede llamar para buscar la cola sin bloquear el subproceso de ejecución actual. Para buscar la cola de forma sincrónica, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Devuelve un <xref:System.IAsyncResult> que identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 Esta sobrecarga especifica un tiempo de espera y un objeto de estado. Si el intervalo especificado por el `timeout` parámetro caduca, este componente genera el <xref:System.Messaging.MessageQueue.PeekCompleted> eventos. Dado que no existe ningún mensaje, una llamada subsiguiente a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se iniciará una excepción.  
  
 El objeto de estado asocia información de estado de la operación. Por ejemplo, si se llama a <xref:System.Messaging.MessageQueue.BeginPeek%2A> varias veces para iniciar varias operaciones, puede identificar cada operación a través de un objeto de estado independiente que defina. Para ver una ilustración de este escenario, vea la sección ejemplo.  
  
 También puede usar el objeto de estado para pasar información a través de subprocesos del proceso. Si se inicia un subproceso, pero la devolución de llamada se encuentra en un subproceso diferente en un escenario asincrónico, el objeto de estado se calculan las referencias y se pasa junto con información del evento.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> es `false`, se provoca el evento de finalización, pero se producirá una excepción al llamar a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una operación de búsqueda peek asincrónica, utilizando la ruta de cola ". \myQueue". Crea un controlador de eventos, `MyPeekCompleted`y lo asocia a la <xref:System.Messaging.MessageQueue.PeekCompleted> delegado controlador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> se llama, con un tiempo de espera de un minuto. Cada llamada a <xref:System.Messaging.MessageQueue.BeginPeek%2A> tiene asociado un entero único que identifica esa operación en particular. Cuando un <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento o ha expirado el tiempo de espera, se recupera el mensaje, si existe alguno, y su cuerpo y el identificador entero específico de la operación se escriben en la pantalla. A continuación, <xref:System.Messaging.MessageQueue.BeginPeek%2A> se vuelve a llamar para iniciar una nueva operación de búsqueda peek asincrónica con el mismo tiempo de espera y el entero asociado de la operación acaba de terminar.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <param name="stateObject">Un objeto de estado, especificado por la aplicación, que contiene información asociada con la operación asincrónica.</param>
        <param name="callback">El <see cref="T:System.AsyncCallback" /> que recibirá la notificación de la finalización de la operación asincrónica.</param>
        <summary>Inicia una operación de búsqueda peek asincrónica que tiene un tiempo de espera especificado y un objeto de estado especificado, que proporciona información relacionada durante toda la operación. Esta sobrecarga recibe una notificación, mediante una devolución de llamada de la identidad del controlador de eventos para la operación. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando utilice esta sobrecarga, la devolución de llamada especificado en el parámetro de devolución de llamada se invoca directamente cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado; el <xref:System.Messaging.MessageQueue.PeekCompleted> no se produce el evento. Las demás sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> dependen de este componente para provocar el <xref:System.Messaging.MessageQueue.PeekCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> También se produce si ya existe un mensaje en la cola.  
  
 El <xref:System.Messaging.MessageQueue.BeginPeek%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginPeek%2A> es asincrónico, se puede llamar para buscar la cola sin bloquear el subproceso de ejecución actual. Para buscar la cola de forma sincrónica, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Devuelve un <xref:System.IAsyncResult> que identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 El objeto de estado asocia información de estado de la operación. Por ejemplo, si se llama a <xref:System.Messaging.MessageQueue.BeginPeek%2A> varias veces para iniciar varias operaciones, puede identificar cada operación a través de un objeto de estado independiente que defina.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una operación de búsqueda peek asincrónica. Los envíos de ejemplo de código un mensaje a una cola de mensajes locales, a continuación, llama a <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, pasando: un valor de tiempo de espera de diez segundos; un entero único que identifica ese mensaje en particular; y una nueva instancia de <xref:System.AsyncCallback> que identifica el controlador de eventos `MyPeekCompleted`. Cuando un <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento, el controlador de eventos se inspecciona el mensaje y escribe el cuerpo del mensaje y el identificador entero del mensaje en la pantalla.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <param name="cursor">Un <see cref="T:System.Messaging.Cursor" /> que mantiene una posición específica en la cola de mensajes.</param>
        <param name="action">Uno de los valores de <see cref="T:System.Messaging.PeekAction" />. Indica si se utiliza inspeccionar el mensaje actual de la cola o el mensaje siguiente.</param>
        <param name="state">Un objeto de estado, especificado por la aplicación, que contiene información asociada con la operación asincrónica.</param>
        <param name="callback">El <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <summary>Inicia una operación de búsqueda peek asincrónica que tiene un tiempo de espera especificado y que usa un cursor, una acción de búsqueda peek y un objeto de estado especificado. El objeto de estado proporciona información relacionada durante toda la duración de la operación. Esta sobrecarga recibe una notificación, mediante una devolución de llamada de la identidad del controlador de eventos para la operación. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando utilice esta sobrecarga, la devolución de llamada especificado en el parámetro de devolución de llamada se invoca directamente cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado. El <xref:System.Messaging.MessageQueue.PeekCompleted> no se produce el evento. Las demás sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> dependen de este componente para provocar el <xref:System.Messaging.MessageQueue.PeekCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> También se produce si ya existe un mensaje en la cola.  
  
 El <xref:System.Messaging.MessageQueue.BeginPeek%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginPeek%2A> es asincrónico, se puede llamar para buscar la cola sin bloquear el subproceso de ejecución actual. Para buscar la cola de forma sincrónica, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Devuelve un <xref:System.IAsyncResult> que identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, utilice el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 El objeto de estado asocia información de estado de la operación. Por ejemplo, si se llama a <xref:System.Messaging.MessageQueue.BeginPeek%2A> varias veces para iniciar varias operaciones, puede identificar cada operación a través de un objeto de estado independiente que defina.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor distinto de <see langword="PeekAction.Current" /> o <see langword="PeekAction.Next" /> se especificó para el <paramref name="action" /> parámetro.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="cursor" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <summary>Inicia una operación de recepción asincrónica al indicar a Message Queuing que empiece a recibir un mensaje y lo notifique al controlador de eventos cuando termine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia una recepción asincrónica operación que no tenga ningún tiempo de espera. La operación no está completa hasta que haya un mensaje disponible en la cola.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el procesamiento asincrónico, usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para generar el <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos cuando un mensaje se ha quitado de la cola.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia una recepción asincrónica operación; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 El <xref:System.Messaging.MessageQueue.BeginReceive%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginReceive%2A> es asincrónico, se puede llamar para recibir un mensaje de la cola sin bloquear el subproceso de ejecución actual. Para recibir sincrónicamente un mensaje, utilice el <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> es `false`, se provoca el evento de finalización, pero se producirá una excepción al llamar a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 No utilice la llamada asincrónica <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transacciones. Si desea realizar una operación transaccional asincrónica, llame a <xref:System.Messaging.MessageQueue.BeginPeek%2A>y coloca la transacción y (sincrónico) <xref:System.Messaging.MessageQueue.Receive%2A> método en el controlador de eventos de la operación de lectura. El controlador de eventos puede incluir la funcionalidad tal como se muestra en el siguiente código de C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se encadena solicitudes asincrónicas. Se supone que hay una cola en el equipo local denominado "myQueue". El `Main` función comienza la operación asincrónica que se controla mediante el `MyReceiveCompleted` rutina. `MyReceiveCompleted` procesa el mensaje actual e inicia una nueva asincrónica operación de recepción.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 En el ejemplo de código siguiente se pone en cola las solicitudes asincrónicas. La llamada a <xref:System.Messaging.MessageQueue.BeginReceive%2A> usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> en su valor devuelto. El `Main` rutina espera a que todas las operaciones asincrónicas se complete antes de salir.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <summary>Inicia una recepción asincrónica operación que tiene un tiempo de espera especificado. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el procesamiento asincrónico, usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para generar el <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia una recepción asincrónica operación; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperar el resultado mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginReceive%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginReceive%2A> es asincrónico, se puede llamar para recibir un mensaje de la cola sin bloquear el subproceso de ejecución actual. Para recibir sincrónicamente un mensaje, utilice el <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> es `false`, se provoca el evento de finalización, pero se producirá una excepción al llamar a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 Esta sobrecarga especifica un tiempo de espera. Si el intervalo especificado por el `timeout` parámetro caduca, este componente genera el <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos. Dado que no existe ningún mensaje, una llamada subsiguiente a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se iniciará una excepción.  
  
 No utilice la llamada asincrónica <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transacciones. Si desea realizar una operación transaccional asincrónica, llame a <xref:System.Messaging.MessageQueue.BeginPeek%2A>y coloca la transacción y (sincrónico) <xref:System.Messaging.MessageQueue.Receive%2A> método en el controlador de eventos de la operación de lectura. El controlador de eventos puede incluir la funcionalidad tal como se muestra en el siguiente código de C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea asincrónico operación de recepción. El ejemplo de código crea un controlador de eventos, `MyReceiveCompleted`y lo asocia a la <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegado controlador de eventos. Los envíos de ejemplo de código un mensaje a una cola de mensajes locales, a continuación, llama a <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, pasando un valor de tiempo de espera de diez segundos. Cuando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> provoca el evento, el controlador de eventos recibe el mensaje y escribe el cuerpo del mensaje en la pantalla.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente porque representa un número negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <param name="stateObject">Un objeto de estado, especificado por la aplicación, que contiene información asociada con la operación asincrónica.</param>
        <summary>Inicia una operación de recepción asincrónica que tiene un tiempo de espera especificado y un objeto de estado especificado, que proporciona información relacionada durante toda la operación. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el procesamiento asincrónico, usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para generar el <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Utilice esta sobrecarga para asociar información con la operación que se conservará durante el ciclo de vida de la operación. El controlador de eventos puede detectar esta información si examina el <xref:System.IAsyncResult.AsyncState%2A> propiedad de la <xref:System.IAsyncResult> que está asociado con la operación.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia una recepción asincrónica operación; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperar el resultado mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginReceive%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginReceive%2A> es asincrónico, se puede llamar para recibir un mensaje de la cola sin bloquear el subproceso de ejecución actual. Para recibir sincrónicamente un mensaje, utilice el <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 Esta sobrecarga especifica un tiempo de espera y un objeto de estado. Si el intervalo especificado por el `timeout` parámetro caduca, este componente genera el <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos. Dado que no existe ningún mensaje, una llamada subsiguiente a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se iniciará una excepción.  
  
 El objeto de estado asocia información de estado de la operación. Por ejemplo, si se llama a <xref:System.Messaging.MessageQueue.BeginReceive%2A> varias veces para iniciar varias operaciones, puede identificar cada operación a través de un objeto de estado independiente que defina.  
  
 También puede usar el objeto de estado para pasar información a través de subprocesos del proceso. Si se inicia un subproceso, pero la devolución de llamada se encuentra en un subproceso diferente en un escenario asincrónico, el objeto de estado se calculan las referencias y se pasa junto con información del evento.  
  
 No utilice la llamada asincrónica <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transacciones. Si desea realizar una operación transaccional asincrónica, llame a <xref:System.Messaging.MessageQueue.BeginPeek%2A>y coloca la transacción y (sincrónico) <xref:System.Messaging.MessageQueue.Receive%2A> método en el controlador de eventos de la operación de lectura. El controlador de eventos puede incluir la funcionalidad tal como se muestra en el siguiente código de C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea asincrónico operación de recepción. El ejemplo de código crea un controlador de eventos, `MyReceiveCompleted`y lo asocia a la <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegado controlador de eventos. Los envíos de ejemplo de código un mensaje a una cola de mensajes locales, a continuación, llama a <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, pasando un valor de tiempo de espera de diez segundos y un entero único que identifica ese mensaje en particular. Cuando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> provoca el evento, el controlador de eventos recibe el mensaje y escribe el cuerpo del mensaje y el identificador entero del mensaje en la pantalla.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <param name="stateObject">Un objeto de estado, especificado por la aplicación, que contiene información asociada con la operación asincrónica.</param>
        <param name="callback">El <see cref="T:System.AsyncCallback" /> que recibirá la notificación de la finalización de la operación asincrónica.</param>
        <summary>Inicia una operación de recepción asincrónica que tiene un tiempo de espera especificado y un objeto de estado especificado, que proporciona información relacionada durante toda la operación. Esta sobrecarga recibe una notificación, mediante una devolución de llamada de la identidad del controlador de eventos para la operación. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando utilice esta sobrecarga, la devolución de llamada especificado en el parámetro de devolución de llamada se invoca directamente cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado; el <xref:System.Messaging.MessageQueue.ReceiveCompleted> no se produce el evento. Las demás sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> dependen de este componente para provocar el <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia una recepción asincrónica operación; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperar el resultado mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginReceive%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginReceive%2A> es asincrónico, se puede llamar para recibir un mensaje de la cola sin bloquear el subproceso de ejecución actual. Para recibir sincrónicamente un mensaje, utilice el <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, usa el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 El objeto de estado asocia información de estado de la operación. Por ejemplo, si se llama a <xref:System.Messaging.MessageQueue.BeginReceive%2A> varias veces para iniciar varias operaciones, puede identificar cada operación a través de un objeto de estado independiente que defina.  
  
 También puede usar el objeto de estado para pasar información a través de subprocesos del proceso. Si se inicia un subproceso, pero la devolución de llamada se encuentra en un subproceso diferente en un escenario asincrónico, el objeto de estado se calculan las referencias y se pasa junto con información del evento.  
  
 No utilice la llamada asincrónica <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transacciones. Si desea realizar una operación transaccional asincrónica, llame a <xref:System.Messaging.MessageQueue.BeginPeek%2A>y coloca la transacción y (sincrónico) <xref:System.Messaging.MessageQueue.Receive%2A> método en el controlador de eventos de la operación de lectura. El controlador de eventos puede incluir la funcionalidad tal como se muestra en el siguiente código de C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea asincrónico operación de recepción. Los envíos de ejemplo de código un mensaje a una cola de mensajes locales, a continuación, llama a <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, pasando: un valor de tiempo de espera de diez segundos; un entero único que identifica ese mensaje en particular; y una nueva instancia de <xref:System.AsyncCallback> que identifica el controlador de eventos `MyReceiveCompleted`. Cuando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> provoca el evento, el controlador de eventos recibe el mensaje y escribe el cuerpo del mensaje y el identificador entero del mensaje en la pantalla.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el intervalo de tiempo de espera para que un mensaje esté disponible.</param>
        <param name="cursor">Un <see cref="T:System.Messaging.Cursor" /> que mantiene una posición específica en la cola de mensajes.</param>
        <param name="state">Un objeto de estado, especificado por la aplicación, que contiene información asociada con la operación asincrónica.</param>
        <param name="callback">El <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <summary>Inicia una operación de recepción asincrónica que tiene un tiempo de espera y utiliza un cursor y un objeto de estado especificado. El objeto de estado proporciona información relacionada durante toda la duración de la operación. Esta sobrecarga recibe una notificación, mediante una devolución de llamada de la identidad del controlador de eventos para la operación. La operación no está completa hasta que un mensaje disponible en la cola o se agota el tiempo de espera.</summary>
        <returns>El <see cref="T:System.IAsyncResult" /> que identifica la solicitud asincrónica publicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando utilice esta sobrecarga, la devolución de llamada especificado en el parámetro de devolución de llamada se invoca directamente cuando un mensaje disponible en la cola o cuando ha transcurrido el intervalo de tiempo especificado; el <xref:System.Messaging.MessageQueue.ReceiveCompleted> no se produce el evento. Las demás sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> dependen de este componente para provocar el <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> También se produce si ya existe un mensaje en la cola.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, cree un controlador de eventos que procesa los resultados de la operación asincrónica y asociarlo al delegado de eventos. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia una recepción asincrónica operación; el <xref:System.Messaging.MessageQueue> se notifica a través de la generación de la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, cuando llega un mensaje en la cola. El <xref:System.Messaging.MessageQueue> , a continuación, se puede obtener acceso al mensaje mediante una llamada a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperar el resultado mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 El <xref:System.Messaging.MessageQueue.BeginReceive%2A> método vuelve inmediatamente, pero la operación asincrónica no se completa hasta que se llama al controlador de eventos.  
  
 Dado que <xref:System.Messaging.MessageQueue.BeginReceive%2A> es asincrónico, se puede llamar para recibir un mensaje de la cola sin bloquear el subproceso de ejecución actual. Para recibir sincrónicamente un mensaje, utilice el <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Una vez que se complete una operación asincrónica, puede llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo en el controlador de eventos para seguir recibiendo notificaciones.  
  
 El <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> devuelve identifica la operación asincrónica iniciada por el método. Puede usar esto <xref:System.IAsyncResult> durante la vigencia de la operación, aunque normalmente no se utiliza hasta <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se llama. Sin embargo, si inicia varias operaciones asincrónicas, puede colocar su <xref:System.IAsyncResult> valores en una matriz y especificar si desea esperar a todas las operaciones o que se complete cualquier operación. En este caso, utilice el <xref:System.IAsyncResult.AsyncWaitHandle%2A> propiedad de la <xref:System.IAsyncResult> para identificar la operación completada.  
  
 El objeto de estado asocia información de estado de la operación. Por ejemplo, si se llama a <xref:System.Messaging.MessageQueue.BeginReceive%2A> varias veces para iniciar varias operaciones, puede identificar cada operación a través de un objeto de estado independiente que defina.  
  
 También puede usar el objeto de estado para pasar información a través de subprocesos del proceso. Si se inicia un subproceso, pero la devolución de llamada se encuentra en un subproceso diferente en un escenario asincrónico, el objeto de estado se calculan las referencias y se pasa junto con información del evento.  
  
 No utilice la llamada asincrónica <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transacciones. Si desea realizar una operación transaccional asincrónica, llame a <xref:System.Messaging.MessageQueue.BeginPeek%2A>y coloca la transacción y (sincrónico) <xref:System.Messaging.MessageQueue.Receive%2A> método en el controlador de eventos de la operación de lectura. El controlador de eventos puede incluir la funcionalidad tal como se muestra en el siguiente código de C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="cursor" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el <see cref="T:System.Messaging.MessageQueue" /> se puede leer.</summary>
        <value><see langword="true" /> Si el <see cref="T:System.Messaging.MessageQueue" /> existe y la aplicación puede leer en él; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> indica si la aplicación es capaz de buscar o recibir mensajes de la cola. Si <xref:System.Messaging.MessageQueue.CanRead%2A> es `true`, el <xref:System.Messaging.MessageQueue> puede recibir o inspeccionar mensajes de la cola. En caso contrario, no puede.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> es `false` si una cola ya está abierta con acceso de lectura exclusivo (o si se ha abierto con acceso no exclusivo y esta <xref:System.Messaging.MessageQueue> solicita acceso exclusivo), o si la aplicación no tiene derechos suficientes para acceder a él. Si la aplicación intenta leer desde una cola cuando <xref:System.Messaging.MessageQueue.CanRead%2A> es `false`, se deniega el acceso.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.CanRead%2A> propiedad.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el <see cref="T:System.Messaging.MessageQueue" /> pueden escribirse en.</summary>
        <value><see langword="true" /> Si el <see cref="T:System.Messaging.MessageQueue" /> existe y la aplicación puede escribir en él; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> indica si la aplicación es capaz de enviar mensajes a la cola. Si <xref:System.Messaging.MessageQueue.CanWrite%2A> es `true`, el <xref:System.Messaging.MessageQueue> puede enviar mensajes a la cola. En caso contrario, no puede.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> es `false` si una cola ya está abierta con acceso de escritura exclusivo (o si se ha abierto con acceso no exclusivo y esta <xref:System.Messaging.MessageQueue> solicita acceso exclusivo), o si la aplicación no tiene derechos suficientes para acceder a él. Si la aplicación intenta escribir en una cola cuando <xref:System.Messaging.MessageQueue.CanWrite%2A> es `false`, se deniega el acceso.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.CanWrite%2A> propiedad.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la categoría de la cola.</summary>
        <value>Un <see cref="T:System.Guid" /> que representa la categoría de la cola (identificador de tipo de Message Queue Server), que permite que una aplicación clasifique sus colas por categorías. De manera predeterminada, es <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Categoría de la cola permite que una aplicación clasifique sus colas por categorías. Por ejemplo, puede colocar todas las colas de facturación en una categoría y todas las colas de pedido en otro.  
  
 El <xref:System.Messaging.MessageQueue.Category%2A> propiedad proporciona acceso a la propiedad de identificador de tipo de Message Queue Server (que es de lectura/escritura), accesible a través de la **propiedades de la cola** cuadro de diálogo en la consola de administración de equipos. Puede definir una nueva categoría. Aunque puede usar <xref:System.Guid.NewGuid%2A> para crear un valor de categoría que sea único en todo <xref:System.Guid> valores, esta acción no es necesario. El valor de categoría debe ser distinto de otras categorías, no de todas las demás <xref:System.Guid> valores. Por ejemplo, puede asignar {00000000-0000-0000-0000-000000000001} como el <xref:System.Messaging.MessageQueue.Category%2A> para un conjunto de colas y {00000000-0000-0000-0000-000000000002} como el <xref:System.Messaging.MessageQueue.Category%2A> para otro conjunto.  
  
 No es necesario establecer el <xref:System.Messaging.MessageQueue.Category%2A>. El valor puede ser `null`.  
  
 Al establecer esta propiedad modifica la cola de Message Queue Server. Por lo tanto, cualquier otro <xref:System.Messaging.MessageQueue> instancias se ven afectadas por el cambio.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.Category%2A> propiedad.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Categoría de la cola se estableció en un valor no válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra la caché de conexión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, los nombres de formato almacenados en la memoria caché se quitan y se cierran los identificadores abiertos y almacenados en la memoria caché.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se llama a <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos asignados por el <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> Libera todos los recursos asociados con un <xref:System.Messaging.MessageQueue>, incluidos los recursos comparten si es necesario. El sistema vuelve a adquirir estos recursos automáticamente si siguen estando disponibles, por ejemplo, al llamar el <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método, como se muestra en el siguiente código de C#.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Cuando se llama a <xref:System.Messaging.MessageQueue.Close%2A>, todos los <xref:System.Messaging.MessageQueue> se borran las propiedades que tienen acceso directamente a la cola de Message Queue Server. El <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, y <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> todos permanecen como estaban.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> no siempre gratis la lectura y escribir identificadores en una cola, porque pueden compartirse. Puede usar cualquiera de los pasos siguientes para asegurarse de que <xref:System.Messaging.MessageQueue.Close%2A> libera los identificadores de lectura y escritura a una cola:  
  
-   Crear el <xref:System.Messaging.MessageQueue> con acceso exclusivo. Para ello, llame a la <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor y establezca el `sharedModeDenyReceive` parámetro a `true`.  
  
-   Crear el <xref:System.Messaging.MessageQueue> con conexión de almacenamiento en caché deshabilitado. Para ello, llame al <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor y establezca el `enableConnectionCache` parámetro `false`.  
  
-   Deshabilitar la memoria caché de conexión. Para ello, establezca el <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propiedad `false`.  
  
 Debe llamar a <xref:System.Messaging.MessageQueue.Close%2A> para una cola antes de eliminar la cola de Message Queue server. En caso contrario, los mensajes enviados a la cola podrían producir excepciones o aparecen en la cola de mensajes no enviados.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se cierra una cola de Message Queue Server.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva cola en la ruta de acceso especificada en un servidor de Message Queue Server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso de la cola que desee crear.</param>
        <summary>Crea una cola no transaccional de Message Queue Server en la ruta de acceso especificada.</summary>
        <returns>Un <see cref="T:System.Messaging.MessageQueue" /> que representa la nueva cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear una cola no transaccional de Message Queue Server.  
  
 Para crear una nueva instancia de la <xref:System.Messaging.MessageQueue> clase en la aplicación y enlazarla a una cola existente, use el <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor. Para crear una nueva cola en Message Queue Server, llame a <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintaxis para el `path` parámetro depende del tipo de cola que hace referencia, como se muestra en la tabla siguiente.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para el equipo local. Para obtener más sintaxis, vea el <xref:System.Messaging.MessageQueue.Path%2A> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea colas públicas y privadas. Envía un mensaje a las colas seleccionadas.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="path" /> parámetro es <see langword="null" /> o es una cadena vacía ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Ya existe una cola en la ruta de acceso especificada.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso de la cola que desee crear.</param>
        <param name="transactional"><see langword="true" /> Para crear una cola transaccional; <see langword="false" /> para crear una cola no transaccional.</param>
        <summary>Crea una cola transaccional o no transaccional de Message Queue Server en la ruta de acceso especificada.</summary>
        <returns>Un <see cref="T:System.Messaging.MessageQueue" /> que representa la nueva cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta sobrecarga para crear una cola transaccional de Message Queue Server. Puede crear una cola no transaccional, estableciendo el `transactional` parámetro `false` o mediante una llamada a la otra sobrecarga de <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Para crear una nueva instancia de la <xref:System.Messaging.MessageQueue> clase en la aplicación y enlazarla a una cola existente, use el <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor. Para crear una nueva cola en Message Queue Server, llame a <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintaxis para el `path` parámetro depende del tipo de cola que hace referencia, como se muestra en la tabla siguiente.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para el equipo local. Para obtener más sintaxis, vea el <xref:System.Messaging.MessageQueue.Path%2A> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente crea colas transaccionales públicas y privadas. Envía un mensaje a las colas seleccionadas.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="path" /> parámetro es <see langword="null" /> o es una cadena vacía ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Ya existe una cola en la ruta de acceso especificada.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Messaging.Cursor" /> para la cola de mensajes actual.</summary>
        <returns>Un nuevo <see cref="T:System.Messaging.Cursor" /> para la cola de mensajes actual. Este cursor se utiliza para mantener una ubicación específica en la cola cuando se leen mensajes de la cola.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la fecha y hora que se creó la cola de Message Queue Server.</summary>
        <value>Un <see cref="T:System.DateTime" /> que representa la fecha y hora en que se creó la cola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> hace referencia a la cola de Message Queue server, no el <xref:System.Messaging.MessageQueue> instancia.  
  
 Si la cola existe, esta propiedad representa la hora en que se creó la cola, se ajusta a la hora local del servidor en el que existe la cola.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.CreateTime%2A> propiedad.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el mensaje de los valores de propiedad que se usará de forma predeterminada cuando la aplicación envía mensajes a la cola.</summary>
        <value>Un <see cref="T:System.Messaging.DefaultPropertiesToSend" /> que contiene el Message Queue Server de valores de propiedad predeterminados usa cuando la aplicación envía objetos distintos de <see cref="T:System.Messaging.Message" /> instancias a la cola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al enviar cualquier objeto que no es de tipo <xref:System.Messaging.Message> a la cola, el <xref:System.Messaging.MessageQueue> inserta el objeto en un mensaje de Message Queue Server. En ese momento, el <xref:System.Messaging.MessageQueue> se aplica al mensaje de los valores de propiedad especificados en el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad. Por el contrario, si envía una <xref:System.Messaging.Message> a la cola, estas propiedades se han especificado para la instancia de sí mismo, por lo que <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> se omite para los <xref:System.Messaging.Message>.  
  
 Aunque se establecen las propiedades a través de la <xref:System.Messaging.MessageQueue> objeto, el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> hace referencia a las propiedades de los mensajes que se envían a la cola, no la propia cola.  
  
 Los valores predeterminados de las propiedades se muestran en la tabla siguiente.  
  
|Propiedad|Valor predeterminado|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|una cadena vacía ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se usa la prioridad de un mensaje para determinar las propiedades predeterminadas para enviar el mensaje.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Las propiedades predeterminadas no se puede establecer para la cola, posiblemente porque una de las propiedades no es válida.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola que se va a eliminar.</param>
        <summary>Elimina una cola en un servidor de Message Queue Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sintaxis para el `path` parámetro depende del tipo de cola.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
  
 Para obtener más sintaxis, vea el <xref:System.Messaging.MessageQueue.Path%2A> propiedad.  
  
 Como alternativa, puede usar el <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> para describir la ruta de acceso de la cola.  
  
|Referencia|Sintaxis|  
|---------------|------------|  
|Nombre de formato|FormatName: [ *nombre de formato* ]|  
|Etiqueta|Etiqueta: [ *etiqueta* ]|  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se elimina una cola de Message Queue Server, si existe.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="path" /> parámetro es <see langword="null" /> o es una cadena vacía ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La sintaxis para el <paramref name="path" /> parámetro no es válido.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si este <see cref="T:System.Messaging.MessageQueue" /> tiene acceso exclusivo para recibir mensajes de la cola de Message Queue Server.</summary>
        <value><see langword="true" /> Si este <see cref="T:System.Messaging.MessageQueue" /> tiene derechos exclusivos para recibir mensajes de la cola; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Especifica el modo compartido de la cola que hace referencia esta <xref:System.Messaging.MessageQueue>. Establecer <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> a `true` para indicar que solo esto <xref:System.Messaging.MessageQueue> deben tener acceso a busquen o reciban mensajes de la cola con los valores especificados <xref:System.Messaging.MessageQueue.Path%2A>. Si otro <xref:System.Messaging.MessageQueue> u otra aplicación está asociada con el mismo recurso de cola, esa instancia o aplicación no pueda busquen o reciban mensajes, pero que todavía puede enviar.  
  
 Si <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> es `false`, la cola está disponible en varias aplicaciones para enviar, inspeccionar o recibir mensajes.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propiedad.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Se deshace de los recursos (distintos de la memoria) que usa <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> cuando haya terminado de usar <xref:System.Messaging.MessageQueue>. El método <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> deja el <xref:System.Messaging.MessageQueue> en un estado no utilizable. Después de llamar a <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, debe liberar todas las referencias a la <xref:System.Messaging.MessageQueue> por lo que la memoria ocupaba puede ser reclamada por la recolección de elementos.  
  
 Debe llamar a <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> antes de liberar la última referencia a la <xref:System.Messaging.MessageQueue>. En caso contrario, los recursos de la <xref:System.Messaging.MessageQueue> no es se liberarán hasta que llame al conjunto de elementos no utilizados los <xref:System.Messaging.MessageQueue> destructor del objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la aplicación va a mantener una caché de conexiones.</summary>
        <value><see langword="true" /> Para crear y utilizar una caché de conexión; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una caché de conexiones es una lista de referencias a las estructuras que contienen leer o escriben los identificadores en las colas. Cuando <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> es `true`, <xref:System.Messaging.MessageQueue> toma prestado identificadores de la caché cada vez que se llama <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, o <xref:System.Messaging.MessageQueue.Receive%2A>, en lugar de abrir nuevos identificadores. Esto puede mejorar el rendimiento. Uso de una caché de conexiones también aísla el <xref:System.Messaging.MessageQueue> de los cambios en la topología de red.  
  
 Si crea una nueva conexión a una cola cuando la caché de conexión está llena, el <xref:System.Messaging.MessageQueue> sobrescribe la estructura que se ha tenido acceso menos recientemente con la nueva conexión. Puede borrar la memoria caché completamente mediante una llamada a <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, por ejemplo, si han cambiado los nombres de formato de las colas que está trabajando para que el anterior de lee y escribe identificadores ya no son válidos.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propiedad.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la cola acepta sólo no privados (no cifrados) mensajes.</summary>
        <value>Uno de los valores de <see cref="T:System.Messaging.EncryptionRequired" />. De manera predeterminada, es <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se especifica que el cifrado es necesario para los mensajes enviados a una cola, se cifran únicamente los cuerpos de mensaje. Los demás miembros (por ejemplo, el <xref:System.Messaging.Message.Label%2A> y <xref:System.Messaging.Message.SenderId%2A> propiedades) no se puede cifrar.  
  
 Al establecer esta propiedad modifica la cola de Message Queue Server. Por lo tanto, cualquier otro <xref:System.Messaging.MessageQueue> instancias se ven afectadas por el cambio.  
  
 Cifrar un mensaje hace que el mensaje privado. Puede especificar el requisito de cifrado de la cola para ser `None`, `Body`, o `Optional` estableciendo el <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propiedad adecuadamente. El <xref:System.Messaging.Message.UseEncryption%2A> configuración del mensaje debe corresponderse con el requisito de cifrado de la cola. Si el mensaje no está cifrado, pero la cola especifica `Body`, o si el mensaje está cifrado pero la cola especifica `None`, se rechaza el mensaje de la cola. Si la aplicación de envío solicita un mensaje de confirmación negativa en este caso, Message Queue Server indica rechazo del mensaje a la aplicación emisora. Si el <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propiedad es `true`, se envía un mensaje que se produce un error de cifrado a la cola de mensajes no enviados. En caso contrario, el mensaje se pierde.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propiedad.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">El <see cref="T:System.IAsyncResult" /> que identifica la operación de búsqueda peek asincrónica para finalizar y desde el que se va a recuperar un resultado final.</param>
        <summary>Completa la operación de búsqueda peek asincrónica especificada.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> asociado con la operación asincrónica completada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Messaging.MessageQueue.PeekCompleted> se provoca el evento, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> completa la operación que fue iniciada por el <xref:System.Messaging.MessageQueue.BeginPeek%2A> llamar. Para ello, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> inspecciona el mensaje.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> puede especificar un tiempo de espera, lo que hace que el <xref:System.Messaging.MessageQueue.PeekCompleted> evento si se produce el tiempo de espera antes de que aparezca un mensaje en la cola. Cuando se produce un tiempo de espera sin un mensaje llegue a la cola, una llamada subsiguiente a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> produce una excepción.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se utiliza para leer el mensaje que provocó la <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 Si desea seguir mensajes de búsqueda peek asincrónica, puede volver a llamar a <xref:System.Messaging.MessageQueue.BeginPeek%2A> después de llamar a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un controlador de eventos denominado `MyPeekCompleted`, lo asocia a la <xref:System.Messaging.MessageQueue.PeekCompleted> delegado controlador de eventos y llamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar una operación de búsqueda peek asincrónica en la cola que se encuentra en la ruta de acceso ". \myQueue". Cuando un <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento, el ejemplo busca el mensaje y escribe el cuerpo en la pantalla. El ejemplo llama a <xref:System.Messaging.MessageQueue.BeginPeek%2A> nuevo para iniciar una nueva operación de búsqueda peek asincrónica.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La sintaxis de la <paramref name="asyncResult" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">El <see cref="T:System.IAsyncResult" /> identifica asincrónico que recibe la operación finalice y desde el que se va a recuperar un resultado final.</param>
        <summary>Se completa la especificado asincrónica operación de recepción.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> asociado con la operación asincrónica completada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Messaging.MessageQueue.ReceiveCompleted> se provoca el evento, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> completa la operación que fue iniciada por el <xref:System.Messaging.MessageQueue.BeginReceive%2A> llamar. Para ello, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> recibe el mensaje.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> puede especificar un tiempo de espera, lo que hace que el <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento si se produce el tiempo de espera antes de que aparezca un mensaje en la cola. Cuando se produce un tiempo de espera sin un mensaje llegue a la cola, una llamada subsiguiente a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> produce una excepción.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se utiliza para leer (quitar de la cola) el mensaje que provocó la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 Si desea seguir recibiendo mensajes de forma asincrónica, puede volver a llamar a <xref:System.Messaging.MessageQueue.BeginReceive%2A> después de llamar a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se encadena solicitudes asincrónicas. Se supone que hay una cola en el equipo local denominado "myQueue". El `Main` función comienza la operación asincrónica que se controla mediante el `MyReceiveCompleted` rutina. `MyReceiveCompleted` procesa el mensaje actual e inicia una nueva asincrónica operación de recepción.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La sintaxis de la <paramref name="asyncResult" /> parámetro no es válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ubicación de la cola para buscar.</param>
        <summary>Determina si existe una cola de Message Queue Server en la ruta de acceso especificada.</summary>
        <returns><see langword="true" /> Si existe una cola con la ruta de acceso especificada; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método determina si existe una cola de Message Queue Server en una ruta de acceso especificada. No existe ningún método para determinar si existe una cola con un nombre de formato especificado. Para obtener más información sobre la sintaxis del nombre de formato y otras formas de sintaxis de ruta de acceso, consulte el <xref:System.Messaging.MessageQueue.Path%2A> propiedad.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> es una operación costosa. Usar solo cuando sea necesario dentro de la aplicación.  
  
> [!NOTE]
>  El <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método no admite el <xref:System.Messaging.MessageQueue.FormatName%2A> prefijo.  
  
 La sintaxis para el `path` parámetro depende del tipo de cola, como se muestra en la tabla siguiente.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> no se puede llamar para comprobar la existencia de una cola privada remota.  
  
 Para obtener más sintaxis, vea el <xref:System.Messaging.MessageQueue.Path%2A> propiedad.  
  
 Como alternativa, puede usar el <xref:System.Messaging.MessageQueue.Label%2A> para describir la ruta de acceso de la cola.  
  
|Referencia|Sintaxis|  
|---------------|------------|  
|Etiqueta|Etiqueta: [ `label` ]|  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se comprueba si existe una cola de Message Queue Server y, a continuación, lo elimina.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="path" /> sintaxis no es válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.  
  
-o bien- 
El <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> se se llama al método en una cola privada remota.</exception>
        <exception cref="T:System.InvalidOperationException">La aplicación usa la sintaxis de nombre de formato al comprobar la existencia de la cola.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de cola único generado por Message Queuing en el momento de creación de la cola.</summary>
        <value>El nombre de la cola, que es único en la red.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.FormatName%2A> propiedad contiene el nombre de formato de la cola. Message Queue Server utiliza el nombre de formato para identificar qué cola para abrir y cómo tener acceso a él. A diferencia de las características de una cola, el nombre de formato no es una propiedad de cola de aplicación de Message Queue Server, por lo que no se puede acceder a él a través de la herramienta de administración de Message Queue Server. El nombre de formato es simplemente un nombre único para la cola, que Message Queuing genera cuando crea la cola o que la aplicación genera más tarde.  
  
 Si especifica una ruta de acceso mediante la sintaxis de nombre de ruta de acceso (como `myComputer\myQueue`) en lugar de usar la sintaxis del nombre de formato al leer o escribir en la cola, el controlador de dominio principal (que usa Active Directory) convierte el <xref:System.Messaging.MessageQueue.Path%2A> en el asociado<xref:System.Messaging.MessageQueue.FormatName%2A> antes de acceder a la cola. Si la aplicación está trabajando sin conexión, debe usar la sintaxis de nombre de formato; en caso contrario, el controlador de dominio principal no estará disponible para realizar la traducción de la ruta de acceso.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.FormatName%2A> propiedad.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> no está establecido.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece al formateador empleado para serializar o deserializar un objeto en el cuerpo de un mensaje que se leen o escriben en la cola.</summary>
        <value>El <see cref="T:System.Messaging.IMessageFormatter" /> que produce una secuencia que se escribirá o leerá desde el cuerpo del mensaje. De manera predeterminada, es <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad contiene una instancia de un objeto de formateador, que transforma los mensajes cuando la aplicación lee o escribe en la cola.  
  
 Cuando la aplicación envía mensajes a la cola, el formateador serializa el objeto en una secuencia y lo inserta en el cuerpo del mensaje. Al leer desde una cola, el formateador deserializa los datos del mensaje en el <xref:System.Messaging.Message.Body%2A> propiedad de un <xref:System.Messaging.Message>.  
  
 El <xref:System.Messaging.XmlMessageFormatter> correspondencia imprecisa, por lo que no es necesario tener el mismo objeto de tipo en el remitente y receptor cuando se usa este formato. El <xref:System.Messaging.ActiveXMessageFormatter> y <xref:System.Messaging.BinaryMessageFormatter> serializar los datos en una representación binaria. El <xref:System.Messaging.ActiveXMessageFormatter> se usa al enviar o recibir los componentes COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> y <xref:System.Messaging.ActiveXMessageFormatter> proporcionan mayor rendimiento que la <xref:System.Messaging.XmlMessageFormatter>. El <xref:System.Messaging.ActiveXMessageFormatter> permite la interoperabilidad con aplicaciones de Message Queue Server de Visual Basic 6.0.  
  
 Cuando la aplicación envía mensajes a la cola, el <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> solo se aplica a los mensajes que utilizan las propiedades del mensaje de forma predeterminada, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Si envía una <xref:System.Messaging.Message> a la cola de Message Queue Server utiliza el formateador definido en el <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad que se va a serializar el cuerpo del mensaje.  
  
 El <xref:System.Messaging.MessageQueue> clase siempre usará un <xref:System.Messaging.Message> para recibir o inspeccionar un mensaje de la cola. El mensaje se deserializa utilizando el <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el formato de un cuerpo de mensaje utilizando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 En el ejemplo de código siguiente se muestra el formato de un cuerpo de mensaje utilizando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los mensajes que se encuentran en la cola.</summary>
        <returns>Una matriz de tipo <see cref="T:System.Messaging.Message" /> que representa todos los mensajes en la cola, en el mismo orden en que aparecen en la cola de Message Queue Server.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Devuelve una instantánea estática de los mensajes en la cola y no uno dinámicos vínculos a esos mensajes. Por lo tanto, no puede usar la matriz para modificar los mensajes de la cola. Si desea una interacción dinámica en tiempo real con la cola (por ejemplo, la capacidad de eliminar los mensajes), llame a la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> método, que devuelve una lista dinámica de los mensajes en la cola.  
  
 Dado que <xref:System.Messaging.MessageQueue.GetAllMessages%2A> devuelve una copia de los mensajes en la cola en el momento en que se llamó al método, la matriz no refleja los nuevos mensajes que llegan a la cola o mensajes que se quitan de la cola.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> recupera solo las propiedades no filtradas por el <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumera los mensajes en una cola. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> está desusada. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> debe usarse en su lugar.</summary>
        <returns>Un <see cref="T:System.Collections.IEnumerator" /> que proporciona una conexión dinámica con los mensajes de la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nombre del equipo que contiene la cola, sin las dos barras diagonales inversas (\\\\) iniciales.</param>
        <summary>Obtiene el identificador del equipo en el que la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" /> se encuentra.</summary>
        <returns>Un <see cref="T:System.Guid" /> que representa un identificador único para el equipo en el que se encuentra la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el identificador del equipo para dos propósitos, entre otros: para leer el diario del equipo y establecer certificados de seguridad. Sin embargo, no puede llamar a <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> para un equipo remoto cuando se trabaja sin conexión porque la aplicación debe tener acceso al servicio de directorio en el controlador de dominio.  
  
 El identificador del equipo (o identificador de equipo) es un <xref:System.Guid> que crea Message Queue Server cuando se agrega un equipo a la empresa. Message Queue Server combina el identificador del equipo con el `Machine` y `Journal` palabras clave para crear el nombre de formato del diario del equipo, que tiene la sintaxis `Machine=<computeridentifier>;Journal`. Los mensajes del diario del equipo, lo que también se conoce como la cola del diario, es una cola del sistema que almacena copias de los generados por la aplicación cuando el <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propiedad es `true`.  
  
 Esta sintaxis para el diario solo es válida al construir el nombre de formato para la cola. La sintaxis de nombre de ruta de acceso es `MachineName` \\ `Journal$`.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se llama a <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">El identificador del equipo no se puede recuperar, posiblemente porque el servicio de directorio no está disponible; Por ejemplo, si está trabajando sin conexión.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un objeto enumerador para todos los mensajes en la cola. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> está desusada. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> debe usarse en su lugar.</summary>
        <returns>El <see cref="T:System.Messaging.MessageEnumerator" /> que contiene los mensajes que se encuentran en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> crea una lista dinámica de todos los mensajes de una cola. Puede quitar de la cola el mensaje en la posición actual del enumerador mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para el <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> devuelve.  
  
 Dado que el cursor está asociado a la lista dinámica de mensajes en la cola, la enumeración refleja cualquier modificación realizada en los mensajes de la cola, si el mensaje está más allá de la posición actual del cursor. Por ejemplo, el enumerador puede tener acceso automáticamente a un mensaje de menor prioridad situado más allá de la posición del cursor actual, pero no un mensaje de prioridad más alta insertado antes de esa posición. Sin embargo, puede restablecer la enumeración, con lo que desplaza el cursor al principio de la lista, mediante una llamada a <xref:System.Messaging.MessageEnumerator.Reset%2A> para el <xref:System.Messaging.MessageEnumerator>.  
  
 El orden de los mensajes en la enumeración refleja su orden en la cola, por lo que aparecerán mensajes de prioridad más alta antes que las de prioridad inferior.  
  
 Si desea una instantánea estática de los mensajes en la cola en lugar de una conexión dinámica con ellos, llame a <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Este método devuelve una matriz de <xref:System.Messaging.Message> objetos que representan los mensajes en el momento en que se llamó al método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El siguiente ejemplo de código obtiene una lista dinámica de los mensajes en una cola y cuenta todos los mensajes con el <xref:System.Messaging.Message.Priority%2A> propiedad establecida en <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un objeto enumerador para todos los mensajes en la cola.</summary>
        <returns>El <see cref="T:System.Messaging.MessageEnumerator" /> que contiene los mensajes que se encuentran en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> crea una lista dinámica de todos los mensajes de una cola. Puede quitar de la cola el mensaje en la posición actual del enumerador mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para el <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> devuelve.  
  
 Dado que el cursor está asociado a la lista dinámica de mensajes en la cola, la enumeración refleja cualquier modificación realizada en los mensajes de la cola, si el mensaje está más allá de la posición actual del cursor. Por ejemplo, el enumerador puede tener acceso automáticamente a un mensaje de menor prioridad situado más allá de la posición del cursor actual, pero no un mensaje de prioridad más alta insertado antes de esa posición. Sin embargo, puede restablecer la enumeración, con lo que desplaza el cursor al principio de la lista, mediante una llamada a <xref:System.Messaging.MessageEnumerator.Reset%2A> para el <xref:System.Messaging.MessageEnumerator>.  
  
 El orden de los mensajes en la enumeración refleja su orden en la cola, por lo que aparecerán mensajes de prioridad más alta antes que las de prioridad inferior.  
  
 Si desea una instantánea estática de los mensajes en la cola en lugar de una conexión dinámica con ellos, llame a <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Este método devuelve una matriz de <xref:System.Messaging.Message> objetos que representan los mensajes en el momento en que se llamó al método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un objeto enumerador para una lista dinámica de las colas públicas en la red.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona la semántica de cursor de solo avance para enumerar todas las colas públicas en la red.</summary>
        <returns>Un <see cref="T:System.Messaging.MessageQueueEnumerator" /> que proporciona una lista dinámica de todas las colas de mensajes públicas de la red.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> devuelve una enumeración de todas las colas públicas que se encuentran en la red.  
  
 Dado que el cursor está asociado con una lista dinámica, la enumeración refleja cualquier modificación realizada en una lista de cola para las colas que se eliminarán o agregarán más allá de la posición del cursor actual. No se reflejan las adiciones o eliminación de colas situadas antes de la posición del cursor actual. Por ejemplo, el enumerador puede tener acceso automáticamente a una cola anexada más allá de la posición del cursor, pero no uno que se insertan antes de esa posición. Sin embargo, puede restablecer la enumeración, con lo que desplaza el cursor al principio de la lista, mediante una llamada a <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para el <xref:System.Messaging.MessageQueueEnumerator>.  
  
 No hay ningún orden definido de colas en una red. Un enumerador no ordenarlos, por ejemplo, por equipo, etiqueta, estado público o privado o cualquier otro criterio accesible.  
  
 Si desea una instantánea estática de las colas de la red en lugar de una conexión dinámica con ellos, llame a <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> o <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada uno de estos dos métodos devuelve una matriz de <xref:System.Messaging.MessageQueue> objetos que representan las colas en el momento en que se llamó al método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se recorre en iteración todas las colas de mensajes en la red y examina la ruta de acceso para cada cola. Por último, muestra el número de colas públicas en la red.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Un <see cref="T:System.Messaging.MessageQueueCriteria" /> que contiene los criterios utilizados para filtrar las colas de mensajes disponibles.</param>
        <summary>Proporciona la semántica de cursor de solo avance para enumerar todas las colas públicas de la red que cumplan los criterios especificados.</summary>
        <returns>Un <see cref="T:System.Messaging.MessageQueueEnumerator" /> que proporciona una lista dinámica de las colas de mensajes públicas de la red que cumplan las restricciones especificadas por el <paramref name="criteria" /> parámetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> devuelve una lista de todas las colas públicas de la red que cumplen los criterios definidos en los criterios de la aplicación. Puede especificar los criterios para incluir, poner en cola, por ejemplo, la hora de creación o modificación, etiqueta, nombre de equipo, categoría o cualquier combinación de estos.  
  
 Dado que el cursor está asociado con una lista dinámica, la enumeración refleja cualquier modificación realizada en una cola que se produce más allá de la posición del cursor actual. No se reflejan los cambios realizados en las colas ubicadas antes de la posición del cursor actual. Por ejemplo, el enumerador puede tener acceso automáticamente a una cola anexada más allá de la posición del cursor, pero no uno que se insertan antes de esa posición. Sin embargo, puede restablecer la enumeración, con lo que desplaza el cursor al principio de la lista, mediante una llamada a <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para el <xref:System.Messaging.MessageQueueEnumerator>.  
  
 No hay ningún orden definido de colas en una red. Un enumerador no ordenarlos, por ejemplo, por equipo, etiqueta, estado público o privado o cualquier otro criterio accesible.  
  
 Si desea una instantánea estática de las colas de la red en lugar de una conexión dinámica con ellos, especificar los criterios para <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> o llamar a <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada uno de estos dos métodos devuelve una matriz de <xref:System.Messaging.MessageQueue> objetos que representan las colas en el momento en que se llamó al método. Una llamada a <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, o <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> proporciona los mismos resultados que una llamada a <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> con los criterios de filtrado de <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, y <xref:System.Messaging.MessageQueue.MachineName%2A>, respectivamente.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente recorre en iteración las colas de mensajes y muestra la ruta de acceso de cada cola que se creó en el último día y que existe en el equipo "Miequipo".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">El equipo desde el que se va a recuperar las colas privadas.</param>
        <summary>Recupera todas las colas privadas en el equipo especificado.</summary>
        <returns>Una matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que hacen referencia a las colas privadas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Recupera una instantánea estática de las colas en un equipo especificado.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El ejemplo de código siguiente recupera listas de colas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="machineName" /> parámetro es <see langword="null" /> o una cadena vacía ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera todas las colas públicas en la red.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera todas las colas públicas en la red.</summary>
        <returns>Una matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que hacen referencia a las colas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga si desea obtener una lista completa de todas las colas públicas en la red. Si desea restringir la lista con determinados criterios, como <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, o de última hora de modificación que utilizar otra sobrecarga de este método. (También puede usar <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, o <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Recupera una instantánea estática de las colas. Para interactuar con una lista dinámica de las colas, utilice <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente recupera listas de colas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Un <see cref="T:System.Messaging.MessageQueueCriteria" /> que contiene los criterios utilizados para filtrar las colas.</param>
        <summary>Recupera todas las colas públicas en la red que cumplan los criterios especificados.</summary>
        <returns>Una matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que hacen referencia a las colas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea filtrar todas las colas públicas en la red por etiqueta, categoría o nombre de equipo, el <xref:System.Messaging.MessageQueue> clase contiene métodos específicos que proporcionan esta funcionalidad (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, y <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectivamente). Utilice esta sobrecarga para obtener una lista de todas las colas públicas en la red que cumplan más de uno de estos criterios (por ejemplo, si desea especificar una etiqueta y una categoría). También puede filtrar por criterios de mensaje distinto <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, y <xref:System.Messaging.MessageQueue.MachineName%2A>. Por ejemplo, utilice esta sobrecarga para filtrar por hora de última modificación de una cola. Basta con crear una nueva instancia de la <xref:System.Messaging.MessageQueueCriteria> clase, establezca las propiedades adecuadas en la instancia y pasar la instancia como el `criteria` parámetro.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Recupera una instantánea estática de las colas. Para interactuar con una lista dinámica de las colas, utilice <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente recupera listas de colas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Un <see cref="T:System.Guid" /> que agrupa el conjunto de colas que se va a recuperar.</param>
        <summary>Recupera todas las colas públicas en la red que pertenecen a la categoría especificada.</summary>
        <returns>Una matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que hacen referencia a las colas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para filtrar las colas públicas por categoría. El <xref:System.Messaging.MessageQueue.Category%2A> propiedad proporciona acceso a la propiedad de Id. de tipo de Message Queue Server (que es de lectura/escritura) de una cola determinada. Aunque puede usar <xref:System.Guid.NewGuid%2A> para crear un valor de categoría que sea único en todo <xref:System.Guid> valores, no es necesario. El valor de categoría debe ser distinto de otras categorías, no de todas las demás <xref:System.Guid> valores. Por ejemplo, puede asignar {00000000-0000-0000-0000-000000000001} como el <xref:System.Messaging.MessageQueue.Category%2A> para un conjunto de colas y {00000000-0000-0000-0000-000000000002} como el <xref:System.Messaging.MessageQueue.Category%2A> para otro conjunto.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Recupera una instantánea estática de las colas. Para interactuar con una lista dinámica de las colas, utilice <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Puede especificar la categoría como parte de la <xref:System.Messaging.MessageQueueCriteria> pasa al método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente recupera listas de colas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Una etiqueta que agrupa el conjunto de colas que se va a recuperar.</param>
        <summary>Recupera todas las colas públicas en la red que tengan la etiqueta especificada.</summary>
        <returns>Una matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que hacen referencia a las colas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para filtrar las colas públicas por etiqueta.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Recupera una instantánea estática de las colas. Para interactuar con una lista dinámica de las colas, utilice <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Puede especificar la etiqueta como parte de la <xref:System.Messaging.MessageQueueCriteria> pasa al método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente recupera listas de colas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="label" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">El nombre del equipo que contiene el conjunto de colas públicas que se va a recuperar.</param>
        <summary>Recupera todas las colas públicas que residen en el equipo especificado.</summary>
        <returns>Una matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que hacen referencia a las colas públicas en el equipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para filtrar las colas públicas por equipo.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Recupera una instantánea estática de las colas. Para interactuar con una lista dinámica de las colas, utilice <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Puede especificar el nombre del equipo como parte de la <xref:System.Messaging.MessageQueueCriteria> pasa al método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|No|  
|Equipo local y el nombre de formato directo|No|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 El ejemplo de código siguiente recupera listas de colas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="machineName" /> parámetro tiene una sintaxis incorrecta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera el contexto de seguridad que MSMQ asocia el usuario actual (identidad de subproceso) en el momento de esta llamada.</summary>
        <returns>Un <see cref="T:System.Messaging.SecurityContext" /> objeto que contiene el contexto de seguridad.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador único de Message Queue Server de la cola.</summary>
        <value>Un <see cref="P:System.Messaging.MessageQueue.Id" /> que representa el identificador de mensaje generado por la aplicación de Message Queue Server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queue Server establece el <xref:System.Messaging.MessageQueue.Id%2A> propiedad cuando crea la cola. Esta propiedad solo está disponible para las colas públicas.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.Id%2A> propiedad.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que no existe ninguna restricción de tamaño para una cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro se utiliza con frecuencia al establecer <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> o <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Messaging.MessageQueue.InfiniteQueueSize> miembro.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que no existe ningún tiempo de espera para los métodos que busquen o reciban mensajes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> admite dos tipos de recuperación de mensajes: sincrónica y asincrónica. Los métodos sincrónicos, <xref:System.Messaging.MessageQueue.Peek%2A> y <xref:System.Messaging.MessageQueue.Receive%2A>, el subproceso debe esperar un intervalo de tiempo especificado para un nuevo mensaje llegue a la cola. Si el intervalo de tiempo especificado es <xref:System.Messaging.MessageQueue.InfiniteTimeout>, el subproceso permanece bloqueado hasta que esté disponible un nuevo mensaje. Por otro lado, <xref:System.Messaging.MessageQueue.BeginPeek%2A> y <xref:System.Messaging.MessageQueue.BeginReceive%2A> (los métodos asincrónicos) permiten que las tareas de la aplicación principal continuar en un subproceso independiente hasta que llegue un mensaje en la cola.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Messaging.MessageQueue.InfiniteTimeout> miembro.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la descripción de la cola.</summary>
        <value>La etiqueta de la cola de mensajes. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud máxima de una etiqueta de la cola de mensajes es de 124 caracteres.  
  
 El <xref:System.Messaging.MessageQueue.Label%2A> propiedad no necesita ser único entre todas las colas. Sin embargo, si varias colas comparten la misma <xref:System.Messaging.MessageQueue.Label%2A>, no puede usar el <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método para difundir un mensaje a todos ellos. Si usa la sintaxis de etiqueta para el <xref:System.Messaging.MessageQueue.Path%2A> propiedad al enviar el mensaje, una excepción se producirá si el <xref:System.Messaging.MessageQueue.Label%2A> no es único.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.Label%2A> propiedad.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La etiqueta se estableció en un valor no válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la última vez que se modificaron las propiedades de una cola.</summary>
        <value>Un <see cref="T:System.DateTime" /> que indica cuándo se modificó por última vez las propiedades de la cola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La hora de última modificación incluye cuando se creó la cola y cualquier <xref:System.Messaging.MessageQueue> propiedad que modifica la cola de Message Queue Server, como <xref:System.Messaging.MessageQueue.BasePriority%2A>. El valor de la <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propiedad representa la hora del sistema del equipo local.  
  
 Debe llamar a <xref:System.Messaging.MessageQueue.Refresh%2A> antes de obtener el <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propiedad; en caso contrario, la hora de modificación asociado a este <xref:System.Messaging.MessageQueue> puede no ser actual.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propiedad.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del equipo donde se encuentra la cola de Message Queue Server.</summary>
        <value>El nombre del equipo donde se encuentra la cola. El valor predeterminado de Message Queue Server es ".", el equipo local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.MachineName%2A> es un componente integral de la sintaxis del nombre descriptivo de la cola <xref:System.Messaging.MessageQueue.Path%2A>. En la tabla siguiente se muestra la sintaxis que debe usar para una cola de un tipo especificado cuando desea identificar la ruta de acceso de la cola mediante su nombre descriptivo.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
|Cola de diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Cola de diario del equipo|`MachineName`\\`Journal$`|  
|Cola de mensajes no enviados del equipo|`MachineName`\\`Deadletter$`|  
|Cola de mensajes no enviados transaccional del equipo|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para el equipo local al especificar el <xref:System.Messaging.MessageQueue.MachineName%2A>. Se reconoce el nombre del equipo para esta propiedad, por ejemplo, `Server0`. El <xref:System.Messaging.MessageQueue.MachineName%2A> propiedad no es compatible con el formato de dirección IP.  
  
 Si define la <xref:System.Messaging.MessageQueue.Path%2A> en términos de la <xref:System.Messaging.MessageQueue.MachineName%2A>, la aplicación produce una excepción cuando se trabaja sin conexión porque el controlador de dominio es necesario para la traducción de la ruta de acceso. Por lo tanto, debe usar el <xref:System.Messaging.MessageQueue.FormatName%2A> para el <xref:System.Messaging.MessageQueue.Path%2A> sintaxis cuando se trabaja sin conexión.  
  
 El <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, y <xref:System.Messaging.MessageQueue.QueueName%2A> propiedades están relacionadas. Cambiar el <xref:System.Messaging.MessageQueue.MachineName%2A> propiedad causa el <xref:System.Messaging.MessageQueue.Path%2A> propiedad que se va a cambiar. Se crea a partir de la nueva <xref:System.Messaging.MessageQueue.MachineName%2A> y <xref:System.Messaging.MessageQueue.QueueName%2A>. Cambiar el <xref:System.Messaging.MessageQueue.Path%2A> (por ejemplo, para utilizar la sintaxis de nombre de formato) restablece el <xref:System.Messaging.MessageQueue.MachineName%2A> y <xref:System.Messaging.MessageQueue.QueueName%2A> propiedades para hacer referencia a la nueva cola. Si el <xref:System.Messaging.MessageQueue.QueueName%2A> propiedad está vacía, el <xref:System.Messaging.MessageQueue.Path%2A> se establece en la cola del diario del equipo que especifique.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.MachineName%2A> propiedad.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <see cref="P:System.Messaging.MessageQueue.MachineName" /> es <see langword="null" />.        
-o bien-

El nombre del equipo no es válido, posiblemente porque la sintaxis es incorrecta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño máximo de la cola del diario.</summary>
        <value>El tamaño máximo, en kilobytes, de la cola del diario. El valor predeterminado de Message Queue Server especifica que no hay límite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> proporciona acceso al límite de almacenamiento del diario de Message Queue Server. Es importante sólo cuando <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> es `true`. Al establecer esta propiedad modifica la cola de Message Queue Server. Por lo tanto, cualquier otro <xref:System.Messaging.MessageQueue> instancias se ven afectadas por el cambio  
  
 Si almacena los mensajes en un diario o cola de mensajes, debe borrar periódicamente la cola para quitar los mensajes que ya no son necesarios. Los mensajes de dicha cola cuentan para la cuota de mensajes para el equipo donde reside la cola. (El administrador establece la cuota del equipo).  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> propiedad.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño de la cola de diario máximo se estableció en un valor no válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño máximo de la cola.</summary>
        <value>El tamaño máximo, en kilobytes, de la cola. El valor predeterminado de Message Queue Server especifica que no hay límite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> proporciona acceso al límite de almacenamiento de mensajes de Message Queue Server, que es independiente de la cuota de mensajes del equipo que el administrador define. Para obtener más información acerca de la cuota de mensajes, consulte <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Al establecer esta propiedad modifica la cola de Message Queue Server. Por lo tanto, cualquier otro <xref:System.Messaging.MessageQueue> instancias se ven afectadas por el cambio  
  
 Si se intenta superar el tamaño máximo de la cola o la cuota de mensajes del equipo, se pueden perder mensajes. Cuando se alcanza la cuota de cola, Message Queue Server notifica a la cola de administración de la aplicación emisora para indicar que la cola está llena, devolviendo un mensaje de confirmación negativa. Message Queue Server continúa enviando confirmaciones negativas hasta que el tamaño total de los mensajes de la cola descienda por debajo del límite.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> propiedad.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño máximo de la cola contiene un valor negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el filtro de propiedad para recibir o buscar mensajes.</summary>
        <value>El <see cref="T:System.Messaging.MessagePropertyFilter" /> utilizado por la cola para filtrar el conjunto de propiedades que recibe o busca para cada mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este filtro es un conjunto de valores booleanos que limita las propiedades del mensaje que el <xref:System.Messaging.MessageQueue> recibe o busca. Cuando el <xref:System.Messaging.MessageQueue> recibe o busca un mensaje de la cola del servidor, recupera únicamente las propiedades para el que el <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valor es `true`.  
  
 La siguiente muestra los valores de propiedad iniciales para la <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propiedad. Estos valores son idénticos a llamar a <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> en un <xref:System.Messaging.MessagePropertyFilter>.  
  
|Propiedad|Valor predeterminado|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> para restringir las propiedades del mensaje recibidas.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El filtro es <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introducido en MSMQ 3.0. Obtiene o establece la dirección de multidifusión asociada a la cola.</summary>
        <value>Un <see cref="T:System.String" /> que contiene una dirección de multidifusión válida (en el formulario se muestra a continuación) o <see langword="null" />, lo que indica que la cola no está asociada con una dirección de multidifusión.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propiedad se utiliza para asociar una dirección de multidifusión que se puede usar al enviar mensajes a una cola no transaccional. No se puede asociar una cola transaccional con una dirección de multidifusión. Cuando la aplicación de envío envía mensajes a una dirección de multidifusión, Message Queue Server envía una copia del mensaje a cada cola asociada a esa dirección.  
  
 Multidifusión IP direcciones deben estar en el intervalo de clase D de 224.0.0.0 a 239.255.255.255, que corresponde al valor de los primeros cuatro bits de orden superior es igual a 1110. Sin embargo, solo determinados intervalos de direcciones de este intervalo están reservados y disponibles para enviar mensajes de multidifusión. Para obtener la lista más reciente reservadas de direcciones de multidifusión, consulte el [direcciones de multidifusión de Internet de Internet Assigned número Authority (IANA)](https://go.microsoft.com/fwlink/?linkid=3859) página Web. No hay ninguna restricción en el número de puerto.  
  
 Si varios equipos de origen están enviando mensajes de multidifusión y desea que una cola específica para recibir mensajes desde un equipo de origen, cada equipo de origen debe enviar mensajes a una combinación diferente del número de puerto y la dirección IP.  
  
 Para desasociar una cola de una dirección de multidifusión, establezca el <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propiedad en una cadena de longitud cero. No se establece `null`, ya que esto dará como resultado un <xref:System.ArgumentNullException>.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ruta de acceso de la cola. Establecer el <see cref="P:System.Messaging.MessageQueue.Path" /> hace que el <see cref="T:System.Messaging.MessageQueue" /> para que apunte a una nueva cola.</summary>
        <value>La cola al que hace referencia el <see cref="T:System.Messaging.MessageQueue" />. El valor predeterminado depende de que <see cref="M:System.Messaging.MessageQueue.#ctor" /> constructor que usa; es <see langword="null" /> o se especifica mediante el constructor <paramref name="path" /> parámetro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sintaxis para el <xref:System.Messaging.MessageQueue.Path%2A> propiedad depende del tipo de cola que puntos a, tal como se muestra en la tabla siguiente.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
|Cola de diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Cola de diario del equipo|`MachineName`\\`Journal$`|  
|Cola de mensajes no enviados del equipo|`MachineName`\\`Deadletter$`|  
|Cola de mensajes no enviados transaccional del equipo|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para representar el equipo local.  
  
 El <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, y <xref:System.Messaging.MessageQueue.QueueName%2A> propiedades están relacionadas. Cambiar el <xref:System.Messaging.MessageQueue.MachineName%2A> propiedad causa el <xref:System.Messaging.MessageQueue.Path%2A> propiedad que se va a cambiar. Se crea a partir de la nueva <xref:System.Messaging.MessageQueue.MachineName%2A> y <xref:System.Messaging.MessageQueue.QueueName%2A>. Cambiar el <xref:System.Messaging.MessageQueue.Path%2A> (por ejemplo, para utilizar la sintaxis de nombre de formato) restablece el <xref:System.Messaging.MessageQueue.MachineName%2A> y <xref:System.Messaging.MessageQueue.QueueName%2A> propiedades para hacer referencia a la nueva cola.  
  
 Como alternativa, puede usar el <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> para describir la ruta de acceso de la cola, como se muestra en la tabla siguiente.  
  
|Referencia|Sintaxis|Ejemplo|  
|---------------|------------|-------------|  
|Nombre de formato|`FormatName:` [ *nombre de formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Etiqueta|`Label:` [ *etiqueta* ]|`Label:` Etiqueta|  
  
 Si usa la sintaxis de etiqueta para el <xref:System.Messaging.MessageQueue.Path%2A> propiedad al enviar el mensaje, una excepción se producirá si el <xref:System.Messaging.MessageQueue.Label%2A> no es único.  
  
 Para trabajar sin conexión, debe usar la sintaxis del nombre de formato, en lugar de la sintaxis del nombre descriptivo de la primera tabla. En caso contrario, se produce una excepción porque el controlador de dominio principal (en el que reside Active Directory) no está disponible para resolver la ruta de acceso en el nombre de formato.  
  
 Establecer una nueva ruta de acceso cierra la cola de mensajes y libera todos los identificadores.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
> [!NOTE]
>  En modo de grupo de trabajo sólo se pueden utilizar las colas privadas. Especifique la ruta de acceso mediante la sintaxis de la cola privada `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo <xref:System.Messaging.MessageQueue> objetos utilizando varios tipos de sintaxis de nombre de ruta de acceso. En cada caso, envía un mensaje a la cola cuya ruta de acceso se define en el constructor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válido, posiblemente porque la sintaxis no es válida.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <summary>Devuelve una copia del primer mensaje en la cola sin quitarlo de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve sin quitar (búsquedas peek) el primer mensaje en la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />. El <see cref="M:System.Messaging.MessageQueue.Peek" /> método es sincrónico, por lo que se bloquea el subproceso actual hasta que haya disponible un mensaje.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> que representa el primer mensaje en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para buscar una cola o esperar hasta que haya un mensaje en la cola.  
  
 El <xref:System.Messaging.MessageQueue.Peek%2A> método lee, pero no quita el primer mensaje de la cola. Por lo tanto, las llamadas repetidas a <xref:System.Messaging.MessageQueue.Peek%2A> devuelven el mismo mensaje, a menos que llegue un mensaje de mayor prioridad en la cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método, por otro lado, lee y quita el primer mensaje de la cola. Las llamadas repetidas a <xref:System.Messaging.MessageQueue.Receive%2A>, por lo tanto, devolver mensajes distintos.  
  
 Message Queue Server ordena los mensajes en la cola según la hora de llegada y prioridad. Se coloca un mensaje más reciente antes de uno más antiguo sólo si es una prioridad más alta.  
  
 Utilice <xref:System.Messaging.MessageQueue.Peek%2A> cuando se acepte bloquear el subproceso actual mientras se espera a que llegue un mensaje a la cola. Dado que esta sobrecarga no especifica un tiempo de espera, la aplicación podría esperar indefinidamente. Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.Messaging.MessageQueue.BeginPeek%2A>. Como alternativa, puede especificar un tiempo de espera para un mensaje llegue a la cola mediante la sobrecarga de <xref:System.Messaging.MessageQueue.Peek%2A> que especifica un tiempo de espera.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 Los ejemplos siguientes usan la <xref:System.Messaging.MessageQueue.Peek%2A> método en una cola.  
  
 En el primer ejemplo, la aplicación espera hasta que haya un mensaje disponible en la cola. Tenga en cuenta que el primer ejemplo no tiene acceso el mensaje que llega; simplemente se detiene el procesamiento hasta que llegue un mensaje. Si un mensaje ya existe en la cola, se devolverá inmediatamente.  
  
 En el segundo ejemplo, un mensaje que contiene una aplicación define `Order` clase es enviado a la cola y, a continuación, inspeccionar en la cola.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo máximo a esperar para que la cola contenga un mensaje.</param>
        <summary>Devuelve sin quitar (búsquedas peek) el primer mensaje en la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />. El <see cref="M:System.Messaging.MessageQueue.Peek" /> método es sincrónico, por lo que se bloquea el subproceso actual hasta que un mensaje disponible o se agota el tiempo de espera especificado.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> que representa el primer mensaje en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para buscar una cola o para esperar un periodo de tiempo hasta que haya un mensaje en la cola. El método vuelve inmediatamente si ya existe un mensaje en la cola.  
  
 El <xref:System.Messaging.MessageQueue.Peek%2A> método lee, pero no quita el primer mensaje de la cola. Por lo tanto, las llamadas repetidas a <xref:System.Messaging.MessageQueue.Peek%2A> devuelven el mismo mensaje, a menos que llegue un mensaje de mayor prioridad en la cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método, por otro lado, lee y quita el primer mensaje de la cola. Las llamadas repetidas a <xref:System.Messaging.MessageQueue.Receive%2A>, por lo tanto, devolver mensajes distintos.  
  
 Message Queue Server ordena los mensajes en la cola según la hora de llegada y prioridad. Se coloca un mensaje más reciente antes de uno más antiguo sólo si es una prioridad más alta.  
  
 Utilice <xref:System.Messaging.MessageQueue.Peek%2A> cuando se acepte bloquear el subproceso actual mientras se espera a que llegue un mensaje a la cola. Se bloqueará el subproceso hasta el período especificado de tiempo o indefinidamente si indicado <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Messaging.MessageQueue.Peek%2A> método con un tiempo de espera de cero para comprobar si la cola está vacía.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo máximo a esperar para que la cola contenga un mensaje.</param>
        <param name="cursor">Un <see cref="T:System.Messaging.Cursor" /> que mantiene una posición específica en la cola de mensajes.</param>
        <param name="action">Uno de los valores de <see cref="T:System.Messaging.PeekAction" />. Indica si se utiliza inspeccionar el mensaje actual de la cola o el mensaje siguiente.</param>
        <summary>Devuelve sin quitar (búsquedas peek) el actual o el siguiente mensaje en la cola, utilizando el cursor especificado. El <see cref="M:System.Messaging.MessageQueue.Peek" /> método es sincrónico, por lo que se bloquea el subproceso actual hasta que un mensaje disponible o se agota el tiempo de espera especificado.</summary>
        <returns>Un <see cref="T:System.Messaging.Message" /> que representa un mensaje en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para buscar una cola o para esperar un periodo de tiempo hasta que haya un mensaje en la cola. El método vuelve inmediatamente si ya existe un mensaje en la cola.  
  
 El <xref:System.Messaging.MessageQueue.Peek%2A> método lee, pero no quita un mensaje de la cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método, por otro lado, lee y quita un mensaje de la cola.  
  
 Utilice <xref:System.Messaging.MessageQueue.Peek%2A> cuando se acepte bloquear el subproceso actual mientras se espera a que llegue un mensaje a la cola. El subproceso está bloqueado hasta el período especificado de tiempo o indefinidamente si indicado <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Si es necesario que la aplicación siga realizando sus procesos sin esperar, hay que utilizar el método asincrónico <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor distinto de <see langword="PeekAction.Current" /> o <see langword="PeekAction.Next" /> se especificó para el <paramref name="action" /> parámetro.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="cursor" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido. Posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inspecciona un mensaje que coincide con un identificador de correlación dado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para echar un vistazo.</param>
        <summary>Busca el mensaje que coincide con el identificador de correlación dado e inmediatamente inicia una excepción si la cola ningún mensaje con el identificador de correlación especificado.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola al que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Si se encuentra ningún mensaje que coincide con el `correlationID` parámetro, se produce una excepción.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos le permiten buscar mensajes en una cola. El <xref:System.Messaging.MessageQueue.Peek%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola. En concreto solicita una confirmación positiva cuando el mensaje original llega o se recupera de la cola.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="correlationId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para echar un vistazo.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <summary>Busca el mensaje que coincide con el identificador de correlación dado y espera hasta que un mensaje con el identificador de correlación especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola al que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Si se encuentra ningún mensaje que coincide con el `correlationID` parámetro y ningún nuevo mensaje llega a la cola dentro del período especificado por el `timeout` parámetro, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.CorrelationId%2A> del nuevo mensaje para ver si coincide con el `correlationId` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el `correlationId` parámetro.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos le permiten buscar mensajes en una cola. El <xref:System.Messaging.MessageQueue.Peek%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="correlationId" /> no existe en la cola y no llegó antes de que expirara el tiempo de espera.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una copia del mensaje que tiene el identificador de mensaje especificado sin quitar el mensaje de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para echar un vistazo.</param>
        <summary>Busca el mensaje cuyo identificador de mensaje coincida con el <paramref name="id" /> parámetro.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> para leer, sin quitarlo de la cola, un mensaje que tiene un identificador de mensaje conocido. El identificador de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro. Esta sobrecarga produce una excepción si la cola no contiene el mensaje.  
  
 Dos métodos adicionales le permiten buscar mensajes en una cola: <xref:System.Messaging.MessageQueue.Peek%2A> y <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. El <xref:System.Messaging.MessageQueue.Peek%2A> método devuelve el primer mensaje en la cola; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> devuelve una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ningún mensaje con los valores especificados <paramref name="id" /> existe.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para echar un vistazo.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <summary>Busca el mensaje cuyo identificador de mensaje coincida con el <paramref name="id" /> parámetro. Espera hasta que aparezca el mensaje en la cola o se produce un tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> para leer, sin quitarlo de la cola, un mensaje que tiene un identificador de mensaje conocido. El identificador de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro. Esta sobrecarga produce una excepción si la cola no contiene el mensaje y no llegue un mensaje nuevo antes de que finalice el tiempo de espera.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.Id%2A> del nuevo mensaje para ver si coincide con el `id` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.Id%2A> coincide con el `id` parámetro.  
  
 Dos métodos adicionales le permiten buscar mensajes en una cola: <xref:System.Messaging.MessageQueue.Peek%2A> y <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. El <xref:System.Messaging.MessageQueue.Peek%2A> método devuelve el primer mensaje en la cola; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> devuelve una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="id" /> no existe en la cola y no llegó antes del período especificado por el <paramref name="timeout" /> parámetro ha expirado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introducido en MSMQ 3.0. Inspecciona un mensaje específico de la cola. El mensaje puede especificarse mediante un identificador de búsqueda o por su posición al principio o al final de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">El <see cref="P:System.Messaging.Message.LookupId" /> del mensaje que inspeccionar.</param>
        <summary>Introducido en MSMQ 3.0. Inspecciona un mensaje que coincide con el identificador de búsqueda dado de una cola no transaccional.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.LookupId" /> coincidencias de propiedad el <paramref name="lookupId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador de búsqueda conocido sin quitarlo de la cola. Este método produce una excepción inmediatamente si el mensaje no está en la cola.  
  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad de un mensaje es único para la cola donde reside el mensaje, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `lookupId` parámetro.  
  
 Para leer un mensaje con un identificador de búsqueda especificado y lo elimina de la cola, utilice el <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="lookupId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Uno de los <see cref="T:System.Messaging.MessageLookupAction" /> valores, que especifican cómo se lee el mensaje en la cola. Especifique uno de los siguientes: 
 <see langword="MessageLookupAction.Current" />: ejecuta el método Peek en el mensaje especificado por <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Next" />: ejecuta el método Peek en el mensaje que sigue al mensaje especificado por <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Previous" />: ejecuta el método Peek en el mensaje que precede al mensaje especificado por <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.First" />: ejecuta el método Peek en el primer mensaje de la cola. El <paramref name="lookupId" /> parámetro debe establecerse en 0.  
  
 <see langword="MessageLookupAction.Last" />: ejecuta el método Peek en el último mensaje de la cola. El <paramref name="lookupId" /> parámetro debe establecerse en 0.</param>
        <param name="lookupId">El <see cref="P:System.Messaging.Message.LookupId" /> del mensaje para inspeccionar o 0. 0 se usa al acceder al primer o último mensaje en la cola.</param>
        <summary>Introducido en MSMQ 3.0. Inspecciona un mensaje específico de la cola. El mensaje puede especificarse mediante un identificador de búsqueda o por su posición al principio o al final de la cola.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> especificado por el <paramref name="action" /> y <paramref name="lookupId" /> pasan los parámetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador de búsqueda conocido sin quitarlo de la cola. Este método produce una excepción inmediatamente si el mensaje no está en la cola.  
  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad de un mensaje es único para la cola donde reside el mensaje, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `lookupId` parámetro.  
  
 Para leer un mensaje con un identificador especificado y lo elimina de la cola, utilice el <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="lookupId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="action" /> no es un miembro de <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se lee un mensaje sin haberlo quitado de la cola. Esto es el resultado de la operación asincrónica, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> se usa en el procesamiento asincrónico para generar el <xref:System.Messaging.MessageQueue.PeekCompleted> evento cuando un mensaje está disponible en la cola.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> se usa para completar la operación iniciada por una llamada a <xref:System.Messaging.MessageQueue.BeginPeek%2A> y buscar el mensaje cuando el <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento.  
  
 Cuando se crea un delegado <xref:System.Messaging.PeekCompletedEventHandler>, se identifica el método que controlará el evento. Para asociar el evento al controlador, se debe agregar una instancia del delegado al evento. Siempre que se produce el evento, se llama a su controlador, a menos que se quite el delegado. Para obtener más información sobre los delegados de controlador de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un controlador de eventos denominado `MyPeekCompleted`, lo asocia a la <xref:System.Messaging.MessageQueue.PeekCompleted> delegado controlador de eventos y llamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar una operación de búsqueda peek asincrónica en la cola que se encuentra en la ruta de acceso ". \myQueue". Cuando un <xref:System.Messaging.MessageQueue.PeekCompleted> provoca el evento, el ejemplo busca el mensaje y escribe el cuerpo en la pantalla. El ejemplo llama a <xref:System.Messaging.MessageQueue.BeginPeek%2A> nuevo para iniciar una nueva operación de búsqueda peek asincrónica  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina todos los mensajes contenidos en la cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Purgar la cola, Message Queue Server establecer la marca de modificación de la cola, lo que afecta a la <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propiedad. Los mensajes que se purgan de la cola se pierden; no se envían a la cola o la cola del diario.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre descriptivo que identifica la cola.</summary>
        <value>El nombre que identifica la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />. El valor no puede ser <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede combinar el <xref:System.Messaging.MessageQueue.QueueName%2A> con el <xref:System.Messaging.MessageQueue.MachineName%2A> para crear una sencilla <xref:System.Messaging.MessageQueue.Path%2A> nombre para la cola. La sintaxis para la variación del nombre descriptivo de la <xref:System.Messaging.MessageQueue.Path%2A> propiedad depende del tipo de cola, como se muestra en la tabla siguiente.  
  
|Tipo de cola|Sintaxis|  
|----------------|------------|  
|cola pública|`MachineName`\\`QueueName`|  
|cola privada|`MachineName`\\`Private$`\\`QueueName`|  
|Cola de diario|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Use "." para representar el equipo local.  
  
 Cambiar el <xref:System.Messaging.MessageQueue.QueueName%2A> afecta a la propiedad el <xref:System.Messaging.MessageQueue.Path%2A> propiedad. Si establece la <xref:System.Messaging.MessageQueue.QueueName%2A> sin establecer el <xref:System.Messaging.MessageQueue.MachineName%2A> propiedad, el <xref:System.Messaging.MessageQueue.Path%2A> propiedad pasa a ser.\\ `QueueName`. En caso contrario, el <xref:System.Messaging.MessageQueue.Path%2A> se convierte en `MachineName` \\ `QueueName`.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|Sí|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.QueueName%2A> propiedad.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es el nombre de cola <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador nativo utilizado para leer mensajes de la cola de mensajes.</summary>
        <value>Un identificador para el objeto de cola nativo que usa para buscar y recibir mensajes de la cola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.ReadHandle%2A> proporciona un identificador nativo de Windows para el objeto de cola de mensajes que se usa para buscar y recibir mensajes de la cola. Si cambia la ruta de acceso de la cola, el identificador se cierra y vuelve a abrir con un nuevo valor.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <summary>Recibe el primer mensaje en la cola y lo quita de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recibe el primer mensaje disponible en la cola al que hace referencia el <see cref="T:System.Messaging.MessageQueue" />. Esta llamada es sincrónica y bloquea el subproceso de ejecución actual hasta que un mensaje esté disponible.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola o espere a que hay mensajes en la cola.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolverá los mensajes que siguen en la cola o nuevo, los mensajes de prioridad más alto.  
  
 Para leer el primer mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. El <xref:System.Messaging.MessageQueue.Peek%2A> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. Dado que esta sobrecarga de la <xref:System.Messaging.MessageQueue.Receive%2A> método especifica un tiempo de espera infinito, la aplicación podría esperar indefinidamente. Si el procesamiento de la aplicación debe continuar sin esperar a que el mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe un mensaje de una cola y envía la información sobre ese mensaje a la pantalla.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el primer mensaje disponible en la cola transaccional al que hace referencia el <see cref="T:System.Messaging.MessageQueue" />. Esta llamada es sincrónica y bloquea el subproceso de ejecución actual hasta que un mensaje esté disponible.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola transaccional utilizando el contexto de transacción interna definido por el `transaction` parámetro o espere hasta que haya mensajes en la cola.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolverá los mensajes que siguen en la cola.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer el primer mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. El <xref:System.Messaging.MessageQueue.Peek%2A> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.Peek%2A>. Dado que <xref:System.Messaging.MessageQueue.Peek%2A> no quita ningún mensaje de la cola, no habría nada para revertir mediante una llamada a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. Dado que esta sobrecarga de la <xref:System.Messaging.MessageQueue.Receive%2A> método especifica un tiempo de espera infinito, la aplicación podría esperar indefinidamente. Si el procesamiento de la aplicación debe continuar sin esperar a que el mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a una cola transaccional en el equipo local y envía un mensaje a la cola. A continuación, recibe el mensaje que contiene un pedido. Si se encuentra una cola no transaccional, producirá excepciones y se deshace la transacción.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.  
  
-o bien- 
La cola es no transaccional.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Recibe el primer mensaje disponible en la cola al que hace referencia el <see cref="T:System.Messaging.MessageQueue" />. Esta llamada es sincrónica y bloquea el subproceso de ejecución actual hasta que un mensaje esté disponible.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola mediante un contexto de transacción definido por el `transactionType` parámetro o espere hasta que haya mensajes en la cola.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolverá los mensajes que siguen en la cola.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer el primer mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. El <xref:System.Messaging.MessageQueue.Peek%2A> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.Peek%2A>. Dado que <xref:System.Messaging.MessageQueue.Peek%2A> no quita ningún mensaje de la cola, no habría nada para revertir mediante una llamada a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. Dado que esta sobrecarga de la <xref:System.Messaging.MessageQueue.Receive%2A> método especifica un tiempo de espera infinito, la aplicación podría esperar indefinidamente. Si el procesamiento de la aplicación debe continuar sin esperar a que el mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <summary>Recibe el primer mensaje disponible en la cola al que hace referencia el <see cref="T:System.Messaging.MessageQueue" /> y espera hasta que un mensaje esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje y devolver en un período de tiempo especificado si no hay ningún mensaje en la cola.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolverá los mensajes que siguen en la cola o nuevo, los mensajes de prioridad más alto.  
  
 Para leer el primer mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. El <xref:System.Messaging.MessageQueue.Peek%2A> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. El subproceso se bloqueará durante el período de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro. Si el procesamiento de la aplicación debe continuar sin esperar a un mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe un mensaje de una cola y envía la información sobre ese mensaje a la pantalla. En el ejemplo se detiene la ejecución hasta cinco segundos mientras se espera un mensaje llegue a la cola.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó en la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="cursor">Un <see cref="T:System.Messaging.Cursor" /> que mantiene una posición específica en la cola de mensajes.</param>
        <summary>Recibe el mensaje actual de la cola, utilizando un cursor especificado. Si está disponible ningún mensaje, este método espera hasta que un mensaje esté disponible o expire el tiempo de espera.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó en la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server 
Utilice esta sobrecarga para recibir un mensaje y devolver en un período de tiempo especificado si no hay ningún mensaje en la cola.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el primer mensaje disponible en la cola transaccional al que hace referencia el <see cref="T:System.Messaging.MessageQueue" /> y espera hasta que un mensaje esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola transaccional utilizando el contexto de transacción interna definido por el `transaction` y devolverlo en un período de tiempo si hay mensajes en la cola especificado.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolverá los mensajes que siguen en la cola.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer el primer mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. El <xref:System.Messaging.MessageQueue.Peek%2A> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.Peek%2A>. Dado que <xref:System.Messaging.MessageQueue.Peek%2A> no quita ningún mensaje de la cola, no habría nada para revertir mediante una llamada a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. El subproceso se bloqueará durante el período de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro. Si el procesamiento de la aplicación debe continuar sin esperar a un mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este método.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó en la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
La cola es no transaccional.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Recibe el primer mensaje disponible en la cola al que hace referencia el <see cref="T:System.Messaging.MessageQueue" />. Esta llamada es sincrónica y espera hasta que un mensaje esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola mediante un contexto de transacción definido por el `transactionType` y devolverlo en un periodo de tiempo si hay mensajes en la cola.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolverá los mensajes que siguen en la cola.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer el primer mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. El <xref:System.Messaging.MessageQueue.Peek%2A> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.Peek%2A>. Dado que <xref:System.Messaging.MessageQueue.Peek%2A> no quita ningún mensaje de la cola, no habría nada para revertir mediante una llamada a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. El subproceso se bloqueará durante el período de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro. Si el procesamiento de la aplicación debe continuar sin esperar a un mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este método.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó en la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="cursor">Un <see cref="T:System.Messaging.Cursor" /> que mantiene una posición específica en la cola de mensajes.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el mensaje actual de la cola, utilizando un cursor especificado. Si está disponible ningún mensaje, este método espera hasta que un mensaje esté disponible o expire el tiempo de espera.</summary>
        <returns>Un <see cref="T:System.Messaging.Message" /> que hace referencia a un mensaje en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola transaccional utilizando el contexto de transacción interna definido por el `transaction` y devolverlo en un período de tiempo si hay mensajes en la cola especificado.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolver los mensajes que siguen en la cola.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devuelve a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer un mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.Peek%2A>. Dado que <xref:System.Messaging.MessageQueue.Peek%2A> no quita ningún mensaje de la cola, no hay nada para revertir mediante una llamada a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. El subproceso se bloquea durante el período de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro. Si el procesamiento de la aplicación debe continuar sin esperar a un mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="cursor" /> es <see langword="null" />.  
  
-o bien- 
El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido. Posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó en la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
La cola es no transaccional.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="cursor">Un <see cref="T:System.Messaging.Cursor" /> que mantiene una posición específica en la cola de mensajes.</param>
        <param name="transactionType">Uno de los <see cref="T:System.Messaging.MessageQueueTransactionType" /> valores que describe el tipo de contexto de transacción para asociar el mensaje.</param>
        <summary>Recibe el mensaje actual de la cola, utilizando un cursor especificado. Si está disponible ningún mensaje, este método espera hasta que un mensaje esté disponible o expire el tiempo de espera.</summary>
        <returns>Un <see cref="T:System.Messaging.Message" /> que hace referencia a un mensaje en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para recibir un mensaje de una cola mediante un contexto de transacción definido por el `transactionType` y devolverlo en un periodo de tiempo si hay mensajes en la cola.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 El <xref:System.Messaging.MessageQueue.Receive%2A> método permite la lectura sincrónica de un mensaje, y lo quita de la cola. Las llamadas subsiguientes a <xref:System.Messaging.MessageQueue.Receive%2A> devolver los mensajes que siguen en la cola.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, el mensaje recibido se devuelve a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer un mensaje en una cola sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.Peek%2A> método. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.Peek%2A>. Dado que <xref:System.Messaging.MessageQueue.Peek%2A> no quita ningún mensaje de la cola, no hay nada para revertir mediante una llamada a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar una llamada a <xref:System.Messaging.MessageQueue.Receive%2A> cuando sea aceptable para el subproceso actual se bloquee mientras espera un mensaje llegue a la cola. El subproceso se bloquea durante el período de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro. Si el procesamiento de la aplicación debe continuar sin esperar a un mensaje, considere la posibilidad de utilizar el método asincrónico, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="cursor" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido. Posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje no llegó en la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <threadsafe>El método no es seguro para subprocesos.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recibe un mensaje que coincide con un identificador de correlación dado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para recibir.</param>
        <summary>Recibe el mensaje que coincide con el identificador de correlación dado (desde una cola no transaccional) e inmediatamente inicia una excepción si la cola ningún mensaje con el identificador de correlación especificado.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola no transaccional que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Si se encuentra ningún mensaje que coincide con el `correlationID` parámetro, se produce una excepción. En caso contrario, el mensaje se quita de la cola y devuelve a la aplicación.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método recupera un mensaje mediante la especificación de su identificador único.  
  
 Para leer un mensaje con un identificador de correlación especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola. En concreto solicita una confirmación positiva cuando el mensaje original llega o se recupera de la cola.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="correlationId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para recibir.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el mensaje que coincide con el identificador de correlación dado (desde una cola transaccional) e inmediatamente inicia una excepción si la cola ningún mensaje con el identificador de correlación especificado.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola transaccional al que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Si se encuentra ningún mensaje que coincide con el `correlationID` parámetro, se produce una excepción. En caso contrario, el mensaje se quita de la cola y devuelve a la aplicación mediante el contexto de transacción interna definido por el `transaction` parámetro.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 Para leer un mensaje con un identificador de correlación especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.  
  
-o bien- 
El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="correlationId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La cola es no transaccional.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para recibir.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Recibe el mensaje que coincide con el identificador de correlación dado e inmediatamente inicia una excepción si la cola ningún mensaje con el identificador de correlación especificado.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola al que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Si se encuentra ningún mensaje que coincide con el `correlationID` parámetro, se produce una excepción. En caso contrario, el mensaje se quita de la cola y devuelve a la aplicación mediante un contexto de transacción definido por el `transactionType` parámetro.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 Para leer un mensaje con un identificador de correlación especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="correlationId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para recibir.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <summary>Recibe el mensaje que coincide con el identificador de correlación dado (desde una cola no transaccional) y espera hasta que un mensaje con el identificador de correlación especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola no transaccional que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Este método vuelve inmediatamente si el mensaje con el identificador de correlación especificado por el `correlationId` parámetro está en la cola. En caso contrario, el método espera el período de tiempo para un nuevo mensaje llegue a determinado. Si no recibe un mensaje nuevo antes de que expire el tiempo de espera, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.CorrelationId%2A> del nuevo mensaje para ver si coincide con el `correlationId` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el `correlationId` parámetro.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 Para leer un mensaje con un identificador de correlación especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El mensaje con los valores especificados <paramref name="correlationId" /> no existe en la cola y no llegó antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para recibir.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el mensaje que coincide con el identificador de correlación dado (desde una cola transaccional) y espera hasta que un mensaje con el identificador de correlación especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola transaccional al que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Este método vuelve inmediatamente si el mensaje con el identificador de correlación especificado por el `correlationId` parámetro está en la cola, utilizando el contexto de transacción interna definido por el `transaction` parámetro. En caso contrario, el método espera el período de tiempo para un nuevo mensaje llegue a determinado. Si no recibe un mensaje nuevo antes de que expire el tiempo de espera, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.CorrelationId%2A> del nuevo mensaje para ver si coincide con el `correlationId` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el `correlationId` parámetro.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 Para leer un mensaje con un identificador de correlación especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.  
  
-o bien- 
El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El mensaje con los valores especificados <paramref name="correlationId" /> no existe en la cola y no llegó antes de que expirara el tiempo de espera.  
  
-o bien- 
La cola es no transaccional.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">El <see cref="P:System.Messaging.Message.CorrelationId" /> del mensaje para recibir.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Recibe el mensaje que coincide con el identificador de correlación dado y espera hasta que un mensaje con el identificador de correlación especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.CorrelationId" /> coincide con el <paramref name="correlationId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en la cola al que hace referencia el <xref:System.Messaging.MessageQueue> para un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el especificado `correlationId` parámetro. Este método vuelve inmediatamente si el mensaje con el identificador de correlación especificado por el `correlationId` parámetro está en la cola, utilizando un contexto de transacción definido por el `transactionType` parámetro. En caso contrario, el método espera el período de tiempo para un nuevo mensaje llegue a determinado. Si no recibe un mensaje nuevo antes de que expire el tiempo de espera, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.CorrelationId%2A> del nuevo mensaje para ver si coincide con el `correlationId` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.CorrelationId%2A> coincide con el `correlationId` parámetro. Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 El <xref:System.Messaging.Message.CorrelationId%2A> propiedad se utiliza para relacionar un mensaje enviado a la cola de mensajes de respuesta, el informe o confirmación asociados.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método se utiliza para recuperar un mensaje mediante la especificación de su identificador único.  
  
 Para leer un mensaje con un identificador de correlación especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="correlationId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="correlationId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El mensaje con los valores especificados <paramref name="correlationId" /> no existe en la cola y no llegó antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recibe el mensaje que coincide con el identificador especificado, quitándolo de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para recibir.</param>
        <summary>Recibe el mensaje que coincide con el identificador dado desde una cola no transaccional e inmediatamente inicia una excepción si actualmente no existe ningún mensaje con el identificador especificado en la cola.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador conocido y quitarlo de la cola. Este método produce una excepción inmediatamente si el mensaje no está en la cola.  
  
 El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método se usa para recuperar una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="id" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para recibir.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el mensaje que coincide con el identificador dado (desde una cola transaccional) e inmediatamente inicia una excepción si actualmente no existe ningún mensaje con el identificador especificado en la cola.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para leer un mensaje con un identificador conocido y quitarlo de la cola, utilizando el contexto de transacción interna definido por el `transaction` parámetro. Este método produce una excepción inmediatamente si el mensaje no está en la cola  
  
 El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método se usa para recuperar una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.  
  
-o bien- 
El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="id" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La cola es no transaccional.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para recibir.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Recibe el mensaje que coincide con el identificador dado e inmediatamente inicia una excepción si actualmente no existe ningún mensaje con el identificador especificado en la cola.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador conocido y quitarlo de la cola. Este método produce una excepción inmediatamente si el mensaje no está en la cola. En caso contrario, el mensaje se quita de la cola y devuelve a la aplicación mediante un contexto de transacción definido por el `transactionType` parámetro.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro. Si el mensaje con el identificador especificado está en una cola que no sea el asociado a este <xref:System.Messaging.MessageQueue> instancia, no se encontrará el mensaje.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método se usa para recuperar una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="id" /> no se pudo encontrar.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para recibir.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <summary>Recibe el mensaje que coincide con el identificador dado (desde una cola no transaccional) y espera hasta que un mensaje con el identificador especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador conocido y quitarlo de la cola. Este método vuelve inmediatamente si el mensaje con el identificador especificado por el `id` parámetro está en la cola. En caso contrario, el método espera el período de tiempo para un nuevo mensaje llegue a determinado. Si no recibe un mensaje nuevo antes de que expire el tiempo de espera, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.Id%2A> del nuevo mensaje para ver si coincide con el `id` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.Id%2A> coincide con el `id` parámetro.  
  
 El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro.  
  
 Utilice esta sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> cuando sea aceptable para el subproceso actual se bloquea mientras continúan nuevos mensajes llegan a la cola dentro del período de tiempo de espera especificado por el `timeout` parámetro. El subproceso se bloqueará durante al menos el período determinado de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro, o si continúan los nuevos mensajes que llegan a la cola dentro del período de tiempo de espera especificado por el `timeout` parámetro.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método se usa para recuperar una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje con los valores especificados <paramref name="id" /> no llegó a la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para recibir.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recibe el mensaje que coincide con el identificador dado (desde una cola transaccional) y espera hasta que un mensaje con el identificador especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para leer un mensaje con un identificador conocido y quitarlo de la cola, utilizando el contexto de transacción interna definido por el `transaction` parámetro. Este método vuelve inmediatamente si el mensaje con el identificador especificado por el `id` parámetro está en la cola. En caso contrario, el método espera el período de tiempo para un nuevo mensaje llegue a determinado. Si no recibe un mensaje nuevo antes de que expire el tiempo de espera, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.Id%2A> del nuevo mensaje para ver si coincide con el `id` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.Id%2A> coincide con el `id` parámetro.  
  
 El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro.  
  
 Utilice esta sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> cuando sea aceptable para el subproceso actual se bloquea mientras continúan nuevos mensajes llegan a la cola dentro del período de tiempo de espera especificado por el `timeout` parámetro. El subproceso se bloqueará durante al menos el período determinado de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro, o si continúan los nuevos mensajes que llegan a la cola dentro del período de tiempo de espera especificado por el `timeout` parámetro.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método se usa para recuperar una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje, a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.  
  
-o bien- 
El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje con los valores especificados <paramref name="id" /> no llegó a la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
La cola es no transaccional.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.Messaging.Message.Id" /> del mensaje para recibir.</param>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que indica el tiempo de espera hasta que haya un nuevo mensaje disponible para su inspección.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Recibe el mensaje que coincide con el identificador dado y espera hasta que un mensaje con el identificador especificado esté disponible en la cola o expira el tiempo de espera.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.Id" /> coincidencias de propiedad el <paramref name="id" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador conocido y quitarlo de la cola. Este método vuelve inmediatamente si el mensaje con el identificador especificado por el `id` parámetro está en la cola, utilizando un contexto de transacción definido por el `transactionType` parámetro. En caso contrario, el método espera el período de tiempo para un nuevo mensaje llegue a determinado. Si no recibe un mensaje nuevo antes de que expire el tiempo de espera, se produce una excepción.  
  
 El `timeout` parámetro no especifica el total de tiempo de ejecución para este método. En su lugar, especifica el tiempo de espera para que un nuevo mensaje llegue a la cola. Cada vez que llega un mensaje nuevo, este método examina los <xref:System.Messaging.Message.Id%2A> del nuevo mensaje para ver si coincide con el `id` parámetro. De lo contrario, este método comienza el período de tiempo de espera de nuevo y espera a que llegue un mensaje nuevo otro. Por lo tanto, si continúan nuevos mensajes que llegan dentro del período de tiempo de espera, es posible que este método siga ejecutándose indefinidamente, hasta que expire el período de tiempo de espera sin mensajes nuevos que llegan, o hasta que llegue un mensaje cuyo <xref:System.Messaging.Message.Id%2A> coincide con el `id` parámetro.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje es único en toda la empresa de Message Queue Server, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `id` parámetro. Si el mensaje con el identificador especificado está en una cola que no sea el asociado a este <xref:System.Messaging.MessageQueue> instancia, no se encontrará el mensaje.  
  
 Utilice esta sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> cuando sea aceptable para el subproceso actual se bloquea mientras continúan nuevos mensajes llegan a la cola dentro del período de tiempo de espera especificado por el `timeout` parámetro. El subproceso se bloqueará durante al menos el período determinado de tiempo o indefinidamente si especifica el valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para el `timeout` parámetro, o si continúan los nuevos mensajes que llegan a la cola dentro del período de tiempo de espera especificado por el `timeout` parámetro.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Otros dos métodos permiten recibir mensajes de una cola. El <xref:System.Messaging.MessageQueue.Receive%2A> método devuelve el primer mensaje en la cola y el <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método se usa para recuperar una confirmación, un informe o un mensaje de respuesta generados por la aplicación que se creó como resultado un mensaje enviado a la cola.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. El <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método siempre devuelve el primer mensaje en la cola, por lo que las llamadas subsiguientes al método devuelven el mismo mensaje a menos que llegue un mensaje de mayor prioridad en la cola. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Dado que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> no quita ningún mensaje de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para el <paramref name="timeout" /> parámetro no es válido, posiblemente <paramref name="timeout" /> es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un mensaje con los valores especificados <paramref name="id" /> no llegó a la cola antes de que expirara el tiempo de espera.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introducido en MSMQ 3.0. Recibe un mensaje concreto de la cola. El mensaje puede especificarse mediante un identificador de búsqueda o por su posición al principio o al final de la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">El <see cref="P:System.Messaging.Message.LookupId" /> del mensaje para recibir.</param>
        <summary>Introducido en MSMQ 3.0. Recibe el mensaje que coincide con el identificador de búsqueda dado de una cola no transaccional.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> cuyo <see cref="P:System.Messaging.Message.LookupId" /> coincidencias de propiedad el <paramref name="lookupId" /> parámetro pasado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para leer un mensaje con un identificador de búsqueda conocido y quitarlo de la cola. Este método produce una excepción inmediatamente si el mensaje no está en la cola.  
  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad de un mensaje es único para la cola donde reside el mensaje, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `lookupId` parámetro.  
  
 Para leer un mensaje con un identificador de búsqueda especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="lookupId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Uno de los <see cref="T:System.Messaging.MessageLookupAction" /> valores, que especifican cómo se lee el mensaje en la cola. Especifique uno de los siguientes: 
 <see langword="MessageLookupAction.Current" />: recibe el mensaje especificado por <paramref name="lookupId" /> y lo quita de la cola.  
  
 <see langword="MessageLookupAction.Next" />: recibe el mensaje siguiente al mensaje especificado por <paramref name="lookupId" /> y lo quita de la cola.  
  
 <see langword="MessageLookupAction.Previous" />: recibe el mensaje anterior al mensaje especificado por <paramref name="lookupId" /> y lo quita de la cola.  
  
 <see langword="MessageLookupAction.First" />: recibe el primer mensaje de la cola y lo quita de esta. El <paramref name="lookupId" /> parámetro debe establecerse en 0.  
  
 <see langword="MessageLookupAction.Last" />: recibe el último mensaje de la cola y lo quita de esta. El <paramref name="lookupId" /> parámetro debe establecerse en 0.</param>
        <param name="lookupId">El <see cref="P:System.Messaging.Message.LookupId" /> del mensaje para recibir o 0. 0 se usa al acceder al primer o último mensaje en la cola.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Introducido en MSMQ 3.0. Recibe un mensaje concreto de una cola transaccional. El mensaje puede especificarse mediante un identificador de búsqueda o por su posición al principio o al final de la cola.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> especificado por el <paramref name="lookupId" /> y <paramref name="action" /> pasan los parámetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para leer un mensaje con un identificador de búsqueda conocido y quitarlo de la cola, utilizando un contexto de transacción definido por el `transaction` parámetro. Este método produce una excepción inmediatamente si el mensaje no está en la cola.  
  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad de un mensaje es único para la cola donde reside el mensaje, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `lookupId` parámetro.  
  
 Dado que este método se llama en una cola transaccional, el mensaje recibido se devolvería a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Dado que <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> no quita los mensajes de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="lookupId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.  
  
-o bien- 
La cola es no transaccional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="action" /> no es un miembro de <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Uno de los <see cref="T:System.Messaging.MessageLookupAction" /> valores, que especifican cómo se lee el mensaje en la cola. Especifique uno de los siguientes: 
 <see langword="MessageLookupAction.Current" />: recibe el mensaje especificado por <paramref name="lookupId" /> y lo quita de la cola.  
  
 <see langword="MessageLookupAction.Next" />: recibe el mensaje siguiente al mensaje especificado por <paramref name="lookupId" /> y lo quita de la cola.  
  
 <see langword="MessageLookupAction.Previous" />: recibe el mensaje anterior al mensaje especificado por <paramref name="lookupId" /> y lo quita de la cola.  
  
 <see langword="MessageLookupAction.First" />: recibe el primer mensaje de la cola y lo quita de esta. El <paramref name="lookupId" /> parámetro debe establecerse en 0.  
  
 <see langword="MessageLookupAction.Last" />: recibe el último mensaje de la cola y lo quita de esta. El <paramref name="lookupId" /> parámetro debe establecerse en 0.</param>
        <param name="lookupId">El <see cref="P:System.Messaging.Message.LookupId" /> del mensaje para recibir o 0. 0 se usa al acceder al primer o último mensaje en la cola.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Introducido en MSMQ 3.0. Recibe un mensaje concreto de la cola, utilizando el contexto de transacción especificado. El mensaje puede especificarse mediante un identificador de búsqueda o por su posición al principio o al final de la cola.</summary>
        <returns>El <see cref="T:System.Messaging.Message" /> especificado por el <paramref name="action" /> y <paramref name="lookupId" /> pasan los parámetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para leer un mensaje con un identificador de búsqueda conocido y quitarlo de la cola, utilizando un contexto de transacción definido por el `transactionType` parámetro. Este método produce una excepción inmediatamente si el mensaje no está en la cola.  
  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad de un mensaje es único para la cola donde reside el mensaje, por lo que habrá al menos un mensaje en la cola que coincida con la determinada `lookupId` parámetro.  
  
 Para leer un mensaje con un identificador especificado sin quitarlo de la cola, utilice el <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. No hay ningún contexto de transacción asociado con un mensaje devuelto por una llamada a <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Dado que <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> no quita los mensajes de la cola, no habría nada que deshacer si se anuló la transacción.  
  
 Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje. Especificar `Single` si desea recibir el mensaje como una sola transacción interna. Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.  
  
 Si se llama a este método para recibir un mensaje desde una cola transaccional, se devolverá el mensaje recibido a la cola si se anula la transacción. El mensaje no se quita permanentemente de la cola hasta que se confirma la transacción.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje con los valores especificados <paramref name="lookupId" /> no se pudo encontrar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="action" /> no es un miembro de <see cref="T:System.Messaging.MessageLookupAction" />.  
  
-o bien- 
El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un mensaje se ha quitado de la cola. Este evento es desencadenado por la operación asincrónica, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> se usa en el procesamiento asincrónico para generar el <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento cuando un mensaje está disponible en la cola.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> se usa para completar la operación iniciada por una llamada a <xref:System.Messaging.MessageQueue.BeginReceive%2A> y buscar el mensaje cuando el <xref:System.Messaging.MessageQueue.ReceiveCompleted> provoca el evento.  
  
 Cuando se crea un delegado <xref:System.Messaging.ReceiveCompletedEventHandler>, se identifica el método que controlará el evento. Para asociar el evento al controlador, se debe agregar una instancia del delegado al evento. Siempre que se produce el evento, se llama a su controlador, a menos que se quite el delegado. Para obtener más información sobre los delegados de controlador de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un controlador de eventos denominado `MyReceiveCompleted`, lo asocia a la <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegado controlador de eventos y llamadas <xref:System.Messaging.MessageQueue.BeginReceive%2A> para iniciar una operación de recepción asincrónica en la cola que se encuentra en la ruta de acceso ". \myQueue". Cuando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> provoca el evento, en el ejemplo se recibe el mensaje y escribe el cuerpo en la pantalla. El ejemplo llama a <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuevo para iniciar un nuevo asincrónica operación de recepción.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Actualiza las propiedades que presenta el <see cref="T:System.Messaging.MessageQueue" /> para reflejar el estado actual del recurso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> sincroniza las propiedades de un <xref:System.Messaging.MessageQueue> con el recurso de servidor de Message Queue Server asociado. Si cualquier propiedad, como <xref:System.Messaging.MessageQueue.Label%2A> o <xref:System.Messaging.MessageQueue.Category%2A>, ha cambiado en el servidor desde el momento en el <xref:System.Messaging.MessageQueue> se creó, <xref:System.Messaging.MessageQueue.Refresh%2A> actualizaciones el <xref:System.Messaging.MessageQueue> con la nueva información.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece la lista de permisos a los valores predeterminados del sistema operativo. Quita los permisos de cola que se hayan agregado a la lista predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, devolver la lista de permisos en sus valores predeterminados. Por lo general, esto concede el creador de la cola de todos los permisos y proporciona el grupo de todos los derechos siguientes:  
  
-   Obtiene las propiedades de la cola.  
  
-   Obtenga los permisos de cola.  
  
-   Escribir en la cola.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía un objeto a una cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a enviar a la cola.</param>
        <summary>Envía un objeto a la cola no transaccional que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para enviar un mensaje que contiene el `obj` parámetro a la cola al que hace referencia el <xref:System.Messaging.MessageQueue>. El objeto que se envía a la cola puede ser un <xref:System.Messaging.Message> o cualquier objeto administrado. Si se envía un objeto que no sea un <xref:System.Messaging.Message>, el objeto se serializa y se inserta en el cuerpo del mensaje.  
  
 Si utiliza esta sobrecarga para enviar un mensaje a una cola transaccional, el mensaje se enviará a la cola de mensajes no enviados. Si desea que el mensaje para formar parte de una transacción que contiene otros mensajes, use una sobrecarga que toma un <xref:System.Messaging.MessageQueueTransaction> o <xref:System.Messaging.MessageQueueTransactionType> como un parámetro.  
  
 Si no establece la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad antes de llamar a <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, el formateador tiene como valor predeterminado el <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad se aplica a cualquier objeto que no sea un <xref:System.Messaging.Message>. Si se especifica, por ejemplo, una etiqueta o una prioridad utilizando el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembro, estos valores se aplican a cualquier mensaje que contiene un objeto que no es de tipo <xref:System.Messaging.Message> cuando la aplicación envía a la cola. Al enviar un <xref:System.Messaging.Message>, establecen los valores de propiedad para el <xref:System.Messaging.Message> prevalecen sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> y el mensaje <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad tiene prioridad sobre la cola <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a una cola de mensajes y envía un mensaje a la cola.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 En el ejemplo de código siguiente se envía un definido por la aplicación `Order` clase a una cola y, a continuación, recibe un mensaje de dicha cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">El <see cref="P:System.Messaging.MessageQueue.Path" /> no se estableció la propiedad.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a enviar a la cola.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envía un objeto a la cola transaccional que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para enviar un mensaje que contiene el `obj` parámetro a la cola transaccional al que hace referencia el <xref:System.Messaging.MessageQueue>, mediante un contexto de transacción interna definido por el `transaction` parámetro. El objeto que se envía a la cola puede ser un <xref:System.Messaging.Message> o cualquier objeto administrado. Si se envía un objeto que no sea un <xref:System.Messaging.Message>, el objeto se serializa y se inserta en el cuerpo del mensaje.  
  
 Si utiliza esta sobrecarga para enviar un mensaje a una cola no transaccional, se podría enviar el mensaje a la cola sin producir una excepción.  
  
 Si no establece la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad antes de llamar a <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, el formateador tiene como valor predeterminado el <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad se aplica a cualquier objeto que no sea un <xref:System.Messaging.Message>. Si se especifica, por ejemplo, una etiqueta o una prioridad utilizando el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembro, estos valores se aplican a cualquier mensaje que contiene un objeto que no es de tipo <xref:System.Messaging.Message> cuando la aplicación envía a la cola. Al enviar un <xref:System.Messaging.Message>, establecen los valores de propiedad para el <xref:System.Messaging.Message> prevalecen sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> y el mensaje <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad tiene prioridad sobre la cola <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad.  
  
 <xref:System.Messaging.MessageQueueTransaction> Tenga en cuenta el apartamento de subprocesos por lo que si el estado del apartamento es `STA`, no se puede utilizar la transacción en varios subprocesos. Visual Basic establece el estado del subproceso principal para `STA`, por lo que se debe aplicar el <xref:System.MTAThreadAttribute> en el `Main` subrutina. De lo contrario, al enviar un mensaje transaccional mediante otro subproceso se producirá una excepción <xref:System.Messaging.MessageQueueException>. Aplica el <xref:System.MTAThreadAttribute> utilizando el siguiente fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 El siguiente ejemplo de código envía una cadena a una cola transaccional y, a continuación, recibe un mensaje de dicha cola.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El <see cref="P:System.Messaging.MessageQueue.Path" /> no se estableció la propiedad.  
  
-o bien- 
La aplicación Message Queuing indicó un uso incorrecto de la transacción.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a enviar a la cola.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Envía un objeto a la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para enviar un mensaje que contiene el `obj` parámetro a la cola al que hace referencia el <xref:System.Messaging.MessageQueue>, mediante un contexto de transacción definido por el `transactionType` parámetro. Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea usar para enviar el mensaje. Especificar `Single` si desea enviar el mensaje como una sola transacción interna. Puede especificar `None` si desea enviar un mensaje transaccional a un subproceso no transaccional.  
  
 El objeto que se envía a la cola puede ser un <xref:System.Messaging.Message> o cualquier objeto administrado. Si se envía un objeto que no sea un <xref:System.Messaging.Message>, el objeto se serializa y se inserta en el cuerpo del mensaje.  
  
 Si no establece la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad antes de llamar a <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, el formateador tiene como valor predeterminado el <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad se aplica a cualquier objeto que no sea un <xref:System.Messaging.Message>. Si se especifica, por ejemplo, una etiqueta o una prioridad utilizando el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembro, estos valores se aplican a cualquier mensaje que contiene un objeto que no es de tipo <xref:System.Messaging.Message> cuando la aplicación envía a la cola. Al enviar un <xref:System.Messaging.Message>, establecen los valores de propiedad para el <xref:System.Messaging.Message> prevalecen sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> y el mensaje <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad tiene prioridad sobre la cola <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El <see cref="P:System.Messaging.MessageQueue.Path" /> no se estableció la propiedad.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a enviar a la cola.</param>
        <param name="label">La etiqueta del mensaje.</param>
        <summary>Envía un objeto a la cola no transaccional que hace referencia esta <see cref="T:System.Messaging.MessageQueue" /> y especifica una etiqueta para el mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para enviar un mensaje que contiene el `obj` parámetro a la cola al que hace referencia el <xref:System.Messaging.MessageQueue>. Con esta sobrecarga, puede especificar la etiqueta de cadena que identifica el mensaje. El objeto que se envía a la cola puede ser un <xref:System.Messaging.Message>, una estructura, un objeto de datos o cualquier objeto administrado. Si se envía un objeto que no sea un <xref:System.Messaging.Message>, el objeto se serializa y se inserta en el cuerpo del mensaje.  
  
 La etiqueta del mensaje es distinta de la etiqueta de la cola de mensajes, pero ambas son dependientes de la aplicación y no tienen significado de herencia para Message Queue Server.  
  
 Si utiliza esta sobrecarga para enviar un mensaje a una cola transaccional, el mensaje se enviará a la cola de mensajes no enviados. Si desea que el mensaje para formar parte de una transacción que contiene otros mensajes, use una sobrecarga que toma un <xref:System.Messaging.MessageQueueTransaction> o <xref:System.Messaging.MessageQueueTransactionType> como un parámetro.  
  
 El <xref:System.Messaging.MessageQueue.Path%2A> propiedad para este <xref:System.Messaging.MessageQueue> se debe especificar la instancia antes de enviar el mensaje. Si no establece la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad antes de llamar a <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, el formateador tiene como valor predeterminado el <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad se aplica a cualquier objeto que no sea un <xref:System.Messaging.Message>. Si se especifica, por ejemplo, una etiqueta o una prioridad utilizando el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembro, estos valores se aplican a cualquier mensaje que contiene un objeto que no es de tipo <xref:System.Messaging.Message> cuando la aplicación envía a la cola. Al enviar un <xref:System.Messaging.Message>, establecen los valores de propiedad para el <xref:System.Messaging.Message> prevalecen sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> y el mensaje <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad tiene prioridad sobre la cola <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="label" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El <see cref="P:System.Messaging.MessageQueue.Path" /> no se estableció la propiedad.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a enviar a la cola.</param>
        <param name="label">La etiqueta del mensaje.</param>
        <param name="transaction">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envía un objeto a la cola transaccional que hace referencia esta <see cref="T:System.Messaging.MessageQueue" /> y especifica una etiqueta para el mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para enviar un mensaje que contiene el `obj` parámetro a la cola transaccional al que hace referencia el <xref:System.Messaging.MessageQueue>, mediante un contexto de transacción interna definido por el `transaction` parámetro. Con esta sobrecarga, puede especificar la etiqueta de cadena que identifica el mensaje. El objeto que se envía a la cola puede ser un <xref:System.Messaging.Message>, una estructura, un objeto de datos o cualquier objeto administrado. Si se envía un objeto que no sea un <xref:System.Messaging.Message>, el objeto se serializa y se inserta en el cuerpo del mensaje.  
  
 La etiqueta del mensaje es distinta de la etiqueta de la cola de mensajes, pero ambas son dependientes de la aplicación y no tienen significado de herencia para Message Queue Server.  
  
 Si utiliza esta sobrecarga para enviar un mensaje a una cola no transaccional, se podría enviar el mensaje a la cola sin producir una excepción.  
  
 Si no establece la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad antes de llamar a <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, el formateador tiene como valor predeterminado el <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad se aplica a cualquier objeto que no sea un <xref:System.Messaging.Message>. Si se especifica, por ejemplo, una etiqueta o una prioridad utilizando el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembro, estos valores se aplican a cualquier mensaje que contiene un objeto que no es de tipo <xref:System.Messaging.Message> cuando la aplicación envía a la cola. Al enviar un <xref:System.Messaging.Message>, establecen los valores de propiedad para el <xref:System.Messaging.Message> prevalecen sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> y el mensaje <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad tiene prioridad sobre la cola <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad  
  
 <xref:System.Messaging.MessageQueueTransaction> Tenga en cuenta el apartamento de subprocesos por lo que si el estado del apartamento es `STA`, no se puede utilizar la transacción en varios subprocesos. Visual Basic establece el estado del subproceso principal para `STA`, por lo que se debe aplicar el <xref:System.MTAThreadAttribute> en el `Main` subrutina. De lo contrario, al enviar un mensaje transaccional mediante otro subproceso se producirá una excepción <xref:System.Messaging.MessageQueueException>. Aplica el <xref:System.MTAThreadAttribute> utilizando el siguiente fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="label" /> es <see langword="null" />.  
  
-o bien- 
El parámetro <paramref name="transaction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El <see cref="P:System.Messaging.MessageQueue.Path" /> no se estableció la propiedad.  
  
-o bien- 
La aplicación Message Queuing indicó un uso incorrecto de la transacción.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a enviar a la cola.</param>
        <param name="label">La etiqueta del mensaje.</param>
        <param name="transactionType">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</param>
        <summary>Envía un objeto a la cola que hace referencia esta <see cref="T:System.Messaging.MessageQueue" /> y especifica una etiqueta para el mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para enviar un mensaje que contiene el `obj` parámetro a la cola al que hace referencia el <xref:System.Messaging.MessageQueue>, mediante un contexto de transacción definido por el `transactionType` parámetro. Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea usar para enviar el mensaje. Especificar `Single` si desea enviar el mensaje como una sola transacción interna. Puede especificar `None` si desea enviar un mensaje transaccional a un subproceso no transaccional.  
  
 El objeto que se envía a la cola puede ser un <xref:System.Messaging.Message> o cualquier objeto administrado. Si se envía un objeto que no sea un <xref:System.Messaging.Message>, el objeto se serializa y se inserta en el cuerpo del mensaje. Con esta sobrecarga, puede especificar la etiqueta de cadena que identifica el mensaje.  
  
 La etiqueta del mensaje es distinta de la etiqueta de la cola de mensajes, pero ambas son dependientes de la aplicación y no tienen significado de herencia para Message Queue Server.  
  
 Si no establece la <xref:System.Messaging.MessageQueue.Formatter%2A> propiedad antes de llamar a <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, el formateador tiene como valor predeterminado el <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad se aplica a cualquier objeto que no sea un <xref:System.Messaging.Message>. Si se especifica, por ejemplo, una etiqueta o una prioridad utilizando el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembro, estos valores se aplican a cualquier mensaje que contiene un objeto que no es de tipo <xref:System.Messaging.Message> cuando la aplicación envía a la cola. Al enviar un <xref:System.Messaging.Message>, establecen los valores de propiedad para el <xref:System.Messaging.Message> prevalecen sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>y el mensaje <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propiedad tiene prioridad sobre la cola <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propiedad.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="label" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">La aplicación Message Queuing indicó un uso incorrecto de la transacción.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">El <see cref="P:System.Messaging.MessageQueue.Path" /> no se estableció la propiedad.  
  
-o bien- 
Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega permisos al conjunto actual. Este controla quién tiene derechos de acceso a las propiedades de la cola y mensajes en la cola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Un <see cref="T:System.Messaging.AccessControlList" /> que contiene uno o más entradas de control de acceso que especifican los administradores de confianza y los permisos se conceden.</param>
        <summary>Asigna derechos de acceso a la cola en función del contenido de una lista de control de acceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para conceder, denegar o revocar los derechos mediante el uso de una colección de entradas de control de acceso para especificar la información de confianza y permisos. Esto sirve, por ejemplo, para conceder permisos a varios usuarios al mismo tiempo.  
  
 El Administrador de confianza que se especifica al construir el `ace` parámetro puede ser un usuario individual, un grupo de usuarios o un equipo. Si el Administrador de confianza es una persona, use el formato `DOMAIN` \\ `user`. Puede especificar "." para el Administrador de confianza indicar el equipo local.  
  
 Los permisos que asigne a través de <xref:System.Messaging.MessageQueue.SetPermissions%2A> agregar derechos a la lista existente. De forma predeterminada, el creador de una cola pública o privada tiene control total y el grupo de dominio todos tiene permiso para obtener propiedades de la cola, obtener permisos y escribir en la cola. Cuando se llama a <xref:System.Messaging.MessageQueue.SetPermissions%2A>, la información de permisos de usuario y se anexa a la parte inferior de la lista existente.  
  
 El sistema examina cada <xref:System.Messaging.AccessControlEntry> en secuencia hasta que se produce uno de los siguientes eventos:  
  
-   Un acceso denegado <xref:System.Messaging.AccessControlEntry> deniega explícitamente cualquiera de los derechos de acceso solicitados a uno de los administradores de confianza que se muestran en el token de acceso del subproceso.  
  
-   Uno o más acceso permiten <xref:System.Messaging.AccessControlEntry> elementos de confianza que figuran en el token de acceso del subproceso explícitamente concede todos los derechos de acceso solicitado.  
  
-   Todos los <xref:System.Messaging.AccessControlEntry> elementos se han comprobado y no hay todavía al menos un derecho de acceso solicitado que no se haya permitido explícitamente, en cuyo caso, implícitamente se deniega el acceso.  
  
 Cuando se construye el `dacl` parámetro, agrega <xref:System.Messaging.AccessControlEntry> instancias a su <xref:System.Messaging.AccessControlList> colección. Cuando se crea cada entrada de control de acceso, puede especificar derechos de acceso genérico o estándar. Los derechos a una cola pueden ser cualquier combinación de las siguientes acciones:  
  
-   Eliminar  
  
-   Seguridad de lectura  
  
-   Seguridad de escritura  
  
-   Sincronizar  
  
-   Modificar propietario  
  
-   Leer  
  
-   Write  
  
-   Ejecutar  
  
-   Obligatorio  
  
-   Todas  
  
-   Ninguna  
  
 Estos derechos son un conjunto de marcadores de bits que se pueden combinar mediante el operador OR bit a bit.  
  
-   Control total.  
  
-   Eliminar mensaje  
  
-   Recibir mensaje  
  
-   Inspeccionar mensaje  
  
-   Recibir mensajes del diario  
  
-   Obtener propiedades de cola  
  
-   Establecer propiedades de cola  
  
-   Obtener permisos  
  
-   Establecimiento de permisos  
  
-   Tomar posesión de la cola  
  
-   Escribir mensaje  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Un <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> que especifica un usuario, un tipo de acceso y un tipo de permiso.</param>
        <summary>Asigna derechos de acceso a la cola en función del contenido de una entrada de control de acceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para conceder, denegar o revocar los derechos mediante el uso de una entrada de control de acceso para especificar el Administrador de confianza y la información de derechos.  
  
 El Administrador de confianza que se especifica al construir el `ace` parámetro puede ser un usuario individual, un grupo de usuarios o un equipo. Si el Administrador de confianza es una persona, use el formato `DOMAIN` \\ `user`. Puede especificar "." para el Administrador de confianza indicar el equipo local.  
  
 Los permisos que asigne a través de <xref:System.Messaging.MessageQueue.SetPermissions%2A> agregar derechos a la lista existente. De forma predeterminada, el creador de una cola pública o privada tiene control total y el grupo de dominio todos tiene permiso para obtener propiedades de la cola, obtener permisos y escribir en la cola. Cuando se llama a <xref:System.Messaging.MessageQueue.SetPermissions%2A>, la información de permisos de usuario y se anexa a la parte inferior de la lista existente.  
  
 El sistema examina cada <xref:System.Messaging.AccessControlEntry> en secuencia hasta que se produce uno de los siguientes eventos:  
  
-   Un acceso denegado <xref:System.Messaging.AccessControlEntry> deniega explícitamente cualquiera de los derechos de acceso solicitados a uno de los administradores de confianza que se muestran en el token de acceso del subproceso.  
  
-   Uno o más acceso permiten <xref:System.Messaging.AccessControlEntry> elementos de confianza que figuran en el token de acceso del subproceso explícitamente concede todos los derechos de acceso solicitado.  
  
-   Todos los <xref:System.Messaging.AccessControlEntry> elementos se han comprobado y no hay todavía al menos un derecho de acceso solicitado que no se haya permitido explícitamente, en cuyo caso, implícitamente se deniega el acceso.  
  
 Los derechos a una cola, que se especifica en el `rights` parámetro al construir su <xref:System.Messaging.MessageQueueAccessControlEntry>, puede ser cualquier combinación de las siguientes acciones:  
  
-   Control total.  
  
-   Eliminar mensaje  
  
-   Recibir mensaje  
  
-   Inspeccionar mensaje  
  
-   Recibir mensajes del diario  
  
-   Obtener propiedades de cola  
  
-   Establecer propiedades de cola  
  
-   Obtener permisos  
  
-   Establecimiento de permisos  
  
-   Tomar posesión de la cola  
  
-   Escribir mensaje  
  
 El `rights` parámetro especificado en el constructor para la `ace` parámetro es un indicador de la <xref:System.Messaging.MessageQueueAccessRights> enumeración. Representa un conjunto de marcas de bits que se pueden combinar mediante el operador bit a bit al construir el `rights` parámetro.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Individuo, grupo o equipo que obtiene derechos adicionales a la cola.</param>
        <param name="rights">Un <see cref="T:System.Messaging.MessageQueueAccessRights" /> que indica el conjunto de derechos a la cola de Message Queue Server asigna a la <paramref name="user" /> pasado.</param>
        <summary>Proporciona un equipo, grupo o usuario los derechos de acceso especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para conceder los derechos especificados a un usuario individual. El usuario puede ser cualquier usuario de confianza válido, que incluye los usuarios individuales, grupos de usuarios o un equipo. Si el usuario es un usuario individual, use el formato `DOMAIN` \\ `user` para el `user` parámetro. Puede especificar "." para el `user` parámetro para indicar el equipo local.  
  
 Los permisos que asigne a través de <xref:System.Messaging.MessageQueue.SetPermissions%2A> agregar derechos a la lista existente. De forma predeterminada, el creador de una cola pública o privada tiene control total y el grupo de dominio todos tiene permiso para obtener propiedades de la cola, obtener permisos y escribir en la cola. Cuando se llama a <xref:System.Messaging.MessageQueue.SetPermissions%2A>, la información de permisos de usuario y se anexa a la parte inferior de la lista existente.  
  
 El sistema examina cada <xref:System.Messaging.AccessControlEntry> en secuencia hasta que se produce uno de los siguientes eventos:  
  
-   Un acceso denegado <xref:System.Messaging.AccessControlEntry> deniega explícitamente cualquiera de los derechos de acceso solicitados a uno de los administradores de confianza que se muestran en el token de acceso del subproceso.  
  
-   Uno o más acceso permiten <xref:System.Messaging.AccessControlEntry> elementos de confianza que figuran en el token de acceso del subproceso explícitamente concede todos los derechos de acceso solicitado.  
  
-   Todos los <xref:System.Messaging.AccessControlEntry> elementos se han comprobado y no hay todavía al menos un derecho de acceso solicitado que no se haya permitido explícitamente, en cuyo caso, implícitamente se deniega el acceso.  
  
 Los derechos a una cola, especificado en el `rights` parámetro, puede ser cualquier combinación de las siguientes acciones:  
  
-   Control total.  
  
-   Eliminar mensaje  
  
-   Recibir mensaje  
  
-   Inspeccionar mensaje  
  
-   Recibir mensajes del diario  
  
-   Obtener propiedades de cola  
  
-   Establecer propiedades de cola  
  
-   Obtener permisos  
  
-   Establecimiento de permisos  
  
-   Tomar posesión de la cola  
  
-   Escribir mensaje  
  
 El <xref:System.Messaging.MessageQueueAccessRights> enumeración representa un conjunto de marcas de bits que se pueden combinar mediante el operador bit a bit o para crear el `rights` parámetro.  
  
 Con esta sobrecarga, solo puede conceder permisos; no se puede revocar o denegar. Debe utilizar una sobrecarga diferente para conceder explícitamente cualquier <xref:System.Messaging.AccessControlEntryType> distinto `Allow`.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="user" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Individuo, grupo o equipo que obtiene derechos adicionales a la cola.</param>
        <param name="rights">Un <see cref="T:System.Messaging.MessageQueueAccessRights" /> que indica el conjunto de derechos a la cola de Message Queue Server asigna a la <paramref name="user" /> pasado.</param>
        <param name="entryType">Un <see cref="T:System.Messaging.AccessControlEntryType" /> que especifica si se va a conceder, denegar o revocar los permisos especificados por el <paramref name="rights" /> parámetro.</param>
        <summary>Proporciona a un equipo, grupo o usuario los derechos de acceso especificada con el tipo de control de acceso especificada (permitir, denegar, revocar o establecer).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para conceder, denegar o revocar los derechos especificados para un usuario individual. El usuario puede ser cualquier usuario de confianza válido, que incluye los usuarios individuales, grupos de usuarios o un equipo. Si el usuario es un usuario individual, use el formato `DOMAIN` \\ `user` para el `user` parámetro. Puede especificar "." para el `user` parámetro para indicar el equipo local.  
  
 Los permisos que asigne a través de <xref:System.Messaging.MessageQueue.SetPermissions%2A> agregar derechos a la lista existente. De forma predeterminada, el creador de una cola pública o privada tiene control total y el grupo de dominio todos tiene permiso para obtener propiedades de la cola, obtener permisos y escribir en la cola. Cuando se llama a <xref:System.Messaging.MessageQueue.SetPermissions%2A>, la información de permisos de usuario y se anexa a la parte inferior de la lista existente.  
  
 El sistema examina cada <xref:System.Messaging.AccessControlEntry> en secuencia hasta que se produce uno de los siguientes eventos:  
  
-   Un acceso denegado <xref:System.Messaging.AccessControlEntry> deniega explícitamente cualquiera de los derechos de acceso solicitados a uno de los administradores de confianza que se muestran en el token de acceso del subproceso.  
  
-   Uno o más acceso permiten <xref:System.Messaging.AccessControlEntry> elementos de confianza que figuran en el token de acceso del subproceso explícitamente concede todos los derechos de acceso solicitado.  
  
-   Todos los <xref:System.Messaging.AccessControlEntry> elementos se han comprobado y no hay todavía al menos un derecho de acceso solicitado que no se haya permitido explícitamente, en cuyo caso, implícitamente se deniega el acceso.  
  
 Los derechos a una cola, especificado en el `rights` parámetro, puede ser cualquier combinación de las siguientes acciones:  
  
-   Control total.  
  
-   Eliminar mensaje  
  
-   Recibir mensaje  
  
-   Inspeccionar mensaje  
  
-   Recibir mensajes del diario  
  
-   Obtener propiedades de cola  
  
-   Establecer propiedades de cola  
  
-   Obtener permisos  
  
-   Establecimiento de permisos  
  
-   Tomar posesión de la cola  
  
-   Escribir mensaje  
  
 El <xref:System.Messaging.MessageQueueAccessRights> enumeración representa un conjunto de marcas de bits que se pueden combinar mediante el operador bit a bit o para crear el `rights` parámetro.  
  
 En la tabla siguiente se muestra si este método está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra el uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto que calcula las referencias de la llamada de controlador de eventos procedente de un <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> o <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> eventos.</summary>
        <value>Un <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, que representa el objeto que calcula las referencias de la llamada de controlador de eventos procedente de un <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> o <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> eventos. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Messaging.MessageQueue.ReceiveCompleted> o <xref:System.Messaging.MessageQueue.PeekCompleted> evento procede de un <xref:System.Messaging.MessageQueue.BeginReceive%2A> o <xref:System.Messaging.MessageQueue.BeginPeek%2A> solicitar, respectivamente, en un subproceso concreto. Normalmente, el <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> se establece cuando su componente relacionado se coloca dentro de un control o formulario, porque estos componentes están enlazados a un subproceso específico.  
  
 Normalmente, el objeto de sincronización calcula las referencias de una llamada al método en un solo subproceso.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la cola acepta solo transacciones.</summary>
        <value><see langword="true" /> Si la cola acepta únicamente mensajes enviados como parte de una transacción; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mensajería transaccional hace referencia a la combinación de varios mensajes relacionados en una única transacción. Envío de mensajes como parte de una transacción asegura que los mensajes se entregan en orden, entrega solo una vez y se recuperan correctamente de su cola de destino.  
  
 Si una cola es transaccional, acepta sólo mensajes que se envían como parte de una transacción. Sin embargo, se puede enviar un mensaje no transaccional o recibido desde una cola de transacciones local sin usar explícitamente transaccionales <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, y <xref:System.Messaging.MessageQueueTransaction.Abort%2A> sintaxis. Si se envía un mensaje no transaccional a una cola transaccional, este componente crea una transacción de mensaje único, excepto en el caso de que hacen referencia a una cola en un equipo remoto mediante un nombre de formato directo. En esta situación, si no especifica un contexto de transacción al enviar un mensaje, no se crea uno automáticamente y se enviará el mensaje a la cola de mensajes no enviados.  
  
 Si envía un mensaje no transaccional a una cola transaccional, no podrá revertir el mensaje si se produce una excepción.  
  
 <xref:System.Messaging.MessageQueueTransaction> Tenga en cuenta el apartamento de subprocesos por lo que si el estado del apartamento es `STA`, no se puede utilizar la transacción en varios subprocesos. Visual Basic establece el estado del subproceso principal para `STA`, por lo que se debe aplicar el <xref:System.MTAThreadAttribute> en el `Main` subrutina. De lo contrario, al enviar un mensaje transaccional mediante otro subproceso se producirá una excepción <xref:System.Messaging.MessageQueueException>. Aplica el <xref:System.MTAThreadAttribute> utilizando el siguiente fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.Transactional%2A> propiedad.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los mensajes recibidos se copian en la cola del diario.</summary>
        <value><see langword="true" /> Si los mensajes recibidos de la cola se copian en la cola del diario; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la aplicación de Message Queue Server crea una nueva cola de aplicación, crea automáticamente una cola del diario asociada en la misma ubicación. La cola del diario se usa para realizar un seguimiento de los mensajes quitados de una cola. Al establecer esta propiedad modifica la cola de Message Queue Server. Por lo tanto, cualquier otro <xref:System.Messaging.MessageQueue> instancias se ven afectadas por el cambio.  
  
 La cola de diario no realiza un seguimiento de mensajes quitados de la cola porque ha expirado su tiempo, ni realiza un seguimiento a los mensajes que se purgan de la cola mediante el uso de un servicio de directorio de Message Queue Server (Store información o Active Directory).  
  
 Las aplicaciones no pueden enviar mensajes a colas del diario; se limitan a acceso de solo lectura de estas colas. Además, Message Queue Server nunca quita mensajes las colas del diario. La aplicación que utiliza la cola debe desactivar estos mensajes al recibirlos o mediante la purga de la cola.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|No|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de una cola de mensajes <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propiedad.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Se produjo un error al obtener acceso a un método de Message Queue Server.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador nativo utilizado para enviar mensajes a la cola de mensajes.</summary>
        <value>Un identificador para el objeto de cola nativo que se utiliza para enviar mensajes a la cola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.MessageQueue.WriteHandle%2A> proporciona un identificador nativo de Windows para el objeto de cola de mensajes que se usa para enviar mensajes a la cola. Si cambia la ruta de acceso de la cola, el identificador se cierra y vuelve a abrir con un nuevo valor.  
  
 En la tabla siguiente se muestra si esta propiedad está disponible en los distintos modos de grupo de trabajo.  
  
|Modo de grupo de trabajo|Disponible|  
|--------------------|---------------|  
|Equipo local|Sí|  
|Equipo local y el nombre de formato directo|Sí|  
|Equipo remoto|No|  
|Equipo remoto y el nombre de formato directo|Sí|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La cola de mensajes no está disponible para escribir en él.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
