<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc03691103b3147a26fd9044a8094613cb513bea" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55401715" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona acceso a las propiedades necesarias para definir un mensaje de Message Queuing.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Messaging.Message> clase busquen o reciban mensajes desde una cola, o tener un control exhaustivo sobre las propiedades de mensaje al enviar un mensaje a una cola.  
  
 <xref:System.Messaging.MessageQueue> usa el <xref:System.Messaging.Message> clase cuando se ejecuta el método Peek o recibe mensajes desde las colas, porque tanto el <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> y <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> métodos crean una nueva instancia de la <xref:System.Messaging.Message> clase y establecer las propiedades de la instancia. El <xref:System.Messaging.Message> aplican propiedades de solo lectura de la clase para recuperar mensajes de una cola, mientras que se aplican las propiedades de lectura/escritura para enviar y recuperar mensajes. Cuando <xref:System.Messaging.MessageQueue> inspecciona o recibe un mensaje de una cola, su <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propiedad determina cuál de las propiedades del mensaje se recuperan.  
  
 El <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Send%2A> método le permite especificar cualquier tipo de objeto para un mensaje que se envía a dicha cola. Puede usar el <xref:System.Messaging.MessageQueue> la instancia <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad para especificar la configuración para los mensajes genéricos enviados a la cola. Los tipos de configuración incluyen el formateador, etiqueta, cifrado y autenticación. También puede especificar valores para adecuado <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> miembros al coordinar su aplicación de mensajería para responder a mensajes de confirmación e informe. Mediante un <xref:System.Messaging.Message> instancia para enviar un mensaje a la cola le ofrece la flexibilidad necesaria para tener acceso y modificar muchas de estas propiedades - para un solo mensaje o en forma de mensaje-mensaje. <xref:System.Messaging.Message> las propiedades tienen prioridad sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Datos del mensaje se almacenan en el <xref:System.Messaging.Message.Body%2A> propiedad y en menor medida, la <xref:System.Messaging.Message.AppSpecific%2A> y <xref:System.Messaging.Message.Extension%2A> propiedades. Cuando se cifra, se serializa o se deserializa, solo el contenido de los datos del mensaje del <xref:System.Messaging.Message.Body%2A> propiedad se ven afectados.  
  
 El contenido de la <xref:System.Messaging.Message.Body%2A> se serializan propiedad cuando se envía el mensaje, mediante la <xref:System.Messaging.Message.Formatter%2A> propiedad especificado. El contenido serializado se encuentra en el <xref:System.Messaging.Message.BodyStream%2A> propiedad. También puede establecer el <xref:System.Messaging.Message.BodyStream%2A> propiedad directamente, por ejemplo, para enviar un archivo como el contenido de datos de un mensaje. Puede cambiar el <xref:System.Messaging.Message.Body%2A> o <xref:System.Messaging.Message.Formatter%2A> propiedades en cualquier momento antes de enviar el mensaje y los datos se serializarán correctamente al llamar a <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Las propiedades definidas por el <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> propiedad se aplica únicamente a mensajes que no son de tipo <xref:System.Messaging.Message>. Si especifica la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propiedad para un <xref:System.Messaging.MessageQueue>, el con el mismo nombre en las propiedades de un <xref:System.Messaging.Message> instancia enviados a dicha cola hacen que se omiten estas propiedades predeterminadas.  
  
 Para obtener una lista de valores de propiedad iniciales de una instancia de <xref:System.Messaging.Message>, consulte el <xref:System.Messaging.Message.%23ctor%2A> constructor.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el formato de un cuerpo de mensaje utilizando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 En el ejemplo de código siguiente se muestra el formato de un cuerpo de mensaje utilizando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.Message" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.Message" /> con un cuerpo de mensaje vacío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear una nueva instancia de la <xref:System.Messaging.Message> clase que tiene un cuerpo vacío.  
  
 Especifique el <xref:System.Messaging.Message.Body%2A> propiedad o el <xref:System.Messaging.Message.BodyStream%2A> propiedad antes de enviar el <xref:System.Messaging.Message> objeto. El <xref:System.Messaging.Message.Body%2A> propiedad puede ser cualquier objeto que se puede serializar, como una cadena de texto, un objeto de estructura, una instancia de clase o un objeto incrustado.  
  
 A menos que escriba el contenido del mensaje directamente a la <xref:System.Messaging.Message.BodyStream%2A> establecer la propiedad, el <xref:System.Messaging.Message.Formatter%2A> propiedad antes de enviar el mensaje. El cuerpo se serializa mediante el <xref:System.Messaging.Message.Formatter%2A> valor de la propiedad en el momento en el <xref:System.Messaging.MessageQueue.Send%2A> se llama al método en el <xref:System.Messaging.MessageQueue> instancia.  
  
 El <xref:System.Messaging.XmlMessageFormatter> correspondencia imprecisa, por lo que no es necesario tener el mismo objeto de tipo en el remitente y receptor cuando se usa este formato. El <xref:System.Messaging.ActiveXMessageFormatter> y <xref:System.Messaging.BinaryMessageFormatter> serializar los datos en una representación binaria. El <xref:System.Messaging.ActiveXMessageFormatter> se usa al enviar o recibir los componentes COM.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Messaging.Message>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider versión 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una cadena vacía ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una cadena vacía ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 El siguiente ejemplo de código envía dos mensajes con prioridades diferentes a la cola y recuperarlas posteriormente.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Objeto que se va a serializar en el cuerpo del mensaje.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Messaging.Message" />, utilizando <see cref="T:System.Messaging.XmlMessageFormatter" /> para serializar el objeto especificado en el cuerpo del mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear una nueva instancia de la <xref:System.Messaging.Message> clase que contiene el <xref:System.Messaging.Message.Body%2A> especificado por el `body` parámetro. El `body` parámetro puede ser cualquier objeto que se puede serializar, como una cadena de texto, un objeto de estructura, una instancia de clase o un objeto incrustado. El cuerpo se serializa mediante el <xref:System.Messaging.XmlMessageFormatter> a menos que cambie la <xref:System.Messaging.Message.Formatter%2A> propiedad antes de la <xref:System.Messaging.Message> se envía. Si cambia el <xref:System.Messaging.Message.Body%2A> o <xref:System.Messaging.Message.Formatter%2A> propiedad en cualquier momento antes de llamar a <xref:System.Messaging.MessageQueue.Send%2A>, se va a serializar el mensaje según el nuevo valor de propiedad.  
  
 El <xref:System.Messaging.XmlMessageFormatter> correspondencia imprecisa, por lo que no es necesario tener el mismo objeto de tipo en el remitente y receptor cuando se usa este formato. El <xref:System.Messaging.ActiveXMessageFormatter> y <xref:System.Messaging.BinaryMessageFormatter> serializar los datos en una representación binaria. El <xref:System.Messaging.ActiveXMessageFormatter> se usa al enviar o recibir los componentes COM.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Messaging.Message>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider versión 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Parámetro `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una cadena vacía ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una cadena vacía ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una nueva cola, envía un mensaje que contiene un pedido a él y, a continuación, lo recupera.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Objeto que se va a serializar en el cuerpo del mensaje.</param>
        <param name="formatter">Un objeto <see cref="T:System.Messaging.IMessageFormatter" /> que especifica el formateador con el que se serializa el cuerpo del mensaje.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Messaging.Message" />, utilizando el formateador especificado para serializar el objeto especificado en el cuerpo del mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear una nueva instancia de la <xref:System.Messaging.Message> clase que contiene el <xref:System.Messaging.Message.Body%2A> especificado por el `body` parámetro y que utiliza cualquier formateador válido para serializar el cuerpo del mensaje. El `body` parámetro es cualquier objeto que se puede serializar, como una cadena de texto, un objeto de estructura, una instancia de clase o un objeto incrustado. Si cambia el <xref:System.Messaging.Message.Body%2A> o <xref:System.Messaging.Message.Formatter%2A> propiedad en cualquier momento antes de llamar a <xref:System.Messaging.MessageQueue.Send%2A>, se va a serializar el mensaje según el nuevo valor de propiedad.  
  
 El <xref:System.Messaging.XmlMessageFormatter> correspondencia imprecisa, por lo que no es necesario tener el mismo objeto de tipo en el remitente y receptor cuando se usa este formato. El <xref:System.Messaging.ActiveXMessageFormatter> y <xref:System.Messaging.BinaryMessageFormatter> serializar los datos en una representación binaria. El <xref:System.Messaging.ActiveXMessageFormatter> se usa al enviar o recibir los componentes COM.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Messaging.Message>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider versión 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Parámetro `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una cadena vacía ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.Formatter%2A>|Parámetro `formatter`.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una cadena vacía ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matriz de bytes de longitud cero|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de mensaje de confirmación que debe devolverse a la aplicación que hace el envío.</summary>
        <value>Uno de los valores de <see cref="T:System.Messaging.AcknowledgeTypes" /> que representa a la vez los tipos de mensajes de confirmación que publica el sistema en la cola de administración y las condiciones según las cuales se devuelven mensajes de confirmación a la aplicación de envío. De manera predeterminada, es <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.AcknowledgeType%2A> propiedad especifica el tipo de mensajes de confirmación solicitados por la aplicación de envío. Establecer el <xref:System.Messaging.Message.AcknowledgeType%2A> propiedad antes de enviar el mensaje para solicitar notificación en determinadas circunstancias - por ejemplo, un mensaje que llega a su cola de destino, un mensaje que se va a recuperar o impide que un mensaje cuando se alcanza o se recupera de un tiempo de espera la cola de destino.  
  
 Message Queue Server devuelve una notificación mediante el envío de mensajes de confirmación a la <xref:System.Messaging.Message.AdministrationQueue%2A> propiedad especificada por el mensaje original. Un mensaje de confirmación <xref:System.Messaging.Message.Acknowledgment%2A> propiedad indica el tipo de confirmación que representa. Por ejemplo, si se ha enviado un mensaje de confirmación porque un mensaje no alcanzó el destino antes de la <xref:System.Messaging.Message.TimeToReachQueue%2A> agotó el intervalo, el <xref:System.Messaging.Message.Acknowledgment%2A> propiedad del mensaje de confirmación contendría el valor `ReachQueueTimeout`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola. En concreto solicita una confirmación positiva cuando el mensaje original llega o se recupera de la cola.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.AcknowledgeType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clasificación de confirmación que representa este mensaje.</summary>
        <value>Uno de los valores de enumeración de <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando reciba un mensaje de una cola de administración, lea el <xref:System.Messaging.Message.Acknowledgment%2A> propiedad para comprobar el estado del mensaje original.  
  
 Cuando se envía un mensaje a su cola de destino, Message Queue Server puede solicitar para registrar un mensaje de confirmación. Este tipo de mensaje puede indicar, por ejemplo, si llegó el mensaje y se recuperó dentro de los tiempos de espera especificados, o puede indicar qué salió mal en el caso de error de entrega. La cola de destino devuelve mensajes de confirmación y envía a la cola de administración especificada en el mensaje original <xref:System.Messaging.Message.AdministrationQueue%2A> propiedad. El <xref:System.Messaging.Message.Id%2A> propiedad de un mensaje de confirmación identifica el mensaje de confirmación, no en el mensaje original. Puede encontrar el identificador del mensaje original en la confirmación <xref:System.Messaging.Message> la instancia <xref:System.Messaging.Message.CorrelationId%2A> propiedad.  
  
 Si este <xref:System.Messaging.Message> instancia representa un mensaje de confirmación, el <xref:System.Messaging.Message.Acknowledgment%2A> propiedad especifica el tipo de confirmación. En caso contrario, el <xref:System.Messaging.Message.Acknowledgment%2A> propiedad contiene el valor `Normal`.  
  
 Use el <xref:System.Messaging.Message.AcknowledgeType%2A> propiedad del mensaje original que se especifican las circunstancias en las que se devolverán las confirmaciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cola utilizada para los mensajes de confirmación generados por Message Queuing.</summary>
        <value>Objeto <see cref="T:System.Messaging.MessageQueue" /> que especifica la cola de administración utilizada para los mensajes de confirmación generados por el sistema. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cola especificada en el <xref:System.Messaging.Message.AdministrationQueue%2A> propiedad puede ser cualquier cola no transaccional. Los mensajes de confirmación enviados a la cola de administración pueden indicar si el mensaje original llegó a su cola de destino y si se quitó de la cola.  
  
 Cuando el <xref:System.Messaging.Message.AcknowledgeType%2A> propiedad tiene cualquier valor distinto `None`, la aplicación de envío debe especificar la cola que se usará como la cola de administración.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola. En concreto solicita una confirmación positiva cuando el mensaje original llega o se recupera de la cola.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.AdministrationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece información adicional específica de la aplicación.</summary>
        <value>Información específica de la aplicación. El valor predeterminado es cero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.AppSpecific%2A> propiedad contiene información específica de la aplicación que se puede utilizar para organizar los diferentes tipos de mensajes. Por ejemplo, se pueden utilizar índices específicos de la aplicación. Es responsabilidad de la aplicación interpretar <xref:System.Messaging.Message.AppSpecific%2A> información de la propiedad.  
  
 Siempre que sea posible, debe incluir los datos del mensaje en el cuerpo del mensaje en lugar de <xref:System.Messaging.Message.AppSpecific%2A> propiedad.  
  
 Al trabajar con colas externas, utilice el <xref:System.Messaging.Message.Extension%2A> propiedad para especificar las propiedades de mensaje que no existen en Message Queue Server. Igual que con el <xref:System.Messaging.Message.AppSpecific%2A> propiedad, es responsabilidad de la aplicación para entender el contenido de la <xref:System.Messaging.Message.Extension%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.AppSpecific" />.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la hora en que llegó el mensaje a la cola de destino.</summary>
        <value><see cref="T:System.DateTime" /> que representa la hora de llegada del mensaje a la cola de destino. La hora se ajusta respecto a la hora GMT para reflejar la hora local del equipo donde reside la cola de destino.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El mensaje <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad indica rápidamente cómo se debe recibir el mensaje desde la cola de destino. El <xref:System.Messaging.Message.TimeToBeReceived%2A> se inicia un temporizador de la propiedad cuando se envía el mensaje, no cuando llega el mensaje en la cola.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.ArrivedTime%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.ArrivedTime" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el identificador del remitente se adjuntará al mensaje.</summary>
        <value><see langword="true" /> si debe adjuntarse <see cref="P:System.Messaging.Message.SenderId" /> al mensaje; en cualquier otro caso, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.SenderId%2A> propiedad es una matriz de bytes que representa el identificador del usuario remitente. El Id. de remitente se establece por Message Queue Server y se usa el Administrador de cola receptor para comprobar si el remitente tiene derechos de acceso a una cola.  
  
 La ausencia del identificador del remitente que es una indicación por parte de la aplicación de envío que Message Queue Server no debe validar el remitente del mensaje ni comprobar el acceso del remitente de derechos a la cola receptora. El <xref:System.Messaging.Message.SenderId%2A> es de confianza solo si se autenticó el mensaje cuando alcanza la cola de destino. Se rechaza el mensaje cuando llega a la cola de destino si la cola acepta sólo mensajes autenticados y, o bien el <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> o <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> propiedad es `false`.  
  
> [!CAUTION]
>  Si se rechaza un mensaje, no envía a la cola (si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> es `true`), o bien se omite. Puede solicitar confirmaciones cuando se produce un error en un mensaje llegar a una cola. En caso contrario, cuando <xref:System.Messaging.Message.UseDeadLetterQueue%2A> es `false` el mensaje podría perderse sin previo aviso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.AttachSenderId%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.AttachSenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se autenticó el mensaje.</summary>
        <value><see langword="true" /> si se solicitó autenticación para el mensaje cuando entró en la cola; en cualquier otro caso, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.Authenticated%2A> propiedad es utilizada únicamente por la aplicación mientras interactúa con el mensaje e intentar determinar si se solicitó autenticación. Si el mensaje está en la cola, se autenticó el mensaje. Por el contrario, si la <xref:System.Messaging.Message.Authenticated%2A> propiedad es `true`, el Administrador de cola receptor autenticó el mensaje cuando recibe ese mensaje.  
  
 No se puede determinar si un mensaje de error de autenticación examinando sus propiedades. Message Queue Server descarta los mensajes que no superan la autenticación antes de entregarlos a la cola. Sin embargo, puede solicitar que se envía un mensaje de confirmación si un error en la entrega impide que el mensaje llegue a la cola.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.Authenticated%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Authenticated" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del proveedor criptográfico que se utiliza para generar la firma digital del mensaje.</summary>
        <value>Nombre del proveedor criptográfico que se utiliza para generar la firma digital del mensaje. El valor predeterminado es Microsoft Base Cryptographic Provider, versión 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, se utiliza el <xref:System.Messaging.Message.AuthenticationProviderName%2A> al trabajar con colas externas. Message Queue Server requiere el nombre del proveedor de autenticación y el tipo de proveedor de autenticación del proveedor criptográfico (proveedor de autenticación) para validar las firmas digitales de los mensajes enviados a una cola externa y mensajes que se pasan al mensaje Puesta en cola desde una cola externa.  
  
 Al enviar un mensaje, establezca siempre la <xref:System.Messaging.Message.AuthenticationProviderName%2A> y <xref:System.Messaging.Message.ConnectorType%2A> propiedades juntas. Cuando se envía el mensaje, Message Queue Server omite el nombre del proveedor de autenticación si no se establece también el tipo de conector.  
  
 El <xref:System.Messaging.Message.AuthenticationProviderName%2A> propiedad no puede ser `null`, pero puede ser una cadena vacía ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se pudo establecer la propiedad <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> se estableció en <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo del proveedor criptográfico que se utiliza para generar la firma digital del mensaje.</summary>
        <value>Uno de los valores de <see cref="T:System.Messaging.CryptographicProviderType" />. De manera predeterminada, es <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, se utiliza el <xref:System.Messaging.Message.AuthenticationProviderType%2A> propiedad al trabajar con colas externas para especificar qué servicios criptográficos el proveedor está asociado con un mensaje. Message Queue Server requiere el nombre del proveedor de autenticación y el tipo de proveedor de autenticación del proveedor criptográfico (proveedor de autenticación) para validar las firmas digitales de los mensajes enviados a una cola externa y mensajes que se pasan al mensaje Puesta en cola desde una cola externa.  
  
 Solo `RsaFull` está pensado para usarse con la mensajería.  
  
 Al enviar un mensaje, establezca siempre la <xref:System.Messaging.Message.AuthenticationProviderType%2A> y <xref:System.Messaging.Message.ConnectorType%2A> propiedades juntas. Cuando se envía el mensaje, Message Queue Server omite el tipo de proveedor de autenticación si no se establece también el tipo de conector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se pudo establecer la propiedad <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contenido del mensaje.</summary>
        <value>Objeto que especifica el contenido del mensaje. El objeto puede ser una cadena, una fecha, una divisa, un número, una matriz de bytes o cualquier objeto administrado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El mensaje <xref:System.Messaging.Message.Body%2A> propiedad normalmente contiene los datos asociados con el mensaje. Aunque también puede enviar los datos específicos de la aplicación en el <xref:System.Messaging.Message.AppSpecific%2A> y <xref:System.Messaging.Message.Extension%2A> propiedades, debe incluir los datos del mensaje en el <xref:System.Messaging.Message.Body%2A> del mensaje siempre que sea posible. Solo el <xref:System.Messaging.Message.Body%2A> se serializa o cifra el contenido de la propiedad.  
  
 El <xref:System.Messaging.Message.Body%2A> propiedad puede contener cualquier objeto cuyo tamaño no superar los 4 MB. Si usas <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> para enviar cualquier objeto que no es de tipo <xref:System.Messaging.Message> a la <xref:System.Messaging.MessageQueue>, ese objeto se ubicará en el <xref:System.Messaging.Message.Body%2A> propiedad de la <xref:System.Messaging.Message> instancia devuelta por <xref:System.Messaging.MessageQueue.Peek%2A> o <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 El argumento de cadena en `MessageQueue.Send("hello.")` es un ejemplo de un objeto genérico.  
  
 El <xref:System.Messaging.Message.BodyType%2A> propiedad indica el tipo de información que se almacena en el cuerpo del mensaje. Message Queue Server utiliza esta información para identificar el tipo de la <xref:System.Messaging.Message.Body%2A> contenido de la propiedad.  
  
 Especifique el <xref:System.Messaging.Message.Body%2A> propiedad o el <xref:System.Messaging.Message.BodyStream%2A> propiedad antes de enviar el <xref:System.Messaging.Message> objeto. El <xref:System.Messaging.Message.Body%2A> propiedad puede ser cualquier objeto serializable, como una cadena de texto, objeto de estructura, instancia de clase o un objeto incrustado.  
  
 A menos que escriba el contenido del mensaje directamente a la <xref:System.Messaging.Message.BodyStream%2A> establecer la propiedad, el <xref:System.Messaging.Message.Formatter%2A> propiedad antes de enviar el mensaje. Cuando el <xref:System.Messaging.MessageQueue.Send%2A> se llama al método en el <xref:System.Messaging.MessageQueue> instancia, el cuerpo se serializa mediante el formateador en el <xref:System.Messaging.Message.Formatter%2A> propiedad. Si envía el mensaje sin especificar un valor para el <xref:System.Messaging.Message.Formatter%2A> propiedad, el formateador predeterminado es <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Al intentar establecer el cuerpo de un mensaje a <xref:System.Decimal.MaxValue> hará que un <xref:System.OverflowException> cuando el `Send` método de la <xref:System.Messaging.MessageQueue> se llama a la clase y el <xref:System.Messaging.ActiveXMessageFormatter> se utiliza.  
  
   
  
## Examples  
 El siguiente ejemplo de código envía dos mensajes con prioridades diferentes a la cola y recuperarlas posteriormente.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Messaging.Message.Formatter" /> es <see langword="null" />.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información del cuerpo del mensaje.</summary>
        <value><see cref="T:System.IO.Stream" /> que contiene la información serializada incluida en el cuerpo (<see cref="P:System.Messaging.Message.Body" />) del mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cuerpo de un mensaje puede constar de cualquier tipo de información: por ejemplo, una cadena, una fecha, moneda, un número, una matriz de bytes o cualquier objeto administrado. Esta información se serializa en un <xref:System.IO.Stream> pasarse a la cola.  
  
 Especifique el <xref:System.Messaging.Message.Body%2A> propiedad o el <xref:System.Messaging.Message.BodyStream%2A> propiedad antes de enviar el <xref:System.Messaging.Message> objeto. Si establece la <xref:System.Messaging.Message.Body%2A> propiedad, el contenido se serializa en el <xref:System.Messaging.Message.BodyStream%2A> propiedad. Sin embargo, puede escribir el <xref:System.Messaging.Message.BodyStream%2A> propiedad directamente. Esto es útil, por ejemplo, cuando desea abrir una conexión a un archivo y transmitir su contenido como el cuerpo del mensaje.  
  
 A menos que escriba el contenido del mensaje directamente a la <xref:System.Messaging.Message.BodyStream%2A> establecer la propiedad, el <xref:System.Messaging.Message.Formatter%2A> propiedad antes de enviar el mensaje. Cuando el <xref:System.Messaging.MessageQueue.Send%2A> se llama al método en el <xref:System.Messaging.MessageQueue> instancia, el cuerpo se serializa mediante el formateador en el <xref:System.Messaging.Message.Formatter%2A> propiedad. Si envía el mensaje sin especificar un valor para el <xref:System.Messaging.Message.Formatter%2A> propiedad, el formateador predeterminado es <xref:System.Messaging.XmlMessageFormatter>.  
  
 Si establece la <xref:System.Messaging.Message.UseEncryption%2A> propiedad `true` para el cuerpo de este mensaje, se cifrará el mensaje al enviarlo, no al establecer el <xref:System.Messaging.Message.Body%2A> propiedad. Por lo tanto, el <xref:System.Messaging.Message.BodyStream%2A> propiedad nunca se cifra.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de datos que contiene el cuerpo del mensaje.</summary>
        <value>El tipo auténtico del cuerpo del mensaje, como por ejemplo una cadena, una fecha, una divisa o un número.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queue Server reconoce el contenido del cuerpo como un objeto o como una secuencia serializada. El <xref:System.Messaging.Message.BodyType%2A> propiedad indica el tipo del objeto dentro de la <xref:System.Messaging.Message.Body%2A> propiedad del mensaje.  
  
 El <xref:System.Messaging.XmlMessageFormatter> realiza el enlace entre tipos nativos y el objeto de un cuerpo del mensaje. Si usas el <xref:System.Messaging.XmlMessageFormatter>, el formateador establece la <xref:System.Messaging.Message.BodyType%2A> propiedad automáticamente.  
  
 Otros formateadores pueden proporcionar funcionalidad de enlace también, como se muestra en el siguiente código de C#.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.BodyType%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene y establece un valor que indica que la aplicación de envío estableció algunas propiedades de mensajes, normalmente establecidas por Message Queuing.</summary>
        <value>Identificador <see cref="T:System.Guid" /> definido por la aplicación y utilizado en combinación con las aplicaciones conectoras o el cifrado de mensajes. Este identificador <see cref="T:System.Guid" /> permite a una aplicación receptora interpretar las propiedades de los mensajes establecidas por la aplicación de envío, aunque normalmente definidas por Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queue Server requiere el <xref:System.Messaging.Message.ConnectorType%2A> propiedad se establece cada vez que una aplicación establece una propiedad de mensaje que se establece normalmente mediante Message Queue Server. Una aplicación normalmente utiliza un <xref:System.Messaging.Message.ConnectorType%2A> en los dos casos siguientes:  
  
-   Cada vez que una aplicación de conexión pasa un mensaje. El <xref:System.Messaging.Message.ConnectorType%2A> informa a las aplicaciones emisoras y receptoras cómo interpretar las propiedades de seguridad y confirmación del mensaje.  
  
-   Cada vez que la aplicación de envío, en lugar de Message Queue Server, cifra un mensaje. El <xref:System.Messaging.Message.ConnectorType%2A> indica a Message Queue Server para usar el <xref:System.Messaging.Message.DestinationSymmetricKey%2A> valor de propiedad para descifrar el mensaje.  
  
 Debe establecer el <xref:System.Messaging.Message.ConnectorType%2A> propiedad si establece cualquiera de las propiedades siguientes (en caso contrario, la cola pasa por alto estas propiedades cuando se envía el mensaje):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.ConnectorType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el identificador de mensaje que utilizan los mensajes de confirmación, informe y respuesta para hacer referencia al mensaje original.</summary>
        <value>Identificador de mensaje especificado por la propiedad <see cref="P:System.Messaging.Message.Id" /> del mensaje original. Message Queuing utiliza el identificador de correlación cuando genera un mensaje de confirmación o informe, y lo utiliza una aplicación cuando genera un mensaje de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando Message Queue Server, se genera un mensaje de confirmación o informe, utiliza la propiedad de identificador de correlación para especificar el identificador de mensaje del mensaje original. De esta forma, el identificador de correlación une el mensaje de confirmación o informe al mensaje original.  
  
 La aplicación de envío puede hacer coincidir la confirmación o informe con el mensaje original utilizando el <xref:System.Messaging.Message.CorrelationId%2A> propiedad para identificar el mensaje original <xref:System.Messaging.Message.Id%2A> propiedad.  
  
 Las aplicaciones conectoras también deben establecer el <xref:System.Messaging.Message.CorrelationId%2A> propiedad de los mensajes de confirmación e informe en el identificador del mensaje original.  
  
 Cuando la aplicación envía un mensaje de respuesta a la aplicación de envío, puede establecer el <xref:System.Messaging.Message.CorrelationId%2A> propiedad del mensaje de respuesta en el identificador del mensaje original. La aplicación de envío puede hacer coincidir el mensaje de respuesta al mensaje que se envió.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola. En concreto solicita una confirmación positiva cuando el mensaje original llega o se recupera de la cola.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.CorrelationId" />.</exception>
        <exception cref="T:System.ArgumentException">El valor de <see cref="P:System.Messaging.Message.CorrelationId" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cola de destino deseada para un mensaje.</summary>
        <value>Valor <see cref="T:System.Messaging.MessageQueue" /> que especifica la cola de destino deseada para el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.DestinationQueue%2A> propiedad normalmente se utiliza para determinar el destino original de un mensaje que llega a una cola de diario o enviados. Por lo general, no es necesario examinar esta propiedad, ya que suelen recuperar el mensaje desde su cola de destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.DestinationQueue%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.DestinationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la clave simétrica utilizada para cifrar los mensajes cifrados por la aplicación o los enviados a colas externas.</summary>
        <value>Matriz de bytes que especifica la clave simétrica de destino utilizada para cifrar el mensaje. El valor predeterminado es una matriz de longitud cero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos escenarios requieren que se use la <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propiedad. La primera es cuando su aplicación, en lugar de Message Queue Server, cifra un mensaje. La segunda es cuando se envía un mensaje cifrado a un sistema de puesta en cola que no sean de Message Queue Server.  
  
 Antes de establecer esta propiedad, debe cifrar la clave simétrica con la clave pública del Administrador de cola receptor. Cuando se envía un mensaje cifrado a la aplicación, el Administrador de la cola receptora utiliza la clave simétrica para descifrar el mensaje antes de enviarlo a su cola de destino.  
  
 Si envía un mensaje a una cola externa, el mensaje se recibe por primera vez por la aplicación del conector adecuado, que reenvía el mensaje cifrado con la clave simétrica adjunta a la aplicación receptora. A continuación, es responsabilidad de la aplicación receptora para descifrar el mensaje mediante la clave simétrica.  
  
 Al establecer el <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propiedad, también debe establecer el <xref:System.Messaging.Message.ConnectorType%2A> propiedad. Cuando se envía el mensaje, Message Queue Server omite la <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propiedad si el <xref:System.Messaging.Message.ConnectorType%2A> propiedad no se establece también.  
  
 El <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propiedad tiene un tamaño máximo de la matriz de 256 bytes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />.</exception>
        <exception cref="T:System.ArgumentException">El valor de <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la firma digital que Message Queuing utiliza para autenticar el mensaje.</summary>
        <value>Matriz de bytes que especifica la firma digital de Message Queuing 1.0 utilizada para autenticar el mensaje. El valor predeterminado es una matriz de longitud cero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queue Server utiliza la firma digital al autenticar mensajes enviados por Message Queue Server versión 1.0. En la mayoría de los casos, Message Queue Server genera y establece el <xref:System.Messaging.Message.DigitalSignature%2A> propiedad cuando la aplicación de envío solicita autenticación. La aplicación receptora utiliza esta propiedad para recuperar la firma digital adjuntada al mensaje.  
  
 Sólo se puede utilizar el <xref:System.Messaging.Message.DigitalSignature%2A> propiedad cuando se ejecuta Message Queue Server versión 2.0. La aplicación de envío debe especificar las firmas de la versión 1.0 de Message Queue Server cuando se solicita la autenticación. Si la aplicación de envío envía una firma de la versión 2.0 de Message Queue Server, esta propiedad contiene un búfer de cuatro bytes, cada con un cero.  
  
 El <xref:System.Messaging.Message.DigitalSignature%2A> propiedad, junto con el <xref:System.Messaging.Message.SenderCertificate%2A> propiedad, también se utiliza en las aplicaciones conectoras cuando se envía un mensaje. En este escenario, el conector aplicación - en lugar de Message Queue Server - genera la firma digital, que basa en el certificado del usuario que envía el mensaje.  
  
 El <xref:System.Messaging.Message.DigitalSignature%2A> propiedad tiene un tamaño máximo de la matriz de 256 bytes.  
  
 Al establecer el <xref:System.Messaging.Message.DigitalSignature%2A> propiedad, también debe establecer el <xref:System.Messaging.Message.ConnectorType%2A> propiedad. Cuando se envía un mensaje, Message Queue Server omite la <xref:System.Messaging.Message.DigitalSignature%2A> propiedad si el <xref:System.Messaging.Message.ConnectorType%2A> propiedad no se establece también.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.DigitalSignature" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Messaging.Message.DigitalSignature" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el algoritmo de cifrado que se utiliza para cifrar el cuerpo de un mensaje privado.</summary>
        <value>Uno de los valores de enumeración de <see cref="T:System.Messaging.EncryptionAlgorithm" />. De manera predeterminada, es <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un mensaje es privado (cifrada), se cifra antes de que se envía y se descifran cuando se reciben. El <xref:System.Messaging.Message.EncryptionAlgorithm%2A> propiedad especifica el algoritmo utilizado para cifrar el cuerpo del mensaje de un mensaje privado.  
  
 Una cola puede requerir entrantes se cifran los mensajes. Si una aplicación envía un mensaje de (no privados) sin cifrar a una cola que sólo acepta mensajes privados, o si envía un mensaje privado a una cola que acepta sólo los mensajes no privados, la cola rechaza el mensaje. La aplicación de envío puede solicitar que se devuelva un mensaje de confirmación negativa en este caso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece información adicional, definida por la aplicación y asociada al mensaje.</summary>
        <value>Matriz de bytes que proporciona información definida por la aplicación y asociada al mensaje. El valor predeterminado es una matriz de longitud cero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.Extension%2A> propiedad proporciona información definida por la aplicación, como un objeto binario grande, que está asociado con el mensaje. Es responsabilidad de la aplicación receptora interpretar el contenido de la <xref:System.Messaging.Message.Extension%2A> propiedad.  
  
 Siempre que sea posible, debe incluir los datos del mensaje en el <xref:System.Messaging.Message.Body%2A> propiedad del mensaje en lugar de <xref:System.Messaging.Message.Extension%2A> propiedad.  
  
 Al trabajar con colas externas, utilice el <xref:System.Messaging.Message.Extension%2A> propiedad para especificar las propiedades de mensaje que no existen en Message Queue Server.  
  
 Existe una cola externa en un sistema de puesta en cola que no sean de Microsoft Message Queue Server. Message Queue Server se comunica con este tipo de colas a través de una aplicación de conexión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Extension" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Messaging.Message.Extension" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el formateador empleado para serializar o deserializar un objeto en el cuerpo de un mensaje.</summary>
        <value>Objeto <see cref="T:System.Messaging.IMessageFormatter" /> que produce una secuencia que se escribirá o leerá desde el cuerpo del mensaje. De manera predeterminada, es <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Messaging.Message.Formatter%2A> propiedad al leer y escribir un mensaje. Cuando se envía un mensaje a la cola, el formateador serializa los <xref:System.Messaging.Message.Body%2A> propiedad en una secuencia que se puede enviar a la cola de mensajes. Al leer desde una cola, el formateador deserializa los datos del mensaje en el <xref:System.Messaging.Message.Body%2A> propiedad.  
  
 A menos que escriba el contenido del mensaje directamente a la <xref:System.Messaging.Message.BodyStream%2A> establecer la propiedad, el <xref:System.Messaging.Message.Formatter%2A> propiedad antes de enviar el mensaje. Cuando el <xref:System.Messaging.MessageQueue.Send%2A> se llama al método en el <xref:System.Messaging.MessageQueue> instancia, el cuerpo se serializa mediante el formateador en el <xref:System.Messaging.Message.Formatter%2A> propiedad. Si envía el mensaje sin especificar un valor para el <xref:System.Messaging.Message.Formatter%2A> propiedad, el formateador predeterminado es <xref:System.Messaging.XmlMessageFormatter>.  
  
 El <xref:System.Messaging.XmlMessageFormatter> correspondencia imprecisa, por lo que no es necesario tener el mismo objeto de tipo en el remitente y receptor cuando se usa este formato. El <xref:System.Messaging.ActiveXMessageFormatter> y <xref:System.Messaging.BinaryMessageFormatter> serializar los datos en una representación binaria. El <xref:System.Messaging.ActiveXMessageFormatter> se usa al enviar o recibir los componentes COM.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el formato de un cuerpo de mensaje utilizando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 En el ejemplo de código siguiente se muestra el formato de un cuerpo de mensaje utilizando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Messaging.Message.Formatter" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el algoritmo de hash que Message Queuing utiliza al autenticar mensajes o al crear una firma digital para un mensaje.</summary>
        <value>Uno de los valores de enumeración de <see cref="T:System.Messaging.HashAlgorithm" />. En Windows XP, el valor predeterminado es <see langword="SHA" />. De lo contrario, el valor predeterminado es <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el equipo de origen, Message Queue Server utiliza el algoritmo hash al crear una firma digital para un mensaje. El Administrador de cola de destino, a continuación, usa el mismo algoritmo hash para autenticar el mensaje cuando se recibe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.HashAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador del mensaje.</summary>
        <value>Identificador único del mensaje, generado por Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queue Server genera un identificador de mensaje cuando se envía el mensaje. El identificador se compone de 20 bytes e incluye dos elementos: la máquina <xref:System.Guid> del equipo de envío y un identificador único para el mensaje en el equipo. La combinación de los dos elementos produce un identificador de mensaje que es único en la red.  
  
 Mensaje message Queuing genera identificadores para todos los mensajes - incluidos los mensajes de confirmación e informe. Por lo general se envía un mensaje de confirmación por Message Queue Server en respuesta a la entrega o falta de un mensaje original enviado. Puede encontrar el <xref:System.Messaging.Message.Id%2A> valor de propiedad del mensaje original en el <xref:System.Messaging.Message.CorrelationId%2A> propiedad de un mensaje de confirmación.  
  
 También puede usar el <xref:System.Messaging.Message.Id%2A> propiedad al enviar un mensaje de respuesta a una cola de respuesta. Para incluir el identificador del mensaje original en un mensaje de respuesta, establezca la <xref:System.Messaging.Message.CorrelationId%2A> propiedad del mensaje de respuesta a la <xref:System.Messaging.Message.Id%2A> propiedad del mensaje original. La aplicación que lee el mensaje de respuesta, a continuación, puede usar el identificador de correlación del mensaje de respuesta para identificar el mensaje original.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía y recibe un mensaje que contiene un pedido hacia y desde una cola. En concreto solicita una confirmación positiva cuando el mensaje original llega o se recupera de la cola.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Id" />.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que no existe un tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> y <xref:System.Messaging.Message.TimeToReachQueue%2A> requieren un valor que especifica un tiempo de espera. En el primer caso, el tiempo de espera es el tiempo máximo permitido para que un mensaje se recibe de la cola. Por último, el tiempo de espera es el tiempo permitido para que un mensaje alcance la cola. En ambos casos, puede especificar el tiempo de espera como un número de segundos o usar <xref:System.Messaging.Message.InfiniteTimeout> para indicar que no existe ningún tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Messaging.Message.InfiniteTimeout> campo.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el mensaje era el primer mensaje enviado en una transacción.</summary>
        <value><see langword="true" /> si el mensaje fue el primer mensaje enviado en una transacción; en cualquier otro caso, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicaciones receptoras utilizan el <xref:System.Messaging.Message.IsFirstInTransaction%2A> propiedad para comprobar que un mensaje fue el primer mensaje enviado en una sola transacción a una única cola.  
  
 Esta propiedad está disponible solo con la versión de Message Queue Server 2.0 y versiones posteriores.  
  
 Para comprobar los límites de transacción, puede usar el <xref:System.Messaging.Message.IsFirstInTransaction%2A> propiedad junto con otras dos propiedades: <xref:System.Messaging.Message.IsLastInTransaction%2A> y <xref:System.Messaging.Message.TransactionId%2A>. Utilice el primero para comprobar si un mensaje fue el último mensaje enviado en la transacción y la segunda para recuperar el identificador de la transacción.  
  
 Si sólo se envía un mensaje en una transacción, el <xref:System.Messaging.Message.IsFirstInTransaction%2A> y <xref:System.Messaging.Message.IsLastInTransaction%2A> propiedades se establecen en `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.IsFirstInTransaction%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.IsFirstInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el mensaje era el último mensaje enviado en una transacción.</summary>
        <value><see langword="true" /> si el mensaje fue el último mensaje enviado en una transacción; en cualquier otro caso, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicaciones receptoras utilizan el <xref:System.Messaging.Message.IsLastInTransaction%2A> propiedad para comprobar que un mensaje fue el último mensaje enviado en una sola transacción a una única cola.  
  
 Esta propiedad está disponible solo con la versión de Message Queue Server 2.0 y versiones posteriores.  
  
 Para comprobar los límites de transacción, puede usar el <xref:System.Messaging.Message.IsLastInTransaction%2A> propiedad junto con otras dos propiedades: <xref:System.Messaging.Message.IsFirstInTransaction%2A> y <xref:System.Messaging.Message.TransactionId%2A>. Utilice el primero para comprobar si un mensaje fue el primer mensaje enviado en la transacción y la segunda para recuperar el identificador de la transacción.  
  
 Si sólo se envía un mensaje en una transacción, el <xref:System.Messaging.Message.IsFirstInTransaction%2A> y <xref:System.Messaging.Message.IsLastInTransaction%2A> propiedades se establecen en `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.IsLastInTransaction%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.IsLastInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una cadena Unicode definida por la aplicación que describe el mensaje.</summary>
        <value>Etiqueta del mensaje. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una etiqueta de mensaje puede usarse para varias cosas. Una etiqueta de mensaje puede utilizarse, por ejemplo, para fines de presentación, o para procesar mensajes de forma selectiva de acuerdo con el valor de la etiqueta. La etiqueta no debe ser único en los mensajes.  
  
 La cola de mensajes y las etiquetas de mensaje representan un valor definido por la aplicación que puede ayudar a identificar la cola o el mensaje de manera legible para el usuario. Es responsabilidad de la aplicación interpretar el contenido de la etiqueta, que no tiene ningún significado intrínseco para la aplicación de Message Queue Server.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.Label%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Label" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introducido en MSMQ 3.0. Obtiene el identificador de búsqueda del mensaje.</summary>
        <value>El identificador de búsqueda del mensaje, generado por Message Queuing y único para la cola donde reside el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad proporciona acceso de solo lectura al identificador de búsqueda de un mensaje. El identificador de búsqueda, introducido en MSMQ 3.0, es un identificador de 64 bits que es generado por Message Queuing y se asigna a cada mensaje cuando el mensaje se coloca en la cola. El identificador de búsqueda no es el mismo que el identificador de mensaje que se genera cuando se envía el mensaje.  
  
 Message Queue Server genera un identificador de búsqueda para todos los mensajes que se colocan en cualquier cola, incluidas generados por la aplicación de destino, administración y las colas de informes, así como diario generados por el sistema, mensajes no enviados, conectores y las colas de salida. En otras palabras, esto incluye ambos mensajes enviados por las aplicaciones emisoras y Message Queue Server. El identificador de búsqueda es único para la cola y no tiene ningún significado fuera de la cola.  
  
 Si se envía un mensaje a varias colas de destino, o si se almacena una copia de un mensaje en un equipo o diario de cola, cada copia del mensaje tendrá su propio identificador de búsqueda cuando se coloca en la cola correspondiente.  
  
 El <xref:System.Messaging.Message.LookupId%2A> propiedad solo puede leerse en mensajes recuperados de una cola.  
  
 Un identificador de búsqueda se utiliza para leer un mensaje concreto en la cola. Una vez que se conoce el identificador de búsqueda de un mensaje, la aplicación receptora puede llamar a la <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> función para ir directamente a ese mensaje y ojear o recuperarlo de la cola, a diferencia de los cursores que se debe empezar al principio de la cola y Desplácese hacia el final de la cola,  
  
 Obtener los identificadores de búsqueda de los mensajes en la cola es responsabilidad de la aplicación. Una posible manera de obtener los identificadores de búsqueda es crear un desencadenador para la cola de destino que invoca un componente que se almacena en caché los identificadores de cada mensaje que se colocan en la cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 no está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.LookupId" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de mensaje: <see langword="Normal" />, <see langword="Acknowledgment" /> o <see langword="Report" />.</summary>
        <value>Uno de los valores de <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queue Server, normalmente establece esta propiedad cuando envía el mensaje. Un mensaje de Message Queuing puede ser de uno de los siguientes tipos:  
  
-   `Normal`, que es un mensaje habitual enviado desde una aplicación a una cola o un mensaje de respuesta devuelto a la aplicación emisora.  
  
-   `Acknowledgement`, que genera Message Queue Server siempre que la aplicación de envío lo solicita. Por ejemplo, Message Queuing puede generar mensajes positivos o negativos para indicar que se entregó o leyó el mensaje original. Message Queuing devuelve el mensaje de confirmación correspondiente a la cola de administración especificada por la aplicación de envío.  
  
-   `Report`, que Message Queuing siempre que se define una cola de informes en el Administrador de cola de origen. Cuando el seguimiento está habilitado, Message Queuing envía un mensaje de informe a su cola de informes cada vez que el mensaje original entra o sale de un servidor de Message Queuing.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.MessageType%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.MessageType" />.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la prioridad del mensaje, que determina en qué punto de la cola se ubica el mensaje.</summary>
        <value>Uno de los valores <see cref="T:System.Messaging.MessagePriority" />, que representan los niveles de prioridad de mensajes no transaccionales. De manera predeterminada, es <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.Priority%2A> propiedad afecta a cómo Message Queue Server controla el mensaje mientras está en tránsito y una vez que llegue a su destino. Se da preferencia a los mensajes de alta prioridad durante el enrutamiento de mensajes, los cuales se insertan al principio de la cola de destino. Los mensajes que tienen la misma prioridad se colocan en la cola según su hora de llegada.  
  
 Puede establecer una prioridad significativa sólo para mensajes no transaccionales. Message Queue Server establece automáticamente la prioridad de mensajes transaccionales a `Lowest`, lo que hace que la prioridad del mensaje transaccional se pasará por alto.  
  
   
  
## Examples  
 El siguiente ejemplo de código envía dos mensajes con prioridades diferentes a la cola y recuperarlas posteriormente.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Priority" />.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se garantiza la entrega del mensaje en caso de haber errores en el equipo o problemas en la red.</summary>
        <value><see langword="true" /> si se garantiza la entrega del mensaje guardándolo en disco mientras se encuentra en tránsito; <see langword="false" /> si no se garantiza. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.Recoverable%2A> propiedad indica si se garantiza la entrega de un mensaje - incluso si un equipo se bloquea mientras el mensaje está en tránsito hacia la cola de destino.  
  
 Si se garantiza la entrega de un mensaje, el mensaje se almacena localmente en cada paso del recorrido, hasta que el mensaje se reenvía correctamente al equipo siguiente. Establecer el <xref:System.Messaging.Message.Recoverable%2A> propiedad `true` podría afectar al rendimiento.  
  
 Si el mensaje es transaccional, Message Queue Server trata automáticamente el mensaje como recuperable, independientemente del valor de la <xref:System.Messaging.Message.Recoverable%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.Recoverable%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.Recoverable" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cola que recibe los mensajes de respuesta generados por la aplicación.</summary>
        <value>Objeto <see cref="T:System.Messaging.MessageQueue" /> al cual se devuelven los mensajes de respuesta generados por la aplicación. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.ResponseQueue%2A> propiedad identifica la cola que recibe mensajes de respuesta generados por la aplicación que la aplicación receptora devuelve a la aplicación emisora. La aplicación de envío especifica las colas de respuesta cuando la aplicación envía sus mensajes. Cualquier cola disponible puede especificarse como cola de respuesta.  
  
 Los mensajes devueltos a la cola de respuesta son específicos de la aplicación. La aplicación debe definir el contenido de los mensajes, así como la acción a realizar cuando se recibe un mensaje.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.ResponseQueue%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.ResponseQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contexto de seguridad para un mensaje.</summary>
        <value>Objeto <see cref="T:System.Messaging.SecurityContext" /> que contiene el contexto de seguridad para un mensaje, si la propiedad se ha establecido anteriormente; de lo contrario NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el certificado de seguridad que se utilizará para autenticar mensajes.</summary>
        <value>Matriz de valores de byte que representa un certificado de seguridad, que Message Queuing utiliza para comprobar el remitente de un mensaje. El valor predeterminado es una matriz de longitud cero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La aplicación receptora utiliza la <xref:System.Messaging.Message.SenderCertificate%2A> propiedad cuando el mensaje incluye un certificado de seguridad externas.  
  
 Message Queue Server puede autenticar un mensaje mediante un certificado de seguridad internos o externos. Message Queue Server proporciona certificados internos, que se usan para comprobar la integridad del mensaje. Una entidad de certificación proporciona un certificado externo, que puede tener acceso a través de la <xref:System.Messaging.Message.SenderCertificate%2A> propiedad del mensaje. Además de permitir que Message Queue Server autenticar el mensaje, un certificado externo permite que la aplicación receptora comprobar el remitente. Un certificado interno no tiene ningún valor utilizable para una aplicación receptora.  
  
 Un certificado externo debe registrarse con el servicio de directorio del sistema de Message Queue Server. Un certificado externo contiene información acerca de la entidad de certificación, el usuario del certificado, el período de validez del certificado, la clave pública del usuario del certificado y la firma de la entidad de certificación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.SenderCertificate" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador del usuario remitente.</summary>
        <value>Matriz de valores de byte que identifica al remitente. El administrador de colas receptor utiliza el identificador cuando autentica el mensaje, para comprobar el remitente del mensaje y sus derechos de acceso a la cola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Messaging.Message.AttachSenderId%2A> propiedad es `false`, el identificador del remitente especificado en el <xref:System.Messaging.Message.SenderId%2A> propiedad no está asociada al mensaje al enviarlo. Esto indica a Message Queue Server que no se debe validar el remitente cuando envía el mensaje a la cola de destino. Si el <xref:System.Messaging.Message.AttachSenderId%2A> propiedad es `true`, el <xref:System.Messaging.Message.SenderId%2A> valor de propiedad es de confianza solo si se autenticó el mensaje. Use la <xref:System.Messaging.Message.Authenticated%2A> propiedad junto con la <xref:System.Messaging.Message.SenderId%2A> propiedad para comprobar los derechos de acceso del remitente.  
  
 Una aplicación de conexión es una aplicación que utiliza un servidor de conector para proporcionar comunicación entre Message Queue Server y otros sistemas de puesta en cola. Message Queue Server requiere que las aplicaciones de conector para proporcionar la identificación del remitente. Debe establecer el <xref:System.Messaging.Message.ConnectorType%2A> propiedad al enviar un mensaje a través de una aplicación de conexión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.SenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la versión de Message Queuing que se utilizó para enviar el mensaje.</summary>
        <value>Versión de Message Queuing que se utilizó para enviar el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.SenderVersion%2A> es importante para determinadas características de la propiedad. Por ejemplo, se admite el procesamiento de transacciones sólo por Message Queue Server 2.0 y versiones posteriores, y las firmas digitales se utilizan para autenticar mensajes enviados por MSMQ 1.0.  
  
 Los conjuntos de administrador de cola de envío el <xref:System.Messaging.Message.SenderVersion%2A> propiedad cuando se envía el mensaje.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.SenderVersion%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.SenderVersion" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la fecha y hora del equipo de envío en las que el administrador de colas de origen envió el mensaje.</summary>
        <value>Valor <see cref="T:System.DateTime" /> que representa la hora a la que se envió el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.SentTime%2A> propiedad se ajusta a la hora local del equipo en el que la instancia de la <xref:System.Messaging.Message> se creó la clase. Esta zona horaria puede ser diferente de las colas de origen y destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.SentTime%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.SentTime" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el equipo donde se originó el mensaje.</summary>
        <value>Nombre del equipo desde el que se envió el mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El formato de la <xref:System.Messaging.Message.SourceMachine%2A> propiedad no incluye dos barras diagonales (\\\\). Por ejemplo, `myServer` es válido <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.SourceMachine%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.SourceMachine" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">No se ha podido obtener acceso a la información de equipo o al servicio de directorio.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el límite máximo de tiempo para recibir el mensaje de la cola de destino.</summary>
        <value>Tiempo total requerido para recibir un mensaje enviado desde la cola de destino. De manera predeterminada, es <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad especifica el tiempo total para un mensaje enviado se recibe de la cola de destino. El límite de tiempo incluye el tiempo empleado en llegar a la cola de destino y el tiempo de espera en la cola antes de que se reciba el mensaje.  
  
> [!CAUTION]
>  Al utilizar equipos cliente dependientes, asegúrese de que el reloj del equipo cliente está sincronizado con el reloj del servidor que ejecuta Message Queue Server. En caso contrario, podría producir un comportamiento impredecible al enviar un mensaje cuyo <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad no es <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Si el intervalo especificado por el <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad caduca antes de que el mensaje se quita de la cola, Message Queue Server descarta el mensaje en una de dos maneras. Si la propiedad <xref:System.Messaging.Message.UseDeadLetterQueue%2A> del mensaje es `true`, éste se envía a la cola de mensajes no enviados. Si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> es `false`, se omite el mensaje.  
  
 Puede establecer el mensaje <xref:System.Messaging.Message.AcknowledgeType%2A> realizar copias de propiedad para solicitar que Message Queue Server envía un mensaje de confirmación negativa a la aplicación de envío si no se recupera el mensaje antes de que expire el temporizador.  
  
 Si el valor especificado por el <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad es menor que el valor especificado por el <xref:System.Messaging.Message.TimeToReachQueue%2A> propiedad <xref:System.Messaging.Message.TimeToBeReceived%2A> tiene prioridad.  
  
 Cuando se envían varios mensajes en una sola transacción, Message Queue Server utiliza el <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad del primer mensaje.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para <see cref="P:System.Messaging.Message.TimeToBeReceived" /> no es válido.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el límite máximo de tiempo para que el mensaje alcance la cola.</summary>
        <value>Límite de tiempo para que el mensaje alcance la cola de destino, desde el momento en que se envía. De manera predeterminada, es <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el intervalo especificado por el <xref:System.Messaging.Message.TimeToReachQueue%2A> propiedad caduca antes de que el mensaje alcance su destino, Message Queue Server descarta el mensaje en una de dos maneras. Si la propiedad <xref:System.Messaging.Message.UseDeadLetterQueue%2A> del mensaje es `true`, éste se envía a la cola de mensajes no enviados. Si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> es `false`, se omite el mensaje  
  
 Puede establecer del mensaje <xref:System.Messaging.Message.AcknowledgeType%2A> realizar copias de propiedad para solicitar que Message Queue Server envía un mensaje de confirmación negativa a la aplicación de envío si no recibe el mensaje antes de que expire el temporizador.  
  
 Si el <xref:System.Messaging.Message.TimeToReachQueue%2A> propiedad está establecida en 0 segundos, Message Queue Server intenta una vez enviar el mensaje a su destino - si la cola está esperando el mensaje. Si la cola es local, el mensaje siempre llega a él.  
  
 Si el valor especificado por el <xref:System.Messaging.Message.TimeToReachQueue%2A> propiedad es mayor que el valor especificado por el <xref:System.Messaging.Message.TimeToBeReceived%2A> propiedad <xref:System.Messaging.Message.TimeToBeReceived%2A> tiene prioridad.  
  
 Cuando se envían varios mensajes en una sola transacción, Message Queue Server utiliza el <xref:System.Messaging.Message.TimeToReachQueue%2A> propiedad del primer mensaje.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.TimeToReachQueue%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.TimeToReachQueue" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para <see cref="P:System.Messaging.Message.TimeToReachQueue" /> no es válido. Podría representar un número negativo.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de la transacción a la que pertenecía el mensaje.</summary>
        <value>Identificador de la transacción asociada al mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicaciones receptoras utilizan el <xref:System.Messaging.Message.TransactionId%2A> propiedad para comprobar que se envió un mensaje como parte de una transacción específica. El identificador de transacción contiene el identificador del equipo emisor (los primeros 16 bits) seguido por un número de secuencia de transacción de 4 bytes.  
  
 Esta propiedad está disponible sólo para la versión de Message Queue Server 2.0 y versiones posteriores.  
  
 Identificadores de transacción no se garantiza que sea único, porque los números de secuencia de transacción no son persistentes y comenzar de nuevo en 2 <sup>20</sup>. Message Queue Server sólo garantiza que las transacciones posteriores tendrán números de secuencia de transacción diferentes.  
  
 Puede usar el <xref:System.Messaging.Message.TransactionId%2A> propiedad junto con la <xref:System.Messaging.Message.IsFirstInTransaction%2A> y <xref:System.Messaging.Message.IsLastInTransaction%2A> propiedades para comprobar los límites de transacción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.TransactionId%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.TransactionId" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cola de estado de transacción del equipo de origen.</summary>
        <value>Cola de estado de transacción del equipo de origen, que se utiliza para devolver mensajes de confirmación a la aplicación de envío. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.TransactionStatusQueue%2A> propiedad identifica la cola transaccional en el equipo de origen que recibe las confirmaciones de lectura de las aplicaciones conectoras. Message Queue Server establece la propiedad y las aplicaciones conectoras utilizan la propiedad al recuperar mensajes transaccionales enviados a colas externas.  
  
 Existe una cola externa en un sistema de puesta en cola que no sean de Microsoft Message Queue Server. Message Queue Server se comunica con este tipo de colas a través de una aplicación de conexión.  
  
 La aplicación de conexión puede utilizar la cola de estado de transacción para enviar mensajes de confirmación a la aplicación de envío. La cola de estado de transacción debería recibir estas confirmaciones, incluso si la aplicación emisora no solicita otro tipo de confirmaciones.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de un mensaje <xref:System.Messaging.Message.TransactionStatusQueue%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El mensaje no se ha enviado. Esta propiedad solo puede leerse en mensajes recuperados de una cola.  
  
O bien 
La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.TransactionStatusQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se autenticó (o debe autenticarse) el mensaje antes de enviarse.</summary>
        <value><see langword="true" /> si la aplicación de envío solicitó autenticación del mensaje; <see langword="false" /> en cualquier otro caso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.UseAuthentication%2A> propiedad especifica si se debe autenticar el mensaje. Si la aplicación de envío solicita autenticación, Message Queue Server crea una firma digital y lo usa para firmar el mensaje al enviarlo y autenticar el mensaje cuando se recibe.  
  
 Si <xref:System.Messaging.Message.UseAuthentication%2A> es `false` y se envía un mensaje a una cola que acepta sólo mensajes autenticados, se rechazará el mensaje cuando llega a la cola.  
  
 No se puede determinar si un mensaje de error de autenticación examinando sus propiedades. Message Queue Server descarta esos mensajes antes de entregarlos a la cola. Sin embargo, puede solicitar que se envía un mensaje de confirmación si un error en la entrega impide que un mensaje llegue a la cola.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.UseAuthentication" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si debe enviarse una copia del mensaje que no pudo entregarse a la cola de mensajes no enviados.</summary>
        <value><see langword="true" /> si el error en la entrega del mensaje debe dar como resultado el envío de una copia del mensaje a una cola de mensajes no enviados; <see langword="false" /> en cualquier otro caso. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.UseJournalQueue%2A> y <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propiedades especifican cómo Message Queue Server realiza un seguimiento de un mensaje. Si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> es `true`, error de entrega (de un mensaje no transaccional), hace que el mensaje se envíe a la cola de mensajes no enviados no transaccional en el equipo que no se pudo entregar el mensaje. Error en la entrega puede deberse a que expire, por ejemplo el temporizador del mensaje.  
  
 En el caso de error en la entrega de un mensaje transaccional, Message Queue Server envía el mensaje a la cola transaccional de mensajes no enviados en la máquina de origen en todos los casos negativos dudosas.  
  
 Al almacenar los mensajes en una cola, debe borrar la cola periódicamente para quitar los mensajes que ya no son necesarios. Mensajes almacenados en las colas de mensajes no enviados se incluyen en la cuota de tamaño para el equipo donde reside la cola. La cuota del equipo se establece mediante el administrador y se refiere al tamaño asignado para almacenar mensajes en todo el equipo, no solo en una sola cola.  
  
 No se crea una cola del diario o enviados. Estas son las colas de sistema que genera Message Queue Server.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el mensaje debe ser privado.</summary>
        <value><see langword="true" /> para requerir que Message Queuing cifre el mensaje; <see langword="false" /> en cualquier otro caso. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un mensaje es privado, su cuerpo se cifra antes de se envían y se descifran cuando se recibe. Para enviar un mensaje privado, debe especificar la aplicación de envío que se utiliza el cifrado y, opcionalmente, el algoritmo de cifrado.  
  
 Al enviar mensajes privados, la aplicación no es necesario realizar el cifrado del mensaje. Message Queue Server puede cifrar el cuerpo del mensaje si la aplicación envía mensajes dentro de una empresa de Microsoft Windows 2000, que tiene acceso al servicio de directorio. Cuando se reciben mensajes privados, el Administrador de cola receptor siempre descifra el cuerpo del mensaje.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.UseEncryption%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.UseEncryption" />.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si debe conservarse una copia del mensaje en un diario del equipo de origen.</summary>
        <value><see langword="true" /> para requerir que se conserve una copia del mensaje en el diario del equipo de origen después de transmitirse con éxito (desde este último al servidor siguiente); <see langword="false" /> en cualquier otro caso. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.UseJournalQueue%2A> y <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propiedades especifican cómo Message Queue Server realiza un seguimiento de un mensaje. Si <xref:System.Messaging.Message.UseJournalQueue%2A> es `true`, se conserva una copia en el diario del equipo en el equipo de origen de cada paso que se transmite un mensaje.  
  
 El mensaje enviado sólo se copia en la cola del diario si la cola de destino está en un equipo remoto. Si el destino está en el equipo local, el mensaje se envía directamente a la cola; No hay ningún paso intermedio para requerir registro en diario.  
  
 Al almacenar los mensajes en una cola del diario, borrar la cola periódicamente para quitar los mensajes que ya no son necesarios. Mensajes almacenados en el recuento de las colas de diario para la cuota para el equipo donde reside la cola. (La cuota del equipo se establece mediante el administrador).  
  
 No se crea una cola del diario o enviados. Estas son las colas de sistema que genera Message Queue Server.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.UseJournalQueue%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.UseJournalQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe seguir la traza de un mensaje mientras se traslada a su cola de destino.</summary>
        <value><see langword="true" /> si cada uno de los pasos intermedios realizados por el mensaje original en su tránsito hacia la cola de destino genera un informe para enviarlo a la cola de informes del sistema; <see langword="false" /> en cualquier otro caso. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Messaging.Message.UseTracing%2A> propiedad especifica si se debe realizar un seguimiento de la ruta de un mensaje mientras se traslada a su cola de destino. Si `true`, se envía un mensaje de informe (generado por Message Queuing) a una cola de informes cada vez que el mensaje pasa a través de un servidor de enrutamiento de Message Queue Server. La cola de informes se especifica mediante el Administrador de cola de origen. Las colas de informes no se limitan a los mensajes de informe generados por Message Queue Server; los mensajes generados por la aplicación también pueden enviarse a colas de informes.  
  
 Uso del seguimiento implica la configuración de Active Directory y especificar una cola de informes para la empresa de Message Queue Server. El administrador configura estas opciones.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el valor de un mensaje <xref:System.Messaging.Message.UseTracing%2A> propiedad.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La cola de mensajes se filtra para omitir la propiedad <see cref="P:System.Messaging.Message.UseTracing" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>