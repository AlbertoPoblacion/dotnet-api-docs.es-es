<Type Name="BlockingCollection&lt;T&gt;" FullName="System.Collections.Concurrent.BlockingCollection&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f6c936056ed99a71dfdd7760349d29df25a72390" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52229934" /></Metadata><TypeSignature Language="C#" Value="public class BlockingCollection&lt;T&gt; : IDisposable, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BlockingCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.BlockingCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class BlockingCollection(Of T)&#xA;Implements ICollection, IDisposable, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BlockingCollection : IDisposable, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BlockingCollection&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IDisposable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}, Type = {m_collection}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo de los elementos de la colección.</typeparam>
    <summary>Proporciona capacidades de bloqueo y establecimiento de límites en colecciones seguras para subprocesos que implementan <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Concurrent.BlockingCollection%601> es una clase de colección segura para subprocesos que ofrece lo siguiente:  
  
-   Una implementación del patrón de productor/consumidor; <xref:System.Collections.Concurrent.BlockingCollection%601> es un contenedor para el <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfaz.  
  
-   Simultánea adición y eliminación de elementos de varios subprocesos con el <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> y <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> métodos.  
  
-   Una colección limitada que bloquea <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> y <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operaciones cuando la colección está vacía o completa.  
  
-   Cancelación de <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> o <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> las operaciones mediante un <xref:System.Threading.CancellationToken> objeto en el <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> o <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> método.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz. Además, tenga en cuenta que el <xref:System.Collections.Concurrent.BlockingCollection%601.Dispose> método no es seguro para subprocesos. Todos los demás miembros públicos y protegidos de <xref:System.Collections.Concurrent.BlockingCollection%601> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.  
  
 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> Representa una colección que permite la adición segura para subprocesos y eliminación de datos. <xref:System.Collections.Concurrent.BlockingCollection%601> se utiliza como un contenedor para un <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> de instancia y permite intentos de eliminación de la colección bloquear hasta que los datos están disponibles para quitarse. De forma similar, puede crear un <xref:System.Collections.Concurrent.BlockingCollection%601> para aplicar un límite superior en el número de elementos de datos permitidos en el <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>; a continuación, pueden bloquear los intentos de adición a la colección hasta que haya espacio disponible para almacenar los elementos agregados. De esta manera, <xref:System.Collections.Concurrent.BlockingCollection%601> es similar a una estructura datos bloqueo tradicional de cola, salvo que el mecanismo de almacenamiento de datos subyacente se abstrae como un <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601> admite límites y bloqueos. Los límites implican que puede establecer la capacidad máxima de la colección. Es importante en determinados escenarios de límite, ya que permite controlar el tamaño máximo de la colección en memoria, y evita que los subprocesos de producción vayan demasiado por delante de los subprocesos de consumo. Varios subprocesos o tareas pueden agregar elementos a la colección al mismo tiempo, y si la colección alcanza su capacidad máxima especificada, los subprocesos de producción se bloquearán hasta que se quita un elemento. Varios consumidores pueden quitar elementos de forma simultánea y, si la colección está vacía, los subprocesos de consumo se bloquearán hasta que un productor agregue un elemento. Un subproceso productor puede llamar a la <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> método para indicar que no se agregará ningún elemento más. Los consumidores supervisan la propiedad <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> para saber cuándo está vacía la colección y no se agregarán más elementos.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> y <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> las operaciones se realizan normalmente en un bucle. Puede cancelar un bucle al pasar un <xref:System.Threading.CancellationToken> de objeto para el <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> o <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> método y, a continuación, comprobar el valor del token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propiedad en cada iteración. Si el valor es `true`, depende de usted responde a la solicitud de cancelación limpiando algún recurso y saliendo del bucle.  
  
 Cuando creas un <xref:System.Collections.Concurrent.BlockingCollection%601> objeto, puede especificar no solo la capacidad limitada, sino también el tipo de colección para usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 No modifique directamente la colección subyacente. Use <xref:System.Collections.Concurrent.BlockingCollection%601> métodos para agregar o quitar elementos. La <xref:System.Collections.Concurrent.BlockingCollection%601> objeto puede dañarse si cambia la colección subyacente directamente.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo agregar y tomar elementos simultáneamente desde una colección de bloqueo:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#1)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>El método Dispose no es seguro para subprocesos. Todos los demás miembros públicos y protegidos de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
    <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
    <related type="Article" href="https://msdn.microsoft.com/library/4c2492de-3876-4873-b5a1-000bb404d770">Cómo: Agregar límite y bloqueo de funcionalidad a una clase de colección</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sin límite superior.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sin límite superior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección subyacente predeterminada es un <xref:System.Collections.Concurrent.ConcurrentQueue%601> object, que proporciona en primer lugar en el comportamiento primero en salir (FIFO).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Colección que se va a usar como almacén de datos subyacente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sin límite superior y usando el objeto <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> proporcionado como almacén de datos subyacente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collection" /> es null.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; boundedCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="boundedCapacity">Tamaño límite de la colección.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> con el límite superior especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección subyacente predeterminada es un <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="boundedCapacity" /> no es un valor positivo.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection, int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection, int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T), boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection, int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; * int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; (collection, boundedCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collection">Colección que se va a usar como almacén de datos subyacente.</param>
        <param name="boundedCapacity">Tamaño límite de la colección.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> con el límite superior especificado y usando el objeto <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> proporcionado como almacén de datos subyacente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collection" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="boundedCapacity" /> no es un valor positivo.</exception>
        <exception cref="T:System.ArgumentException">El <paramref name="collection" /> proporcionado contiene más valores de los permitidos por <paramref name="boundedCapacity" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega el elemento a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; unit" Usage="blockingCollection.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a agregar a la colección. El valor puede ser una referencia nula.</param>
        <summary>Agrega el elemento a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se especificó una capacidad limitada cuando esta instancia de <xref:System.Collections.Concurrent.BlockingCollection%601> estaba inicializado, una llamada a Add puede bloquear hasta que haya espacio disponible para almacenar el elemento proporcionado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
O bien 
La colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T * System.Threading.CancellationToken -&gt; unit" Usage="blockingCollection.Add (item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a agregar a la colección. El valor puede ser una referencia nula.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Agrega el elemento a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se especificó una capacidad limitada cuando esta instancia de <xref:System.Collections.Concurrent.BlockingCollection%601> se inicializó, una llamada a <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> pueden bloquear hasta que haya espacio disponible para almacenar el elemento proporcionado.  
  
 Este método puede devolver al principio con un <xref:System.OperationCanceledException> si el `cancellationToken` se cancela.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ha sido eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que posee <paramref name="cancellationToken" /> ha sido eliminado.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
O bien 
La colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se va a agregar a una de las colecciones.</param>
        <summary>Agrega el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección de la matriz <paramref name="collections" /> donde se agregó el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se especificó una capacidad limitada cuando todos los <xref:System.Collections.Concurrent.BlockingCollection%601> se inicializaron las instancias, una llamada a AddToAny puede bloquear hasta que haya espacio disponible en una de las colecciones para almacenar el elemento proporcionado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se va a agregar a una de las colecciones.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Agrega el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección de la matriz <paramref name="collections" /> donde se agregó el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se especificó una capacidad limitada cuando todos los <xref:System.Collections.Concurrent.BlockingCollection%601> se inicializaron las instancias, una llamada a AddToAny puede bloquear hasta que haya espacio disponible en una de las colecciones para almacenar el elemento proporcionado. Este método puede devolver antes de que el elemento se agrega a cualquier colección si el `cancellationToken` se cancela antes de que hay espacio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una colección subyacente no aceptó el elemento.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o se ha eliminado la <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="BoundedCapacity">
      <MemberSignature Language="C#" Value="public int BoundedCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BoundedCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BoundedCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BoundedCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BoundedCapacity : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.BoundedCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la capacidad límite de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>La capacidad límite de esta colección o int.MaxValue si no se proporciona ningún límite.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CompleteAdding">
      <MemberSignature Language="C#" Value="public void CompleteAdding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompleteAdding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompleteAdding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompleteAdding();" />
      <MemberSignature Language="F#" Value="member this.CompleteAdding : unit -&gt; unit" Usage="blockingCollection.CompleteAdding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> para que no acepten nuevas adiciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de una colección se ha marcado como completa para agregar, no se permite agregar a la colección y no espera al intentar quitar de la colección cuando la colección está vacía.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="blockingCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. La matriz debe tener una indización de base cero.</param>
        <param name="index">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia todos los elementos de la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 CopyTo representa una instantánea de la colección en un momento concreto en el tiempo. Si otros subprocesos están agregando o quitando elementos mientras CopyTo se está ejecutando, los elementos devueltos por CopyTo no podrían representar el estado de la colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="array" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="index" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="index" /> es mayor o igual que la longitud de <paramref name="array" />.  
  
La matriz de destino es demasiado pequeña para contener todos los elementos BlockingCcollection.  
  
El rango de la matriz no coincide.  
  
El tipo de la matriz es incompatible con el tipo de los elementos BlockingCollection.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos contenidos en <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>Número de elementos contenidos en <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un método en BlockingCollection se está ejecutando mientras la propiedad Count se está obteniendo acceso a, el valor devuelto es aproximado. Recuento puede reflejar un número que sea mayor o menor que el número real de elementos de BlockingCollection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="blockingCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Dispose` método no es seguro para subprocesos.  
  
 Llame a `Dispose` cuando haya terminado de usar <xref:System.Collections.Concurrent.BlockingCollection%601>. El método `Dispose` deja el <xref:System.Collections.Concurrent.BlockingCollection%601> en un estado no utilizable. Después de llamar a `Dispose`, debe liberar todas las referencias a la <xref:System.Collections.Concurrent.BlockingCollection%601> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Collections.Concurrent.BlockingCollection%601> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a `Dispose` antes de liberar la última referencia al objeto <xref:System.Collections.Concurrent.BlockingCollection%601>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Collections.Concurrent.BlockingCollection%601> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="blockingCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Si se desecha de forma explícita (true) o a través de un finalizador (false).</param>
        <summary>Libera los recursos utilizados por la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConsumingEnumerable">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerator`1" /> en uso para los elementos de la colección.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsumingEnumerable () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable();" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : unit -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerator`1" /> en uso para los elementos de la colección.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> que quita y devuelve elementos de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> método:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#4)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : System.Threading.CancellationToken -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__2))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__68))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> en uso para los elementos de la colección.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> que quita y devuelve elementos de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite que el código de cliente quitar elementos de la colección mediante el uso de un bucle foreach (para cada en Visual Basic), o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> o una consulta PLINQ. El enumerador seguirá proporcionando elementos (si existe alguno) hasta <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> devuelve true y si <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> es false el bucle se bloquea hasta que haya disponible un artículo o hasta que el <xref:System.Threading.CancellationToken> se ha cancelado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ha sido eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ha sido eliminado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsAddingCompleted">
      <MemberSignature Language="C#" Value="public bool IsAddingCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAddingCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAddingCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAddingCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAddingCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsAddingCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completa para las funciones de agregación.</summary>
        <value>Si esta colección se ha marcado como completa para las funciones de agregación.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completa para las funciones de agregación y está vacía.</summary>
        <value>Si esta colección se ha marcado como completa para las funciones de agregación y está vacía.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona una interfaz <see cref="T:System.Collections.Generic.IEnumerator`1" /> para los elementos de la colección.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> para los elementos de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A>, <xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType> devuelve un enumerador estándar que no modifica la colección subyacente. Si otros subprocesos están agregando o quitando elementos simultáneamente cuando se llama a GetEnumerator, los elementos devueltos por el enumerador no podrían representar el estado actual de la colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. La matriz debe tener una indización de base cero.</param>
        <param name="index">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia todos los elementos de la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="array" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="index" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="index" /> es mayor o igual que la longitud de <paramref name="array" />, la matriz es multidimensional o el parámetro de tipo para la colección no se puede convertir automáticamente al tipo de la matriz de destino.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado.</summary>
        <value>siempre devuelve false.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />. Esta propiedad no es compatible.</summary>
        <value>devuelve NULL.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">La propiedad SyncRoot no es compatible.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona una interfaz <see cref="T:System.Collections.IEnumerator" /> para los elementos de la colección.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> para los elementos de la colección.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Take">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take" />
      <MemberSignature Language="VB.NET" Value="Public Function Take () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take();" />
      <MemberSignature Language="F#" Value="member this.Take : unit -&gt; 'T" Usage="blockingCollection.Take " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Elemento que se ha quitado de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> pueden bloquear hasta que esté disponible para quitar un elemento.  
  
 El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <xref:System.Collections.Concurrent.BlockingCollection%601>. Cuando crea un objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, puede especificar el tipo de colección que se va a usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">La colección subyacente se modificó fuera de esta estancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />, o la <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vacía y la colección se ha marcado como completa para agregar.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Take : System.Threading.CancellationToken -&gt; 'T" Usage="blockingCollection.Take cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Objeto que se puede usar para cancelar la operación en la que se toma un elemento.</param>
        <summary>Quita un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Elemento que se ha quitado de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> pueden bloquear hasta que está disponible para quitar un elemento o se cancela el token.  
  
 El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <xref:System.Collections.Concurrent.BlockingCollection%601>. Cuando crea un objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, puede especificar el tipo de colección que se va a usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ha sido eliminado o <see cref="T:System.Threading.CancellationTokenSource" /> que creó el token se canceló.</exception>
        <exception cref="T:System.InvalidOperationException">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o BlockingCollection se ha marcado como completa para las funciones de agregación o bien <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> está vacía.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Toma un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se ha quitado de una de las colecciones.</param>
        <summary>Toma un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección de la matriz <paramref name="collections" /> de la que se quitó el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a un método TakeFromAny puede bloquear hasta que esté disponible para quitar un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo o se ha llamado a <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> en la colección.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se ha quitado de una de las colecciones.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Toma un elemento de cualquiera de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas observando el token de cancelación indicado.</summary>
        <returns>Índice de la colección de la matriz <paramref name="collections" /> de la que se quitó el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a un método TakeFromAny puede bloquear hasta que esté disponible para quitar un elemento. El método devolverá al principio con una excepción OperationCanceledException si se cancela el token.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo o se ha llamado a <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> en la colección.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="blockingCollection.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia los elementos de la instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> en una nueva matriz.</summary>
        <returns>Matriz que contiene copias de los elementos de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se quitan los elementos copiados de la colección.  
  
 Si un método en BlockingCollection se ejecuta mientras se ejecuta el método ToArray, el valor devuelto es aproximado. ToArray puede incluir elementos que ya se han quitado o excluir elementos que ya se han insertado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T -&gt; bool" Usage="blockingCollection.TryAdd item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a agregar a la colección.</param>
        <summary>Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>true si se pudo agregar <paramref name="item" />; en caso contrario, false. Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la colección es una colección limitada y está lleno, este método devuelve inmediatamente false sin agregar el elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
O bien 
La colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a agregar a la colección.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del periodo de tiempo indicado.</summary>
        <returns>Es true si se pudo agregar <paramref name="item" /> a la colección en el tiempo especificado; en caso contrario, es false. Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
O bien 
La colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * TimeSpan -&gt; bool" Usage="blockingCollection.TryAdd (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a agregar a la colección.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Es true si se pudo agregar <paramref name="item" /> a la colección en el intervalo de tiempo especificado; en caso contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
O bien 
La colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que se va a agregar a la colección.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Intenta agregar el elemento especificado a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del periodo de tiempo indicado, observando un token de cancelación.</summary>
        <returns>Es true si se pudo agregar <paramref name="item" /> a la colección en el tiempo especificado; en caso contrario, es false. Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha eliminado o el <see cref="T:System.Threading.CancellationTokenSource" /> subyacente se ha eliminado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha marcado como completo en lo relativo a las adiciones.  
  
O bien 
La colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se va a agregar a una de las colecciones.</param>
        <summary>Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se va a agregar a una de las colecciones.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
O bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se va a agregar a una de las colecciones.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Intenta agregar el elemento especificado a cualquiera de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> especificadas observando el token de cancelación indicado.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede devolver al principio si se cancela el cancellationToken antes de que había espacio para la operación de adición.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o de <see cref="T:System.Threading.CancellationTokenSource" /> que crearon <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.  
  
O bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una colección subyacente no aceptó el elemento.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se va a agregar a una de las colecciones.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una colección subyacente no aceptó el elemento.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
O bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTake">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo, se muestra cómo utilizar el método <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A>.  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#2)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  -&gt; bool" Usage="blockingCollection.TryTake item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que va a quitarse de la colección.</param>
        <summary>Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns><see langword="true" /> si se pudo quitar un elemento; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la colección está vacía, este método inmediatamente devuelve false.  
  
 El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <xref:System.Collections.Concurrent.BlockingCollection%601>. Cuando crea un objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, puede especificar el tipo de colección que se va a usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">La colección subyacente se modificó fuera de esta instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que va a quitarse de la colección.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del periodo de tiempo especificado.</summary>
        <returns>Es <see langword="true" /> si se pudo quitar un elemento de la colección en el tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <xref:System.Collections.Concurrent.BlockingCollection%601>. Cuando creas un <xref:System.Collections.Concurrent.BlockingCollection%601>, puede especificar el tipo de colección que se va a usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.InvalidOperationException">La colección subyacente se modificó fuera de esta instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * TimeSpan -&gt; bool" Usage="blockingCollection.TryTake (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que va a quitarse de la colección.</param>
        <param name="timeout">Objeto que representa el número de milisegundos de espera u objeto que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del periodo de tiempo especificado.</summary>
        <returns>Es <see langword="true" /> si se pudo quitar un elemento de la colección en el tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <xref:System.Collections.Concurrent.BlockingCollection%601>. Cuando crea un objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, puede especificar el tipo de colección que se va a usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> es un número negativo distinto de-1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">La colección subyacente se modificó fuera de esta instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Elemento que va a quitarse de la colección.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Intenta quitar un elemento de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dentro del periodo de tiempo especificado, observando un token de cancelación.</summary>
        <returns>Es <see langword="true" /> si se pudo quitar un elemento de la colección en el tiempo especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <xref:System.Collections.Concurrent.BlockingCollection%601>. Cuando crea un objeto <xref:System.Collections.Concurrent.BlockingCollection%601>, puede especificar el tipo de colección que se va a usar. Por ejemplo, puede especificar un objeto <xref:System.Collections.Concurrent.ConcurrentQueue%601> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <xref:System.Collections.Concurrent.ConcurrentStack%601> para un comportamiento LIFO (último en entrar, primero en salir). Puede usar cualquier clase de colección que implemente la interfaz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. El tipo de colección predeterminado para <xref:System.Collections.Concurrent.BlockingCollection%601> es <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">El <see cref="T:System.Threading.CancellationToken" /> se ha cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">La <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> se ha eliminado o el <see cref="T:System.Threading.CancellationTokenSource" /> subyacente se ha eliminado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.InvalidOperationException">La colección subyacente se modificó fuera de esta instancia de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se ha quitado de una de las colecciones.</param>
        <summary>Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a TryTakeFromAny puede bloquear hasta que esté disponible para quitar un elemento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType> método:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#3)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se ha quitado de una de las colecciones.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a TryTakeFromAny puede bloquear hasta que esté disponible para quitar un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
O bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se ha quitado de una de las colecciones.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a TryTakeFromAny puede bloquear hasta que esté disponible para quitar un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.  
  
O bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matriz de colecciones.</param>
        <param name="item">Elemento que se ha quitado de una de las colecciones.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">Token de cancelación que se va a observar.</param>
        <summary>Intenta quitar un elemento de cualquiera de las instancias especificadas de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Índice de la colección en la matriz <paramref name="collections" /> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a TryTakeFromAny puede bloquear hasta que esté disponible para quitar un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si se cancela <see cref="T:System.Threading.CancellationToken" />.</exception>
        <exception cref="T:System.InvalidOperationException">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="collections" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito. 
O bien 
El recuento de <paramref name="collections" /> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="collections" /> es una matriz de longitud 0 o contiene un elemento nulo.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado al menos una de las instancias de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Colecciones seguras para subprocesos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Información general sobre BlockingCollection</related>
      </Docs>
    </Member>
  </Members>
</Type>