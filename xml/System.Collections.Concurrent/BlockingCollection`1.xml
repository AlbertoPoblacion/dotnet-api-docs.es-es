<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BlockingCollection`1.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50df771ecf34f5bb842d4f014e7a03bea934d6866.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0df771ecf34f5bb842d4f014e7a03bea934d6866</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The type of elements in the collection.</source>
          <target state="translated">Tipo de los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Provides blocking and bounding capabilities for thread-safe collections that implement <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph>.</source>
          <target state="translated">Proporciona capacidades de bloqueo y establecimiento de límites en colecciones seguras para subprocesos que implementan <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a thread-safe collection class that provides the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es una clase de colección segura para subprocesos que proporciona lo siguiente:</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>An implementation of the producer/consumer pattern; <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a wrapper for the <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Una implementación del patrón de productores y consumidores; <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es un contenedor para el <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Concurrent addition and removal of items from multiple threads with the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and  <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> methods.</source>
          <target state="translated">Simultánea adición y eliminación de elementos de varios subprocesos con el <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>A bounded collection that blocks <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations when the collection is full or empty.</source>
          <target state="translated">Una colección limitada que bloquea <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operaciones cuando la colección está vacía o completa.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Cancellation of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations by using a <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> object in the  <ph id="ph4">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method.</source>
          <target state="translated">Cancelación de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> las operaciones mediante una <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> objeto en el <ph id="ph4">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> o <ph id="ph5">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Este tipo implementa la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Para deshacerse del tipo directamente, llame a su <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> método en un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Para deshacerse de él indirectamente, use una construcción de lenguaje como <ph id="ph1">`using`</ph> (en C#) o <ph id="ph2">`Using`</ph> (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> tema de la interfaz.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Also, note that the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Dispose&gt;</ph> method is not thread-safe.</source>
          <target state="translated">Además, tenga en cuenta que el <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Dispose&gt;</ph> método no es seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>All other public and protected members of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Todos los demás miembros públicos y protegidos de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> son seguras para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> represents a collection that allows for thread-safe adding and removal of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> Representa una colección que permite agregar segura para subprocesos y la eliminación de datos.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is used as a wrapper for an <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> instance, and allows removal attempts from the collection to block until data is available to be removed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> se utiliza como un contenedor para una <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> una instancia y permite que los intentos de eliminación de la colección bloquear hasta que haya datos disponibles va a quitar.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Similarly, you can create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> to enforce an upper bound on the number of data elements allowed in the <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>; addition attempts to the collection may then block until space is available to store the added items.</source>
          <target state="translated">De forma similar, puede crear un <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> para aplicar un límite superior en el número de elementos de datos permitidos en el <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>; a continuación, pueden bloquear los intentos de adición a la colección hasta que haya espacio disponible para almacenar los elementos agregados.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>In this manner, <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is similar to a traditional blocking queue data structure, except that the underlying data storage mechanism is abstracted away as an <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</source>
          <target state="translated">De esta manera, <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es similar a una estructura datos bloqueo tradicional de cola, salvo que el mecanismo de almacenamiento de datos subyacente se resume como un <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> supports bounding and blocking.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> admite límites y bloqueos.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Bounding means that you can set the maximum capacity of the collection.</source>
          <target state="translated">Delimitación significa que puede establecer la capacidad máxima de la colección.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">Límite es importante en determinados escenarios, porque le permite controlar el tamaño máximo de la colección en memoria y se evita que los subprocesos productores de moverse demasiado lejos por delante de los subprocesos de consumo. Varios subprocesos o tareas pueden agregar elementos a la colección simultáneamente y, si la colección alcanza su capacidad máxima especificada, los subprocesos productores se bloquearán hasta que se quita un elemento.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">Varios consumidores pueden quitar elementos de forma simultánea y, si la colección está vacía, los subprocesos de consumo se bloquearán hasta que un productor agregue un elemento.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>A producing thread can call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> method to indicate that no more items will be added.</source>
          <target state="translated">Puede llamar un subproceso productor el <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> método para indicar que no hay más elementos se agregarán.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Consumers monitor the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">Los consumidores supervisan la propiedad <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> para saber cuándo está vacía la colección y no se agregarán más elementos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations are typically performed in a loop.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> normalmente se realizan operaciones en un bucle.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>You can cancel a loop by passing in a <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method, and then checking the value of the token's <ph id="ph4">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property on each iteration.</source>
          <target state="translated">Puede cancelar un bucle pasando un <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> el objeto a la <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> método y, a continuación, comprobando el valor del token <ph id="ph4">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> propiedad en cada iteración.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>If the value is <ph id="ph1">`true`</ph>, it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">Si el valor es <ph id="ph1">`true`</ph>, depende de usted para responder a la solicitud de cancelación limpiando los recursos y salir del bucle.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated">Cuando se crea un <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> objeto, puede especificar no solo la capacidad límite sino también el tipo de colección a usar.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Do not modify the underlying collection directly.</source>
          <target state="translated">No modifique directamente la colección subyacente.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> methods to add or remove elements.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> métodos para agregar o quitar elementos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object can become corrupted if you change the underlying collection directly.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> objeto puede dañar si cambia la colección subyacente directamente.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The following example shows how to add and take items concurrently from a blocking collection:</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo agregar y quitar elementos de forma simultánea de una colección de bloqueo:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The Dispose method is not thread-safe.</source>
          <target state="translated">El método Dispose no es seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>All other public and protected members of <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Todos los demás miembros públicos y protegidos de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> son seguras para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sin límite superior.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sin límite superior.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
          <source>The default underlying collection is a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object, which provides first in, first out (FIFO) behavior.</source>
          <target state="translated">La colección subyacente predeterminada es un <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object, que proporciona en primer lugar en el comportamiento primero en salir (FIFO).</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>The collection to use as the underlying data store.</source>
          <target state="translated">Colección que se va a usar como almacén de datos subyacente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound and using the provided <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> as its underlying data store.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sin límite superior y usando el objeto <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> proporcionado como almacén de datos subyacente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>The <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The bounded size of the collection.</source>
          <target state="translated">Tamaño límite de la colección.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class with the specified upper-bound.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> con el límite superior especificado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The default underlying collection is a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">La colección subyacente predeterminada es un <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> is not a positive value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> no es un valor positivo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The collection to use as the underlying data store.</source>
          <target state="translated">Colección que se va a usar como almacén de datos subyacente.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The bounded size of the collection.</source>
          <target state="translated">Tamaño límite de la colección.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class with the specified upper-bound and using the provided <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> as its underlying data store.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> con el límite superior especificado y usando el objeto <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> proporcionado como almacén de datos subyacente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> is not a positive value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> no es un valor positivo.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The supplied <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contains more values than is permitted by <ph id="ph2">&lt;paramref name="boundedCapacity" /&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> proporcionado contiene más valores de los permitidos por <ph id="ph2">&lt;paramref name="boundedCapacity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Agrega el elemento a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento que se va a agregar a la colección.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The value can be a null reference.</source>
          <target state="translated">El valor puede ser una referencia nula.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Agrega el elemento a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>If a bounded capacity was specified when this instance of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was initialized, a call to Add may block until space is available to store the provided item.</source>
          <target state="translated">Si se especificó una capacidad limitada cuando esta instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> estaba inicializado, una llamada a Add se puede bloquear hasta que haya espacio disponible para almacenar el elemento proporcionado.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completo en lo relativo a las adiciones.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento que se va a agregar a la colección.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The value can be a null reference.</source>
          <target state="translated">El valor puede ser una referencia nula.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Agrega el elemento a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>If a bounded capacity was specified when this instance of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was initialized, a call to <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> may block until space is available to store the provided item.</source>
          <target state="translated">Si se especificó una capacidad limitada cuando esta instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> se inicializó, una llamada a <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> puede bloquear hasta que haya espacio disponible para almacenar el elemento proporcionado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>This method can return early with an <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph> if the <ph id="ph2">`cancellationToken`</ph> is canceled.</source>
          <target state="translated">Este método puede devolver al principio con un <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph> si el <ph id="ph2">`cancellationToken`</ph> se cancela.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that owns <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ha sido eliminado o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que posee <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> ha sido eliminado.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completo en lo relativo a las adiciones.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Agrega el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento que se va a agregar a una de las colecciones.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Agrega el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added.</source>
          <target state="translated">Índice de la colección de la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> donde se agregó el elemento.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>If a bounded capacity was specified when all of the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instances were initialized, a call to AddToAny may block until space is available in one of the collections to store the provided item.</source>
          <target state="translated">Si se especificó una capacidad limitada cuando todos los <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> se inicializaron instancias, una llamada a AddToAny se puede bloquear hasta que haya espacio disponible en una de las colecciones para almacenar el elemento proporcionado.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Al menos una colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento que se va a agregar a una de las colecciones.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Agrega el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added.</source>
          <target state="translated">Índice de la colección de la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> donde se agregó el elemento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>If a bounded capacity was specified when all of the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instances were initialized, a call to AddToAny may block until space is available in one of the collections to store the provided item.</source>
          <target state="translated">Si se especificó una capacidad limitada cuando todos los <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> se inicializaron instancias, una llamada a AddToAny se puede bloquear hasta que haya espacio disponible en una de las colecciones para almacenar el elemento proporcionado.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>This method may return before the item is added to any collection if the <ph id="ph1">`cancellationToken`</ph> is canceled before space is available.</source>
          <target state="translated">Este método puede devolver antes de que el elemento se agrega a cualquier colección si el <ph id="ph1">`cancellationToken`</ph> se cancela antes de espacio esté disponible.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Al menos una colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed, or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o se ha eliminado la <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>Gets the bounded capacity of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Obtiene la capacidad límite de esta instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>The bounded capacity of this collection, or int.MaxValue if no bound was supplied.</source>
          <target state="translated">La capacidad límite de esta colección o int.MaxValue si no se proporciona ningún límite.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>Marks the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances as not accepting any more additions.</source>
          <target state="translated">Marca las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> para que no acepten nuevas adiciones.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>After a collection has been marked as complete for adding, adding to the collection is not permitted and attempts to remove from the collection will not wait when the collection is empty.</source>
          <target state="translated">Después de una colección se ha marcado como completa para agregar, no se permite agregar a la colección y los intentos para quitar de la colección no esperarán cuando la colección está vacía.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Matriz unidimensional que constituye el destino de los elementos copiados desde la instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">La matriz debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>Copies all of the items in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia todos los elementos de la instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>CopyTo represents a snapshot of the collection at a precise point in time.</source>
          <target state="translated">CopyTo representa una instantánea de la colección en un momento concreto en el tiempo.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>If other threads are adding or removing items while CopyTo is executing, then the elements returned by CopyTo might not represent the state of the collection.</source>
          <target state="translated">Si otros subprocesos están agregando o quitando elementos mientras CopyTo se está ejecutando, los elementos devueltos por CopyTo no podrían representar el estado de la colección.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="array" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="array" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is less than zero.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor o igual que la longitud de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The destination array is too small to hold all of the BlockingCcollection elements.</source>
          <target state="translated">La matriz de destino es demasiado pequeña para contener todos los elementos BlockingCcollection.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array rank doesn't match.</source>
          <target state="translated">El rango de la matriz no coincide.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array type is incompatible with the type of the BlockingCollection elements.</source>
          <target state="translated">El tipo de la matriz es incompatible con el tipo de los elementos BlockingCollection.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>Gets the number of items contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Obtiene el número de elementos contenidos en <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>The number of items contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Número de elementos contenidos en <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>If any method in BlockingCollection is executing while the Count property is being accessd, the return value is approximate.</source>
          <target state="translated">Si un método en BlockingCollection se está ejecutando mientras la propiedad Count se está obteniendo acceso a, el valor devuelto es aproximado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>Count may reflect a number that is either greater than or less than the actual number of items in the BlockingCollection.</source>
          <target state="translated">Recuento puede reflejar un número que sea mayor o menor que el número real de elementos de BlockingCollection.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos usados por la instancia actual de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos usados por la instancia actual de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method is not thread-safe.</source>
          <target state="translated">El <ph id="ph1">`Dispose`</ph> método no es seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</source>
          <target state="translated">Llame a <ph id="ph1">`Dispose`</ph> cuando haya terminado de usar <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> in an unusable state.</source>
          <target state="translated">El método <ph id="ph1">`Dispose`</ph> deja el <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> en un estado no utilizable.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was occupying.</source>
          <target state="translated">Después de llamar a <ph id="ph1">`Dispose`</ph>, debe liberar todas las referencias a la <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> estaba ocupando.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> y <bpt id="p2">[</bpt>implementa un método Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</source>
          <target state="translated">Realice siempre una llamada a <ph id="ph1">`Dispose`</ph> antes de liberar la última referencia al objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> del objeto <ph id="ph2">`Finalize`</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
          <source>Whether being disposed explicitly (true) or due to a finalizer (false).</source>
          <target state="translated">Si se desecha de forma explícita (true) o a través de un finalizador (false).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
          <source>Releases resources used by the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Libera los recursos utilizados por la instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Proporciona una interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> en uso para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Proporciona una interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> en uso para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that removes and returns items from the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> que quita y devuelve elementos de la colección.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> method:</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Proporciona una interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> en uso para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that removes and returns items from the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> que quita y devuelve elementos de la colección.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>This method enables client code to remove items from the collection by using a foreach loop (For Each in Visual Basic), or <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> or a PLINQ query.</source>
          <target state="translated">Este método permite que el código de cliente quitar elementos de la colección mediante un bucle foreach (para cada en Visual Basic), o <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> o una consulta PLINQ.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>The enumerator will continue to provide items (if any exist) until <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> returns true, and if <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> is false the loop blocks until an item becomes available or until the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> is cancelled.</source>
          <target state="translated">El enumerador continuará proporcionando elementos (si existe alguno) hasta que <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> devuelve true y si <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> es false el bucle se bloquea hasta que un elemento esté disponible o hasta que el <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> se cancela.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ha sido eliminado o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> ha sido eliminado.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete for adding.</source>
          <target state="translated">Obtiene si <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completa para las funciones de agregación.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>Whether this collection has been marked as complete for adding.</source>
          <target state="translated">Si esta colección se ha marcado como completa para las funciones de agregación.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete for adding and is empty.</source>
          <target state="translated">Obtiene si <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completa para las funciones de agregación y está vacía.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>Whether this collection has been marked as complete for adding and is empty.</source>
          <target state="translated">Si esta colección se ha marcado como completa para las funciones de agregación y está vacía.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Proporciona una interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for the items in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Unlike <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> returns a standard enumerator that does not modify the underlying collection.</source>
          <target state="translated">A diferencia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> devuelve un enumerador estándar que no modifica la colección subyacente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If other threads are adding or removing elements concurrently when GetEnumerator is called, then the elements returned by the enumerator might not represent the current state of the collection.</source>
          <target state="translated">Si otro subproceso está agregando o quitando elementos concurrentemente cuando se llama a GetEnumerator, los elementos devueltos por el enumerador no podrían representar el estado actual de la colección.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Matriz unidimensional que constituye el destino de los elementos copiados desde la instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">La matriz debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>Copies all of the items in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia todos los elementos de la instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="array" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="array" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is less than zero.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, the array is multidimensional, or the type parameter for the collection cannot be cast automatically to the type of the destination array.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor o igual que la longitud de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, la matriz es multidimensional o el parámetro de tipo para la colección no se puede convertir automáticamente al tipo de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized.</source>
          <target state="translated">Obtiene un valor que indica si el acceso a <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> está sincronizado.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>always returns false.</source>
          <target state="translated">siempre devuelve false.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Obtiene un objeto que se puede usar para sincronizar el acceso a <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>This property is not supported.</source>
          <target state="translated">Esta propiedad no es compatible.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>returns null.</source>
          <target state="translated">devuelve NULL.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>The SyncRoot property is not supported.</source>
          <target state="translated">La propiedad SyncRoot no es compatible.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Proporciona una interfaz <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the items in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> para los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Removes an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Quita un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>Removes  an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Quita un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The item removed from the collection.</source>
          <target state="translated">Elemento que se ha quitado de la colección.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>A call to <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Cuando crea un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, puede especificar el tipo de colección que se va a usar.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance, or the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> is empty and the collection has been marked as complete for adding.</source>
          <target state="translated">La colección subyacente se modificó fuera de esta estancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>, o la <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> está vacía y la colección se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>Object that can be used to cancel the take operation.</source>
          <target state="translated">Objeto que se puede usar para cancelar la operación en la que se toma un elemento.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>Removes an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Quita un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The item removed from the collection.</source>
          <target state="translated">Elemento que se ha quitado de la colección.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>A call to <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> may block until an item is available to be removed or the token is canceled.</source>
          <target state="translated">Una llamada a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> pueden bloquear hasta que un elemento está disponible para poder quitarlo o se cancela el token.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Cuando crea un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, puede especificar el tipo de colección que se va a usar.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> se cancela.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ha sido eliminado o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó el token se canceló.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance or the BlockingCollection is marked as complete for adding, or the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> is empty.</source>
          <target state="translated">La colección subyacente se modificó fuera de esta instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o BlockingCollection se ha marcado como completa para las funciones de agregación o bien <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> está vacía.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Toma un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento que se ha quitado de una de las colecciones.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Toma un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed.</source>
          <target state="translated">Índice de la colección de la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> de la que se quitó el elemento.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>A call to TakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a TakeFromAny puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element or <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> has been called on the collection.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento nulo o se ha llamado a <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> en la colección.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento que se ha quitado de una de las colecciones.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances while observing the specified cancellation token.</source>
          <target state="translated">Toma un elemento de cualquiera de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas observando el token de cancelación indicado.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed.</source>
          <target state="translated">Índice de la colección de la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> de la que se quitó el elemento.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>A call to TakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a TakeFromAny puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The method will return early with an OperationCanceledException if the token is canceled.</source>
          <target state="translated">El método devolverá al principio con una excepción OperationCanceledException si el token se cancela.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> has been called on the collection.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento nulo o se ha llamado a <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> en la colección.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>Copies the items from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance into a new array.</source>
          <target state="translated">Copia los elementos de la instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> en una nueva matriz.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>An array containing copies of the elements of the collection.</source>
          <target state="translated">Matriz que contiene copias de los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>The copied elements are not removed from the collection.</source>
          <target state="translated">No se quitan los elementos copiados de la colección.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>If any method in BlockingCollection is executing while the ToArray method executes, the return value is approximate.</source>
          <target state="translated">Si un método en BlockingCollection se está ejecutando mientras se ejecuta el método ToArray, el valor devuelto es aproximado.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>ToArray  may include items that have already been removed, or exclude items that have already been inserted.</source>
          <target state="translated">ToArray puede incluir elementos que ya se han quitado o excluir los elementos que ya se han insertado.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Intenta agregar el elemento especificado a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento que se va a agregar a la colección.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Intenta agregar el elemento especificado a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>true if <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added; otherwise false.</source>
          <target state="translated">true si se pudo agregar <ph id="ph1">&lt;paramref name="item" /&gt;</ph>; en caso contrario, false.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>If the collection is a bounded collection, and is full, this method immediately returns false without adding the item.</source>
          <target state="translated">Si la colección es una colección limitada y está lleno, este método inmediatamente devuelve a false sin tener que agregar el elemento.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completo en lo relativo a las adiciones.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento que se va a agregar a la colección.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> within the specified time period.</source>
          <target state="translated">Intenta agregar el elemento especificado a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> dentro del periodo de tiempo indicado.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time; otherwise, false.</source>
          <target state="translated">Es true si se pudo agregar <ph id="ph1">&lt;paramref name="item" /&gt;</ph> a la colección en el tiempo especificado; en caso contrario, es false.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completo en lo relativo a las adiciones.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento que se va a agregar a la colección.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el número de milisegundos de espera o estructura <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Intenta agregar el elemento especificado a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time span; otherwise, false.</source>
          <target state="translated">Es true si se pudo agregar <ph id="ph1">&lt;paramref name="item" /&gt;</ph> a la colección en el intervalo de tiempo especificado; en caso contrario, es false.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completo en lo relativo a las adiciones.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento que se va a agregar a la colección.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> within the specified time period, while observing a cancellation token.</source>
          <target state="translated">Intenta agregar el elemento especificado a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> dentro del periodo de tiempo indicado, observando un token de cancelación.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time; otherwise, false.</source>
          <target state="translated">Es true si se pudo agregar <ph id="ph1">&lt;paramref name="item" /&gt;</ph> a la colección en el tiempo especificado; en caso contrario, es false.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Si el elemento es un duplicado, y la colección subyacente no acepta elementos duplicados, se producirá una excepción <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the underlying <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ha sido eliminado o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> subyacente ha sido eliminado.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> se ha marcado como completo en lo relativo a las adiciones.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento que se va a agregar a una de las colecciones.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Al menos una colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento que se va a agregar a una de las colecciones.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Al menos una colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento que se va a agregar a una de las colecciones.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el número de milisegundos de espera o estructura <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances while observing the specified cancellation token.</source>
          <target state="translated">Intenta agregar el elemento especificado a cualquiera de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> especificadas observando el token de cancelación indicado.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>This method can return early if the cancellationToken is cancelled before space was available for the Add operation.</source>
          <target state="translated">Este método puede devolver antes si cancellationToken está cancelado antes de espacio disponible para la operación de agregación.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o de <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que crearon <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Al menos una colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento que se va a agregar a una de las colecciones.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta agregar el elemento especificado a cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> a la que se agregó el elemento o -1 si no se pudo agregar el elemento.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Al menos una colección subyacente no aceptó el elemento.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento NULL, o al menos una de las colecciones se ha marcado como completa para agregar.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Intenta quitar un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method.</source>
          <target state="translated">En el siguiente ejemplo, se muestra cómo utilizar el método <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento que va a quitarse de la colección.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Intenta quitar un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se pudo quitar un elemento; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>If the collection is empty, this method immediately returns false.</source>
          <target state="translated">Si la colección está vacía, este método inmediatamente devuelve false.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Cuando crea un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, puede especificar el tipo de colección que se va a usar.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">La colección subyacente se modificó fuera de esta instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento que va a quitarse de la colección.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period.</source>
          <target state="translated">Intenta quitar un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> dentro del periodo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se pudo quitar un elemento de la colección en el tiempo especificado; de lo contrario, es, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, you can specify the type of collection to use.</source>
          <target state="translated">Cuando se crea un <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, puede especificar el tipo de colección que se va a usar.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">La colección subyacente se modificó fuera de esta instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento que va a quitarse de la colección.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>An object that represents the number of milliseconds to wait, or an object that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Objeto que representa el número de milisegundos de espera u objeto que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period.</source>
          <target state="translated">Intenta quitar un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> dentro del periodo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se pudo quitar un elemento de la colección en el tiempo especificado; de lo contrario, es, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Cuando crea un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, puede especificar el tipo de colección que se va a usar.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">La colección subyacente se modificó fuera de esta instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento que va a quitarse de la colección.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period while observing a cancellation token.</source>
          <target state="translated">Intenta quitar un elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> dentro del periodo de tiempo especificado, observando un token de cancelación.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se pudo quitar un elemento de la colección en el tiempo especificado; de lo contrario, es, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">El orden en que se quita un elemento depende del tipo de colección usado para crear la instancia de <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Cuando crea un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, puede especificar el tipo de colección que se va a usar.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Por ejemplo, puede especificar un objeto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> para un comportamiento FIFO (primero en entrar, primero en salir) o un objeto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> para un comportamiento LIFO (último en entrar, primero en salir).</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Puede usar cualquier clase de colección que implemente la interfaz <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">El tipo de colección predeterminado para <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> es <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has been canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the underlying <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> ha sido eliminado o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> subyacente ha sido eliminado.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The underlying collection was modified outside this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">La colección subyacente se modificó fuera de esta instancia de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta quitar un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento que se ha quitado de una de las colecciones.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta quitar un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a TryTakeFromAny puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType&gt;</ph> method:</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento nulo.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento que se ha quitado de una de las colecciones.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta quitar un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a TryTakeFromAny puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento nulo.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento que se ha quitado de una de las colecciones.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el número de milisegundos de espera o estructura <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta quitar un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a TryTakeFromAny puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento nulo.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matriz de colecciones.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento que se ha quitado de una de las colecciones.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token de cancelación que se va a observar.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Intenta quitar un elemento de cualquiera de las instancias especificadas de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Índice de la colección en la matriz <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> de la que se quitó el elemento o -1 si no se pudo quitar el elemento.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una llamada a TryTakeFromAny puede bloquear hasta que haya un elemento disponible para poder quitarlo.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Si se cancela <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Al menos una de las colecciones subyacentes se modificó fuera de su instancia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">El recuento de <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es mayor que el tamaño máximo de 62 para STA y 63 para MTA.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> es una matriz de longitud 0 o contiene un elemento nulo.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Se ha eliminado al menos una de las instancias de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>