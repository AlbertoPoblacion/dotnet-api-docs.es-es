<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2dbc0f7ae686463d4772e0cdd1f503f889472ddd" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56779387" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una clase base para un servicio que existirá como parte de una aplicación de servicio. Deberá derivarse de <see cref="T:System.ServiceProcess.ServiceBase" /> cuando se cree una nueva clase de servicio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivar de <xref:System.ServiceProcess.ServiceBase> al definir la clase de servicio en una aplicación de servicio. Cualquier servicio útil reemplaza el <xref:System.ServiceProcess.ServiceBase.OnStart%2A> y <xref:System.ServiceProcess.ServiceBase.OnStop%2A> métodos. Para obtener funcionalidad adicional, puede invalidar <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> con un comportamiento específico en respuesta a cambios en el estado del servicio.  
  
 Un servicio es un ejecutable de larga ejecución que no es compatible con una interfaz de usuario y que podría no ejecutarse bajo la cuenta de usuario con sesión iniciada. El servicio puede ejecutarse sin que ningún usuario que se inició sesión en el equipo.  
  
 De forma predeterminada, los servicios se ejecutan bajo la cuenta del sistema, que no es igual que la cuenta de administrador. No se puede cambiar los derechos de la cuenta del sistema. Como alternativa, puede usar un <xref:System.ServiceProcess.ServiceProcessInstaller> para especificar una cuenta de usuario bajo la que se ejecutará el servicio.  
  
 Un ejecutable puede contener más de un servicio, pero debe contener un independiente <xref:System.ServiceProcess.ServiceInstaller> para cada servicio. El <xref:System.ServiceProcess.ServiceInstaller> instancia registra el servicio con el sistema. El instalador también asocia cada servicio con un registro de eventos que puede usar para registrar comandos de servicio. El `main()` función en el archivo ejecutable define qué servicios deben ejecutarse. El directorio de trabajo actual del servicio es el directorio del sistema, no el directorio donde se encuentra el archivo ejecutable.  
  
 Cuando se inicia un servicio, el sistema busca el ejecutable y se ejecuta el <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método para el servicio, incluido en el archivo ejecutable. Sin embargo, que ejecuta el servicio no es igual que la ejecución del ejecutable. El archivo ejecutable carga solo el servicio. Se accede al servicio (por ejemplo, iniciar y detener) mediante el Administrador de Control de servicios.  
  
 El ejecutable llama el <xref:System.ServiceProcess.ServiceBase> derivada tiempo el primer constructor de la clase se llama a Start para el servicio. El <xref:System.ServiceProcess.ServiceBase.OnStart%2A> se llama al método de control de comandos inmediatamente después de que se ejecuta el constructor. No se ejecuta el constructor de nuevo después de la primera vez que se ha cargado el servicio, por lo que es necesario separar el procesamiento realizado por el constructor del realizado por <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Todos los recursos que se pueden liberar por <xref:System.ServiceProcess.ServiceBase.OnStop%2A> debe crearse en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creación de recursos en el constructor impide que se creen correctamente si el servicio se inicia después de volver a <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ha liberado los recursos.  
  
 El Administrador de Control de servicios (SCM) proporciona una manera de interactuar con el servicio. Puede utilizar el SCM para pasar iniciar, detener, pausar, continuar o comandos personalizados en el servicio. El SCM utiliza los valores de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> y <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> para determinar si el servicio acepta detener, pausar o continuar comandos. Detener, pausar y continuar están habilitadas en solo si en del SCM contexto menús la propiedad correspondiente <xref:System.ServiceProcess.ServiceBase.CanStop%2A> o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `true` en la clase de servicio. Si está habilitada, el comando se pasa al servicio, y <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> se llama. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el método de control de comandos correspondiente (como <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) no se procesarán, incluso si ha implementado el método.  
  
 Puede usar el <xref:System.ServiceProcess.ServiceController> clase hacer mediante programación qué SCM realiza mediante una interfaz de usuario. Puede automatizar las tareas disponibles en la consola. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `true` pero no ha implementado un método de control de comandos correspondiente (como <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) el sistema produce una excepción y omite el comando.  
  
 No es necesario implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, o cualquier otro método en <xref:System.ServiceProcess.ServiceBase>. Sin embargo, se describe el comportamiento del servicio en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, por lo que como mínimo, se debe invalidar este miembro. El `main()` función del ejecutable registra el servicio en el archivo ejecutable con el Administrador de Control de servicio mediante una llamada a la <xref:System.ServiceProcess.ServiceBase.Run%2A> método. El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> propiedad de la <xref:System.ServiceProcess.ServiceBase> objeto pasa a la <xref:System.ServiceProcess.ServiceBase.Run%2A> método debe coincidir con el <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> propiedad del instalador del servicio para ese servicio.  
  
 Puede usar `InstallUtil.exe` para instalar servicios del sistema.  
  
> [!NOTE]
>  Puede especificar un registro distinto del registro de eventos de aplicación para recibir la notificación de llamadas de servicio, pero ninguna de ellas el <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ni <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad puede escribir en un registro personalizado. Establecer <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` si no desea utilizar el registro automático.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No cree una instancia de la <xref:System.ServiceProcess.ServiceBase> clase. En su lugar, se derivan de <xref:System.ServiceProcess.ServiceBase> y crear una instancia de la clase derivada. El mínimo necesario implementar en el constructor para una clase heredada de <xref:System.ServiceProcess.ServiceBase> consiste en establecer el <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> en el componente. En concreto no se requiere ningún otro procesamiento en el constructor. Debe controlar la inicialización de la mayoría de <xref:System.ServiceProcess.ServiceBase.OnStart%2A> en lugar de en el constructor. En caso contrario, no hay ninguna garantía de que los objetos se reinicializarán al reiniciar un servicio después de que se ha detenido.  
  
 Si reemplaza el constructor de la clase derivada, llame al constructor de clase base en el código.  
  
 El <xref:System.ServiceProcess.ServiceBase> constructor establece <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true`. Si no desea que se inicie automáticamente las llamadas al servicio desde el Administrador de Control de servicios (SCM), establezca <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false`.  
  
 Si el archivo ejecutable contiene un único servicio, el sistema llama al constructor del servicio cuando inicio está seleccionado en el SCM y ejecuta el destructor si se llama a detener.  
  
 Si el archivo ejecutable contiene varios servicios, al llamar a iniciar en un servicio, los constructores que se llamará para todos los servicios en el archivo ejecutable, pero se inicia el servicio especificado. Los destructores para los servicios se ejecutan juntos cuando todos los servicios se han detenido, no de manera individual cuando se detiene cada servicio.  
  
> [!NOTE]
>  Si invalida el constructor de clase base, se debe llamar explícitamente en el constructor de la clase derivada.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si los comandos Iniciar, Detener, Pausar y Continuar deben notificarse en el registro de eventos.</summary>
        <value><see langword="true" /> para notificar información en el registro de eventos; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true` indica al servicio que utilice el registro de eventos de aplicación para notificar errores de comandos, así como información de cambio de estado para iniciar, detener, pausar y continuar con los eventos en el servicio. El nombre del servicio se utiliza como el registro <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Para notificar información a un registro de eventos personalizado en lugar de con el registro de aplicación, establezca <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` y escribir las instrucciones incluidas en los métodos de control de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para publicar en el registro adecuado.  
  
> [!NOTE]
>  El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, que proporciona la cadena de origen para el registro de eventos, debe establecerse antes de que el servicio intenta escribir en el registro de eventos. Intenta obtener acceso al registro de eventos antes de establece el nombre del origen, produce una excepción.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el servicio puede controlar notificaciones de los cambios de estado de la alimentación del equipo.</summary>
        <value><see langword="true" /> si el servicio controla los cambios de estado de la alimentación del equipo indicados en la clase <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando los cambios de estado de energía de equipo en que el Administrador de Control de servicios (SCM) comprueba de si el servicio acepta comandos de eventos de energía con el valor de <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> es `true`, el comando se pasa al servicio y el <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> se llama al método si ha definido. Si <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> no está implementada en la clase derivada, el SCM controla el evento de energía a través de la clase base vacía <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se modifica después de haber iniciado el servicio.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el servicio puede controlar eventos de cambio de sesión recibidos de una sesión de Terminal Server.</summary>
        <value><see langword="true" /> si el servicio puede controlar eventos de cambio de sesión de Terminal Server; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se modifica después de haber iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se puede pausar y reanudar el servicio.</summary>
        <value><see langword="true" /> si se puede pausar el servicio; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca el valor de la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propiedad en el constructor para el servicio.  
  
 Cuando se pausa un servicio, se detiene lo que está haciendo. Al continuar el servicio (ya sea mediante el Administrador de Control de servicios o mediante programación), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> se ejecuta.  
  
 Enviar una solicitud de pausa en el servicio puede ahorrar recursos del sistema. Pausa no puede liberar todos los recursos del sistema, pero sí de detención. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> a menudo se implementan para llevar a cabo un procesamiento menor que <xref:System.ServiceProcess.ServiceBase.OnStop%2A> y <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `true`, invalidar <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para especificar el procesamiento que debe producirse cuando el Administrador de Control de servicios (SCM) pasa una solicitud Pausar o continuar al servicio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> debe implementarse para deshacer el procesamiento en <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el SCM no pasará pausar o continuar solicitudes al servicio, por lo que el <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos no se llamará incluso si se implementan. En el SCM, la `Pause` y `Continue` controles están deshabilitados cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe informar al servicio de que el sistema se está cerrando.</summary>
        <value><see langword="true" /> si se debe notificar al servicio cuando se está cerrando el sistema; en caso contrario, <see langword="false" />.  De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> es `true`, el servicio se notifica cuando se está cerrando el sistema. Al apagar el equipo, el <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> se llama al método si se ha implementado en la clase derivada.  
  
> [!NOTE]
>  Solo el sistema debe hacer el <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> método se debe ejecutar; el servicio puede llamarlo, pero esto no es recomendable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si puede detenerse el servicio una vez se ha iniciado.</summary>
        <value><see langword="true" /> si se puede detener el servicio y llamar al método <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a detener en un servicio, el Administrador de Control de servicios (SCM) comprueba si el servicio acepta comandos Detener con el valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Para la mayoría de los servicios, el valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `true`, pero algunos servicios del sistema operativo, por ejemplo, no permiten al usuario detenerlos.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `true`, el comando Detener se pasa al servicio y el <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se llama al método si se ha definido. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> no está implementada en la clase derivada, el SCM controla el comando Detener mediante la clase base vacía <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Se deshace de los recursos (distintos de la memoria) que usa <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.ServiceProcess.ServiceBase.Dispose%2A> en su clase derivada (y a través de él, en el <xref:System.ServiceProcess.ServiceBase> clase) cuando haya terminado de utilizar la clase derivada. El <xref:System.ServiceProcess.ServiceBase.Dispose%2A> método deja la clase derivada en un estado inutilizable. Después de llamar a <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, debe liberar todas las referencias a la clase derivada y <xref:System.ServiceProcess.ServiceBase> por lo que la memoria que se estaba ocupando pueda ser reclamada por la recolección.  
  
> [!NOTE]
>  Llame siempre a <xref:System.ServiceProcess.ServiceBase.Dispose%2A> antes de liberar la última referencia a la clase derivada de <xref:System.ServiceProcess.ServiceBase>. En caso contrario, los recursos <xref:System.ServiceProcess.ServiceBase> y la clase derivada usa will no liberarse hasta que la colección de elementos no utilizados llama a los destructores de los objetos.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> a menudo se implementa para procesar el código en <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinado con una llamada a <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Si decide hacer esto en su clase derivada, lo habitual es implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para asignar cualquier <xref:System.ServiceProcess.ServiceBase.Dispose%2A> publicado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un registro de eventos que se puede utilizar para escribir la notificación de llamadas de comandos de servicio, como Iniciar y Detener, en el registro de eventos de aplicación.</summary>
        <value>Instancia de <see cref="T:System.Diagnostics.EventLog" /> cuyo origen se encuentra registrado en el registro de aplicaciones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor inicializa el <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad a una instancia con el <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> y <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> conjunto de propiedades. El origen es el <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servicio, y el registro es el registro de aplicación del equipo. Estos valores se establecen automáticamente y no pueden cambiarse en el registro automático de los comandos de servicio.  
  
 Cuando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> es `true`, iniciar, detener, pausar, continuar y comandos personalizados se registran automáticamente en el registro de eventos de aplicación. Puede usar el <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad para escribir mensajes adicionales en ese registro. Las llamadas de componente <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> mediante este <xref:System.ServiceProcess.ServiceBase.EventLog%2A> miembro.  
  
 Para notificar información a un registro de eventos personalizado en lugar de con el registro de aplicación, establezca <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` y escribir las instrucciones incluidas en los métodos de control de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para publicar en el registro adecuado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el código de salida para el servicio.</summary>
        <value>El código de salida para el servicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> propiedad en un valor distinto de cero antes de detener el servicio para indicar un error con el Administrador de Control de servicios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Indica el tamaño máximo de un nombre de servicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName y DisplayName tienen restricciones de tamaño que deben tenerse en cuenta al establecer las propiedades de la clase de servicio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía un comando Continuar al servicio. Especifica las acciones que deben realizarse cuando se reanuda el funcionamiento normal de un servicio después de una pausa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implemente <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para reflejar la respuesta de la aplicación a <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Al continuar el servicio (ya sea a través de la consola Servicios o mediante programación), el <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> de procesamiento se ejecuta y el servicio vuelve a estar activo.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> se espera que se invalide cuando la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propiedad es `true`.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el SCM no pasará pausar o continuar solicitudes al servicio, por lo que el <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos no se llamará incluso si se implementan. En el SCM, la `Pause` y `Continue` controles están deshabilitados cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Mensaje de comando enviado al servicio.</param>
        <summary>Si se implementa en una clase derivada, <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) pasa un comando personalizado al servicio. Especifica las acciones que deben realizarse cuando se ejecuta un comando con el valor de parámetro especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> le permite especificar funcionalidad adicional al iniciar, detener, pausar y continuar servicios.  
  
 El SCM no examina el comando personalizado para comprobar si el servicio admite la `command` parámetro pasado. El comando personalizado pasa directamente al servicio. Si el servicio no reconoce el `command` parámetro, no hace nada.  
  
 Comandos personalizados generados por un <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instrucción en un <xref:System.ServiceProcess.ServiceController> componente. Use una instrucción switch o si... a continuación, la condición que se va a controlar los comandos personalizados que defina en el servicio.  
  
 Los únicos valores de un comando personalizado que puede definir en la aplicación o usar en <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> son aquellos entre 128 y 255. Enteros inferiores a 128 corresponden a valores de sistema reservado.  
  
 Si el <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> propiedad es `true`, comandos personalizados, al igual que todos los otros comandos, escriben entradas en el registro de eventos para notificar si la ejecución del método se realizó correctamente o no.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía un comando Pausar al servicio. Especifica las acciones que deben realizarse cuando un servicio realiza una pausa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnPause%2A> para especificar el procesamiento que se produce cuando el servicio recibe un comando de pausa. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> se espera que se invalide cuando la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propiedad es `true`.  
  
 Al continuar un servicio en pausa (ya sea a través de la consola Servicios o mediante programación), el <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> procesamiento se ejecuta y el servicio vuelve a estar activo.  
  
 El comando Pausar sólo permite la aplicación reaccionar ante un evento específico. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> no hace nada para el servicio que no definen hacer.  
  
 Enviar una solicitud de pausa en el servicio puede ahorrar recursos del sistema porque la pausa no necesita liberar todos los recursos del sistema. Por ejemplo, si se han abierto los subprocesos por el proceso, poner en pausa un servicio en lugar de detenerlo puede permitir que los subprocesos permanezcan abiertos, obviando la necesidad de reasignarlos cuando el servicio continúa. Si define pausar para liberar todos los recursos del sistema, se comporta como un comando Detener.  
  
 Establecer <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> a `true`e invalidar <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para especificar el procesamiento que debe producirse cuando el SCM pasa una solicitud Pausar o continuar al servicio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> debe implementarse para deshacer el procesamiento en <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el SCM no pasará pausar o continuar solicitudes al servicio, por lo que el <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos no se llamará aunque estén implementados. En el SCM, la `Pause` y `Continue` controles están deshabilitados cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus"><see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> que indica una notificación del sistema sobre su estado de la alimentación.</param>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el estado de la alimentación del equipo cambia. Esto se aplica a equipos portátiles cuando entran en modo suspendido, que no es lo mismo que un cierre de sistema.</summary>
        <returns>Cuando se implementa en una clase derivada, las necesidades de la aplicación determinan qué valor se debe devolver. Por ejemplo, si se pasa un estado de difusión <see langword="QuerySuspend" />, puede hacerse que la aplicación rechace la consulta mediante un valor devuelto <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> para especificar el procesamiento que se produce cuando el evento del sistema indicado en el <xref:System.ServiceProcess.PowerBroadcastStatus> enumeración--por ejemplo, se produce cuando el equipo se coloca en modo de suspensión o indica la alimentación de batería baja.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> se espera que se invalide cuando la <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> propiedad es `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Estructura que identifica el tipo de cambio.</param>
        <summary>Se ejecuta cuando se recibe un evento de cambio de una sesión de Terminal Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe establecer el <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> propiedad `true` para habilitar la ejecución de este método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el sistema se está cerrando. Especifica lo que tiene que suceder inmediatamente antes de que se cierre el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> para especificar el procesamiento que se produce cuando se cierra el sistema.  
  
 Este evento se produce únicamente cuando se apaga el sistema operativo, no cuando se apaga el equipo.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> se espera que se invalide cuando la <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> propiedad es `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Datos pasados por el comando Iniciar.</param>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía un comando Iniciar al servicio o cuando se inicia el sistema operativo (en el caso de un servicio que se inicia de forma automática). Especifica las acciones que deben realizarse cuando se inicia el servicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para especificar el procesamiento que se produce cuando el servicio recibe un comando de inicio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> es el método en el que se especifica el comportamiento del servicio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> puede tomar argumentos como una forma de pasar datos, pero este uso es poco frecuente.  
  
> [!CAUTION]
>  No utilice el constructor para realizar el procesamiento que debería estar en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para controlar toda la inicialización del servicio. Se llama al constructor al ejecutable de la aplicación se ejecuta, no cuando se ejecuta el servicio. El ejecutable se ejecuta antes de <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Al continuar, por ejemplo, se llama al constructor no nuevo porque el SCM ya contiene el objeto en memoria. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> libera recursos asignados en el constructor en lugar de en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, los recursos necesarios no se crearía la segunda vez que se llama al servicio.  
  
 Servicios pueden configurarse para iniciarse automáticamente cuando se reinicia el equipo estableciendo el <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> en el instalador del servicio a <xref:System.ServiceProcess.ServiceStartMode.Automatic>. En esta situación, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> se llamaría al iniciar el sistema.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> se espera que se invalide en la clase derivada. Para el servicio sea útil, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> y <xref:System.ServiceProcess.ServiceBase.OnStop%2A> tienen que implementarse en la clase de servicio.  
  
 Procesar argumentos de inicialización para el servicio en la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método, no en el método Main. Los argumentos de la `args` matriz de parámetros puede establecerse manualmente en la ventana Propiedades para el servicio en la consola de servicios. No se guardan los argumentos especificados en la consola; se pasan al servicio en una sola vez cuando se inicia el servicio desde el panel de control. Argumentos que deben estar presentes cuando se inicia automáticamente el servicio se pueden colocar en el valor de cadena ImagePath para la clave de registro del servicio (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\< nombre del servicio >*). Puede obtener los argumentos del registro mediante el <xref:System.Environment.GetCommandLineArgs%2A> método, por ejemplo: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía a un comando Detener al servicio. Especifica las acciones que deben realizarse cuando un servicio deja de ejecutarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para especificar el procesamiento que se produce cuando el servicio recibe un comando Detener.  
  
 Cuando el SCM recibe un comando Detener, utiliza el valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> para comprobar si el servicio acepta comandos Detener. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `true`, el comando Detener se pasa al servicio y el <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se llama al método si se ha definido. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> no está implementado en el servicio, el SCM controla el comando Detener.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `false`, el SCM omite el comando Detener. No se pasa al servicio. El comando Detener devuelve y produce una excepción.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se espera que se invalide en la clase derivada. Para el servicio sea útil, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> y <xref:System.ServiceProcess.ServiceBase.OnStop%2A> tienen que implementarse en la clase de servicio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Tiempo solicitado en milisegundos.</param>
        <summary>Solicita tiempo adicional para una operación pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> método está pensado para ser llamado por invalidado <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> métodos para solicitar más tiempo para que una operación pendiente, para evitar que el Administrador de Control de servicios (SCM) de marcado de la servicio no responde.  Si la operación pendiente no es un continuar, pausa, inicio o detención, un <xref:System.InvalidOperationException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El servicio no está en estado pendiente.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona el punto de entrada principal para un ejecutable de servicio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service"><see cref="T:System.ServiceProcess.ServiceBase" /> que indica que va a iniciarse un servicio.</param>
        <summary>Registra el ejecutable para un servicio con el Administrador de control de servicios (SCM, Service Control Manager).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta sobrecarga en el `main()` funcionamiento del servicio para registrar el servicio con el Administrador de Control de servicio ejecutable. Después de llamar a <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, el Administrador de Control de servicio emite un comando de inicio, lo que resulta en una llamada a la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método en el servicio. El servicio no se inicia hasta que se ejecuta el comando de inicio.  
  
 El <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> se llama al método en la misma manera que <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> para aplicaciones de Windows Forms.  
  
 Si <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> es `true`, se escribe una entrada en el registro de eventos si el servicio especificado por el `service` parámetro no puede iniciarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Una matriz de instancias de ServiceBase, que indica los servicios que se van a iniciar.</param>
        <summary>Registra el ejecutable para varios servicios con el Administrador de control de servicios (SCM, Service Control Manager).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta sobrecarga en el `main()` funcionamiento del servicio para registrar los servicios con el Administrador de Control de servicio ejecutable. Después de llamar a <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, el Administrador de Control de servicio emite comandos de inicio, que producen las llamadas a la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> métodos en los servicios. Los servicios no se inician hasta que se ejecutan los comandos de inicio.  
  
 El <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> se llama al método en la misma manera que el <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> método para las aplicaciones de Windows Forms.  
  
 Si <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> es `true`, se escribe una entrada al registro de eventos si no se puede iniciar cualquier servicio en la matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No proporcionó un servicio para que se inicie. La matriz podría ser <see langword="null" /> o estar vacía.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador del control de servicios para el servicio.</summary>
        <value>Una estructura <see cref="T:System.IntPtr" /> que contiene el identificador del control de servicios para el servicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El identificador del control de servicio se usa para comunicarse con el Administrador de Control de servicios (SCM).  El identificador puede usarse para actualizar la información de estado del Administrador de control de servicio para el servicio que realiza la llamada con el no administrado `SetServiceStatus` función.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">Número de argumentos de la matriz de argumentos.</param>
        <param name="argPointer">Estructura <see cref="T:System.IntPtr" /> que señala a una matriz de argumentos.</param>
        <summary>Registra el controlador de comandos e inicia el servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre corto utilizado para identificar el servicio en el sistema.</summary>
        <value>Nombre del servicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifica el servicio con el Administrador de Control de servicios. El valor de esta propiedad debe ser idéntico al nombre registrado para el servicio en la <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> propiedad de la clase de instalador correspondiente. En el código, el <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servicio se establece normalmente el `main()` función del archivo ejecutable.  
  
 El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> también se utiliza para especificar el <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> asociado con el <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad. Esto <xref:System.ServiceProcess.ServiceBase.EventLog%2A> es una instancia que escribe información de comandos de servicio en el registro de aplicación.  
  
 El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, que proporciona la cadena de origen para el registro de eventos, debe establecerse antes de que el servicio se escribe en el registro de eventos. Intenta obtener acceso el registro de eventos antes de que se establece el nombre de origen hace que se produzca una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <exception cref="T:System.ArgumentException">El nombre especificado es una cadena de longitud cero o es más largo que <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, o el nombre especificado contiene caracteres de barra diagonal o barra diagonal inversa.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detiene el servicio en ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceProcess.ServiceBase.Stop%2A> método establece el estado del servicio para indicar un delimitador está pendiente y llama el <xref:System.ServiceProcess.ServiceBase.OnStop%2A> método.  Después de la aplicación se detiene, el estado del servicio se establece en detenido. Si la aplicación es un servicio hospedado, se descarga el dominio de aplicación.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>