<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d659a5675f8e308404ab56d663607e4230bf1530" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530909" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una clase base para un servicio que existirá como parte de una aplicación de servicio. Deberá derivarse de <see cref="T:System.ServiceProcess.ServiceBase" /> cuando se cree una nueva clase de servicio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivar de <xref:System.ServiceProcess.ServiceBase> al definir la clase de servicio en una aplicación de servicio. Cualquier servicio útil reemplaza el <xref:System.ServiceProcess.ServiceBase.OnStart%2A> y <xref:System.ServiceProcess.ServiceBase.OnStop%2A> métodos. Para obtener funcionalidad adicional, puede invalidar <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> con un comportamiento específico en respuesta a los cambios en el estado del servicio.  
  
 Un servicio es un ejecutable de larga duración que no admite una interfaz de usuario, y que podría no ejecutarse bajo la cuenta de usuario que inició sesión. El servicio puede ejecutarse sin que ningún usuario que se inició sesión en el equipo.  
  
 De forma predeterminada, los servicios se ejecutan bajo la cuenta del sistema, que no es igual que la cuenta de administrador. No se puede cambiar los derechos de la cuenta del sistema. Como alternativa, puede usar un <xref:System.ServiceProcess.ServiceProcessInstaller> para especificar una cuenta de usuario bajo la que se ejecutará el servicio.  
  
 Un ejecutable puede contener más de un servicio, pero debe contener un independiente <xref:System.ServiceProcess.ServiceInstaller> para cada servicio. El <xref:System.ServiceProcess.ServiceInstaller> instancia registra el servicio con el sistema. El instalador también asocia cada servicio a un registro de eventos que puede utilizar para registrar comandos de servicio. El `main()` función en el archivo ejecutable define qué servicios deben ejecutarse. El directorio de trabajo actual del servicio es el directorio del sistema, no en el directorio donde se encuentra el archivo ejecutable.  
  
 Cuando se inicia un servicio, el sistema busca el ejecutable y ejecuta el <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método para ese servicio, contenido dentro del ejecutable. Sin embargo, ejecuta el servicio no es igual que la ejecución del ejecutable. El ejecutable solamente carga el servicio. Se tiene acceso al servicio (por ejemplo, iniciar y detener) mediante el Administrador de Control de servicios.  
  
 El ejecutable llama el <xref:System.ServiceProcess.ServiceBase> derivada tiempo el primer constructor de la clase llamar a Start en el servicio. El <xref:System.ServiceProcess.ServiceBase.OnStart%2A> se denomina método de gestión de comandos inmediatamente después de que el constructor se ejecuta. El constructor no se ejecuta después de la primera vez que se han cargado el servicio, por lo que es necesario separar el procesamiento realizado por el constructor del realizado por <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Todos los recursos que se pueden liberar por <xref:System.ServiceProcess.ServiceBase.OnStop%2A> deben crearse en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creación de recursos en el constructor impide que se creen adecuadamente si se inicia el servicio de nuevo después de <xref:System.ServiceProcess.ServiceBase.OnStop%2A> ha liberado los recursos.  
  
 El Administrador de Control de servicios (SCM) proporciona una manera de interactuar con el servicio. Puede utilizar el SCM para pasar iniciar, detener, pausar, continuar o comandos personalizados en el servicio. El SCM utiliza los valores de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> y <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> para determinar si el servicio acepta detener, pausar o continuar comandos. Detener, pausar y continuar están habilitadas en solo si en del SCM contexto menús la propiedad correspondiente <xref:System.ServiceProcess.ServiceBase.CanStop%2A> o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `true` en la clase de servicio. Si está habilitada, el comando se pasa al servicio, y <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> se llama. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el método de gestión de comandos correspondiente (como <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) no se procesarán, incluso si ha implementado el método.  
  
 Puede usar el <xref:System.ServiceProcess.ServiceController> clase para realizar mediante programación lo que el SCM hace mediante una interfaz de usuario. Puede automatizar las tareas disponibles en la consola. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `true` pero no se implementa un método de control de comandos correspondiente (como <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) el sistema produce una excepción y omite el comando.  
  
 No es necesario implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, o cualquier otro método en <xref:System.ServiceProcess.ServiceBase>. Sin embargo, el comportamiento del servicio se describe en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, por lo que como mínimo, se debe invalidar este miembro. El `main()` función del ejecutable registra el servicio en el ejecutable con el Administrador de Control de servicio mediante una llamada a la <xref:System.ServiceProcess.ServiceBase.Run%2A> método. El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> propiedad de la <xref:System.ServiceProcess.ServiceBase> objeto pasa a la <xref:System.ServiceProcess.ServiceBase.Run%2A> método debe coincidir con el <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> propiedad del instalador del servicio para ese servicio.  
  
 Puede usar `InstallUtil.exe` para instalar servicios del sistema.  
  
> [!NOTE]
>  Puede especificar un registro distinto del registro de eventos de aplicación para recibir la notificación de llamadas de servicio, pero no la <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ni <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad puede escribir en un registro personalizado. Establecer <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` si no desea utilizar el registro automático.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No cree una instancia de la <xref:System.ServiceProcess.ServiceBase> clase. En su lugar, se derivan de <xref:System.ServiceProcess.ServiceBase> y crear una instancia de la clase derivada. Lo mínimo que se debe implementar en el constructor para una clase heredada de <xref:System.ServiceProcess.ServiceBase> consiste en establecer el <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> en el componente. En concreto no se requiere ningún otro procesamiento en el constructor. Debe controlar la mayoría de inicialización en <xref:System.ServiceProcess.ServiceBase.OnStart%2A> en lugar de en el constructor. En caso contrario, no hay ninguna garantía de que los objetos se reinicializará cuando se reinicia un servicio después de que se ha detenido.  
  
 Si reemplaza el constructor de la clase derivada, llame al constructor de clase base en el código.  
  
 El <xref:System.ServiceProcess.ServiceBase> constructor establece <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true`. Si no desea registrar automáticamente las llamadas al servicio desde el Administrador de Control de servicios (SCM), establezca <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false`.  
  
 Si el archivo ejecutable contiene un único servicio, el sistema llama al constructor del servicio cuando inicio está seleccionado en el SCM y ejecuta el destructor si se llama a detener.  
  
 Si el archivo ejecutable contiene varios servicios, al llamar a iniciar en un servicio, los constructores llamarlo para todos los servicios en el archivo ejecutable, pero se inicia sólo el servicio especificado. Destructores para los servicios se ejecutan juntos cuando todos los servicios se han detenido, no individualmente cuando se detiene cada servicio.  
  
> [!NOTE]
>  Si reemplaza el constructor de clase base, se debe llamar explícitamente en el constructor de la clase derivada.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si los comandos Iniciar, Detener, Pausar y Continuar deben notificarse en el registro de eventos.</summary>
        <value>
          <see langword="true" /> para notificar información en el registro de eventos; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `true` indica al servicio que utilice el registro de eventos de aplicación para notificar errores de comandos, así como información de cambio de estado para iniciar, detener, pausar y continuar eventos en el servicio. El nombre del servicio se utiliza como el registro <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Para enviar información a un registro de eventos personalizado en lugar de con el registro de aplicación, establezca <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` y escriba instrucciones en los métodos de control de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para registrar en el registro adecuado.  
  
> [!NOTE]
>  El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, lo que proporciona la cadena de origen para el registro de eventos, debe establecerse antes de que el servicio intenta escribir en el registro de eventos. Intentar obtener acceso al registro de eventos antes de establece el nombre del origen, produce una excepción.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el servicio puede controlar notificaciones de los cambios de estado de la alimentación del equipo.</summary>
        <value>
          <see langword="true" /> si el servicio controla los cambios de estado de la alimentación del equipo indicados en la clase <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando los cambios de estado de energía de equipo, en que el Administrador de Control de servicios (SCM) comprueba de si el servicio acepta comandos de eventos de energía con el valor de <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> es `true`, el comando se pasa al servicio y el <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> método se llama si ha definido. Si <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> no se ha implementado en la clase derivada, el SCM controla el evento de energía a través de la clase base vacía <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se modifica después de haber iniciado el servicio.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el servicio puede controlar eventos de cambio de sesión recibidos de una sesión de Terminal Server.</summary>
        <value>
          <see langword="true" /> si el servicio puede controlar eventos de cambio de sesión de Terminal Server; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se modifica después de haber iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se puede pausar y reanudar el servicio.</summary>
        <value>
          <see langword="true" /> si se puede pausar el servicio; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca el valor de la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propiedad en el constructor para el servicio.  
  
 Cuando se pausa un servicio, se detiene lo que está haciendo. Si continúa con el servicio (ya sea mediante el Administrador de Control de servicios o mediante programación), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> se ejecuta.  
  
 Enviar una solicitud de pausa en el servicio puede ahorrar recursos del sistema. Pausa no puede liberar todos los recursos del sistema, pero detener sí lo hace. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> a menudo se implementan para llevar a cabo un procesamiento menor que <xref:System.ServiceProcess.ServiceBase.OnStop%2A> y <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `true`, invalidar <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para especificar el procesamiento que debe producirse cuando el Administrador de Control de servicios (SCM) pasa una solicitud Pausar o continuar al servicio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> debe implementarse para deshacer el procesamiento en <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el SCM no pasará pausar o continuar solicitudes al servicio, por lo que la <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos no se llamará incluso si se implementan. En el SCM, la `Pause` y `Continue` controles están deshabilitados cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe informar al servicio de que el sistema se está cerrando.</summary>
        <value>
          <see langword="true" /> si se debe notificar al servicio cuando se está cerrando el sistema; en caso contrario, <see langword="false" />.  El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> es `true`, el servicio es una notificación cuando el sistema se está cerrando. Al apagar el equipo, el <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> se denomina método si se ha implementado en la clase derivada.  
  
> [!NOTE]
>  Solamente el sistema debe hacer el <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> método para ejecutar; el servicio puede llamarlo, pero no se recomienda hacerlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si puede detenerse el servicio una vez se ha iniciado.</summary>
        <value>
          <see langword="true" /> si se puede detener el servicio y llamar al método <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a detener en un servicio, el Administrador de Control de servicios (SCM) comprueba si el servicio acepta comandos Detener con el valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Para la mayoría de los servicios, el valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `true`, pero algunos servicios del sistema operativo, por ejemplo, no permiten al usuario detenerlos.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `true`, el comando Detener se pasa al servicio y el <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se denomina método si se ha definido. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> no está implementada en la clase derivada, el SCM controla el comando Detener a través de la clase base vacía <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Se deshace de los recursos (distintos de la memoria) que usa <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.ServiceProcess.ServiceBase.Dispose%2A> en su clase derivada (y a través de él, en la <xref:System.ServiceProcess.ServiceBase> clase) cuando haya terminado de usar la clase derivada. El <xref:System.ServiceProcess.ServiceBase.Dispose%2A> método deja la clase derivada en un estado no utilizable. Después de llamar a <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, debe liberar todas las referencias a la clase derivada y <xref:System.ServiceProcess.ServiceBase> para que la memoria que se estaba ocupando puede ser reclamada por la recolección.  
  
> [!NOTE]
>  Llame siempre a <xref:System.ServiceProcess.ServiceBase.Dispose%2A> antes de liberar la última referencia a la clase derivada de <xref:System.ServiceProcess.ServiceBase>. En caso contrario, los recursos <xref:System.ServiceProcess.ServiceBase> y la clase derivada usa will no se liberarán hasta que la colección de elementos no utilizados llama a los destructores de los objetos.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se implementa a menudo para procesar el código en <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinado con una llamada a <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Si decide hacerlo en la clase derivada, lo habitual es implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para asignar cualquier <xref:System.ServiceProcess.ServiceBase.Dispose%2A> publicado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un registro de eventos que se puede utilizar para escribir la notificación de llamadas de comandos de servicio, como Iniciar y Detener, en el registro de eventos de aplicación.</summary>
        <value>Instancia de <see cref="T:System.Diagnostics.EventLog" /> cuyo origen se encuentra registrado en el registro de aplicaciones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor inicializa la <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad a una instancia con la <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> y <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> propiedades establecidas. El origen es el <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servicio, y el registro es el registro de aplicación del equipo. Estos valores se establecen automáticamente y no se puede cambiar para el registro automático de comandos de servicio.  
  
 Cuando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> es `true`, iniciar, detener, pausar, continuar y comandos personalizados se registran automáticamente en el registro de eventos de aplicación. Puede usar el <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad para escribir mensajes adicionales en ese registro. Las llamadas de componentes <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> mediante este <xref:System.ServiceProcess.ServiceBase.EventLog%2A> miembro.  
  
 Para enviar información a un registro de eventos personalizado en lugar de con el registro de aplicación, establezca <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> a `false` y escriba instrucciones en los métodos de control de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para registrar en el registro adecuado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el código de salida para el servicio.</summary>
        <value>El código de salida para el servicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> propiedad en un valor distinto de cero antes de detener el servicio para indicar un error con el Administrador de Control de servicios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Indica el tamaño máximo de un nombre de servicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName y DisplayName tienen restricciones de tamaño que deben tenerse en cuenta al establecer las propiedades en la clase de servicio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía un comando Continuar al servicio. Especifica las acciones que deben realizarse cuando se reanuda el funcionamiento normal de un servicio después de una pausa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implemente <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para reflejar la respuesta de la aplicación a <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Si continúa con el servicio (ya sea a través de la consola Servicios o mediante programación), el <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> de procesamiento se ejecuta y el servicio vuelve a estar activo.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> se espera que reemplazarse cuando la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propiedad es `true`.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el SCM no pasará pausar o continuar solicitudes al servicio, por lo que la <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos no se llamará incluso si se implementan. En el SCM, la `Pause` y `Continue` controles están deshabilitados cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Mensaje de comando enviado al servicio.</param>
        <summary>Si se implementa en una clase derivada, <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) pasa un comando personalizado al servicio. Especifica las acciones que deben realizarse cuando se ejecuta un comando con el valor de parámetro especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> le permite especificar funcionalidad adicional al iniciar, detener, pausar y continuar servicios.  
  
 El SCM no examina el comando personalizado para comprobar si el servicio admite la `command` parámetro pasado con. El comando personalizado pasa directamente al servicio. Si el servicio no reconoce el `command` parámetro, no realiza ninguna acción.  
  
 Comandos personalizados generados por una <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instrucción en un <xref:System.ServiceProcess.ServiceController> componente. Use una instrucción switch o si... a continuación, la condición que se va a controlar los comandos personalizados que defina en el servicio.  
  
 Los únicos valores para un comando personalizado que puede definir en la aplicación o usar en <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> son aquellos entre 128 y 255. Los enteros inferiores a 128 corresponden a valores reservados por el sistema.  
  
 Si el <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> propiedad es `true`, los comandos personalizados, al igual que todos los demás comandos, escriben entradas en el registro de eventos para notificar si la ejecución del método se realizó correctamente o no.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía un comando Pausar al servicio. Especifica las acciones que deben realizarse cuando un servicio realiza una pausa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnPause%2A> para especificar el procesamiento que se produce cuando el servicio recibe un comando Pausar. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> se espera que reemplazarse cuando la <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propiedad es `true`.  
  
 Al continuar un servicio en pausa (ya sea a través de la consola Servicios o mediante programación), el <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> el procesamiento se ejecuta y el servicio vuelve a estar activo.  
  
 El comando Pausar sólo permite la aplicación reaccionar ante un evento específico. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> no hace nada para el servicio que lo define hacer.  
  
 Enviar una solicitud de pausa en el servicio puede ahorrar recursos del sistema porque pausar no necesita liberar todos los recursos del sistema. Por ejemplo, si se han abierto los subprocesos por el proceso, pausar un servicio en lugar de detenerlo puede permitir que los subprocesos permanezcan abiertos, obviando la necesidad de reasignarlos cuando el servicio sigue. Si define pausar para que libere todos los recursos del sistema, se comporta como un comando de detención.  
  
 Establecer <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> a `true`e invalidar <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para especificar el procesamiento que debe producirse cuando el SCM pasa una solicitud Pausar o continuar al servicio. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> debe implementarse para deshacer el procesamiento en <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`, el SCM no pasará pausar o continuar solicitudes al servicio, por lo que la <xref:System.ServiceProcess.ServiceBase.OnPause%2A> y <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos no se llamará aunque estén implementados. En el SCM, la `Pause` y `Continue` controles están deshabilitados cuando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> es `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">
          <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> que indica una notificación del sistema sobre su estado de la alimentación.</param>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el estado de la alimentación del equipo cambia. Esto se aplica a equipos portátiles cuando entran en modo suspendido, que no es lo mismo que un cierre de sistema.</summary>
        <returns>Cuando se implementa en una clase derivada, las necesidades de la aplicación determinan qué valor se debe devolver. Por ejemplo, si se pasa un estado de difusión <see langword="QuerySuspend" />, puede hacerse que la aplicación rechace la consulta mediante un valor devuelto <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> para especificar el procesamiento que se produce cuando el evento del sistema indicado en la <xref:System.ServiceProcess.PowerBroadcastStatus> enumeración se produce, por ejemplo, cuando el equipo se pone en modo de suspensión o indica la alimentación de batería baja.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> se espera que reemplazarse cuando la <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> propiedad es `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Estructura que identifica el tipo de cambio.</param>
        <summary>Se ejecuta cuando se recibe un evento de cambio de una sesión de Terminal Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe establecer el <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> propiedad `true` para habilitar la ejecución de este método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el sistema se está cerrando. Especifica lo que tiene que suceder inmediatamente antes de que se cierre el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> para especificar el procesamiento que se produce cuando el sistema se apaga.  
  
 Este evento sólo se produce cuando se apaga el sistema operativo, no cuando el equipo está apagado.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> se espera que reemplazarse cuando la <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> propiedad es `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Datos pasados por el comando Iniciar.</param>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía un comando Iniciar al servicio o cuando se inicia el sistema operativo (en el caso de un servicio que se inicia de forma automática). Especifica las acciones que deben realizarse cuando se inicia el servicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para especificar el procesamiento que se produce cuando el servicio recibe un comando de inicio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> es el método en el que se especifica el comportamiento del servicio. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> puede tomar argumentos como una manera de pasar datos, pero este uso es poco frecuente.  
  
> [!CAUTION]
>  No utilice el constructor para realizar el procesamiento que debería estar en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para controlar toda la inicialización del servicio. Se llama al constructor al ejecutable de la aplicación se ejecuta, no cuando se ejecuta el servicio. El ejecutable se ejecuta antes de <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Al pasar, por ejemplo, se llama al constructor no nuevo porque el SCM ya contiene el objeto en la memoria. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> libera los recursos asignados en el constructor en lugar de en <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, los recursos necesarios no se crearán la segunda vez que se llama al servicio.  
  
 Servicios pueden establecerse para iniciarse automáticamente cuando se reinicia el equipo estableciendo el <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> en el instalador del servicio para <xref:System.ServiceProcess.ServiceStartMode.Automatic>. En esta situación, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> se denominaría al iniciarse el sistema.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> se espera que sea reemplazado en la clase derivada. Para que sean útiles, el servicio <xref:System.ServiceProcess.ServiceBase.OnStart%2A> y <xref:System.ServiceProcess.ServiceBase.OnStop%2A> tienen que implementarse en la clase de servicio.  
  
 Procesar argumentos de inicialización para el servicio en la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método, no en el método Main. Los argumentos en la `args` matriz de parámetros se puede establecer manualmente en la ventana de propiedades para el servicio en la consola de servicios. Los argumentos especificados en la consola no se guardan; se pasan al servicio de forma única el servicio se inicia desde el panel de control. Argumentos que deben estar presentes cuando se inicia automáticamente el servicio se pueden colocar en el valor de cadena ImagePath para la clave de registro del servicio (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<nombre del servicio >*). Puede obtener los argumentos en el registro mediante el <xref:System.Environment.GetCommandLineArgs%2A> método, por ejemplo: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si se implementa en una clase derivada, se ejecuta cuando el Administrador de control de servicios (SCM, Service Control Manager) envía a un comando Detener al servicio. Especifica las acciones que deben realizarse cuando un servicio deja de ejecutarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para especificar el procesamiento que se produce cuando el servicio recibe un comando de detención.  
  
 Cuando el SCM recibe un comando de detención, usa el valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> para comprobar si el servicio acepta comandos Detener. Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `true`, el comando Detener se pasa al servicio y el <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se denomina método si se ha definido. Si <xref:System.ServiceProcess.ServiceBase.OnStop%2A> no está implementada en el servicio, el SCM controla el comando Detener.  
  
 Si <xref:System.ServiceProcess.ServiceBase.CanStop%2A> es `false`, el SCM omite el comando Detener. No se pasa al servicio. El comando de detención se devuelve y produce una excepción.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> se espera que sea reemplazado en la clase derivada. Para que sean útiles, el servicio <xref:System.ServiceProcess.ServiceBase.OnStart%2A> y <xref:System.ServiceProcess.ServiceBase.OnStop%2A> tienen que implementarse en la clase de servicio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Tiempo solicitado en milisegundos.</param>
        <summary>Solicita tiempo adicional para una operación pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> método está pensado para ser invocado por el invalidado <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> métodos para solicitar más tiempo para que una operación pendiente, para impedir que el Administrador de Control de servicios (SCM) marque el servicio como no responde.  Si la operación pendiente no es continuar, pausar, iniciar o detener y un <xref:System.InvalidOperationException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El servicio no está en estado pendiente.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona el punto de entrada principal para un ejecutable de servicio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.ServiceProcess.ServiceBase" /> que indica que va a iniciarse un servicio.</param>
        <summary>Registra el ejecutable para un servicio con el Administrador de control de servicios (SCM, Service Control Manager).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta sobrecarga en el `main()` funcionamiento del servicio ejecutable para registrar el servicio con el Administrador de Control de servicios. Después de llamar a <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, el Administrador de Control de servicios envía un comando de inicio, lo que resulta en una llamada a la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método en el servicio. El servicio no se inicia hasta que se ejecuta el comando de inicio.  
  
 El <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> se denomina método de la misma manera como <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> para aplicaciones de Windows Forms.  
  
 Si <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> es `true`, se escribe una entrada en el registro de eventos si el servicio especificado por el `service` parámetro no se puede iniciar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Una matriz de instancias de ServiceBase, que indica los servicios que se van a iniciar.</param>
        <summary>Registra el ejecutable para varios servicios con el Administrador de control de servicios (SCM, Service Control Manager).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta sobrecarga en el `main()` funcionamiento del servicio ejecutable para registrar los servicios con el Administrador de Control de servicios. Después de llamar a <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, el Administrador de Control de servicios ejecuta comandos de inicio, que producen llamadas a la <xref:System.ServiceProcess.ServiceBase.OnStart%2A> métodos en los servicios. Los servicios no se inician hasta que se ejecutan los comandos de inicio.  
  
 El <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> se denomina método de la misma manera como el <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> método para aplicaciones de Windows Forms.  
  
 Si <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> es `true`, se escribe una entrada en el registro de eventos si cualquier servicio de la matriz no se inicia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No proporcionó un servicio para que se inicie. La matriz podría ser <see langword="null" /> o estar vacía.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador del control de servicios para el servicio.</summary>
        <value>Una estructura <see cref="T:System.IntPtr" /> que contiene el identificador del control de servicios para el servicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El identificador del control de servicio se usa para comunicarse con el Administrador de Control de servicios (SCM).  El identificador puede usarse para actualizar la información de estado del Administrador de control de servicios para el servicio que realiza la llamada mediante la no administrada `SetServiceStatus` función.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Número de argumentos de la matriz de argumentos.</param>
        <param name="argPointer">Estructura <see cref="T:System.IntPtr" /> que señala a una matriz de argumentos.</param>
        <summary>Registra el controlador de comandos e inicia el servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre corto utilizado para identificar el servicio en el sistema.</summary>
        <value>Nombre del servicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifica el servicio con el Administrador de Control de servicios. El valor de esta propiedad debe ser idéntico al nombre registrado para el servicio en la <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> propiedad de la clase del instalador correspondiente. En el código, el <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> del servicio se establece normalmente el `main()` función del archivo ejecutable.  
  
 El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> también se utiliza para especificar el <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> asociados con el <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propiedad. Esto <xref:System.ServiceProcess.ServiceBase.EventLog%2A> es una instancia que escribe información de comandos de servicio en el registro de aplicación.  
  
 El <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, lo que proporciona la cadena de origen para el registro de eventos, debe establecerse antes de que el servicio se escribe en el registro de eventos. Intentar obtener acceso al registro de eventos antes de establece el nombre del origen, produce una excepción que se produzca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ya se inició el servicio. La propiedad <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> no puede cambiarse una vez iniciado el servicio.</exception>
        <exception cref="T:System.ArgumentException">El nombre especificado es una cadena de longitud cero o es más largo que <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, o el nombre especificado contiene caracteres de barra diagonal o barra diagonal inversa.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detiene el servicio en ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ServiceProcess.ServiceBase.Stop%2A> método establece el estado del servicio para indicar una detención pendiente y llama el <xref:System.ServiceProcess.ServiceBase.OnStop%2A> método.  Cuando se detiene la aplicación, el estado del servicio se establece en detenido. Si la aplicación es un servicio hospedado, se descarga el dominio de aplicación.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>