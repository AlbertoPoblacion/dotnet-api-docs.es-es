<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a247d2896ea3528404d0f1bb04ecb2c3a4bb676" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37485455" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un lector que proporciona acceso rápido a datos XML, sin almacenamiento en caché y con desplazamiento solo hacia delante.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> proporciona acceso de solo avance y solo lectura a los datos en un documento o secuencia XML. Esta clase se ajusta a la W3C [Extensible Markup Language (XML) 1.0 (fourth edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) y [espacios de nombres en XML 1.0 (tercera edición)](https://www.w3.org/TR/REC-xml-names/) recomendaciones.  
  
 <xref:System.Xml.XmlReader> los métodos que permiten desplazarse por los datos XML y leer el contenido de un nodo. Las propiedades de la clase reflejan el valor del nodo actual, que es donde se coloca el lector. El <xref:System.Xml.XmlReader.ReadState%2A> valor de propiedad indica el estado actual del lector XML. Por ejemplo, la propiedad se establece en <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> por la <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método y <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> por el <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> método. <xref:System.Xml.XmlReader> También proporciona comprobaciones del cumplimiento en datos y la validación con una DTD o esquema.  
  
 <xref:System.Xml.XmlReader> usa un modelo de extracción para recuperar datos. Este modelo:  
  
-   Simplifica la administración de estados mediante un perfeccionamiento natural, de arriba a abajo procedimientos.  
  
-   Admite varios flujos de entrada y distribución en capas.  
  
-   Permite al cliente proporcionar al analizador un búfer en el que se escribe directamente la cadena y, por tanto, evita la necesidad de una copia de la cadena adicional.  
  
-   Admite el procesamiento selectivo. El cliente puede omitir los elementos y procesarlos que son de interés para la aplicación. También puede establecer propiedades de antemano para administrar cómo se procesa la secuencia XML (por ejemplo, la normalización).  
  
 En esta sección:  
  
 [Crear un lector XML](#xmlreader_create)   
 [Validación de datos XML](#xmlreader_validate)   
 [Cumplimiento en datos](#xmlreader_data)   
 [Navegar por los nodos](#xmlreader_nodes)   
 [Elementos XML de lectura](#xmlreader_elements)   
 [Atributos de lectura XML](#xmlreader_attributes)   
 [Contenido XML de lectura](#xmlreader_content)   
 [Convertir a tipos CLR](#xmlreader_clr)   
 [Programación asincrónica](#xmlreader_async)   
 [Consideraciones de seguridad](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Crear un lector XML  
 Use la <xref:System.Xml.XmlReader.Create%2A> método para crear un <xref:System.Xml.XmlReader> instancia.  
  
 Aunque .NET Framework proporciona implementaciones concretas de la <xref:System.Xml.XmlReader> clase, como el <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>y el <xref:System.Xml.XmlValidatingReader> clases, se recomienda que utilice las clases especializadas solo en estos escenarios:  
  
-   Si desea leer un subárbol DOM XML desde un <xref:System.Xml.XmlNode> de objeto, utilice el <xref:System.Xml.XmlNodeReader> clase. (Sin embargo, esta clase no admite validación de DTD o esquema).  
  
-   Si debe expandir entidades a solicitud, no desea que el texto contenido normalizado o no desea que los atributos devueltos predeterminados, use la <xref:System.Xml.XmlTextReader> clase.  
  
 Para especificar el conjunto de características que desea habilitar en el lector XML, pase un <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> de objeto para el <xref:System.Xml.XmlReader.Create%2A> método. Puede usar una sola <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> de objeto para crear varios lectores con la misma funcionalidad o modificar el <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> objeto para crear un nuevo lector con un conjunto de características diferente. También puede agregar características a un sistema de lectura existente.  
  
 Si no usa un <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> de objeto, se utiliza la configuración predeterminada. Consulte la <xref:System.Xml.XmlReader.Create%2A> página de referencia para obtener más información.  
  
 <xref:System.Xml.XmlReader> se produce un <xref:System.Xml.XmlException> errores de análisis de XML. Una vez que se produce una excepción, el estado del lector no es predecible. Por ejemplo, el tipo de nodo notificado puede ser diferente del tipo de nodo real del nodo actual. Use el <xref:System.Xml.XmlReader.ReadState%2A> propiedad para comprobar si el lector está en estado de error.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Validación de datos XML  
 Para definir la estructura de un documento XML y sus relaciones de elementos, tipos de datos y restricciones de contenido, utilice una definición de tipo de documento (DTD) o esquema (XSD). Un documento XML se considera correcto si cumple todos los requisitos sintácticos que define la [recomendación W3C XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/). Se considera válido si es correcto y además cumpla las restricciones que define su DTD o esquema. (Vea el [W3C XML Schema Part 1: estructuras](https://www.w3.org/TR/xmlschema-1/) y [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/)recomendaciones.) Por lo tanto, aunque todos los documentos XML válidos sean correctos, no todos los documentos XML correctos son válidos.  
  
 Puede validar los datos con una DTD, un esquema XSD, en línea o un esquema XSD se almacena en un <xref:System.Xml.Schema.XmlSchemaSet> objeto (caché); estos escenarios se describen en la <xref:System.Xml.XmlReader.Create%2A> página de referencia. <xref:System.Xml.XmlReader> no admite la validación de esquemas reducidos de datos XML (XDR).  
  
 Utilice la siguiente configuración en el <xref:System.Xml.XmlReaderSettings> clase para especificar qué tipo de validación, si existe, el <xref:System.Xml.XmlReader> instancia admite.  
  
|Use esta <xref:System.Xml.XmlReaderSettings> miembro|Para especificar|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|Propiedad <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|Si se permite el procesamiento de DTD. El valor predeterminado es no permitir el procesamiento de DTD.|  
|Propiedad <xref:System.Xml.XmlReaderSettings.ValidationType%2A>|Si el lector debe validar los datos y qué tipo de validación que se debe realizar (DTD o esquema). El valor predeterminado es que no hay validación de datos.|  
|Evento <xref:System.Xml.XmlReaderSettings.ValidationEventHandler>|Un controlador de eventos para recibir información sobre los eventos de validación. Si no se proporciona un controlador de eventos, se inicia una <xref:System.Xml.XmlException> en el primer error de validación.|  
|Propiedad <xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|Opciones de validación adicional a través de la <xref:System.Xml.Schema.XmlSchemaValidationFlags> miembros de enumeración:<br /><br /> -   `AllowXmlAttributes`--Permitir atributos XML (`xml:*`) en documentos de instancia, incluso cuando no se han definido en el esquema. Los atributos se validan basándose en su tipo de datos. Consulte la <xref:System.Xml.Schema.XmlSchemaValidationFlags> página de referencia de la configuración para usar en escenarios concretos. (Deshabilitado de forma predeterminada).<br />-   `ProcessIdentityConstraints` --Procesa las restricciones de identidad (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) encontrado durante la validación. (Habilitada de forma predeterminada).<br />-   `ProcessSchemaLocation` --Procesar esquemas que especifican el `xsi:schemaLocation` o `xsi:noNamespaceSchemaLocation` atributo. (Habilitada de forma predeterminada).<br />-   `ProcessInlineSchema`--Procesar insertada esquemas XML durante la validación. (Deshabilitado de forma predeterminada).<br />-   `ReportValidationWarnings`--Informar de eventos si se produce una advertencia de validación. Normalmente se produce una advertencia cuando no hay ninguna DTD ni esquema XML para validar un elemento o atributo en particular. <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> se utiliza para las notificaciones. (Deshabilitado de forma predeterminada).|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<xref:System.Xml.Schema.XmlSchemaSet> que se va a usar para validación.|  
|Propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|El <xref:System.Xml.XmlResolver> para resolver y tener acceso a recursos externos. Esto puede incluir entidades externas, como DTD y esquemas y cualquier `xs:include` o `xs:import` elementos contenidos en el esquema XML. Si no especifica un <xref:System.Xml.XmlResolver>, <xref:System.Xml.XmlReader> usa un valor predeterminado <xref:System.Xml.XmlUrlResolver> sin credenciales de usuario.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Cumplimiento en datos  
 Los lectores XML que se crean mediante el <xref:System.Xml.XmlReader.Create%2A> método cumplir los siguientes requisitos de cumplimiento de forma predeterminada:  
  
-   Las líneas nuevas y el valor del atributo se normalizan según el W3C [recomendación XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Todas las entidades se expanden automáticamente.  
  
-   Siempre se agregan atributos predeterminados declarados en la definición de tipo de documento incluso cuando no valida el lector.  
  
-   Se permite la declaración de prefijo XML asignado para el espacio de nombres XML correcto URI.  
  
-   Los nombres de notación de una sola `NotationType` declaración de atributos y `NmTokens` en una sola `Enumeration` declaración de atributo son distintos.  
  
 Use estos <xref:System.Xml.XmlReaderSettings> propiedades para especificar el tipo de conformidad comprueba desean habilitar:  
  
|Use esta <xref:System.Xml.XmlReaderSettings> propiedad|En|Default|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|Propiedad <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|Habilitar o deshabilitar comprueba lo siguiente:<br /><br /> -Caracteres están dentro del intervalo de caracteres XML legales, tal como se define por la [2.2 Characters](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) sección de la recomendación W3C XML 1.0.<br />-Todos los nombres XML son válidos, tal como se define por la [2.3 Common Syntactic Constructs construcciones](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) sección de la recomendación W3C XML 1.0.<br /><br /> Cuando esta propiedad se establece en `true` (valor predeterminado), un <xref:System.Xml.XmlException> excepción se produce si el archivo XML contiene caracteres no válidos o los nombres XML no válidos (por ejemplo, un nombre de elemento se inicia con un número).|Carácter y comprobación de nombres está habilitada.<br /><br /> Al establecer la propiedad <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> en `false`, se desactiva la comprobación de caracteres en las referencias a entidades de caracteres. Si el lector está procesando datos de texto, siempre comprueba que los nombres XML son válidos, independientemente de esta configuración. **Nota:** la recomendación XML 1.0 requiere que haya cumplimiento de nivel de documento cuando hay una DTD. Por lo tanto, si el lector está configurado para admitir <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, pero los datos XML contienen una definición de tipo de documento (DTD), un <xref:System.Xml.XmlException> se produce.|  
|Propiedad <xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|Elija el nivel de conformidad para aplicar:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Se ajusta a las reglas para un [documento XML 1.0 correcto](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Se ajusta a las reglas para un fragmento de documento con formato correcto que pueden utilizarse como un [externo entidad analizada](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Se ajusta al nivel decidido por el lector.<br /><br /> Si los datos no cumplen las reglas, un <xref:System.Xml.XmlException> es una excepción.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Navegar por los nodos  
 El nodo actual es el nodo XML en el que está situado actualmente el lector XML. Todos los <xref:System.Xml.XmlReader> métodos realizan operaciones en relación con este nodo y todos <xref:System.Xml.XmlReader> propiedades reflejan el valor del nodo actual.  
  
 Los métodos siguientes fácil desplazarse por los nodos y analizar datos.  
  
|Use esta <xref:System.Xml.XmlReaderSettings> (método)|En|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Leer el primer nodo y avanzar por el nodo de una secuencia a la vez. Tales llamadas se realizan normalmente dentro de un `while` bucle.<br /><br /> Use el <xref:System.Xml.XmlReader.NodeType%2A> propiedad va a obtener el tipo (por ejemplo, atributo, comentario, elemento etc.) del nodo actual.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Omitir a los elementos secundarios del nodo actual y pasar al siguiente nodo.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> y <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Omitir nodos sin contenido y pasar al siguiente nodo de contenido o hasta el final del archivo.<br /><br /> Los nodos no-content incluyen <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, y <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Nodos de contenido incluyen texto sin espacios en blanco, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , y <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Leer un elemento y todos sus elementos secundarios y devolver un nuevo <xref:System.Xml.XmlReader> instancia establecida en <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Este método es útil para crear límites alrededor de los elementos XML; Por ejemplo, si desea pasar datos a otro componente para su procesamiento y desea limitar la cantidad de los datos puede acceder el componente.|  
  
 Consulte la <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> página de referencia para obtener un ejemplo de la navegación a través de un una nodo secuencia de texto a la vez y muestra el tipo de cada nodo.  
  
 Las secciones siguientes describen cómo puede leer tipos específicos de datos, como elementos, atributos y tipos de datos.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Elementos XML de lectura  
 La tabla siguiente enumeran los métodos y propiedades que el <xref:System.Xml.XmlReader> proporciona clase para procesar elementos. Después de que <xref:System.Xml.XmlReader> se sitúe en un elemento, las propiedades del nodo como, por ejemplo, <xref:System.Xml.XmlReader.Name%2A>, reflejan los valores del elemento. Además de los miembros que se describen a continuación, también se puede utilizar cualquiera de los métodos y propiedades generales de la clase <xref:System.Xml.XmlReader> para procesar elementos. Por ejemplo, puede utilizar el método <xref:System.Xml.XmlReader.ReadInnerXml%2A> para leer el contenido de un elemento.  
  
> [!NOTE]
>  Vea la sección 3.1 de la [recomendación W3C XML 1.0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) para las definiciones de las etiquetas de inicio, finalización etiquetas y las etiquetas de elemento vacío.  
  
|Use esta <xref:System.Xml.XmlReader> miembro|En|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Método <xref:System.Xml.XmlReader.IsStartElement%2A>|Compruebe si el nodo actual es una etiqueta de apertura o una etiqueta de elemento vacío.|  
|Método <xref:System.Xml.XmlReader.ReadStartElement%2A>|Compruebe que el nodo actual es un elemento y avanzar el lector hasta el siguiente nodo (llamadas <xref:System.Xml.XmlReader.IsStartElement%2A> seguido <xref:System.Xml.XmlReader.Read%2A>).|  
|Método <xref:System.Xml.XmlReader.ReadEndElement%2A>|Compruebe que el nodo actual es una etiqueta de cierre y avanzar el lector hasta el siguiente nodo.|  
|Método <xref:System.Xml.XmlReader.ReadElementString%2A>|Leer un elemento de sólo texto.|  
|Método <xref:System.Xml.XmlReader.ReadToDescendant%2A>|Avanzar el lector XML al siguiente elemento descendiente (secundario) que tiene el nombre especificado.|  
|Método <xref:System.Xml.XmlReader.ReadToNextSibling%2A>|Avanzar el lector XML para el siguiente elemento relacionado que tenga el nombre especificado.|  
|Propiedad <xref:System.Xml.XmlReader.IsEmptyElement%2A>|Compruebe si el elemento actual tiene una etiqueta de elemento final. Por ejemplo:<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> es `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> es `false`, aunque el contenido del elemento está vacío.)|  
  
 Para obtener un ejemplo de leer el contenido de texto de elementos, vea el <xref:System.Xml.XmlReader.ReadString%2A> método. El ejemplo siguiente procesa elementos utilizando un `while` bucle.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Atributos de lectura XML  
 Los atributos XML se suelen encontrar en elementos, pero también se permiten en la declaración XML y los nodos de tipo de documento.  
  
 Cuando se coloca en un nodo de elemento, el <xref:System.Xml.XmlReader.MoveToAttribute%2A> método le permite ir a través de la lista de atributos del elemento. Tenga en cuenta que después <xref:System.Xml.XmlReader.MoveToAttribute%2A> se ha llamado, propiedades de nodo como <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, y <xref:System.Xml.XmlReader.Prefix%2A> reflejan las propiedades de ese atributo, no las propiedades del elemento el atributo que pertenece.  
  
 La <xref:System.Xml.XmlReader> clase proporciona estos métodos y propiedades para leer y procesar atributos en elementos.  
  
|Use esta <xref:System.Xml.XmlReader> miembro|En|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propiedad <xref:System.Xml.XmlReader.HasAttributes%2A>|Comprobar si el nodo actual tiene atributos.|  
|Propiedad <xref:System.Xml.XmlReader.AttributeCount%2A>|Obtiene el número de atributos en el elemento actual.|  
|Método <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>|Mover hasta el primer atributo en un elemento.|  
|Método <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>|Mover hasta el siguiente atributo en un elemento.|  
|Método <xref:System.Xml.XmlReader.MoveToAttribute%2A>|Mover a un atributo especificado.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> método o <xref:System.Xml.XmlReader.Item%2A> propiedad|Obtiene el valor de un atributo especificado.|  
|Propiedad <xref:System.Xml.XmlReader.IsDefault%2A>|Compruebe si el nodo actual es un atributo que se generó a partir del valor predeterminado definido en la DTD o esquema.|  
|Método <xref:System.Xml.XmlReader.MoveToElement%2A>|Desplazarse al elemento que posee el atributo actual. Utilice este método para devolver a un elemento después de navegar a través de sus atributos.|  
|Método <xref:System.Xml.XmlReader.ReadAttributeValue%2A>|Analizar el valor del atributo en uno o varios `Text`, `EntityReference`, o `EndEntity` nodos.|  
  
 También se puede utilizar cualquiera de las propiedades y los métodos <xref:System.Xml.XmlReader> generales para procesar atributos. Por ejemplo, después de situar <xref:System.Xml.XmlReader> en un atributo, las propiedades <xref:System.Xml.XmlReader.Name%2A> y <xref:System.Xml.XmlReader.Value%2A> reflejan los valores del atributo. También puede utilizar cualquiera de los métodos `Read` de contenido para obtener el valor del atributo.  
  
 Este ejemplo se usa el <xref:System.Xml.XmlReader.AttributeCount%2A> propiedad para navegar por todos los atributos de un elemento.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 Este ejemplo se usa el <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> método en un `while` bucle para navegar por los atributos.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Lectura de atributos en nodos de declaraciones XML**  
  
 Cuando se coloca el lector XML en un nodo de declaración XML, el <xref:System.Xml.XmlReader.Value%2A> propiedad devuelve la información de versión, independiente y codificación como una sola cadena. <xref:System.Xml.XmlReader> los objetos creados por el <xref:System.Xml.XmlReader.Create%2A> método, el <xref:System.Xml.XmlTextReader> (clase) y el <xref:System.Xml.XmlValidatingReader> clase exponer la versión, independiente y elementos de codificación como atributos.  
  
 **Lectura de atributos en nodos de tipo de documento**  
  
 Cuando se coloca el lector XML en un nodo de tipo de documento, el <xref:System.Xml.XmlReader.GetAttribute%2A> método y <xref:System.Xml.XmlReader.Item%2A> propiedad puede usarse para devolver los valores de los literales SYSTEM y PUBLIC. Por ejemplo, al llamar a `reader.GetAttribute("PUBLIC")`, se devuelve el valor PUBLIC.  
  
 **Lectura de atributos en nodos de instrucción de procesamiento**  
  
 Cuando <xref:System.Xml.XmlReader> está situado en un nodo de instrucción de procesamiento, la propiedad <xref:System.Xml.XmlReader.Value%2A> devuelve el contenido de texto completo. Elementos en el nodo de instrucción de procesamiento no se tratan como atributos. No se pueden leer con el <xref:System.Xml.XmlReader.GetAttribute%2A> o <xref:System.Xml.XmlReader.MoveToAttribute%2A> método.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Contenido XML de lectura  
 La clase XMLReader incluye a los siguientes miembros que leen el contenido de un archivo XML y devuelven el contenido como valores de cadena. (Para devolver tipos CLR, vea el [siguiente sección](#xmlreader_clr).)  
  
|Use esta <xref:System.Xml.XmlReader> miembro|En|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propiedad <xref:System.Xml.XmlReader.Value%2A>|Obtener el contenido de texto del nodo actual. El valor devuelto depende del tipo de nodo; Consulte la <xref:System.Xml.XmlReader.Value%2A> página de referencia para obtener más información.|  
|Método <xref:System.Xml.XmlReader.ReadString%2A>|Obtener el contenido de un nodo de elemento o de texto como una cadena. Este método detiene en instrucciones de procesamiento y comentarios.<br /><br /> Para obtener más información acerca de cómo este método controla los tipos de nodo específico, consulte la <xref:System.Xml.XmlReader.ReadString%2A> página de referencia.|  
|Métodos <xref:System.Xml.XmlReader.ReadInnerXml%2A> y <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>|Obtenga todo el contenido del nodo actual, incluido el marcado, pero sin incluir etiquetas inicial y final. Por ejemplo, para:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> Devuelve:<br /><br /> `this<child id="123"/>`|  
|Métodos <xref:System.Xml.XmlReader.ReadOuterXml%2A> y <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>|Obtenga todo el contenido del nodo actual y sus elementos secundarios, incluidas las etiquetas de marcado y el inicio y fin. Por ejemplo, para:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> Devuelve:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Convertir a tipos CLR  
 Puede usar los miembros de la <xref:System.Xml.XmlReader> clase (se muestran en la tabla siguiente) para leer datos XML y devolver valores como el de common language runtime (CLR) de tipos en lugar de cadenas. Estos miembros le permiten obtener valores en la representación que sea más adecuada para su tarea de codificación sin tener que analizar manualmente o convertir los valores de cadena.  
  
-   El **ReadElementContentAs** solo se puede llamar a métodos en tipos de nodo de elemento. Estos métodos no se pueden utilizar en elementos que contienen elementos segundarios o incluyen contenido mixto. Al llamar al objeto <xref:System.Xml.XmlReader>, éste lee la etiqueta de inicio y el contenido del elemento y, a continuación, se mueve después de la etiqueta del elemento de fin. Las instrucciones de procesamiento y los comentarios se omiten y las entidades se expanden.  
  
-   El **ReadContentAs** métodos leen el contenido de texto en la posición actual del lector y si los datos XML no tienen ningún esquema ni información asociada con él, de tipo de datos, convertir el contenido de texto en el tipo de valor devuelto solicitado. El texto, el espacio en blanco, el espacio en blanco significativo y las secciones CDATA se concatenan. Se omiten los comentarios y las instrucciones de procesamiento, y se resuelven automáticamente las referencias de entidad.  
  
 El <xref:System.Xml.XmlReader> clase utiliza las reglas definidas por el [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/)recomendación.  
  
|Use esta <xref:System.Xml.XmlReader> (método)|Para devolver este tipo CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> y <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|El tipo especificado con el `returnType` parámetro|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> y <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|El tipo más adecuado, según lo especificado por el <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> propiedad. Consulte [compatibilidad de tipos en las clases System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) de información de asignación.|  
  
 Si un elemento no puede convertirse fácilmente en un tipo CLR debido a su formato, puede usar una asignación de esquema para garantizar una conversión correcta. En el ejemplo siguiente se usa un archivo .xsd para convertir el `hire-date` elemento a la `xs:date` tipo y, a continuación, utiliza el <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> método para devolver el elemento como un <xref:System.DateTime> objeto.  
  
 **Entrada (Hiredate1.XML):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Esquema (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Código:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Salida:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Programación asincrónica  
 La mayoría de los <xref:System.Xml.XmlReader> métodos tienen equivalentes asincrónicos que tienen "Async" al final de los nombres de método. Por ejemplo, el equivalente asincrónico de <xref:System.Xml.XmlReader.ReadContentAsObject%2A> es <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Los métodos siguientes pueden usarse con llamadas de método asincrónico:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 Las secciones siguientes describen el uso asincrónico para métodos que no tienen equivalentes asincrónicos.  
  
 **Método ReadStartElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **Método ReadEndElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **Método ReadToNextSibling**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **Método ReadToFollowing**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **Método ReadToDescendant**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Consideraciones de seguridad  
 Tenga en cuenta lo siguiente al trabajar con el <xref:System.Xml.XmlReader> clase:  
  
-   Las excepciones producidas por la <xref:System.Xml.XmlReader> pueden revelar información de ruta de acceso que no es posible que desee que se ejecuta hasta la aplicación. La aplicación debe detectar las excepciones y procesarlas adecuadamente.  
  
-   No habilite el procesamiento de DTD si le preocupa la denegación de problemas de servicio o si trabaja con orígenes de confianza. El procesamiento de DTD está deshabilitado de forma predeterminada para <xref:System.Xml.XmlReader> los objetos creados por el <xref:System.Xml.XmlReader.Create%2A> método.  
  
     Si tiene habilitado el procesamiento de DTD, puede utilizar <xref:System.Xml.XmlSecureResolver> para restringir los recursos a los que tiene acceso <xref:System.Xml.XmlReader>. También puede diseñar la aplicación para que el procesamiento de XML es la memoria y restricciones de tiempo. Por ejemplo, puede configurar los límites de tiempo de espera en la aplicación ASP.NET.  
  
-   Los datos XML pueden incluir referencias a recursos externos como, por ejemplo, un archivo de esquemas. De forma predeterminada, los recursos externos se resuelven utilizando un <xref:System.Xml.XmlUrlResolver> objeto sin credenciales de usuario. Puede aumentar la protección aún más realizando cualquiera de las siguientes acciones:  
  
    -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> en un objeto <xref:System.Xml.XmlSecureResolver>.  
  
    -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> en `null`.  
  
-   El <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> y <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> marcas de validación de un <xref:System.Xml.XmlReaderSettings> objeto no se establecen de forma predeterminada. Esto ayuda a proteger el <xref:System.Xml.XmlReader> contra ataques basados en esquemas cuando está procesando datos XML de un origen que no es de confianza. Cuando se establecen estas marcas, se utiliza el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> del objeto <xref:System.Xml.XmlReaderSettings> para resolver las ubicaciones de esquemas que se encuentra en el documento de la instancia de <xref:System.Xml.XmlReader>. Si el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propiedad está establecida en `null`, las ubicaciones de esquemas no se resuelve incluso si la <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> y <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> se establecen marcas de validación.  
  
     Los esquemas agregados durante la validación agregan nuevos tipos y pueden cambiar el resultado de la validación del documento. Como consecuencia, los esquemas externos solo se deberían resolver desde orígenes de confianza.  
  
     Se recomienda deshabilitar el <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> marca al validar la confianza, grandes documentos XML en escenarios de alta disponibilidad con un esquema que tiene restricciones de identidad en una gran parte del documento. Esta marca está habilitada de forma predeterminada.  
  
-   Los datos XML pueden contener un gran número de atributos, declaraciones de espacios de nombres, elementos anidados, etc. cuyo procesamiento tarda una cantidad de tiempo importante. Para limitar el tamaño de la entrada que se envía a la <xref:System.Xml.XmlReader>, puede:  
  
    -   Limitar el tamaño del documento estableciendo el <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> propiedad.  
  
    -   Limitar el número de caracteres que resultan de expandir las entidades estableciendo la <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> propiedad.  
  
    -   Crear un personalizado `IStream` implementación para el <xref:System.Xml.XmlReader>.  
  
-   El <xref:System.Xml.XmlReader.ReadValueChunk%2A> método puede utilizarse para controlar grandes flujos de datos. Este método lee una pequeña cantidad de caracteres a la vez en lugar de asignar una única cadena para todo el valor.  
  
-   Al leer un documento XML con un gran número de nombres locales únicos, los espacios de nombres o prefijos, puede producirse un problema. Si usa una clase que derive de <xref:System.Xml.XmlReader>, y se llama a la <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, o <xref:System.Xml.XmlReader.NamespaceURI%2A> propiedad para cada elemento, la cadena devuelta se agrega a un <xref:System.Xml.NameTable>. La colección contenida por la <xref:System.Xml.NameTable> nunca disminuye de tamaño, creando una pérdida de memoria virtual de los identificadores de cadena. Una forma de mitigarlo es derivar de la <xref:System.Xml.NameTable> clase y aplicar una cuota de tamaño máximo. (No hay ninguna manera de evitar el uso de un <xref:System.Xml.NameTable>, o para cambiar el <xref:System.Xml.NameTable> cuando está lleno). Otra solución consiste en evitar el uso de las propiedades mencionadas y utilice en su lugar el <xref:System.Xml.XmlReader.MoveToAttribute%2A> método con el <xref:System.Xml.XmlReader.IsStartElement%2A> método siempre que sea posible; esos métodos no devuelven cadenas y, por tanto, evitar el problema de llenar demasiado la <xref:System.Xml.NameTable> colección.  
  
-   Los objetos <xref:System.Xml.XmlReaderSettings> pueden contener información confidencial como, por ejemplo, credenciales de usuario. Un componente que no sea de confianza podría utilizar el objeto <xref:System.Xml.XmlReaderSettings> y sus credenciales de usuario para crear objetos <xref:System.Xml.XmlReader> para leer datos. Tenga cuidado al almacenar en caché <xref:System.Xml.XmlReaderSettings> objetos, o al pasar el <xref:System.Xml.XmlReaderSettings> objeto de un componente a otro.  
  
-   No admita componentes como, por ejemplo, objetos <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> y <xref:System.Xml.XmlResolver>, de un origen que no sea de confianza.  
  
   
  
## Examples  
 Ejemplo de código siguiente muestra cómo usar la API asincrónica para analizar el XML.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see langword="XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor llama a constructores de clases derivadas para inicializar el estado de este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el número de atributos en el nodo actual.</summary>
        <value>Número de atributos del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es relevante para `Element`, `DocumentType` y `XmlDeclaration` sólo los nodos. (Otros tipos de nodos no tienen atributos).  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el identificador URI base del nodo actual.</summary>
        <value>Identificador URI base del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un documento XML en red se compone de fragmentos de datos agregados mediante varios mecanismos de inclusión estándar de W3C y, por tanto, contiene nodos que proceden de distintos lugares. Las entidades DTD son un ejemplo de esto, pero esto no se limita a las DTD. La base de URI explica procedencia de estos nodos. Si no hay ningún URI base para los nodos que se devuelven (por ejemplo, han analizado desde una cadena en memoria), `String.Empty` se devuelve.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xml.XmlReader" /> implementa los métodos de lectura de contenido binario.</summary>
        <value>Es <see langword="true" /> si se implementan los métodos de lectura de contenido binario; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lectura de contenido binario métodos incluyen la <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, y <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> métodos. Si esta propiedad devuelve `false` un <xref:System.NotSupportedException> se devuelve cuando cualquiera de los binarios de lectura se llama a métodos.  
  
 Todas las implementaciones de Microsoft .NET Framework de la <xref:System.Xml.XmlReader> clase retorno `true` para esta propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xml.XmlReader" /> implementa el método <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Xml.XmlReader" /> implementa el método <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Analizar texto <xref:System.Xml.XmlReader> objetos que se crearon desde estático <xref:System.Xml.XmlReader.Create%2A> método devuelven siempre `true`. Todas las otras implementaciones de Microsoft .NET Framework de la <xref:System.Xml.XmlReader> clase, incluido el <xref:System.Xml.XmlTextReader> class, devolver `false`.  
  
 Si esta propiedad devuelve `false` un <xref:System.NotSupportedException> se devuelve cuando el <xref:System.Xml.XmlReader.ReadValueChunk%2A> se llama al método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este lector puede analizar y resolver entidades.</summary>
        <value>Es <see langword="true" /> si el lector puede analizar y resolver entidades; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad siempre devuelve `false` para las implementaciones de <xref:System.Xml.XmlReader> que no admiten la información de DTD. En este caso, una llamada a <xref:System.Xml.XmlReader.ResolveEntity%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, cambia <see cref="P:System.Xml.XmlReader.ReadState" /> a <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método también libera los recursos utilizados durante la lectura. Si <xref:System.Xml.XmlReader.Close%2A> ya ha sido no llamado, se realiza ninguna acción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mayoría de los <xref:System.Xml.XmlReader.Create%2A> sobrecargas incluyen un `settings` parámetro que acepta un <xref:System.Xml.XmlReaderSettings> objeto. Puede utilizar este objeto:  
  
-   Especifique las características que van a admitir en el <xref:System.Xml.XmlReader> objeto.  
  
-   Reutilizar el <xref:System.Xml.XmlReaderSettings> objeto va a crear varios lectores. Puede utilizar los mismos valores para crear varios sistemas de lectura con la misma funcionalidad. O bien, puede modificar la configuración en un <xref:System.Xml.XmlReaderSettings> de instancia y crear un nuevo lector con un conjunto de características diferente.  
  
-   Agregar características a un lector XML existente. El método <xref:System.Xml.XmlReader.Create%2A> puede aceptar otro objeto <xref:System.Xml.XmlReader>. Subyacente <xref:System.Xml.XmlReader> objeto puede ser un lector definido por el usuario, un <xref:System.Xml.XmlTextReader> objeto u otro <xref:System.Xml.XmlReader> instancia que desea agregar características adicionales.  
  
-   Aprovechar al máximo las características, como una mejor comprobación de conformidad y el cumplimiento de la [XML 1.0 (fourth edition)](https://www.w3.org/TR/2006/REC-xml-20060816/)recomendación que solo están disponibles en <xref:System.Xml.XmlReader> los objetos creados por estático <xref:System.Xml.XmlReader.Create%2A> método.  
  
> [!NOTE]
>  Aunque .NET Framework incluye implementaciones concretas de la <xref:System.Xml.XmlReader> clase, como el <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>y el <xref:System.Xml.XmlValidatingReader> clases, le recomendamos que cree <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A> método.  
  
## <a name="default-settings"></a>Configuración predeterminada  
 Si usa un <xref:System.Xml.XmlReader.Create%2A> sobrecarga que no acepte un <xref:System.Xml.XmlReaderSettings> de objeto, se usan las siguientes configuraciones de lector predeterminadas:  
  
|Parámetro|Default|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Un objeto <xref:System.Xml.Schema.XmlSchemaSet> vacío|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> Habilitado|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Un nuevo objeto <xref:System.Xml.XmlUrlResolver>.  A partir de .NET Framework 4.5.2, esta configuración tiene un valor predeterminado de `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Configuración para escenarios comunes  
 Estos son los <xref:System.Xml.XmlReaderSettings> propiedades que se debe establecer para algunos de los escenarios típicos de lector XML.  
  
|Requisito|Set|  
|-----------------|---------|  
|Datos deben ser un documento XML bien formado.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> para <xref:System.Xml.ConformanceLevel.Document>.|  
|Datos deben ser una entidad analizada XML bien formada.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> para <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Datos deben validarse en relación con una DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> a <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> para <xref:System.Xml.ValidationType.DTD>.|  
|Datos se deben validar con un esquema XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> para el <xref:System.Xml.Schema.XmlSchemaSet> debe usarse para validar. Tenga en cuenta que <xref:System.Xml.XmlReader> no admite la validación de esquemas reducidos de datos XML (XDR).|  
|Datos se deben validar con un esquema XML alineado.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> para <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Compatibilidad de tipos.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> para el <xref:System.Xml.Schema.XmlSchemaSet> a usar.|  
  
 <xref:System.Xml.XmlReader> no admite la validación de esquemas reducidos de datos XML (XDR).  
  
## <a name="asynchronous-programming"></a>Programación asincrónica  
 En modo sincrónico, el <xref:System.Xml.XmlReader.Create%2A> método lee el primer fragmento de datos desde el búfer del lector de texto, secuencia o archivo. Esto puede producir una excepción si se produce un error en una operación de E/S. En modo asíncrono, la primera operación de E/S se produce con una operación de lectura, por lo que se producirá excepciones que surgen cuando se produce la operación de lectura.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 De forma predeterminada, el <xref:System.Xml.XmlReader> usa un <xref:System.Xml.XmlUrlResolver> objeto sin credenciales de usuario para abrir los recursos. Esto significa que, de forma predeterminada, el lector XML puede tener acceso a cualquier ubicación que no requiera credenciales. Use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propiedad para controlar el acceso a los recursos:  
  
-   Establecer <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a un <xref:System.Xml.XmlSecureResolver> objeto para restringir los recursos que puede tener acceso el lector XML.  
  
 O bien  
  
-   Establecer <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null` para evitar que el lector XML abra ningún recurso externo.  
  
   
  
## Examples  
 Este ejemplo crea un lector XML que elimina espacios en blanco insignificantes, elimina los comentarios y realiza la comprobación del cumplimiento de nivel de fragmento.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 En el ejemplo siguiente se usa un <xref:System.Xml.XmlUrlResolver> con credenciales predeterminadas para tener acceso a un archivo.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 El código siguiente encapsula una instancia del lector dentro de otro lector.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 En este ejemplo se vincula a los lectores de agregar validación de esquemas DTD y XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Flujo que contiene los datos XML.  <see cref="T:System.Xml.XmlReader" /> examina los primeros bytes de la secuencia buscando una marca de orden de bytes u otro signo de codificación. Cuando se especifica la codificación, esta se usa para seguir leyendo el flujo, y el procesamiento continúa analizando la entrada como un flujo de caracteres (Unicode).</param>
        <summary>Crea una nueva instancia <see cref="T:System.Xml.XmlReader" /> mediante el flujo especificado con la configuración predeterminada.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xml.XmlReaderSettings> objeto con la configuración predeterminada se usa para crear el lector. Si desea especificar las características que se admiten en el lector creado, utilice la sobrecarga que toma un <xref:System.Xml.XmlReaderSettings> objeto como uno de sus argumentos y pase un <xref:System.Xml.XmlReaderSettings> objeto con la configuración correcta.  
  
 Valor predeterminado es <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si el recurso externo se encuentra en un recurso de red que requiere autenticación, especifique un <xref:System.Xml.XmlResolver> con las credenciales necesarias mediante la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Xml.XmlReader> objeto que lee un <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> no tiene permisos suficientes para obtener acceso a la ubicación de los datos XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">Lector de texto desde el que se leen los datos XML. Un lector de texto devuelve un flujo de caracteres Unicode, por lo que el lector XML no usa la codificación especificada en la declaración XML para descodificar el flujo de datos.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> mediante el lector de texto especificado.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xml.XmlReaderSettings> objeto con la configuración predeterminada se usa para crear el lector. Si desea especificar las características que se admiten en el lector creado, utilice la sobrecarga que toma un <xref:System.Xml.XmlReaderSettings> objeto como uno de sus argumentos y pase un <xref:System.Xml.XmlReaderSettings> objeto con la configuración correcta.  
  
 Valor predeterminado es <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si el recurso externo se encuentra en un recurso de red que requiere autenticación, especifique un <xref:System.Xml.XmlResolver> con las credenciales necesarias mediante la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.StringReader> clase para leer una cadena XML.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI del archivo que contiene los datos XML. La clase <see cref="T:System.Xml.XmlUrlResolver" /> se utiliza para convertir la ruta de acceso en una representación de datos canónicos.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> con el URI especificado.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xml.XmlReaderSettings> objeto con la configuración predeterminada se usa para crear el lector. Si desea especificar las características que se admiten en el lector creado, utilice la sobrecarga que toma un <xref:System.Xml.XmlReaderSettings> objeto como uno de sus argumentos y pase un <xref:System.Xml.XmlReaderSettings> objeto con la configuración correcta.  
  
 Valor predeterminado es <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si el recurso externo se encuentra en un recurso de red que requiere autenticación, especifique un <xref:System.Xml.XmlResolver> con las credenciales necesarias mediante la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Xml.XmlReader> objeto que lee el archivo de datos XML que especifica el URI.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="inputUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> no tiene permisos suficientes para obtener acceso a la ubicación de los datos XML.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No existe el archivo identificado por el URI.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> En [.NET para aplicaciones de la Tienda Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), detecte la excepción de clase base, <see cref="T:System.FormatException" />, en su lugar.  </para>
          </block> El formato de URI no es correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Flujo que contiene los datos XML.  <see cref="T:System.Xml.XmlReader" /> examina los primeros bytes de la secuencia buscando una marca de orden de bytes u otro signo de codificación. Cuando se especifica la codificación, esta se usa para seguir leyendo el flujo, y el procesamiento continúa analizando la entrada como un flujo de caracteres (Unicode).</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> con el flujo y la configuración especificados.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Lector de texto desde el que se leen los datos XML. Un lector de texto devuelve un flujo de caracteres Unicode, por lo que el lector XML no usa la codificación especificada en la declaración XML para descodificar el flujo de datos.</param>
        <param name="settings">Configuración del nuevo <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <summary>Crea una nueva instancia <see cref="T:System.Xml.XmlReader" /> usando el lector de texto y la configuración especificados.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI del archivo que contiene los datos XML. El objeto <see cref="T:System.Xml.XmlResolver" /> del objeto <see cref="T:System.Xml.XmlReaderSettings" /> se utiliza para convertir la ruta de acceso en una representación de datos canónicos. Si <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> es <see langword="null" />, se utiliza un nuevo objeto <see cref="T:System.Xml.XmlUrlResolver" />.</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> usando el URI y la configuración especificados.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Esto significa que el <xref:System.Xml.XmlReader> puede tener acceso a cualquier ubicación que no requiere autenticación. Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede restringir los recursos que la <xref:System.Xml.XmlReader> puede tener acceso estableciendo el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propiedad a un <xref:System.Xml.XmlSecureResolver> objeto.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Xml.XmlReader> objeto que admita la validación de definición (DTD) de tipo de documento.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="inputUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado por el URI.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> En [.NET para aplicaciones de la Tienda Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), detecte la excepción de clase base, <see cref="T:System.FormatException" />, en su lugar.  </para>
          </block> El formato de URI no es correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto que desea usar como lector XML subyacente.</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />.  El nivel de conformidad del objeto <see cref="T:System.Xml.XmlReaderSettings" /> debe coincidir con el del lector subyacente o establecerse en <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> con el lector XML y la configuración especificados.</summary>
        <returns>Objeto que se encapsula alrededor del objeto <see cref="T:System.Xml.XmlReader" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite agregar características adicionales a una subyacente <xref:System.Xml.XmlReader> objeto. Subyacente <xref:System.Xml.XmlReader> objeto puede ser otro <xref:System.Xml.XmlReader> objeto creado por el <xref:System.Xml.XmlReader.Create%2A> método, o un <xref:System.Xml.XmlReader> objeto creado mediante uno de lo hormigón <xref:System.Xml.XmlReader> implementaciones.  
  
 Valor predeterminado es <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a los recursos externos, como un esquema.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si el recurso externo se encuentra en un recurso de red que requiere autenticación, especifique un <xref:System.Xml.XmlResolver> con las credenciales necesarias mediante la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
   
  
## Examples  
 El ejemplo siguiente crea una validación <xref:System.Xml.XmlReader> objeto ajustado alrededor de un <xref:System.Xml.XmlNodeReader> objeto.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="reader" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Si el objeto <see cref="T:System.Xml.XmlReaderSettings" /> especifica un nivel de conformidad que no es coherente con el nivel de conformidad del lector subyacente.  -o bien- El elemento <see cref="T:System.Xml.XmlReader" /> subyacente se encuentra en un estado <see cref="F:System.Xml.ReadState.Error" /> o <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Flujo que contiene los datos XML.  <see cref="T:System.Xml.XmlReader" /> examina los primeros bytes de la secuencia buscando una marca de orden de bytes u otro signo de codificación. Cuando se especifica la codificación, esta se usa para seguir leyendo el flujo, y el procesamiento continúa analizando la entrada como un flujo de caracteres (Unicode).</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <param name="baseUri">URI base de la entidad o documento que se lee. Este valor puede ser <see langword="null" />.  **Nota sobre seguridad** El URI base se usa para resolver el URI relativo del documento XML. No use un URI base de un origen que no sea de confianza.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> usando el flujo, el URI base y la configuración especificados.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Flujo que contiene los datos XML.  <see cref="T:System.Xml.XmlReader" /> examina los primeros bytes de la secuencia buscando una marca de orden de bytes u otro signo de codificación. Cuando se especifica la codificación, esta se usa para seguir leyendo el flujo, y el procesamiento continúa analizando la entrada como un flujo de caracteres (Unicode).</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <param name="inputContext">Información de contexto necesaria para analizar el fragmento XML. La información de contexto puede incluir la <see cref="T:System.Xml.XmlNameTable" /> que se va a usar, la codificación, el ámbito del espacio de nombres, el ámbito actual de <c>xml:lang</c> y <c>xml:space</c>, el URI base y la definición de tipo de documento.  Este valor puede ser <see langword="null" />.</param>
        <summary>Crea una nueva instancia <see cref="T:System.Xml.XmlReader" /> con el flujo, la configuración y la información de contexto especificados para el análisis.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Lector de texto desde el que se leen los datos XML. Un lector de texto devuelve un flujo de caracteres Unicode, por lo que el <see cref="T:System.Xml.XmlReader" /> no usa la codificación especificada en la declaración XML para descodificar el flujo de datos.</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <param name="baseUri">URI base de la entidad o documento que se lee. Este valor puede ser <see langword="null" />.  **Nota sobre seguridad** El URI base se usa para resolver el URI relativo del documento XML. No use un URI base de un origen que no sea de confianza.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> mediante el lector de texto, la configuración y el URI base especificados.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Lector de texto desde el que se leen los datos XML. Un lector de texto devuelve un flujo de caracteres Unicode, por lo que el lector XML no usa la codificación especificada en la declaración XML para descodificar el flujo de datos.</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <param name="inputContext">Información de contexto necesaria para analizar el fragmento XML. La información de contexto puede incluir la <see cref="T:System.Xml.XmlNameTable" /> que se va a usar, la codificación, el ámbito del espacio de nombres, el ámbito actual de <c>xml:lang</c> y <c>xml:space</c>, el URI base y la definición de tipo de documento.  Este valor puede ser <see langword="null" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> con el lector de texto, la configuración y la información de contexto especificados para el análisis.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede usar uno de los métodos siguientes para controlar los recursos que la <xref:System.Xml.XmlReader> puede tener acceso:  
>   
>  -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlReader> estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
>   
>  O bien  
>   
>  -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> en `null`.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Xml.XmlReader> objeto que lee un fragmento de XML.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="input" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Tanto la propiedad <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> como la propiedad <see cref="P:System.Xml.XmlParserContext.NameTable" /> contienen valores. (Solo se puede establecer y usar una de estas propiedades <see langword="NameTable" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI del archivo que contiene los datos XML. El objeto <see cref="T:System.Xml.XmlResolver" /> del objeto <see cref="T:System.Xml.XmlReaderSettings" /> se utiliza para convertir la ruta de acceso en una representación de datos canónicos. Si <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> es <see langword="null" />, se utiliza un nuevo objeto <see cref="T:System.Xml.XmlUrlResolver" />.</param>
        <param name="settings">Configuración de la nueva instancia <see cref="T:System.Xml.XmlReader" />. Este valor puede ser <see langword="null" />.</param>
        <param name="inputContext">Información de contexto necesaria para analizar el fragmento XML. La información de contexto puede incluir la <see cref="T:System.Xml.XmlNameTable" /> que se va a usar, la codificación, el ámbito del espacio de nombres, el ámbito actual de <c>xml:lang</c> y <c>xml:space</c>, el URI base y la definición de tipo de documento.  Este valor puede ser <see langword="null" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Xml.XmlReader" /> usando el URI, la configuración y la información de contexto especificados.</summary>
        <returns>Objeto usado para leer los datos XML del flujo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada un <xref:System.Xml.XmlUrlResolver> sin credenciales se usa para tener acceso a recursos externos como una definición de tipo de documento (DTD), entidades, esquemas y así sucesivamente.  
  
> [!IMPORTANT]
>  A partir de .NET Framework 4.5.2, ningún valor predeterminado <xref:System.Xml.XmlUrlResolver> se proporciona. Si su solución tiene como destino .NET Framework 4.5.2 o versiones posteriores, especifique un <xref:System.Xml.XmlResolver> utilizando el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad.  
  
 Esto significa que el <xref:System.Xml.XmlReader> puede tener acceso a cualquier ubicación que no requiere autenticación. Si se encuentra el recurso externo en un recurso de red que requiere autenticación, use el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propiedad para especificar un <xref:System.Xml.XmlResolver> con las credenciales necesarias.  
  
> [!IMPORTANT]
>  Puede restringir los recursos que la <xref:System.Xml.XmlReader> puede tener acceso estableciendo el <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propiedad a un <xref:System.Xml.XmlSecureResolver> objeto.  
  
 Creado <xref:System.Xml.XmlReader> objeto expande las referencias de entidad y realiza la normalización XML de los caracteres de nueva línea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <see langword="inputUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> no tiene permisos suficientes para obtener acceso a la ubicación de los datos XML.</exception>
        <exception cref="T:System.ArgumentException">Tanto la propiedad <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> como la propiedad <see cref="P:System.Xml.XmlParserContext.NameTable" /> contienen valores. (Solo se puede establecer y usar una de estas propiedades <see langword="NameTable" />).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado por el URI.</exception>
        <exception cref="T:System.UriFormatException">El formato del URI no es correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene la profundidad del nodo actual en el documento XML.</summary>
        <value>Profundidad del nodo actual en el documento XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.Depth%2A> (en el `XmlTextReader` clase) para obtener un ejemplo de uso de esta propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Libera los recursos que usa la clase <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.Xml.XmlReader" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene un valor que indica si el lector está situado al final del flujo.</summary>
        <value>Es <see langword="true" /> si el lector está situado al final del flujo; en caso contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor de un atributo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Índice del atributo. El índice está basado en cero. El primer atributo tiene índice 0.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo con el índice especificado.</summary>
        <returns>Valor del atributo especificado. Este método no desplaza el lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente obtiene el valor del tercer atributo.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> está fuera del intervalo. Debe ser no negativo y menor que el tamaño de la colección de atributos.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo con la propiedad <see cref="P:System.Xml.XmlReader.Name" /> especificada.</summary>
        <returns>Valor del atributo especificado. Si no se encuentra el atributo o el valor es <see langword="String.Empty" />, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no desplaza el lector.  
  
 Si el lector está situado en un `DocumentType` nodo, este método puede usarse para obtener los literales PUBLIC y SYSTEM, por ejemplo, `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 El ejemplo siguiente obtiene el valor del atributo ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre local del atributo.</param>
        <param name="namespaceURI">URI de espacio de nombres del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo con las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificadas.</summary>
        <returns>Valor del atributo especificado. Si no se encuentra el atributo o el valor es <see langword="String.Empty" />, se devuelve <see langword="null" />. Este método no desplaza el lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El siguiente código XML contiene un atributo en un espacio de nombres específico:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Para buscar el `dt:type` atributo mediante un argumento (prefijo y nombre local) o dos argumentos (nombre local y URI de espacio de nombres):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Para buscar el `xmlns:dt` atributo, utilice uno de los argumentos siguientes:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 También puede obtener esta información mediante el <xref:System.Xml.XmlReader.Prefix%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene de forma asincrónica el valor del nodo actual.</summary>
        <returns>Valor del nodo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el nodo actual tiene algún atributo.</summary>
        <value>
          <see langword="true" /> si el nodo actual tiene atributos; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene un valor que indica si el nodo actual puede tener una propiedad <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value>Es <see langword="true" /> si el nodo en el que está situado actualmente el lector puede tener un <see langword="Value" />; en caso contrario, es <see langword="false" />. Si es <see langword="false" />, el nodo tiene un valor de <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la siguiente tabla se recogen los tipos de nodo que tienen un valor para devolver.  
  
|Tipo de nodo|Valor|  
|---------------|-----------|  
|`Attribute`|El valor del atributo.|  
|`CDATA`|Contenido de la sección CDATA.|  
|`Comment`|El contenido del comentario.|  
|`DocumentType`|El subconjunto interno.|  
|`ProcessingInstruction`|El contenido completo, sin incluir el destino.|  
|`SignificantWhitespace`|Espacio en blanco entre marcas en un modelo de contenido mixto.|  
|`Text`|El contenido del nodo de texto.|  
|`Whitespace`|El espacio en blanco entre marcado.|  
|`XmlDeclaration`|El contenido de la declaración.|  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.HasValue%2A> (en el `XmlTextReader` clase) para obtener un ejemplo con este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si el nodo actual es un atributo generado a partir del valor predeterminado definido en la DTD o el esquema.</summary>
        <value>Es <see langword="true" /> si el nodo actual es un atributo cuyo valor fue generado a partir del valor predeterminado definido en la DTD o el esquema; es <see langword="false" /> si el valor de atributo se estableció explícitamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` siempre devuelve `false` para las implementaciones de `XmlReader` que no admiten información de DTD o esquema. Esta propiedad solo se aplica a un nodo de atributo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el elemento raíz.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 El ejemplo utiliza los siguientes archivos como entrada.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene un valor que indica si el nodo actual es un elemento vacío (por ejemplo, <c>&lt;MyElement/&gt;</c>).</summary>
        <value>
          <see langword="true" /> Si el nodo actual es un elemento (<see cref="P:System.Xml.XmlReader.NodeType" /> es igual a <see langword="XmlNodeType.Element" />) que termina en <c> / &gt; </c>; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad le permite determinar la diferencia entre lo siguiente:  
  
 `<item num="123"/>` (`IsEmptyElement` es `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` es `false`, aunque el contenido del elemento está vacío).  
  
 Correspondiente `EndElement` nodo no se genera para elementos vacíos.  
  
 Si se ha agregado el contenido predeterminado a un elemento debido a la validación de esquemas, `IsEmptyElement` sigue devolviendo `true`. No tiene un impacto en si el elemento tiene un valor predeterminado. En otras palabras, `IsEmptyElement` simplemente notifica si el elemento del documento de origen tenía una etiqueta de elemento de cierre o no.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el contenido de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 En el ejemplo se utiliza el archivo `elems.xml`como entrada.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Nombre que se va a validar.</param>
        <summary>Devuelve un valor que indica si el argumento de cadena es un nombre XML válido.</summary>
        <returns>Es <see langword="true" /> si el nombre es válido; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [recomendación W3C XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) para determinar si el nombre es válido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="str" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Token de nombre que se va a validar.</param>
        <summary>Devuelve un valor que indica si el argumento de cadena es un token de nombre XML válido.</summary>
        <returns>Es <see langword="true" /> si es un token de nombre válido; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [recomendación W3C XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) para determinar si el token de nombre es válido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="str" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Comprueba si el nodo de contenido actual es una etiqueta de apertura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Llama al método <see cref="M:System.Xml.XmlReader.MoveToContent" /> y comprueba si el nodo de contenido actual es una etiqueta de apertura o una etiqueta de elemento vacío.</summary>
        <returns>Es <see langword="true" /> si <see cref="M:System.Xml.XmlReader.MoveToContent" /> encuentra una etiqueta de apertura o una etiqueta de elemento vacío; es <see langword="false" /> si se encuentra un tipo de nodo que no sea <see langword="XmlNodeType.Element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método omite las instrucciones de procesamiento, comentarios y espacios en blanco hasta que el lector está situado en un nodo de contenido. A continuación, el método comprueba si el nodo actual es un elemento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el contenido de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 En el ejemplo se utiliza el archivo `elems.xml`como entrada.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se detecta XML incorrecto en el flujo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que se compara con la propiedad <see langword="Name" /> del elemento encontrado.</param>
        <summary>Llama al método <see cref="M:System.Xml.XmlReader.MoveToContent" /> y comprueba si el nodo de contenido actual es una etiqueta de apertura o una etiqueta de elemento vacío y si la propiedad <see cref="P:System.Xml.XmlReader.Name" /> del elemento encontrado coincide con el argumento especificado.</summary>
        <returns>
          <see langword="true" /> si el nodo resultante es un elemento y la propiedad <see langword="Name" /> coincide con la cadena especificada. <see langword="false" /> si se encuentra un tipo de nodo que no sea <see langword="XmlNodeType.Element" /> o si la propiedad <see langword="Name" /> del elemento no coincide con la cadena especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método omite las instrucciones de procesamiento, comentarios y espacios en blanco hasta que el lector está situado en un nodo de contenido. A continuación, el método comprueba si el nodo actual es un elemento.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cada elemento de precio.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se detecta XML incorrecto en el flujo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Cadena con la que se compara la propiedad <see langword="LocalName" /> del elemento encontrado.</param>
        <param name="ns">Cadena con la que se compara la propiedad <see langword="NamespaceURI" /> del elemento encontrado.</param>
        <summary>Llama al método <see cref="M:System.Xml.XmlReader.MoveToContent" /> y comprueba si el nodo de contenido actual es una etiqueta de apertura o una etiqueta de elemento vacío y si las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> del elemento encontrado coinciden con las cadenas especificadas.</summary>
        <returns>
          <see langword="true" /> si el nodo resultante es un elemento. <see langword="false" /> si se encuentra un tipo de nodo que no sea <see langword="XmlNodeType.Element" /> o si las propiedades <see langword="LocalName" /> y <see langword="NamespaceURI" /> del elemento no coinciden con la cadena especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método omite las instrucciones de procesamiento, comentarios y espacios en blanco hasta que el lector está situado en un nodo de contenido. A continuación, el método comprueba si el nodo actual es un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se detecta XML incorrecto en el flujo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Índice del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo con el índice especificado.</summary>
        <value>Valor del atributo especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no mueve el lector.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo con la propiedad <see cref="P:System.Xml.XmlReader.Name" /> especificada.</summary>
        <value>Valor del atributo especificado. Si no se encuentra el atributo, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no mueve el lector.  
  
 Si el lector está situado en un `DocumentType` nodo, este método puede usarse para obtener los literales PUBLIC y SYSTEM, por ejemplo, `reader["PUBLIC"]`  
  
   
  
## Examples  
 El ejemplo siguiente obtiene el valor del atributo ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre local del atributo.</param>
        <param name="namespaceURI">URI de espacio de nombres del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor del atributo con las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificadas.</summary>
        <value>Valor del atributo especificado. Si no se encuentra el atributo, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no mueve el lector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el nombre local del nodo actual.</summary>
        <value>Nombre del nodo actual sin prefijo. Por ejemplo, <see langword="LocalName" /> es <see langword="book" /> para el elemento <c> &lt;bk: book&gt;</c>.  Para los tipos de nodo sin nombre (por ejemplo, <see langword="Text" />, <see langword="Comment" />, etc.), esta propiedad devuelve <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el nombre local de cada nodo, y, si existen, el prefijo y URI de espacio de nombres.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 En el ejemplo se usa el archivo book2.xml como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo cuyo identificador URI de espacio de nombres se desea resolver. Para hacer coincidir el espacio de nombres predeterminado, pase una cadena vacía.</param>
        <summary>Cuando se invalida en una clase derivada, resuelve un prefijo de espacio de nombres en el ámbito del elemento actual.</summary>
        <returns>Identificador URI de espacio de nombres al que se asigna el prefijo o <see langword="null" /> si no se encuentra ningún prefijo coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la siguiente cadena XML, si el lector está situado en la `href` atributo, el prefijo `a` se resuelve mediante una llamada a `reader.LookupNamespace("a")`. La cadena devuelta es `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Cuando se invalida en una clase derivada, se desplaza al atributo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Índice del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, se desplaza al atributo con el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro tiene un valor negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, se desplaza al atributo con la propiedad <see cref="P:System.Xml.XmlReader.Name" /> especificada.</summary>
        <returns>Es <see langword="true" /> si se encuentra el atributo; en caso contrario, es <see langword="false" />. Si es <see langword="false" />, no cambia la posición del lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, y <xref:System.Xml.XmlReader.Prefix%2A> reflejan las propiedades de dicho atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentException">El parámetro es una cadena vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre local del atributo.</param>
        <param name="ns">URI de espacio de nombres del atributo.</param>
        <summary>Cuando se invalida en una clase derivada, se desplaza al atributo con las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificadas.</summary>
        <returns>Es <see langword="true" /> si se encuentra el atributo; en caso contrario, es <see langword="false" />. Si es <see langword="false" />, no cambia la posición del lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, y <xref:System.Xml.XmlReader.Prefix%2A> reflejan las propiedades de dicho atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos valores del parámetro son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba si el nodo actual es un nodo de contenido (texto sin espacios en blanco, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" /> o <see langword="EndEntity" />). Si el nodo no es un nodo de contenido, el lector salta hasta el siguiente nodo de contenido o el final del archivo. Omite los siguientes tipos de nodo: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" /> o <see langword="SignificantWhitespace" />.</summary>
        <returns>El <see cref="P:System.Xml.XmlReader.NodeType" /> del nodo actual encontrado por el método o <see langword="XmlNodeType.None" /> si el lector alcanzó el final del flujo de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el nodo actual es un nodo de atributo, este método mueve el lector al elemento que posee el atributo.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Esto es útil cuando desea escribir código que puede omitir marcado XML aleatorio sin interrupciones. Por ejemplo, suponga que tiene el siguiente código:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Este código puede controlar las siguientes entradas sin interrupción:  
  
```xml  
<price>123.4</price>  
```  
  
 y  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 y  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 y  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML incorrecto que se encuentra en el flujo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;MoveToContentAsync&gt;c__async5))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>De forma asincrónica comprueba si el nodo actual es un nodo de contenido. Si el nodo no es un nodo de contenido, el lector salta hasta el siguiente nodo de contenido o el final del archivo.</summary>
        <returns>El <see cref="P:System.Xml.XmlReader.NodeType" /> del nodo actual encontrado por el método o <see langword="XmlNodeType.None" /> si el lector alcanzó el final del flujo de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.MoveToContent%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, se desplaza al elemento que contiene el nodo de atributo actual.</summary>
        <returns>Es <see langword="true" /> si el lector está situado en un atributo (el lector se desplaza hasta el elemento que posee el atributo); es <see langword="false" /> si el lector no está situado en un atributo (no cambia la posición del lector).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para devolver a un elemento después de navegar a través de sus atributos. Este método mueve el lector a uno de los siguientes tipos de nodo: `Element`, `DocumentType`, o `XmlDeclaration`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, se desplaza hasta el primer atributo.</summary>
        <returns>Es <see langword="true" /> si existe un atributo (el lector se desplaza hasta el primer atributo); en caso contrario, es <see langword="false" /> (no cambia la posición del lector).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente obtiene el valor del primer atributo.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, se desplaza hasta el siguiente atributo.</summary>
        <returns>Es <see langword="true" /> si hay siguiente atributo; es <see langword="false" /> si no hay más atributos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el nodo actual es un nodo de elemento, este método es equivalente a <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Si `MoveToNextAttribute` devuelve `true`, el lector se desplaza hasta el siguiente atributo; en caso contrario, no cambia la posición del lector.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el nombre completo del nodo actual.</summary>
        <value>Nombre completo del nodo actual. Por ejemplo, <see langword="Name" /> es <see langword="bk:book" /> para el elemento <c> &lt;bk: book&gt;</c>.  El nombre devuelto depende de la propiedad <see cref="P:System.Xml.XmlReader.NodeType" /> del nodo:  Los siguientes tipos de nodo devuelven los valores que figuran en la lista. Todos los demás tipos de nodo devuelven una cadena vacía.  
  
 <list type="table"><listheader><term> Tipo de nodo </term><description> nombre </description></listheader><item><term><see langword="Attribute" /></term><description> el nombre del atributo.  </description></item><item><term><see langword="DocumentType" /></term><description> El nombre de tipo de documento.  </description></item><item><term><see langword="Element" /></term><description> El nombre de etiqueta.  </description></item><item><term><see langword="EntityReference" /></term><description> El nombre de la entidad al que hace referencia.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> El destino de la instrucción de procesamiento.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> La cadena literal <see langword="xml" />.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 El ejemplo usa el `items.xml` archivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el identificador URI de espacio de nombres (según se define en la especificación relativa a espacios de nombres del Consorcio W3C) del nodo en el que está situado el lector.</summary>
        <value>URI de espacio de nombres del nodo actual; en caso contrario, una cadena vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es relevante para `Element` y `Attribute` sólo los nodos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre local de cada nodo, y, si existen, el prefijo y URI de espacio de nombres.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 En el ejemplo se usa el archivo book2.xml como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el objeto <see cref="T:System.Xml.XmlNameTable" /> que está asociado a esta implementación.</summary>
        <value>
          <see langword="XmlNameTable" /> que permite obtener la versión subdividida de una cadena en el nodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devuelven todos los nombres de nodo y de atributo de <xref:System.Xml.XmlReader> se subdividen mediante el `NameTable`. Cuando se devuelve varias veces el mismo nombre (por ejemplo, `Customer`), a continuación, en el mismo `String` se devolverá el objeto de ese nombre. Esto permite escribir código eficiente que comparaciones de objetos en estas cadenas en lugar de costosas comparaciones de cadenas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el tipo del nodo actual.</summary>
        <value>Uno de los valores de enumeración que especifica el tipo del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 El ejemplo usa el `items.xml` archivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el prefijo de espacio de nombres asociado al nodo actual.</summary>
        <value>Prefijo de espacio de nombres asociado al nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el nombre local de cada nodo, y, si existen, el prefijo y URI de espacio de nombres.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 En el ejemplo se usa el archivo book2.xml como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el carácter de comillas entre las que se encierra el valor de un nodo de atributo.</summary>
        <value>Carácter de comillas (" o ') entre las que se encierra el valor de un nodo de atributo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad solo se aplica a un nodo de atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, lee el siguiente nodo del flujo.</summary>
        <returns>Es <see langword="true" /> si el siguiente nodo se ha leído correctamente; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Xml.XmlReader> es el primero creado e inicializado, no hay ninguna información disponible. Debe llamar a <xref:System.Xml.XmlReader.Read%2A> para leer el primer nodo. El <xref:System.Xml.XmlReader.Read%2A> método establece el estado del lector XML para iniciar <xref:System.Xml.ReadState> y mueve secuencialmente a través del archivo XML hasta que llega al final del archivo, momento en que el método devuelve un valor de `false`.  
  
 Este método requiere al menos cuatro bytes desde el flujo de datos para poder empezar a analizar. Si se devuelven menos de cuatro bytes y no hay ningún dato más en la secuencia, el método devuelve `false`. Si hay más datos en la secuencia, el método bloqueará hasta que se reciba el cuarto byte de análisis.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 El ejemplo usa el `items.xml` archivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Salida:**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se ha producido un error al analizar el fragmento de XML.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>De forma asincrónica lee el nodo siguiente del flujo.</summary>
        <returns>Es <see langword="true" /> si se lee correctamente el siguiente nodo; es <see langword="false" /> si no hay más nodos que leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.Read%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, analiza el valor de atributo en uno o varios nodos <see langword="Text" />, <see langword="EntityReference" /> o <see langword="EndEntity" />.</summary>
        <returns>
          <see langword="true" /> si hay nodos para devolver.  
  
 <see langword="false" /> si el lector no está situado en un nodo de atributo cuando se realiza la llamada inicial o si se leyeron todos los valores de atributo.  Un atributo vacío, como <c>misc=""</c>, devuelve <see langword="true" /> con un solo nodo cuyo valor es <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método después de llamar a <xref:System.Xml.XmlReader.MoveToAttribute%2A> para leer los nodos de referencia de texto o una entidad que constituyen el valor del atributo. El <xref:System.Xml.XmlReader.Depth%2A> de los nodos de valor de atributo es uno más la profundidad del nodo de atributo; aumenta y disminuye en uno al entrar y salir de las referencias de entidad general.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo del valor que se va a devolver.  **Nota** Con el lanzamiento de .NET Framework 3.5, el valor del parámetro <c>returnType</c> ahora puede ser el tipo <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que se utiliza para resolver prefijos de espacios de nombres relacionados con la conversión de tipos. Por ejemplo, se puede utilizar al convertir un objeto <see cref="T:System.Xml.XmlQualifiedName" /> en <c>xs:string</c>.  Este valor puede ser <see langword="null" />.</param>
        <summary>Lee el contenido como objeto del tipo especificado.</summary>
        <returns>Contenido de texto concatenado o valor de atributo convertido en el tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee el contenido de texto en la posición actual del lector y lo convierte en el tipo de valor devuelto solicitado. El texto, el espacio en blanco, el espacio en blanco significativo y las secciones CDATA se concatenan. Los comentarios y las instrucciones de procesamiento se omiten y las referencias de entidad se resuelven automáticamente.  
  
 Este método se utiliza para leer, convertir si es necesario y devolver elementos de valor atómico del nodo actual contenido. Se devuelve si el tipo de entrada es un asignaciones válidas para el tipo del nodo actual, a continuación, una instancia del tipo de destino que contiene el valor del nodo actual. Vea la sección de comentarios en el <xref:System.Xml.XmlReader> referencepage para obtener una lista de las asignaciones predeterminadas.  
  
 Por ejemplo, si tuviera el siguiente texto XML:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Si se escriban los datos y se proporciona una matriz de cadenas a la <xref:System.Xml.XmlReader.ReadContentAs%2A> llamada al método y, a continuación, los valores enteros se convierten de cadenas según la lista de asignaciones de tipos CLR válidas.  
  
 Si los datos sin tipo y se proporciona una matriz de cadenas a la <xref:System.Xml.XmlReader.ReadContentAs%2A> llamada de método, a continuación, el contenido se analiza en cadenas independientes. Se devuelve una matriz que contiene dos cadenas con los valores "123" y "456". No se conservan los espacios del contenido.  
  
 En general, al leer datos sin tipo se analiza el contenido según el tipo proporcionado. Por ejemplo, si se proporciona una matriz de enteros a la <xref:System.Xml.XmlReader.ReadContentAs%2A> llame al método, se analiza la cadena en una matriz de enteros {123,456}.  
  
 En el ejemplo siguiente, el texto XML no es separado por espacios  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Si el contenido sin tipo y se proporciona una matriz de cadenas para el <xref:System.Xml.XmlReader.ReadContentAs%2A> método, a continuación, llamar a una matriz que contiene una cadena concatenada que se devuelve con el valor "123456789".  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.XmlReader.ReadContentAs%2A> método para devolver el contenido del elemento de colores en una matriz de objetos de cadena.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile_2.xml`.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">El formato del contenido no es correcto para el tipo de destino.</exception>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="returnType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.OverflowException">Lea <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsAsync&gt;c__async1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo del valor que se va a devolver.</param>
        <param name="namespaceResolver">Objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que se utiliza para resolver prefijos de espacios de nombres relacionados con la conversión de tipos.</param>
        <summary>Lee asincrónicamente el contenido como objeto del tipo especificado.</summary>
        <returns>Contenido de texto concatenado o valor de atributo convertido en el tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadContentAs%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el contenido y devuelve los bytes binarios descodificados en Base64.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método envía el contenido, descodifica el `Base64` de contenido y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `Base64` codificado en formato GIF) en el búfer. Puede llamar sucesivamente a este método para leer grandes flujos de texto incrustado. Para obtener más información, vea RFC 1521, "MIME (Multipurpose Internet Mail Extensions) parte uno: mecanismos para especificar y describir el formato de los cuerpos de mensaje de Internet". Puede obtener RFC del [sitio Web de comentarios de solicitud de](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Debe tener acceso a cualquiera de las propiedades del lector entre las llamadas a no la <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> método hasta que el método devuelve el valor `0`.  
  
 Este método tiene el siguiente comportamiento:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Devuelve el valor `0` cuando alcanza el final de la secuencia de bytes que estaba operando. El lector está situado en el primer nodo sin contenido.  
  
-   Si solicita un número menor, o el número exacto de bytes que quedan en la secuencia en el sistema de lectura permanece en su posición actual.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> no se admite en los siguientes tipos de nodo XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlReader" /> no admite este método.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee asincrónicamente el contenido y devuelve los bytes binarios descodificados en Base64.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el contenido y devuelve los bytes binarios descodificados de <see langword="BinHex" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método envía el contenido, descodifica el `BinHex` de contenido y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `BinHex` codificado en formato GIF) en el búfer. Puede llamar sucesivamente a este método para leer grandes flujos de texto incrustado.  
  
> [!NOTE]
>  Debe tener acceso a cualquiera de las propiedades del lector entre las llamadas a no la <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> método hasta que el método devuelve el valor `0`.  
  
 Este método tiene el siguiente comportamiento:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Devuelve el valor `0` cuando alcanza el final de la secuencia de bytes que estaba operando. El lector está situado en el primer nodo sin contenido.  
  
-   Si solicita un número menor, o el número exacto de bytes que quedan en la secuencia, el lector permanece en su posición actual.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> no se admite en los siguientes tipos de nodo XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlReader" /> no admite este método.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee asincrónicamente el contenido y devuelve los bytes binarios descodificados de <see langword="BinHex" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como valor <see langword="Boolean" />.</summary>
        <returns>El contenido del texto como objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:boolean`, el lector devuelve una conversión unboxing <xref:System.Boolean> objeto. Si no se escribe el contenido `xsd:boolean`, el lector intenta convertirlo en un <xref:System.Boolean> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, consulte el <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> método para leer el atributo como una B`oolean` valor.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile_2.xml`.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como un objeto <see cref="T:System.DateTime" />.</summary>
        <returns>El contenido del texto como objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:dateTime`, el lector devuelve una conversión unboxing <xref:System.DateTime> objeto. Si no se escribe el contenido `xsd:dateTime`, el lector intenta convertirlo en un <xref:System.DateTime> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
> [!NOTE]
>  No puede confiar en el valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> si el contenido tiene el tipo `xsd:gMonthDay`. <xref:System.Xml.XmlReader> siempre se establece la <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor en 1904 en este caso.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, consulte el <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como un objeto <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>El contenido del texto como objeto <see cref="T:System.DateTimeOffset" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como un objeto <see cref="T:System.Decimal" />.</summary>
        <returns>El contenido de texto en la posición actual como objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:decimal`, el lector devuelve una conversión unboxing <xref:System.Decimal> objeto. Si no se escribe el contenido `xsd:decimal`, el lector intenta convertirlo en un <xref:System.Decimal> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, consulte el <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como número de punto flotante de precisión doble.</summary>
        <returns>El contenido de texto como número de punto flotante de precisión doble.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:double`, el lector devuelve un número de punto flotante de precisión doble. Si no se escribe el contenido `xsd:double`, el lector intenta convertirlo en un número de punto flotante de precisión doble según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, consulte el <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como número de punto flotante de precisión sencilla.</summary>
        <returns>El contenido de texto en la posición actual como número de punto flotante de precisión sencilla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:float`, el lector devuelve una conversión unboxing y un número de punto flotante de precisión sencilla. Si no se escribe el contenido `xsd:float`, el lector intenta convertirlo en un número de punto flotante de precisión sencilla según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como un entero de 32 bits con signo.</summary>
        <returns>El contenido de texto como entero de 32 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:integer`, el lector devuelve un entero de 32 bits con signo con conversión unboxing. Si no se escribe el contenido `xsd:integer`, el lector intenta convertirlo en un entero de 32 bits con signo según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como un entero de 64 bits con signo.</summary>
        <returns>El contenido de texto como entero de 64 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido `xsd:long`, el lector devuelve un entero de 64 bits con signo con conversión unboxing. Si no se escribe el contenido `xsd:long`, el lector intenta convertirlo en un entero con signo de 64 bits según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 En la tabla siguiente describe este método trata cada tipo de nodo.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que `XmlConvert.ToXxx` en el valor del atributo.|El sistema de lectura permanece en la posición actual|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como <see cref="T:System.Object" />.</summary>
        <returns>El contenido de texto como el objeto de Common Language Runtime (CLR) más adecuado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Si se escribe el contenido, el lector devuelve un CLR del tipo más apropiado, especificado por el <xref:System.Xml.XmlReader.ValueType%2A> propiedad. Si el contenido es un tipo de lista, el lector devuelve una matriz de objetos con conversión boxing del tipo adecuado.  
  
> [!NOTE]
>  Si se produce un error de validación al analizar el contenido y el lector es una <xref:System.Xml.XmlReader> objeto creado por el <xref:System.Xml.XmlReader.Create%2A> método, el lector devuelve el contenido como una cadena. En otras palabras cuando se produce un error de validación o advertencia, el contenido se considera sin tipo.  
  
 Si el contenido no tiene tipo, el sistema de lectura lo devuelve como una cadena.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|El valor del elemento si el lector es un lector de validación del esquema (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> está establecido en <xref:System.Xml.ValidationType.Schema>); en caso contrario, una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsObjectAsync&gt;c__async0))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee asincrónicamente el contenido de texto en la posición actual como un objeto <see cref="T:System.Object" />.</summary>
        <returns>El contenido de texto como el objeto de Common Language Runtime (CLR) más adecuado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de texto en la posición actual como un objeto <see cref="T:System.String" />.</summary>
        <returns>El contenido del texto como objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método concatena texto, espacios en blanco, espacio en blanco significativo y secciones CDATA y omite los comentarios o instrucciones de procesamiento. Las referencias de entidad se resuelven automáticamente.  
  
 Se puede usar este método convierte los valores con tipo como una cadena, o para leer el contenido de texto mientras pasa por alto los comentarios y las instrucciones de procesamiento.  
  
 En la tabla siguiente se describe cómo trata a cada tipo de nodo de este método.  
  
|Tipo XmlNode|Valor devuelto|Comportamiento del sistema de lectura|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|El contenido concatenado de los nodos de texto, CDATA, espacio en blanco y espacio en blanco significativo se convierten en el tipo solicitado.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`Attribute`|Igual que llamar al `XmlConvert.ToXxx` del valor del atributo.|El sistema de lectura permanece en la posición actual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Omite la instrucción de procesamiento o los comentarios y lee el contenido del texto concatenado que sigue a la instrucción de procesamiento o los comentarios.|Se mueve a la siguiente etiqueta del elemento de inicio o de fin. Las referencias de entidad se expanden automáticamente.|  
|`EndElement`|Una cadena vacía.|El sistema de lectura permanece en la posición actual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Se inicia una <xref:System.InvalidOperationException>.|No definido, aunque normalmente el sistema de lectura permanece en la posición actual.|  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La conversión intentada no es válida.</exception>
        <exception cref="T:System.FormatException">El formato de la cadena no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee asincrónicamente el contenido de texto en la posición actual como un objeto <see cref="T:System.String" />.</summary>
        <returns>El contenido del texto como objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadContentAsString%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como objeto del tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo del valor que se va a devolver.  **Nota** Con el lanzamiento de .NET Framework 3.5, el valor del parámetro <c>returnType</c> ahora puede ser el tipo <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que se utiliza para resolver prefijos de espacios de nombres relacionados con la conversión de tipos.</param>
        <summary>Lee el contenido de los elementos como el tipo solicitado.</summary>
        <returns>Contenido de elementos convertido en el objeto con tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.XmlReader.ReadElementContentAs%2A> método para leer el contenido de la `date` nodo.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Lea <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo del valor que se va a devolver.  **Nota** Con el lanzamiento de .NET Framework 3.5, el valor del parámetro <c>returnType</c> ahora puede ser el tipo <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que se utiliza para resolver prefijos de espacios de nombres relacionados con la conversión de tipos.</param>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI de espacio de nombres coinciden con los del elemento actual y, a continuación, lee el contenido de los elementos como el tipo solicitado.</summary>
        <returns>Contenido de elementos convertido en el objeto con tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
        <exception cref="T:System.OverflowException">Lea <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsAsync&gt;c__async4))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Tipo del valor que se va a devolver.</param>
        <param name="namespaceResolver">Objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que se utiliza para resolver prefijos de espacios de nombres relacionados con la conversión de tipos.</param>
        <summary>Lee asincrónicamente el contenido del elemento como el tipo solicitado.</summary>
        <returns>Contenido de elementos convertido en el objeto con tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el elemento y descodifica el contenido de <see langword="Base64" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee el contenido del elemento, se descodifica mediante `Base64` codificación y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `Base64`-codificado en formato GIF) en el búfer. Para obtener más información, vea RFC 1521, "MIME (Multipurpose Internet Mail Extensions) parte uno: mecanismos para especificar y describir el formato de los cuerpos de mensaje de Internet". Puede obtener RFC del [sitio Web de comentarios de solicitud de](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> solo se puede leer elementos de contenido simple. El elemento puede contener texto, espacios en blanco, espacio en blanco significativo, secciones CDATA, comentarios y las instrucciones de procesamiento. También puede contener referencias de entidad, que se expanden automáticamente. El elemento no puede tener elementos secundarios.  
  
 Este método es muy similar a la <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> método excepto en que sólo se puede llamar en tipos de nodo de elemento.  
  
 Si el `count` valor es mayor que el número de bytes en el documento, o si es igual al número de bytes en el documento, el <xref:System.Xml.XmlReader> lee todos los bytes restantes en el documento y devuelve el número de bytes leídos. La siguiente <xref:System.Xml.XmlReader> llamada al método devuelve un cero y desplaza el lector al siguiente nodo del `EndElement`.  
  
 Si se llama a <xref:System.Xml.XmlReader.Read%2A> antes de que se consuma todo el contenido del elemento, el lector puede comportarse como si se consumió el primer contenido y, a continuación, el <xref:System.Xml.XmlReader.Read%2A> se llamó al método. Esto significa que el lector leerá todo el texto hasta que se encuentra el elemento final. A continuación, leerá el nodo de la etiqueta final, lea el siguiente nodo y, a continuación, se sitúa en el siguiente nodo.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee un elemento incorporado `Base64` imagen codificada. El `Base64` datos se incrustan en el `<image>` elemento. Un <xref:System.IO.BinaryWriter> se usa para crear un nuevo archivo de datos binarios.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlReader" /> no admite este método.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento contiene un contenido mixto.</exception>
        <exception cref="T:System.FormatException">El contenido no puede convertirse en el tipo solicitado.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee asincrónicamente el elemento y descodifica el contenido de <see langword="Base64" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el elemento y descodifica el contenido de <see langword="BinHex" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee el contenido del elemento, se descodifica mediante `BinHex` codificación y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `BinHex`-codificado en formato GIF) en el búfer.  
  
 Este método solo puede leer elementos de contenido simple. El elemento puede contener texto, espacios en blanco, espacio en blanco significativo, secciones CDATA, comentarios y las instrucciones de procesamiento. También puede contener referencias de entidad, que se expanden automáticamente. El elemento no puede tener elementos secundarios.  
  
 Este método es muy similar a la <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> método excepto en que sólo se puede llamar en tipos de nodo de elemento.  
  
 Si el `count` valor es mayor que el número de bytes en el documento, o si es igual al número de bytes en el documento, el <xref:System.Xml.XmlReader> lee todos los bytes restantes en el documento y devuelve el número de bytes leídos. La siguiente <xref:System.Xml.XmlReader> llamada al método devuelve un cero y desplaza el lector al siguiente nodo del `EndElement`.  
  
 Si se llama a <xref:System.Xml.XmlReader.Read%2A> antes de que se consuma todo el contenido del elemento, el lector puede comportarse como si se consumió el primer contenido y, a continuación, el <xref:System.Xml.XmlReader.Read%2A> se llamó al método. Esto significa que el lector leerá todo el texto hasta que se encuentra el elemento final. A continuación, leerá el nodo de la etiqueta final, lea el siguiente nodo y, a continuación, se sitúa en el siguiente nodo.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee un elemento incorporado `BinHex` imagen codificada. El `BinHex` datos se incrustan en el `<image>` elemento. Un <xref:System.IO.BinaryWriter> se usa para crear un nuevo archivo de datos binarios.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlReader" /> no admite este método.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento contiene un contenido mixto.</exception>
        <exception cref="T:System.FormatException">El contenido no puede convertirse en el tipo solicitado.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee asincrónicamente el elemento y descodifica el contenido de <see langword="BinHex" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el valor del elemento actual como un objeto <see cref="T:System.Boolean" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como un objeto <see cref="T:System.Boolean" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido del elemento `xsd:boolean`, el lector devuelve una conversión unboxing <xref:System.Boolean> objeto. Si no se escribe el contenido `xsd:boolean`, el lector intenta convertirlo en un <xref:System.Boolean> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no puede convertirse en un objeto <see cref="T:System.Boolean" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como objeto <see cref="T:System.Boolean" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:boolean`, el lector devuelve una conversión unboxing <xref:System.Boolean> objeto. Si no se escribe el contenido `xsd:boolean`, el lector intenta convertirlo en un <xref:System.Boolean> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como un objeto <see cref="T:System.DateTime" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como un objeto <see cref="T:System.DateTime" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:dateTime`, el lector devuelve una conversión unboxing <xref:System.DateTime> objeto. Si no se escribe el contenido `xsd:dateTime`, el lector intenta convertirlo en un <xref:System.DateTime> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
> [!NOTE]
>  No puede confiar en el valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> si el contenido tiene el tipo `xsd:gMonthDay`. <xref:System.Xml.XmlReader> siempre se establece la <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor en 1904 en este caso.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> método para leer el contenido de la `date` elemento.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no puede convertirse en un objeto <see cref="T:System.DateTime" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como objeto <see cref="T:System.DateTime" />.</summary>
        <returns>El contenido del elemento como objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:dateTime`, el lector devuelve una conversión unboxing <xref:System.DateTime> objeto. Si no se escribe el contenido `xsd:dateTime`, el lector intenta convertirlo en un <xref:System.DateTime> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
> [!NOTE]
>  No puede confiar en el valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> si el contenido tiene el tipo `xsd:gMonthDay`. <xref:System.Xml.XmlReader> siempre se establece la <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor en 1904 en este caso.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el valor del elemento actual como un objeto <see cref="T:System.Decimal" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como un objeto <see cref="T:System.Decimal" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 El lector intenta convertir el elemento de contenido a un <xref:System.Decimal> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no puede convertirse en <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como objeto <see cref="T:System.Decimal" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 El lector intenta convertir el elemento de contenido a un <xref:System.Decimal> objeto según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no puede convertirse en <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como número de punto flotante de precisión doble.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como número de punto flotante de precisión doble.</summary>
        <returns>El contenido del elemento como número de punto flotante de precisión doble.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:double`, el lector devuelve un número de punto flotante de precisión doble. Si no se escribe el contenido `xsd:double`, el lector intenta convertirlo en un número de punto flotante de precisión doble según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 El ejemplo siguiente usa el método para devolver el contenido del elemento como un número de punto flotante de precisión doble.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en número de punto flotante de precisión doble.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como número de punto flotante de precisión doble.</summary>
        <returns>El contenido del elemento como número de punto flotante de precisión doble.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:double`, el lector devuelve un número de punto flotante de precisión doble. Si no se escribe el contenido `xsd:double`, el lector intenta convertirlo en un número de punto flotante de precisión doble según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el valor del elemento actual como número de punto flotante de precisión sencilla.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como número de punto flotante de precisión sencilla.</summary>
        <returns>El contenido del elemento como número de punto flotante de precisión sencilla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 El lector intenta convertir el contenido del elemento en un número de punto flotante de precisión sencilla según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en número de punto flotante de precisión sencilla.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como número de punto flotante de precisión sencilla.</summary>
        <returns>El contenido del elemento como número de punto flotante de precisión sencilla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 El lector intenta convertir el contenido del elemento en un número de punto flotante de precisión sencilla según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en número de punto flotante de precisión sencilla.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como un entero de 32 bits con signo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como un entero de 32 bits con signo.</summary>
        <returns>El elemento contiene un entero de 32 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:integer`, el lector devuelve un entero de 32 bits con signo con conversión unboxing. Si no se escribe el contenido `xsd:integer`, el lector intenta convertirlo en un entero de 32 bits con signo según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en un entero de 32 bits con signo.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee el elemento actual y devuelve el contenido como entero de 32 bits con signo.</summary>
        <returns>El elemento contiene un entero de 32 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:integer`, el lector devuelve un entero de 32 bits con signo con conversión unboxing. Si no se escribe el contenido `xsd:integer`, el lector intenta convertirlo en un entero de 32 bits con signo según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en un entero de 32 bits con signo.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como un entero de 64 bits con signo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como un entero de 64 bits con signo.</summary>
        <returns>El elemento contiene un entero de 64 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:long`, el lector devuelve un entero de 64 bits con signo con conversión unboxing. Si no se escribe el contenido `xsd:long`, el lector intenta convertirlo en un entero con signo de 64 bits según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> método para leer el contenido de la `longValue` elemento.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en un entero de 64 bits con signo.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee el elemento actual y devuelve el contenido como entero de 64 bits con signo.</summary>
        <returns>El elemento contiene un entero de 64 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Si se escribe el contenido `xsd:long`, el lector devuelve un entero de 64 bits con signo con conversión unboxing. Si no se escribe el contenido `xsd:long`, el lector intenta convertirlo en un entero con signo de 64 bits según las reglas definidas por el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en un entero de 64 bits con signo.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como objeto <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como objeto <see cref="T:System.Object" />.</summary>
        <returns>Objeto de Common Language Runtime (CLR) del tipo más adecuado al que se le ha aplicado la conversión boxing. La propiedad <see cref="P:System.Xml.XmlReader.ValueType" /> determina el tipo CLR adecuado. Si el contenido se escribe como tipo de lista, este método devuelve una matriz de objetos del tipo adecuado a los que se les ha aplicado la conversión boxing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el método para leer el contenido de la `price` nodo. El lector utiliza la información del esquema para asignar el contenido para el tipo de datos correcto.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 El ejemplo utiliza los dos archivos siguientes como entrada.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como objeto <see cref="T:System.Object" />.</summary>
        <returns>Objeto de Common Language Runtime (CLR) del tipo más adecuado al que se le ha aplicado la conversión boxing. La propiedad <see cref="P:System.Xml.XmlReader.ValueType" /> determina el tipo CLR adecuado. Si el contenido se escribe como tipo de lista, este método devuelve una matriz de objetos del tipo adecuado a los que se les ha aplicado la conversión boxing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no se puede convertir en el tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsObjectAsync&gt;c__async2))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee asincrónicamente el elemento actual y devuelve el contenido como objeto <see cref="T:System.Object" />.</summary>
        <returns>Objeto de Common Language Runtime (CLR) del tipo más adecuado al que se le ha aplicado la conversión boxing. La propiedad <see cref="P:System.Xml.XmlReader.ValueType" /> determina el tipo CLR adecuado. Si el contenido se escribe como tipo de lista, este método devuelve una matriz de objetos del tipo adecuado a los que se les ha aplicado la conversión boxing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee el elemento actual y devuelve el contenido como un objeto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el elemento actual y devuelve el contenido como un objeto <see cref="T:System.String" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee el `stringValue` elemento y devuelve el contenido de texto (se omitirá el comentario e instrucción de procesamiento).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no puede convertirse en un objeto <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba que el nombre local especificado y el URI del espacio de nombres coinciden con los del elemento actual y, a continuación, lee este elemento y devuelve el contenido como objeto <see cref="T:System.String" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee la etiqueta de apertura, el contenido del elemento y desplaza el lector más allá de la etiqueta de elemento final. Expande las entidades y omite los comentarios y las instrucciones de procesamiento. El elemento solo puede contener un contenido simple. Es decir, no puede tener elementos secundarios.  
  
 Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia y el [W3C XML Schema Part 2: Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recomendación.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee el `stringValue` elemento y devuelve el contenido de texto (se omitirá el comentario e instrucción de procesamiento).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 En el ejemplo se utiliza como entrada el archivo `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento actual contiene elementos secundarios.  -o bien- El contenido del elemento no puede convertirse en un objeto <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">Se llama al método con argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre local y el identificador URI del espacio de nombres especificados no coinciden con los del elemento que se está leyendo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsStringAsync&gt;c__async3))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee asincrónicamente el elemento actual y devuelve el contenido como un objeto <see cref="T:System.String" />.</summary>
        <returns>Contenido de elemento como objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <summary>Lee los elementos sencillos de solo texto. Sin embargo, se recomienda usar el método <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> en su lugar, porque proporciona una manera más sencilla de controlar esta operación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que use el <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> método para leer un elemento de texto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee un elemento de solo texto. Sin embargo, se recomienda usar el método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> en su lugar, porque proporciona una manera más sencilla de controlar esta operación.</summary>
        <returns>Texto que contiene el elemento leído. Cadena vacía si el elemento está vacío.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que use el <xref:System.Xml.XmlReader.ReadElementContentAsString> método para leer un elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">El siguiente nodo de contenido no es una etiqueta de apertura o el elemento encontrado no contiene un valor de texto simple.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a comprobar.</param>
        <summary>Comprueba si la propiedad <see cref="P:System.Xml.XmlReader.Name" /> del elemento encontrado coincide con la cadena especificada antes de leer un elemento de sólo texto. Sin embargo, se recomienda usar el método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> en su lugar, porque proporciona una manera más sencilla de controlar esta operación.</summary>
        <returns>Texto que contiene el elemento leído. Cadena vacía si el elemento está vacío.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que use el <xref:System.Xml.XmlReader.ReadElementContentAsString> método para leer un elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Si el siguiente nodo de contenido no es una etiqueta de apertura; si el elemento <see langword="Name" /> no coincide con el argumento especificado o si el elemento encontrado no contiene un valor de texto simple.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Nombre local que se va a comprobar.</param>
        <param name="ns">Identificador URI de espacio de nombres que se va a comprobar.</param>
        <summary>Comprueba si las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> del elemento encontrado coinciden con las cadenas especificadas antes de leer un elemento de sólo texto. Sin embargo, se recomienda usar el método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> en su lugar, porque proporciona una manera más sencilla de controlar esta operación.</summary>
        <returns>Texto que contiene el elemento leído. Cadena vacía si el elemento está vacío.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que use el <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> método para leer un elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Si el siguiente nodo de contenido no es una etiqueta de apertura; si el elemento <see langword="LocalName" /> o <see langword="NamespaceURI" /> no coincide con los argumentos especificados o si el elemento encontrado no contiene un valor de texto simple.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba si el nodo de contenido actual es una etiqueta de cierre y desplaza el lector hasta el siguiente nodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el contenido de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 El ejemplo se usa el `book3.xml` archivo.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">El nodo actual no es una etiqueta de cierre o si se encuentra XML incorrecto en el flujo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, lee todo el contenido, incluido el marcado, como una cadena.</summary>
        <returns>Todo el contenido XML, incluido el marcado, del nodo actual. Si el nodo actual no tiene nodos secundarios, se devuelve una cadena vacía.  Si el nodo actual no es un elemento ni un atributo, se devuelve una cadena vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve todo el contenido del nodo actual, incluido el marcado. No se devuelve el nodo actual (etiqueta de inicio) ni el correspondiente nodo final (etiqueta de fin). Por ejemplo, si tuviera el siguiente:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` devuelve `this <child id="123"/>`  
  
 Este método controla los nodos de elemento y atributo de la siguiente manera:  
  
|Tipo de nodo|Posición antes de la llamada|Fragmento XML|Valor devuelto|Posición después de la llamada|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|En la etiqueta de inicio `item1`.|\<Item1 > text1\</item1 >\<item2 > text2\</item2 >|texto1|En la etiqueta de inicio `item2`.|  
|`Attribute`|En el nodo de atributos `attr1`.|\<elemento attr1 = "val1" attr2 = "val2" > texto\</Item >|val1|Permanece en el nodo de atributos `attr1`.|  
  
 Si el sistema de lectura se encuentra situado en un nodo hoja, una llamada a `ReadInnerXml` es equivalente a una llamada a <xref:System.Xml.XmlReader.Read%2A>. El método devuelve `String.Empty` (excepto para los nodos de atributo, en cuyo caso se devuelve el valor del atributo).  
  
 Este método comprueba XML bien formado. Si `ReadInnerXml` se llama desde un <xref:System.Xml.XmlValidatingReader>, este método también valida el contenido devuelto.  
  
 Como se implementa en el <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> y `XmlValidatingReader` clases el `ReadOuterXml` método es compatible con el espacio de nombres.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan los `ReadInnerXml` y <xref:System.Xml.XmlReader.ReadOuterXml%2A> métodos.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 El ejemplo se utiliza `2books.xml` como entrada de archivo.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">El fragmento de XML no está bien formado o se ha producido un error al analizarlo.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadInnerXmlAsync&gt;c__async6))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>De forma asincrónica lee todo el contenido, incluido el marcado, como una cadena.</summary>
        <returns>Todo el contenido XML, incluido el marcado, del nodo actual. Si el nodo actual no tiene nodos secundarios, se devuelve una cadena vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadInnerXml%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, lee el contenido, incluido el marcado, que representa este nodo y todos sus nodos secundarios.</summary>
        <returns>Si el lector está situado en un nodo de elemento o de atributo, este método devuelve todo el contenido XML, incluido el marcado, del nodo actual y de todos sus nodos secundarios; en caso contrario, devuelve una cadena vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es similar a <xref:System.Xml.XmlReader.ReadInnerXml%2A> salvo que también devuelve las etiquetas inicial y final.  
  
 Este método controla los nodos de elemento y atributo de la siguiente manera:  
  
|Tipo de nodo|Posición antes de la llamada|Fragmento XML|Valor devuelto|Posición después de la llamada|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|En la etiqueta de inicio `item1`.|\<Item1 > text1\</item1 >\<item2 > text2\</item2 >|\<Item1 > text1\</item1 >|En la etiqueta de inicio `item2`.|  
|`Attribute`|En el nodo de atributos `attr1`.|\<elemento attr1 = "val1" attr2 = "val2" > texto\</Item >|attr1="val1"|Permanece en el nodo de atributos `attr1`.|  
  
 Si el sistema de lectura se encuentra situado en un nodo hoja, una llamada a `ReadOuterXml` es equivalente a una llamada a <xref:System.Xml.XmlReader.Read%2A>. El método devuelve `String.Empty` (excepto para los nodos de atributo, en cuyo caso se devuelve el marcado de atributo).  
  
 Este método comprueba XML bien formado. Si `ReadOuterXml` se llama desde un <xref:System.Xml.XmlValidatingReader>, este método también valida el contenido devuelto  
  
 Como se implementa en el <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> y `XmlValidatingReader` clases el `ReadOuterXml` método es compatible con el espacio de nombres. Dado el siguiente texto XML `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, si el lector se coloca en el `S:B` etiqueta, de apertura `ReadOuterXml` devuelve `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan los `ReadInnerXml` y `ReadOuterXml` métodos.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 El ejemplo se utiliza `2books.xml` como entrada de archivo.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">El fragmento de XML no está bien formado o se ha producido un error al analizarlo.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadOuterXmlAsync&gt;c__async8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>De forma asincrónica lee el contenido, incluido el marcado, que representa este nodo y todos sus elementos secundarios.</summary>
        <returns>Si el lector está situado en un nodo de elemento o de atributo, este método devuelve todo el contenido XML, incluido el marcado, del nodo actual y de todos sus nodos secundarios; en caso contrario, devuelve una cadena vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadOuterXml%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Comprueba si el nodo actual es un elemento y hace avanzar el sistema de lectura hasta el siguiente nodo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba si el nodo actual es un elemento y hace avanzar el sistema de lectura hasta el siguiente nodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama a <xref:System.Xml.XmlReader.IsStartElement%2A> seguido <xref:System.Xml.XmlReader.Read%2A> a coloque en el contenido del elemento encontrado en el flujo de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se detectó XML incorrecto en el flujo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del elemento.</param>
        <summary>Comprueba si el nodo de contenido actual es un elemento con la propiedad <see cref="P:System.Xml.XmlReader.Name" /> especificada y desplaza el lector hasta el siguiente nodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a este método corresponde a una llamada a <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por una llamada a <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el contenido de texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 El ejemplo se usa el `book3.xml` archivo.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se detectó XML incorrecto en el flujo de entrada.  -o bien- El <see cref="P:System.Xml.XmlReader.Name" /> del elemento no coincide con el <paramref name="name" /> especificado.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Nombre local del elemento.</param>
        <param name="ns">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Comprueba si el nodo de contenido actual es un elemento con las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificadas y desplaza el lector hasta el siguiente nodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a este método corresponde a una llamada a <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por una llamada a <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se detectó XML incorrecto en el flujo de entrada.  -o bien- Las propiedades <see cref="P:System.Xml.XmlReader.LocalName" /> y <see cref="P:System.Xml.XmlReader.NamespaceURI" /> del elemento encontrado no coinciden con los argumentos especificados.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el estado del lector.</summary>
        <value>Uno de los valores de enumeración que especifica el estado del lector.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xml.XmlReader.ReadState%2A> propiedad tiene uno de los siguientes valores:  
  
-   <xref:System.Xml.ReadState.Initial>, cuando el <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> se llama al método.  
  
-   <xref:System.Xml.ReadState.Interactive>, cuando el <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> ha llamado al método y se pueden llamar métodos adicionales en el lector.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, cuando se ha alcanzado el final del documento XML correctamente.  
  
-   <xref:System.Xml.ReadState.Closed>, cuando el <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> se llama al método.  
  
-   <xref:System.Xml.ReadState.Error>, cuando un error impide continuar la operación de lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, lee el contenido de un nodo de elemento o de texto como una cadena. Sin embargo, se recomienda usar el método <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> en su lugar, porque proporciona una manera más sencilla de controlar esta operación.</summary>
        <returns>El contenido del elemento o una cadena vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que use el <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> método para leer el contenido de un nodo de texto o elementos como una cadena.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se ha producido un error al analizar el fragmento de XML.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una nueva instancia de <see langword="XmlReader" /> que se puede utilizar para leer el nodo actual y todos sus descendientes.</summary>
        <returns>Una nueva instancia del lector XML establecida en <see cref="F:System.Xml.ReadState.Initial" />. Al llamar al método <see cref="M:System.Xml.XmlReader.Read" />, se coloca el nuevo lector en el nodo que era el actual antes de la llamada al método <see cref="M:System.Xml.XmlReader.ReadSubtree" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> se puede llamar solo en nodos de elemento. Cuando se ha leído el subárbol completo, las llamadas a la <xref:System.Xml.XmlReader.Read%2A> devuelve del método `false`. Cuando se cerró el nuevo lector XML, el original readeris situado en la `EndElement` nodo del subárbol. Por lo tanto, si llama a la <xref:System.Xml.XmlReader.ReadSubtree%2A> se ha cerrado el método en la etiqueta de apertura del elemento de libro, una vez que ha sido el subárbol de lectura y el nuevo lector XML, se coloca el lector XML original en la etiqueta de cierre del elemento de libro.  
  
 No debería realizar ninguna operación en el sistema de lectura original hasta que se haya cerrado el sistema de lectura nuevo. Esta acción no está admitida, por lo que se puede producir un comportamiento impredecible.  
  
> [!NOTE]
>  El <xref:System.Xml.XmlReader.ReadSubtree%2A> método no está pensado para creatingcopies de los datos XML que puede trabajar independientemente. Está diseñada de su para crear un límite alrededor de un elemento XML. Esto es útil si desea pasar datos a otro componente para el procesamiento y desea limitar la cantidad de los datos que el componente puede tener acceso. Cuando se pasa un lector XML devuelto por la <xref:System.Xml.XmlReader.ReadSubtree%2A> método a otra aplicación, la aplicación puede tener acceso a solo ese elemento XML, no en el documento XML completo.  
  
   
  
## Examples  
 En el siguiente ejemplo, se muestra cómo utilizar el método <xref:System.Xml.XmlReader.ReadSubtree%2A>.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Use los siguientes datos XML para ejecutar los ejemplos de este tema:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Hace avanzar el objeto <see cref="T:System.Xml.XmlReader" /> hasta el siguiente elemento descendiente coincidente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del elemento al que se desea desplazar.</param>
        <summary>Hace avanzar el objeto <see cref="T:System.Xml.XmlReader" /> hasta al siguiente elemento descendiente con el nombre completo especificado.</summary>
        <returns>Es <see langword="true" /> si se encuentra un elemento descendiente; en caso contrario, es <see langword="false" />. Si no se encuentra ningún elemento secundario relacionado, el objeto <see cref="T:System.Xml.XmlReader" /> se coloca en la etiqueta de cierre (<see cref="P:System.Xml.XmlReader.NodeType" /> es <see langword="XmlNodeType.EndElement" />) del elemento.  Si <see cref="T:System.Xml.XmlReader" /> no está en un elemento cuando se llama a <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />, este método devuelve <see langword="false" /> y la posición de <see cref="T:System.Xml.XmlReader" /> no cambia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente analiza el segundo nodo de libro.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 En el ejemplo se utiliza el archivo `2books.xml`como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentException">El parámetro es una cadena vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento al que se desea desplazar.</param>
        <param name="namespaceURI">URI del espacio de nombres del elemento al que se desea desplazar.</param>
        <summary>Hace avanzar el objeto <see cref="T:System.Xml.XmlReader" /> hasta el siguiente elemento descendiente que tenga el URI de espacio de nombres y el nombre local especificados.</summary>
        <returns>Es <see langword="true" /> si se encuentra un elemento descendiente; en caso contrario, es <see langword="false" />. Si no se encuentra ningún elemento secundario relacionado, el objeto <see cref="T:System.Xml.XmlReader" /> se coloca en la etiqueta de cierre (<see cref="P:System.Xml.XmlReader.NodeType" /> es <see langword="XmlNodeType.EndElement" />) del elemento.  Si <see cref="T:System.Xml.XmlReader" /> no está en un elemento cuando se llama a <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />, este método devuelve <see langword="false" /> y la posición de <see cref="T:System.Xml.XmlReader" /> no cambia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos valores del parámetro son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Lee hasta que encuentra el elemento con nombre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del elemento.</param>
        <summary>Lee hasta que encuentra un elemento con el nombre completo especificado.</summary>
        <returns>Es <see langword="true" /> si se encuentra un elemento coincidente; de lo contrario, es <see langword="false" /> y el objeto <see cref="T:System.Xml.XmlReader" /> está en un estado de final de archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es funcionalmente equivalente ejecutando el `following::name` expresión XPath del nodo actual. Proporciona una forma rápida de buscar un elemento con nombre en el documento XML. Desplaza el lector hasta el siguiente elemento que coincide con el nombre especificado y devuelve `true` si se encuentra un elemento coincidente. En el ejemplo siguiente, el lector leería a la primera instancia del elemento especificado al leer hacia delante.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Este método puede llamarse en todos los tipos de nodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentException">El parámetro es una cadena vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Lee hasta que encuentra un elemento con el nombre local y el URI de espacio de nombres especificados.</summary>
        <returns>Es <see langword="true" /> si se encuentra un elemento coincidente; de lo contrario, es <see langword="false" /> y el objeto <see cref="T:System.Xml.XmlReader" /> está en un estado de final de archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es funcionalmente equivalente ejecutando el `following::name` expresión XPath del nodo actual. Proporciona una forma rápida de buscar un elemento con nombre en el documento XML. Desplaza el lector hasta el siguiente elemento que coincide con el nombre especificado y devuelve `true` si se encuentra un elemento coincidente.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Este método puede llamarse en todos los tipos de nodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos valores del parámetro son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Ya hay una operación asincrónica en curso".</exception>
        <summary>Hace avanzar el objeto <see langword="XmlReader" /> hasta el siguiente elemento relacionado coincidente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del elemento relacionado al que se desea desplazar.</param>
        <summary>Hace avanzar el objeto <see langword="XmlReader" /> hasta al siguiente elemento relacionado con el nombre completo especificado.</summary>
        <returns>Es <see langword="true" /> si se encuentra un elemento relacionado; en caso contrario, es <see langword="false" />. Si no se encuentra ningún elemento relacionado, el objeto <see langword="XmlReader" /> se coloca en la etiqueta de cierre (<see cref="P:System.Xml.XmlReader.NodeType" /> es <see langword="XmlNodeType.EndElement" />) del elemento principal.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  No llame a <xref:System.Xml.XmlReader.ReadToNextSibling%2A> cuando el `XmlReader` es un estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> es <xref:System.Xml.ReadState.Initial>). Puede llamar a <xref:System.Xml.XmlReader.Read%2A> para avanzar el `XmlReader` y, a continuación, llame a la <xref:System.Xml.XmlReader.ReadToNextSibling%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente lee el atributo ISBN en cada nodo de libro.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentException">El parámetro es una cadena vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del elemento relacionado al que se desea desplazar.</param>
        <param name="namespaceURI">URI del espacio de nombres del elemento relacionado al que se desea desplazar.</param>
        <summary>Hace avanzar el objeto <see langword="XmlReader" /> al siguiente elemento del mismo nivel que tenga el URI del espacio de nombres y el nombre local especificados.</summary>
        <returns>Es <see langword="true" /> si se encuentra un elemento relacionado; en caso contrario, es <see langword="false" />. Si no se encuentra ningún elemento relacionado, el objeto <see langword="XmlReader" /> se coloca en la etiqueta de cierre (<see cref="P:System.Xml.XmlReader.NodeType" /> es <see langword="XmlNodeType.EndElement" />) del elemento principal.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  No llame a <xref:System.Xml.XmlReader.ReadToNextSibling%2A> cuando el `XmlReader` es un estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> es <xref:System.Xml.ReadState.Initial>). Puede llamar a <xref:System.Xml.XmlReader.Read%2A> para avanzar el `XmlReader` y, a continuación, llame a la <xref:System.Xml.XmlReader.ReadToNextSibling%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentNullException">Ambos valores del parámetro son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres que sirve como búfer en el que se escribe el contenido de texto. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Desplazamiento en el búfer en el que <see cref="T:System.Xml.XmlReader" /> puede empezar a copiar los resultados.</param>
        <param name="count">Número máximo de caracteres que se van a copiar en el búfer. El número real de caracteres copiados se devuelve desde este método.</param>
        <summary>Lee grandes flujos de texto incrustados en un documento XML.</summary>
        <returns>Número de caracteres leídos en el búfer. Si no hay más contenido de texto, se devuelve el valor cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método habilita la lectura de secuencias muy grandes de texto incrustados en un documento XML en un modo de transmisión por secuencias, es decir, un pequeño número de caracteres a la vez en lugar de asignar una cadena única para todo el valor. Este método puede llamarse en cualquier nodo que tiene un valor (<xref:System.Xml.XmlReader.HasValue%2A> es `true`); sin embargo, la transmisión real del valor del nodo solo se produce cuando se llama en un texto, espacios en blanco y nodos de espacio en blanco significativo. Otros valores de tipo de nodo se almacenan en caché, incluidos los atributos y nodos CDATA.  
  
 Este método devuelve sólo el contenido de la <xref:System.Xml.XmlReader.Value%2A> propiedad y no se mueve el <xref:System.Xml.XmlReader>.  
  
 Este método lee el número especificado de caracteres (`count`) del valor del nodo en un búfer de caracteres (`buffer`) en un desplazamiento especificado (`index`) y devuelve el número de caracteres escritos en el búfer. Devuelve el `0` cuando alcanza el final del valor. No se puede reiniciar para volver a leer a través del valor.  
  
 Entre las llamadas a <xref:System.Xml.XmlReader.ReadValueChunk%2A> el <xref:System.Xml.XmlReader> propiedades no hacer ningún cambio, excepto el <xref:System.Xml.XmlReader.Value%2A> propiedad. Cuando el <xref:System.Xml.XmlReader.Value%2A> se tiene acceso a propiedad, puede devolver un valor parcial (con caracteres que aún no se han devueltos por <xref:System.Xml.XmlReader.ReadValueChunk%2A>) o un valor dependiendo de la implementación completo. Todas la <xref:System.Xml.XmlReader> implementaciones en el <xref:System.Xml> espacio de nombres devuelven un valor parcial para el <xref:System.Xml.XmlReader.Value%2A> implementación de propiedades.  
  
 Cualquier lectura método puede llamarse entre las llamadas a <xref:System.Xml.XmlReader.ReadValueChunk%2A>. Si esto ocurre, el <xref:System.Xml.XmlReader> se desplaza a la siguiente <xref:System.Xml.XmlNodeType> se omiten en el flujo y cualquier carácter que aún no se han devuelto.  
  
 Puede haber un caso cuando <xref:System.Xml.XmlReader.ReadValueChunk%2A> devuelve menor que el número de caracteres solicitado. Por ejemplo, si tenía un valor de tipo long de 200 caracteres con un par suplente en las posiciones 127 y 128 y que ha llamado <xref:System.Xml.XmlReader.ReadValueChunk%2A> con un búfer de 128 caracteres, la llamada al método devolvería los 127 caracteres en lugar de los 128 solicitados. A continuación, se devolvería el par suplente en los próximos <xref:System.Xml.XmlReader.ReadValueChunk%2A> llamar. En este caso, <xref:System.Xml.XmlReader.ReadValueChunk%2A> no devolvió los 128 caracteres solicitados porque al hacerlo podría haber creado un par suplente incompleto al final del búfer.  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlReader" /> no admite este método.</exception>
        <exception cref="T:System.Xml.XmlException">El formato de los datos XML no es correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres que sirve como búfer en el que se escribe el contenido de texto. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Desplazamiento en el búfer en el que <see cref="T:System.Xml.XmlReader" /> puede empezar a copiar los resultados.</param>
        <param name="count">Número máximo de caracteres que se van a copiar en el búfer. El número real de caracteres copiados se devuelve desde este método.</param>
        <summary>Lee asincrónicamente grandes flujos de texto incrustados en un documento XML.</summary>
        <returns>Número de caracteres leídos en el búfer. Si no hay más contenido de texto, se devuelve el valor cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.ReadValueChunk%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, resuelve la referencia a entidad para los nodos <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el lector está situado en un `EntityReference` nodo (`XmlNodeType.EntityReference`), si <xref:System.Xml.XmlReader.Read%2A> se llama después de llamar a este método, el texto de reemplazo de entidad se analiza. Cuando finalice el texto de reemplazo de entidad, un `EndEntity` nodo se devuelve al cerrar el ámbito de referencia de entidad.  
  
> [!NOTE]
>  Después de llamar a este método, si la entidad forma parte de un valor de atributo, debe llamar a <xref:System.Xml.XmlReader.ReadAttributeValue%2A> para ir a la entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la información de esquema asignada al nodo actual como resultado de la validación del esquema.</summary>
        <value>Objeto <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> que contiene la información de esquema del nodo actual. La información del esquema se puede establecer en elementos, atributos o nodos de texto con un <see cref="P:System.Xml.XmlReader.ValueType" /> no nulo (valores con tipo).  Si el nodo actual no es ninguno de los tipos de nodo anteriores, o si la instancia de <see langword="XmlReader" /> no proporciona la información del esquema, esta propiedad devuelve <see langword="null" />.  Si los objetos <see cref="T:System.Xml.XmlTextReader" /> y <see cref="T:System.Xml.XmlValidatingReader" /> llaman a esta propiedad, siempre devuelve <see langword="null" />. Estas implementaciones de <see langword="XmlReader" /> no exponen ninguna información de esquema a través de la propiedad <see langword="SchemaInfo" />.  
  
 <block subset="none" type="note"><para> Si tiene que obtener el conjunto de información posterior a la validación del esquema (PSVI) para un elemento, sitúe el lector en la etiqueta de cierre del elemento, en lugar de en la etiqueta de apertura. El PSVI se obtiene a través de la <see langword="SchemaInfo" /> propiedad de un lector. El lector de validación que se crea mediante <see cref="Overload:System.Xml.XmlReader.Create" /> con el <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> propiedad establecida en <see cref="F:System.Xml.ValidationType.Schema" /> tiene el PSVI completo para un elemento solo cuando el lector está situado en la etiqueta de cierre de un elemento.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xml.Schema.IXmlSchemaInfo> interfaz expone un subconjunto del esquema de validación del conjunto de información (PSVI) asociado con un nodo XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xml.XmlReaderSettings" /> que se usa para crear esta instancia de <see cref="T:System.Xml.XmlReader" />.</summary>
        <value>Objeto <see cref="T:System.Xml.XmlReaderSettings" /> utilizado para crear esta instancia del lector. Si este lector no se creó utilizando el método <see cref="Overload:System.Xml.XmlReader.Create" />, esta propiedad devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  La <xref:System.Xml.XmlReaderSettings> objeto puede contener información confidencial como credenciales de usuario. Las aplicaciones deben tener cuidado al almacenamiento en caché este objeto o pasarlo a otro componente.  
  
 La <xref:System.Xml.XmlReaderSettings> clase se utiliza para especificar el conjunto de características compatibles con la instancia de lector creado. La <xref:System.Xml.XmlReaderSettings> objeto devuelto por esta propiedad no se puede modificar. Cualquier intento de cambiar la configuración individual provocará que se produzca una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Omite los nodos secundarios del nodo actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el siguiente código XML de entrada si el lector está situado en la `<a>` nodo o cualquiera de sus atributos, una llamada a `Skip` coloca el lector a la `<b>` nodo.  
  
 Si el lector ya está situado en un nodo hoja (como el `<x>` nodo o el nodo de texto `abc`), al llamar a `Skip` es igual que llamar a <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Este método comprueba XML bien formado.  
  
 Si el lector es una <xref:System.Xml.XmlValidatingReader>, este método también valida el contenido omitido.  
  
 El `XmlReader` implementación determina si el `Skip` método expandirá las entidades externas. La tabla siguiente se describen si se expanden las entidades externas para los distintos tipos de `XmlReader` objetos.  
  
|Tipo de XmlReader|Expande las entidades externas|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|No.|  
|<xref:System.Xml.XmlReader> instancia creada por el <xref:System.Xml.XmlReader.Create%2A> método que está leyendo datos de texto.|No.|  
|<xref:System.Xml.XmlReader> instancia creada por el <xref:System.Xml.XmlReader.Create%2A> método que está leyendo datos binarios.|No es aplicable.|  
|Una validación de esquema <xref:System.Xml.XmlReader> instancia creada por el <xref:System.Xml.XmlReader.Create%2A> método.|Sí.|  
|<xref:System.Xml.XmlValidatingReader>|Sí.|  
|<xref:System.Xml.XmlReader> instancia devuelta por un <xref:System.Xml.XPath.XPathNavigator> objeto.|No es aplicable.|  
|<xref:System.Xml.XmlNodeReader>|No.|  
|<xref:System.Xml.XmlReader> instancia de contenido en otro <xref:System.Xml.XmlReader> instancia.|Depende de la implementación de subyacente <xref:System.Xml.XmlReader>. (El `Skip` método subyacente <xref:System.Xml.XmlReader> se denomina).|  
  
 Para obtener la versión asincrónica de este método, consulte <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente analiza un archivo XML a partir del segundo nodo de libro.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 En el ejemplo se utiliza el archivo `2books.xml`como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Omite de forma asincrónica los elementos secundarios del valor del nodo actual.</summary>
        <returns>Nodo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la versión asincrónica de <xref:System.Xml.XmlReader.Skip%2A>, con la misma funcionalidad. Para usar este método, debe establecer el <xref:System.Xml.XmlReaderSettings.Async%2A> marca `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método asincrónico de <see cref="T:System.Xml.XmlReader" /> sin establecer la marca <see cref="P:System.Xml.XmlReaderSettings.Async" /> en <see langword="true" />. En este caso, se produce <see cref="T:System.InvalidOperationException" /> con el mensaje "Establezca XmlReaderSettings.Async en true si quiere usar métodos asincrónicos".</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el valor de texto del nodo actual.</summary>
        <value>El valor devuelto depende de la propiedad <see cref="P:System.Xml.XmlReader.NodeType" /> del nodo:  En la siguiente tabla se recogen los tipos de nodo que tienen un valor para devolver. Todos los demás tipos de nodo devuelven <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Tipo de nodo </term><description> valor </description></listheader><item><term><see langword="Attribute" /></term><description> el valor del atributo.  </description></item><item><term><see langword="CDATA" /></term><description> El contenido de la sección CDATA.  </description></item><item><term><see langword="Comment" /></term><description> El contenido del comentario.  </description></item><item><term><see langword="DocumentType" /></term><description> Subconjunto interno.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Todo el contenido, salvo el destino.  </description></item><item><term><see langword="SignificantWhitespace" /></term><description> El espacio en blanco entre marcas en un modelo de contenido mixto.  </description></item><item><term><see langword="Text" /></term><description> El contenido del nodo de texto.  </description></item><item><term><see langword="Whitespace" /></term><description> El espacio en blanco entre marcas.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> El contenido de la declaración.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener la versión asincrónica de esta propiedad, vea el <xref:System.Xml.XmlReader.GetValueAsync%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 El ejemplo usa el `items.xml` archivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de Common Language Runtime (CLR) del nodo actual.</summary>
        <value>Tipo de CLR correspondiente al valor con tipo del nodo. El valor predeterminado es <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte [compatibilidad de tipos en las clases System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) para obtener una lista de las asignaciones predeterminadas.  
  
 Un elemento de tipo `xs:int` tiene un `ValueType` de `System.Int32` de forma predeterminada. Sin embargo, el `ValueType` puede ser uno de los tipos válidos que se pueden asignar a `xs:int`, tales como `System.Int16` o `System.Double`.  
  
 Si un nodo está sin tipo, o si el nodo es un elemento que contiene contenido mixto, el valor del nodo se asigna a la `System.String` tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <block subset="none" type="overrides">
          <para>Los implementadores deben proporcionar un <see langword="ValueType" /> por cada nodo, aunque solo sea el <see langword="System.String" /> tipo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el ámbito de <see langword="xml:lang" /> actual.</summary>
        <value>Ámbito de <see langword="xml:lang" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad representa el `xml:lang` definir el ámbito en que reside el nodo actual. Por ejemplo, este es un fragmento XML con `xml:lang` establecido en inglés de Estados Unidos en el elemento raíz:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Cuando el lector está situado en la `name` elemento, puede utilizar esta propiedad para saber que está en el ámbito de un inglés de Estados Unidos `xml:lang` atributo.  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> para obtener un ejemplo del uso de esta propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el ámbito de <see langword="xml:space" /> actual.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.XmlSpace" />. Si no existe ningún ámbito de <see langword="xml:space" />, el valor predeterminado de esta propiedad será <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.XmlSpace%2A> (en el `XmlTextReader` clase) para obtener un ejemplo de uso de esta propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó un método <see cref="T:System.Xml.XmlReader" /> antes de que se termine una operación asincrónica anterior. En este caso, se genera <see cref="T:System.InvalidOperationException" /> con el mensaje “Ya hay una operación asincrónica en curso”.</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>