<Type Name="XmlNode" FullName="System.Xml.XmlNode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c48fa7f47d4343bbfa1daab5ffe003781b8eae3f" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52742176" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlNode : ICloneable, System.Collections.IEnumerable, System.Xml.XPath.IXPathNavigable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlNode extends System.Object implements class System.Collections.IEnumerable, class System.ICloneable, class System.Xml.XPath.IXPathNavigable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlNode&#xA;Implements ICloneable, IEnumerable, IXPathNavigable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlNode abstract : ICloneable, System::Collections::IEnumerable, System::Xml::XPath::IXPathNavigable" />
  <TypeSignature Language="F#" Value="type XmlNode = class&#xA;    interface ICloneable&#xA;    interface IEnumerable&#xA;    interface IXPathNavigable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.XPath.IXPathNavigable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un único nodo en el documento XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase implementa el nivel 1 principal del Document Object Model (DOM) de W3C y nivel 2 de DOM Core. El DOM es una representación de árbol en memoria (caché) de un documento XML. `XmlNode` es la clase base en la implementación de .NET del DOM. Admite selecciones XPath y proporciona capacidades de edición. El <xref:System.Xml.XmlDocument> extiende la clase `XmlNode` y representa un documento XML. Puede usar `XmlDocument` para cargar y guardar los datos XML. También incluye métodos para la creación de nodos. Consulte [Document Object Model (DOM) XML](~/docs/standard/data/xml/xml-document-object-model-dom.md) para obtener más información.  
  
> [!IMPORTANT]
>  Las excepciones generadas como resultado de utilizar el <xref:System.Xml.XmlNode> clase, como el <xref:System.Xml.XmlException> clase puede contener información confidencial que no debe exponerse en escenarios de confianza. Las excepciones se deben administrar correctamente para que esta información confidencial no se expone en escenarios de confianza.  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Xml.XmlNode.SelectNodes(System.String)" />
    <related type="Article" href="~/docs/standard/data/xml/create-new-nodes-in-the-dom.md">[&lt;topic://cpconCreateNewNodesInDOM&gt;]</related>
  </Docs>
  <Members>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode AppendChild (System.Xml.XmlNode newChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode AppendChild(class System.Xml.XmlNode newChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.AppendChild(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AppendChild (newChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ AppendChild(System::Xml::XmlNode ^ newChild);" />
      <MemberSignature Language="F#" Value="abstract member AppendChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.AppendChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.AppendChild newChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Nodo que se va a agregar. Todo el contenido del nodo que se va a agregar se pasa a la ubicación especificada.</param>
        <summary>Agrega el nodo especificado al final de la lista de nodos secundarios de este nodo.</summary>
        <returns>Nodo agregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `newChild` está ya en el árbol, se quita de su posición original y se agrega a su posición de destino. Para obtener más información acerca de cómo insertar nodos, consulte [insertar nodos en un documento XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Si el nodo que se va a insertar se creó desde otro documento, puede usar <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> para importar el nodo para el documento actual. El nodo importado, a continuación, se puede insertar en el documento actual.  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo nodo en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.AppendChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.AppendChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.AppendChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.AppendChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.AppendChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.AppendChild Example/VB/source.vb#1)]  
  
 **Salida:**  
  
```  
Display the modified XML...  
<?xml version="1.0" encoding="IBM437"?>  
<book genre="novel" ISBN="1-861001-57-5">  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este nodo es de un tipo que no permite nodos secundarios del tipo del nodo <paramref name="newChild" />.  
  
<paramref name="newChild" /> es un nodo antecesor de este nodo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> se creó a partir de un documento diferente del que creó este nodo.  
  
Este nodo es de sólo lectura.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="AppendChild" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="AppendChild" /> método de la clase base.</para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Inserción de nodos en un documento XML</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlAttributeCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Attributes As XmlAttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlAttributeCollection ^ Attributes { System::Xml::XmlAttributeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Xml.XmlAttributeCollection" Usage="System.Xml.XmlNode.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Xml.XmlAttributeCollection" /> que contiene los atributos de este nodo.</summary>
        <value><see langword="XmlAttributeCollection" /> que contiene los atributos de este nodo.  
  
Si el nodo es del tipo XmlNodeType.Element, se devuelven sus atributos. En caso contrario, esta propiedad devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente agrega un nuevo atributo al documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public virtual string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlNode.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI base del nodo actual.</summary>
        <value>Ubicación desde la que se cargó el nodo o String.Empty si el nodo no tiene un identificador URI base.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un documento XML en red se compone de fragmentos de datos agregados mediante varios mecanismos de inclusión estándar de W3C y, por tanto, contiene nodos que proceden de distintos lugares. El `BaseURI` explica procedencia de estos nodos.  
  
 El valor de esta propiedad varía según el tipo de nodo. Por ejemplo, los nodos de documento devuelven la ubicación de la <xref:System.Xml.XmlDocument> objeto. Nodos que son nodos secundarios de nodos EntityReference externos devuelven la ubicación de la propia entidad. Por ejemplo, considere el siguiente documento XML:  
  
```xml  
<!DOCTYPE item [  
<!ENTITY xyz SYSTEM "a/b.xml">  
]>  
<item num='123'>&xyz;</item>  
```  
  
 donde la entidad externa `a/b.xml` contiene el texto XML: `<test>123</test>`.  
  
 Si el documento se carga desde http://server/mydata.xml, `BaseURI` devuelve lo siguiente:  
  
|NodeType|Name|BaseURI|  
|--------------|----------|-------------|  
|Atributo|num|http://server/mydata.xml|  
|Documento|#document|http://server/mydata.xml|  
|DocumentType|elemento|http://server/mydata.xml|  
|Entity|XYZ|http://server/mydata.xml|  
|Element|elemento|http://server/mydata.xml|  
|EntityReference|XYZ|http://server/mydata.xml|  
|Element|prueba|http://server/a/b.xml|  
|Texto|#text|http://server/a/b.xml|  
  
 `BaseURI` busca la entidad hacen referencia a los límites, por lo que si se expanden las entidades no se conserva esta información y esta propiedad devuelve la ubicación de la `XmlDocument` objeto en todos los casos.  
  
 Como segundo ejemplo, dado el siguiente documento XML:  
  
```xml  
<!DOCTYPE Mydata SYSTEM "http://localhost/doctype.dtd">  
<baa>&xyz;</baa>  
```  
  
 donde el archivo DTD contiene lo siguiente:  
  
```  
<!ENTITY xyz <E1>My Data</E1>  
<!ELEMENT baa #PCDATA>  
<!ATTLIST baa attr1 "woof">  
```  
  
 Si el documento XML se carga desde http://localhost/mydata.xml, `BaseURI` devuelve lo siguiente para cada uno de los nodos:  
  
|NodeType|Name|BaseURI|  
|--------------|----------|-------------|  
|Documento|#document|http://localhost/mydata.xml|  
|DocumentType|Mydata|http://localhost/mydata.xml<br /><br /> El <xref:System.Xml.XmlDocumentType.SystemId%2A?displayProperty=nameWithType> o <xref:System.Xml.XmlDocumentType.PublicId%2A?displayProperty=nameWithType> propiedades pueden usarse para identificar dónde se cargó el archivo DTD desde.|  
|Element|acuerdo de asociación|http://localhost/mydata.xml|  
|Entity|XYZ|http://localhost/doctype.dtd|  
|EntityReference|XYZ|http://localhost/mydata.xml|  
|Atributo|woof|http://localhost/mydata.xml|  
  
> [!NOTE]
>  El URI base de un atributo predeterminado es el mismo que el URI base del elemento al que pertenecen.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNodes">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList ChildNodes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNodeList ChildNodes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.ChildNodes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ChildNodes As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeList ^ ChildNodes { System::Xml::XmlNodeList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildNodes : System.Xml.XmlNodeList" Usage="System.Xml.XmlNode.ChildNodes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene todos los nodos secundarios del nodo.</summary>
        <value>Objeto que contiene todos los nodos secundarios del nodo.  
  
Si no hay ningún nodo secundario, esta propiedad devuelve un objeto <see cref="T:System.Xml.XmlNodeList" /> vacío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de los nodos secundarios, vea el [especificación de nivel 1 de DOM del W3C (núcleos)](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html)  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los nodos secundarios del elemento raíz.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Xml.XmlNode&#xA;override this.Clone : unit -&gt; System.Xml.XmlNode" Usage="xmlNode.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un duplicado de este nodo.</summary>
        <returns>Nodo clonado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Clonación de un <xref:System.Xml.XmlElement> copia todos los atributos y sus valores, los generados por el procesador XML para representar los atributos predeterminados incluidos. Este método recursivamente clona el nodo y su subárbol.  
  
 `Clone` equivale a llamar a `CloneNode(true)`.  
  
 En la tabla siguiente se describe el comportamiento específico para cada <xref:System.Xml.XmlNodeType>.  
  
|Tipo XmlNode|Clonar|  
|-----------------|-----------|  
|Atributo|Clona el nodo de atributo, incluidos los nodos secundarios.|  
|CData|Clona el nodo de CData, incluido su contenido de datos.|  
|Comentario|Clona el nodo de comentario, incluido su contenido de texto.|  
|Documento|Clona el nodo de documento, incluidos todos los nodos secundarios.|  
|DocumentFragment|Clona el nodo de fragmento de documento, incluidos todos los nodos secundarios.|  
|DocumentType|Clona el nodo de tipo de documento.|  
|Element|Clona el nodo de elemento, sus atributos y nodos secundarios.|  
|Entity|Los nodos de entidad no se pueden clonar.|  
|EntityReference|Clona el nodo de referencia de entidad. El texto de sustitución no se incluye.|  
|Notation|Los nodos Notation no se pueden clonar.|  
|ProcessingInstruction|Clona el nodo de instrucción de procesamiento, incluidos sus datos y destino.|  
|SignificantWhitespace|Clona el nodo de espacio en blanco significativo con su valor de datos.|  
|Texto|Clona el nodo de texto, incluidos su valor de datos.|  
|Whitespace|Clona el nodo de espacio en blanco, incluidos su valor de datos.|  
|XmlDeclaration|Clona el nodo XmlDeclaration con su valor de datos.|  
|Todos los demás tipos de nodo.|Estos tipos de nodo no se puede clonar.|  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente clona el nodo raíz del documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.Clone Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.Clone Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlNode.CloneNode(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="abstract member CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlNode.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep"><see langword="true" /> para clonar de forma recursiva el subárbol del nodo especificado; <see langword="false" /> solo para clonar el nodo en sí.</param>
        <summary>Crea un duplicado del nodo, cuando se invalida en una clase derivada.</summary>
        <returns>Nodo clonado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método actúa como un constructor de copias de los nodos. Nodo duplicado no tiene ningún elemento primario (<xref:System.Xml.XmlNode.ParentNode%2A> devuelve `null`).  
  
 En la tabla siguiente se describe el comportamiento específico para cada <xref:System.Xml.XmlNodeType>.  
  
|Tipo XmlNode|CloneNode (true)|CloneNode(false)|  
|-----------------|-----------------------|------------------------|  
|Atributo|Clona el nodo de atributo, incluidos los nodos secundarios.|Clona el nodo de atributo, incluidos los nodos secundarios.|  
|CData|Clona el nodo de CData, incluido su contenido de datos.|Clona el nodo de CData, incluido su contenido de datos.|  
|Comentario|Clona el nodo de comentario, incluido su contenido de texto.|Clona el nodo de comentario, incluido su contenido de texto.|  
|Documento|Clona el nodo de documento, incluidos todos los nodos secundarios.|Clona el nodo de documento.|  
|DocumentFragment|Clona el nodo de fragmento de documento, incluidos todos los nodos secundarios.|Clona el nodo de fragmento de documento.|  
|DocumentType|Clona el nodo de tipo de documento.|Clona el nodo de tipo de documento.|  
|Element|Clona el nodo de elemento, sus atributos y nodos secundarios.|Clona el nodo de elemento y sus atributos, incluidos los atributos de forma predeterminada.|  
|Entity|Los nodos de entidad no se pueden clonar.|Los nodos de entidad no se pueden clonar.|  
|EntityReference|Clona el nodo de referencia de entidad. El texto de sustitución no se incluye.|Clona el nodo de referencia de entidad. El texto de sustitución no se incluye.|  
|Notation|Los nodos Notation no se pueden clonar.|Los nodos Notation no se pueden clonar.|  
|ProcessingInstruction|Clona el nodo de instrucción de procesamiento, incluidos sus datos y destino.|Clona el nodo de instrucción de procesamiento, incluidos sus datos y destino.|  
|SignificantWhitespace|Clona el nodo de espacio en blanco significativo con su valor de datos.|Clona el nodo de espacio en blanco significativo con su valor de datos.|  
|Texto|Clona el nodo de texto, incluidos su valor de datos.|Clona el nodo de texto, incluidos su valor de datos.|  
|Whitespace|Clona el nodo de espacio en blanco, incluidos su valor de datos.|Clona el nodo de espacio en blanco, incluidos su valor de datos.|  
|XmlDeclaration|Clona el nodo XmlDeclaration con su valor de datos.|Clona el nodo XmlDeclaration con su valor de datos.|  
|Todos los demás tipos de nodo.|Estos tipos de nodo no se puede clonar.|Estos tipos de nodo no se puede clonar.|  
  
   
  
## Examples  
 El ejemplo siguiente muestra la diferencia entre un clon superficial.  
  
 [!code-cpp[Classic WebData XmlNode.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Llamar a este método en un tipo de nodo que no se puede clonar.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="abstract member CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator&#xA;override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlNode.CreateNavigator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.XPath.IXPathNavigable.CreateNavigator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para desplazarse por este objeto.</summary>
        <returns>Un objeto <see langword="XPathNavigator" /> utilizado para navegar por el nodo. <see langword="XPathNavigator" /> se sitúa en el nodo desde el que se llamó al método. No se sitúa en la raíz del documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XPathNavigator` proporciona acceso aleatorio de solo lectura a los datos. Dado que está optimizado para las transformaciones XSLT, ofrece ventajas de rendimiento cuando se usa como mecanismo de entrada la <xref:System.Xml.Xsl.XslTransform.Transform%2A?displayProperty=nameWithType> método.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 En el siguiente ejemplo se carga y se edita un documento XML antes de realizar una transformación XSLT.  
  
 [!code-cpp[XslTransform.Transform2#1](~/samples/snippets/cpp/VS_Snippets_Data/XslTransform.Transform2/CPP/trans_snip.cpp#1)]
 [!code-csharp[XslTransform.Transform2#1](~/samples/snippets/csharp/VS_Snippets_Data/XslTransform.Transform2/CS/trans_snip.cs#1)]
 [!code-vb[XslTransform.Transform2#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XslTransform.Transform2/VB/trans_snip.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Xsl.XslTransform" />
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FirstChild As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ FirstChild { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Xml.XmlNode" Usage="System.Xml.XmlNode.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el primer nodo secundario del nodo.</summary>
        <value>Primer nodo secundario del nodo. Si no hay nodo secundario, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de los nodos secundarios, vea el [especificación de nivel 1 de DOM del W3C (núcleos)](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html)  
  
   
  
## Examples  
 El ejemplo siguiente muestra el elemento de título.  
  
 [!code-cpp[Classic WebData XmlNode.FirstChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.FirstChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.FirstChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.FirstChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.FirstChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.FirstChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="xmlNode.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un enumerador que recorre en iteración los nodos secundarios del nodo actual.</summary>
        <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede utilizarse para recorrer en iteración los nodos secundarios en el nodo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proporciona compatibilidad para el estilo "for each" iteración a través de los nodos en el `XmlNode`.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los libros en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `books.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlNode.GetEnumerator Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamespaceOfPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetNamespaceOfPrefix (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetNamespaceOfPrefix(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.GetNamespaceOfPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNamespaceOfPrefix (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetNamespaceOfPrefix(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member GetNamespaceOfPrefix : string -&gt; string&#xA;override this.GetNamespaceOfPrefix : string -&gt; string" Usage="xmlNode.GetNamespaceOfPrefix prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo cuyo URI de espacio de nombres se desea buscar.</param>
        <summary>Busca la declaración **xmlns** más cercana para el prefijo especificado que está en el ámbito del nodo actual y devuelve el identificador URI de espacio de nombres de la declaración.</summary>
        <returns>Identificador URI de espacio de nombres del prefijo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo atributo al documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrefixOfNamespace">
      <MemberSignature Language="C#" Value="public virtual string GetPrefixOfNamespace (string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPrefixOfNamespace(string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.GetPrefixOfNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrefixOfNamespace (namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPrefixOfNamespace(System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetPrefixOfNamespace : string -&gt; string&#xA;override this.GetPrefixOfNamespace : string -&gt; string" Usage="xmlNode.GetPrefixOfNamespace namespaceURI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceURI">Identificador URI de espacio de nombres cuyo prefijo se desea buscar.</param>
        <summary>Busca la declaración **xmlns** más cercana para el identificador URI de espacio de nombres especificado que está en el ámbito del nodo actual y devuelve el prefijo definido en la declaración.</summary>
        <returns>Prefijo del identificador URI de espacio de nombres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo elemento en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.GetPrefixOfNamespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetPrefixOfNamespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetPrefixOfNamespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetPrefixOfNamespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetPrefixOfNamespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetPrefixOfNamespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChildNodes">
      <MemberSignature Language="C#" Value="public virtual bool HasChildNodes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildNodes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.HasChildNodes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasChildNodes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasChildNodes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildNodes : bool" Usage="System.Xml.XmlNode.HasChildNodes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este nodo tiene nodos secundarios.</summary>
        <value>Es <see langword="true" /> si el nodo tiene nodos secundarios; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de los nodos secundarios, vea el [especificación de nivel 1 de DOM del W3C (núcleos)](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html)  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los nodos secundarios del elemento raíz.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public virtual string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Xml.XmlNode.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los valores concatenados del nodo y de todos sus nodos secundarios.</summary>
        <value>Valores concatenados del nodo y de todos sus nodos secundarios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad reemplaza todos los nodos secundarios con el contenido analizado de la cadena especificada.  
  
 Para los nodos hoja, `InnerText` devuelve el mismo contenido que el <xref:System.Xml.XmlNode.Value%2A> propiedad.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan los `InnerText` y <xref:System.Xml.XmlNode.InnerXml%2A> propiedades.  
  
 [!code-cpp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/VB/source.vb#1)]  
  
 **Salida:**  
  
```  
Display the InnerText of the element...  
some textmore text  
Display the InnerXml of the element...  
some text<child />more text  
<elem>Text containing &lt;markup/&gt; will have char(&lt;) and char(&gt;) escape  
d.</elem>  
<elem>Text containing <markup />.</elem>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public virtual string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlNode.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el marcado que representa solo los nodos secundarios de este nodo.</summary>
        <value>Marcado de los nodos secundarios de este nodo.  
  
 <block subset="none" type="note"><para><see langword="InnerXml" /> no devuelve los atributos predeterminados.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Intenta establecer esta propiedad desde un nodo que no puede tener nodos secundarios, por ejemplo un nodo de texto, se produce una excepción. En caso contrario, establecer `InnerXml` reemplaza los nodos secundarios, del nodo, con el contenido analizado de la cadena especificada. El análisis se realiza en el contexto del espacio de nombres actual.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
> [!NOTE]
>  `InnerXml` no es una manera eficaz para modificar el DOM. Puede haber problemas de rendimiento al reemplazar nodos complejos. Resulta más eficaz para construir nodos y usar métodos como `InsertBefore`, `InsertAfter`, `AppendChild`, y `RemoveChild` para modificar el documento Xml.  
  
   
  
## Examples  
 En el ejemplo siguiente se comparan los <xref:System.Xml.XmlNode.InnerText%2A> y `InnerXml` propiedades.  
  
 [!code-cpp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Establecer esta propiedad en un nodo que no puede tener secundarios.</exception>
        <exception cref="T:System.Xml.XmlException">El código XML especificado al establecer esta propiedad no es correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertAfter">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode InsertAfter (System.Xml.XmlNode newChild, System.Xml.XmlNode refChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode InsertAfter(class System.Xml.XmlNode newChild, class System.Xml.XmlNode refChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.InsertAfter(System.Xml.XmlNode,System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InsertAfter (newChild As XmlNode, refChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ InsertAfter(System::Xml::XmlNode ^ newChild, System::Xml::XmlNode ^ refChild);" />
      <MemberSignature Language="F#" Value="abstract member InsertAfter : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.InsertAfter : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.InsertAfter (newChild, refChild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
        <Parameter Name="refChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild"><see langword="XmlNode" /> que se va a insertar.</param>
        <param name="refChild"><see langword="XmlNode" /> que es el nodo de referencia. <c>newNode</c> se coloca después de <c>refNode</c>.</param>
        <summary>Inserta el nodo especificado inmediatamente detrás del nodo de referencia igualmente especificado.</summary>
        <returns>Nodo que se va a insertar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `refChild` es `null`, insertar `newChild` al principio de la lista de nodos secundarios. Todo el contenido de la `newChild` se insertan en el mismo orden, después `refChild`. Si el `newChild` está ya en el árbol, se quita de su posición original y se agrega a su posición de destino. Para obtener más información acerca de cómo insertar nodos, consulte [insertar nodos en un documento XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Si el nodo que se va a insertar se creó desde otro documento, puede usar <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> para importar el nodo para el documento actual. El nodo importado, a continuación, se puede insertar en el documento actual.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo nodo en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.InsertAfter Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InsertAfter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InsertAfter Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InsertAfter Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InsertAfter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InsertAfter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este nodo es de un tipo que no permite nodos secundarios del tipo del nodo <paramref name="newChild" />.  
  
<paramref name="newChild" /> es un nodo antecesor de este nodo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> se creó a partir de un documento diferente del que creó este nodo.  
  
<paramref name="refChild" /> no es un nodo secundario de este nodo.  
  
Este nodo es de sólo lectura.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="InsertAfter" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="InsertAfter" /> método de la clase base.</para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Inserción de nodos en un documento XML</related>
      </Docs>
    </Member>
    <Member MemberName="InsertBefore">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode InsertBefore (System.Xml.XmlNode newChild, System.Xml.XmlNode refChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode InsertBefore(class System.Xml.XmlNode newChild, class System.Xml.XmlNode refChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.InsertBefore(System.Xml.XmlNode,System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InsertBefore (newChild As XmlNode, refChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ InsertBefore(System::Xml::XmlNode ^ newChild, System::Xml::XmlNode ^ refChild);" />
      <MemberSignature Language="F#" Value="abstract member InsertBefore : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.InsertBefore : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.InsertBefore (newChild, refChild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
        <Parameter Name="refChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild"><see langword="XmlNode" /> que se va a insertar.</param>
        <param name="refChild"><see langword="XmlNode" /> que es el nodo de referencia. <paramref name="newChild" /> se coloca delante de este nodo.</param>
        <summary>Inserta el nodo especificado inmediatamente antes del nodo de referencia igualmente especificado.</summary>
        <returns>Nodo que se va a insertar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `refChild` es `null`, insertar `newChild` al final de la lista de nodos secundarios. Todo el contenido de la `newChild` se insertan, en el mismo orden, antes `refChild`. Si el `newChild` está ya en el árbol, se quita de su posición original y se agrega a su posición de destino. Para obtener más información acerca de cómo insertar nodos, consulte [insertar nodos en un documento XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Si el nodo que se va a insertar se creó desde otro documento, puede usar <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> para importar el nodo para el documento actual. El nodo importado, a continuación, se puede insertar en el documento actual.  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo nodo en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.InsertBefore Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InsertBefore Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InsertBefore Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InsertBefore Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InsertBefore Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InsertBefore Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El nodo actual es de un tipo que no permite nodos secundarios del tipo del nodo <paramref name="newChild" />.  
  
<paramref name="newChild" /> es un nodo antecesor de este nodo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> se creó a partir de un documento diferente del que creó este nodo.  
  
<paramref name="refChild" /> no es un nodo secundario de este nodo.  
  
Este nodo es de sólo lectura.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="InsertBefore" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="InsertBefore" /> método de la clase base.</para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Inserción de nodos en un documento XML</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlNode.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el nodo es de solo lectura.</summary>
        <value>Es <see langword="true" /> si el nodo es de sólo lectura; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nodo de solo lectura es uno cuyos nodos secundarios, atributos o propiedades no se puede cambiar. Puede quitar un nodo de solo lectura del árbol e insértelo en otro lugar. Por ejemplo, los nodos de entidad son siempre de solo lectura.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el elemento secundario especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlElement ^ default[System::String ^] { System::Xml::XmlElement ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Xml.XmlElement" Usage="System.Xml.XmlNode.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del elemento que se va a recuperar.</param>
        <summary>Obtiene el primer elemento secundario con el <see cref="P:System.Xml.XmlNode.Name" /> especificado.</summary>
        <value>Primer <see cref="T:System.Xml.XmlElement" /> que coincide con el nombre especificado. Devuelve una referencia nula (<see langword="Nothing" /> en Visual Basic) si no hay ninguna coincidencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente muestra el elemento de título.  
  
 [!code-cpp[Classic WebData XmlNode.this Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.this Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.this Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement this[string localname, string ns] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(localname As String, ns As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlElement ^ default[System::String ^, System::String ^] { System::Xml::XmlElement ^ get(System::String ^ localname, System::String ^ ns); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : System.Xml.XmlElement" Usage="System.Xml.XmlNode.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Nombre local del elemento.</param>
        <param name="ns">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Obtiene el primer elemento secundario con el <see cref="P:System.Xml.XmlNode.LocalName" /> y el <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <value>Primer <see cref="T:System.Xml.XmlElement" /> con los parámetros <paramref name="localname" /> y <paramref name="ns" /> coincidentes. Archivos .natvis Devuelve una referencia nula (<see langword="Nothing" /> en Visual Basic) si no hay ninguna coincidencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode LastChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode LastChild" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.LastChild" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LastChild As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ LastChild { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LastChild : System.Xml.XmlNode" Usage="System.Xml.XmlNode.LastChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el último nodo secundario del nodo.</summary>
        <value>Último nodo secundario del nodo. Si no hay nodo secundario, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el elemento de precio.  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlNode.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre local del nodo, cuando se invalida en una clase derivada.</summary>
        <value>Nombre del nodo sin prefijo. Por ejemplo, <see langword="LocalName" /> es "book" para el elemento &lt;bk: book&gt;.  
  
El nombre devuelto depende de la propiedad <see cref="P:System.Xml.XmlNode.NodeType" /> del nodo. 
 <list type="table"><listheader><term> Tipo 
 </term><description> Name 
 </description></listheader><item><term> Atributo 
 </term><description> Nombre local del atributo.  
  
 </description></item><item><term> CDATA 
 </term><description> #cdata-section 
 </description></item><item><term> Comentario 
 </term><description> #comment 
 </description></item><item><term> Documento 
 </term><description> #document 
 </description></item><item><term> DocumentFragment 
 </term><description> #document-fragment 
 </description></item><item><term> DocumentType 
 </term><description> Nombre del tipo de documento.  
  
 </description></item><item><term> Element 
 </term><description> Nombre local del elemento.  
  
 </description></item><item><term> Entity 
 </term><description> Nombre de la entidad.  
  
 </description></item><item><term> EntityReference 
 </term><description> Nombre de la entidad a la que se hace referencia.  
  
 </description></item><item><term> Notation 
 </term><description> Nombre de la notación.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Destino de la instrucción de procesamiento.  
  
 </description></item><item><term> Texto 
 </term><description> #text 
 </description></item><item><term> Whitespace 
 </term><description> #whitespace 
 </description></item><item><term> SignificantWhitespace 
 </term><description> #significant-whitespace 
 </description></item><item><term> XmlDeclaration 
 </term><description> #xml-declaration 
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el nodo no tiene un prefijo, LocalName es igual a <xref:System.Xml.XmlNode.Name%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlNode.Prefix" />
        <altmember cref="P:System.Xml.XmlNode.Name" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlNode.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el nombre completo del nodo.</summary>
        <value>Nombre completo del nodo. El nombre devuelto depende de la propiedad <see cref="P:System.Xml.XmlNode.NodeType" /> del nodo. 
 <list type="table"><listheader><term> Tipo 
 </term><description> Name 
 </description></listheader><item><term> Atributo 
 </term><description> Nombre completo del atributo.  
  
 </description></item><item><term> CDATA 
 </term><description> #cdata-section 
 </description></item><item><term> Comentario 
 </term><description> #comment 
 </description></item><item><term> Documento 
 </term><description> #document 
 </description></item><item><term> DocumentFragment 
 </term><description> #document-fragment 
 </description></item><item><term> DocumentType 
 </term><description> Nombre del tipo de documento.  
  
 </description></item><item><term> Element 
 </term><description> Nombre completo del elemento.  
  
 </description></item><item><term> Entity 
 </term><description> Nombre de la entidad.  
  
 </description></item><item><term> EntityReference 
 </term><description> Nombre de la entidad a la que se hace referencia.  
  
 </description></item><item><term> Notation 
 </term><description> Nombre de la notación.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Destino de la instrucción de procesamiento.  
  
 </description></item><item><term> Texto 
 </term><description> #text 
 </description></item><item><term> Whitespace 
 </term><description> #whitespace 
 </description></item><item><term> SignificantWhitespace 
 </term><description> #significant-whitespace 
 </description></item><item><term> XmlDeclaration 
 </term><description> #xml-declaration 
 </description></item></list></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public virtual string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlNode.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI de espacio de nombres de este nodo.</summary>
        <value>Identificador URI de espacio de nombres de este nodo. Si no hay identificador URI de espacio de nombres, esta propiedad devuelve String.Empty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este es el espacio de nombres que URI especificado en tiempo de creación. Por ejemplo, `NamespaceURI` es urn: ejemplos para el elemento \<bk: book bk = "urn: ejemplos" >  
  
 Un atributo no hereda desde el elemento a que está asociado su espacio de nombres. Si un atributo no se especifica explícitamente un espacio de nombres, simplemente no tiene ningún espacio de nombres.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NextSibling As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ NextSibling { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Xml.XmlNode" Usage="System.Xml.XmlNode.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nodo inmediatamente siguiente a éste.</summary>
        <value>La clase <see langword="XmlNode" /> siguiente. Si no hay nodo siguiente, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra todos los libros en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlNode.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del nodo actual cuando se invalida en una clase derivada.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.XmlNodeType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad nunca devuelve el `XmlNodeType` EndElement, EndEntity o None.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public virtual void Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Normalize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Normalize();" />
      <MemberSignature Language="F#" Value="abstract member Normalize : unit -&gt; unit&#xA;override this.Normalize : unit -&gt; unit" Usage="xmlNode.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que todos los nodos XmlText de toda la profundidad del subárbol situado bajo XmlNode aparezcan de forma "normal", de modo que solo el marcado (es decir, las etiquetas, comentarios, instrucciones de procesamiento, secciones CDATA y referencias a entidades) separa los nodos XmlText, es decir, no hay nodos XmlText adyacentes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede usarse para asegurarse de que la vista DOM de un documento es el mismo que si se hubiera guardado y volver a cargar y es útil cuando las operaciones (por ejemplo, búsquedas XPointer) que dependen de una estructura de árbol de documento concreto que se van a utilizar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterXml">
      <MemberSignature Language="C#" Value="public virtual string OuterXml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.OuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OuterXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ OuterXml { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OuterXml : string" Usage="System.Xml.XmlNode.OuterXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el marcado que contiene este nodo y todos sus nodos secundarios.</summary>
        <value>Marcado que contiene este nodo y todos sus nodos secundarios.  
  
 <block subset="none" type="note"><para><see langword="OuterXml" /> no devuelve los atributos predeterminados.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente compara los resultados de la <xref:System.Xml.XmlNode.InnerXml%2A> y `OuterXml` propiedades.  
  
 [!code-cpp[Classic WebData XmlNode.OuterXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.OuterXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.OuterXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.OuterXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.OuterXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.OuterXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlNode.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clase <see cref="T:System.Xml.XmlDocument" /> a la que pertenece este nodo.</summary>
        <value><see cref="T:System.Xml.XmlDocument" /> al que pertenece este nodo.  
  
Si el nodo es <see cref="T:System.Xml.XmlDocument" /> (NodeType es igual que XmlNodeType.Document), esta propiedad devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Agregar nodos al nodo actual, use el <xref:System.Xml.XmlDocument> devuelto por la <xref:System.Xml.XmlNode.OwnerDocument%2A> propiedad para crear el nodo.  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlElement.OwnerDocument%2A> (en la clase XmlElement) para obtener un ejemplo de uso de esta propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlNode.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nodo primario de este nodo (para nodos que pueden tener nodos primarios).</summary>
        <value><see langword="XmlNode" /> que es el elemento principal del nodo actual. Si se acaba de crear un nodo y todavía no se ha agregado al árbol, o si se ha quitado del árbol, el elemento principal es <see langword="null" />. Para todos los demás nodos, el valor devuelto depende de <see cref="P:System.Xml.XmlNode.NodeType" /> del nodo. En la tabla siguiente se describen los valores devueltos posibles de la propiedad <see langword="ParentNode" />.  
  
 <list type="table"><listheader><term> NodeType 
 </term><description> Valor devuelto de ParentNode 
 </description></listheader><item><term> Attribute, Document, DocumentFragment, Entity, Notation 
 </term><description> Devuelve <see langword="null" />; estos nodos no tienen nodos primarios.  
  
 </description></item><item><term> CDATA 
 </term><description> Devuelve el elemento o la referencia a entidad que contiene la sección CDATA.  
  
 </description></item><item><term> Comentario 
 </term><description> Devuelve el elemento, la referencia a entidad, el tipo de documento o el documento que contiene el comentario.  
  
 </description></item><item><term> DocumentType 
 </term><description> Devuelve el nodo de documento.  
  
 </description></item><item><term> Element 
 </term><description> Devuelve el nodo primario del elemento. Si el elemento es el nodo raíz del árbol, el nodo primario es el nodo de documento.  
  
 </description></item><item><term> EntityReference 
 </term><description> Devuelve el elemento, el atributo o la referencia a entidad que contiene la referencia a entidad.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Devuelve el documento, el elemento, el tipo de documento o la referencia a entidad que contiene la instrucción de procesamiento.  
  
 </description></item><item><term> Texto 
 </term><description> Devuelve el elemento primario, el atributo o la referencia a entidad que contiene el nodo de texto.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de los nodos primarios y secundarios, consulte el [especificación de nivel 1 de DOM del W3C (núcleos)](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public virtual string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Xml.XmlNode.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el prefijo de espacio de nombres de este nodo.</summary>
        <value>Prefijo de espacio de nombres de este nodo. Por ejemplo, <see langword="Prefix" /> es "bk" para el elemento &lt;bk: book&gt;. Si no hay prefijo, esta propiedad devuelve String.Empty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer esta propiedad, cuando se lo permita, cambia el <xref:System.Xml.XmlNode.Name%2A> propiedad, que contiene el nombre completo, en los nodos de elemento y atributo. Al establecer esta propiedad en tipos de nodo que no pueden tener un prefijo (por ejemplo, texto, comentario, EntityReference, CDATA, ProcessingInstruction, documento y DocumentFragment) no tiene ningún efecto. Cambiar el prefijo de un atributo que se sabe que tiene un valor predeterminado, realice un nuevo atributo con el valor predeterminado y aparece el prefijo original, ya que no cambian el espacio de nombres URI y el nombre local.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Este nodo es de sólo lectura.</exception>
        <exception cref="T:System.Xml.XmlException">El prefijo especificado contiene un carácter no válido.  
  
El prefijo especificado tiene un formato incorrecto.  
  
El prefijo especificado es "xml" y el URI del espacio de nombres de este nodo es diferente de "http://www.w3.org/XML/1998/namespace".  
  
Este nodo es un atributo, el prefijo especificado es "xmlns" y su identificador URI de espacio de nombres no es "http://www.w3.org/2000/xmlns/".  
  
Este nodo es un atributo y su nombre completo es "xmlns".</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="Prefix" /> en una clase derivada, no se puede establecer esta propiedad.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PrependChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode PrependChild (System.Xml.XmlNode newChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode PrependChild(class System.Xml.XmlNode newChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.PrependChild(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrependChild (newChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ PrependChild(System::Xml::XmlNode ^ newChild);" />
      <MemberSignature Language="F#" Value="abstract member PrependChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.PrependChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.PrependChild newChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Nodo que se va a agregar. Todo el contenido del nodo que se va a agregar se pasa a la ubicación especificada.</param>
        <summary>Agrega el nodo especificado al principio de la lista de nodos secundarios de este nodo.</summary>
        <returns>Nodo agregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `newChild` está ya en el árbol, se quita de su posición original y se agrega a su posición de destino. Para obtener más información acerca de cómo insertar nodos, consulte [insertar nodos en un documento XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Si el nodo que se va a insertar se creó desde otro documento, puede usar <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> para importar el nodo para el documento actual. El nodo importado, a continuación, se puede insertar en el documento actual.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo nodo en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.PrependChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PrependChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PrependChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PrependChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PrependChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PrependChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este nodo es de un tipo que no permite nodos secundarios del tipo del nodo <paramref name="newChild" />.  
  
<paramref name="newChild" /> es un nodo antecesor de este nodo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> se creó a partir de un documento diferente del que creó este nodo.  
  
Este nodo es de sólo lectura.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="PrependChild" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="PrependChild" /> método de la clase base.</para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Inserción de nodos en un documento XML</related>
      </Docs>
    </Member>
    <Member MemberName="PreviousSibling">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode PreviousSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode PreviousSibling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.PreviousSibling" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PreviousSibling As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ PreviousSibling { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousSibling : System.Xml.XmlNode" Usage="System.Xml.XmlNode.PreviousSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nodo inmediatamente anterior a éste.</summary>
        <value><see langword="XmlNode" /> anterior. Si no hay nodo anterior, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra todos los libros en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousText">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode PreviousText { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode PreviousText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.PreviousText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PreviousText As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ PreviousText { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousText : System.Xml.XmlNode" Usage="System.Xml.XmlNode.PreviousText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nodo de texto inmediatamente anterior a este.</summary>
        <value>Devuelva <see cref="T:System.Xml.XmlNode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad tiene un rendimiento más rápido que el <xref:System.Xml.XmlNode.PreviousSibling%2A> propiedad, pero se puede usar solo para obtener un nodo de tipo <xref:System.Xml.XmlNodeType.Text>. Para obtener cualquier otro tipo de nodo que precede a este nodo, use el <xref:System.Xml.XmlNode.PreviousSibling%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public virtual void RemoveAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.RemoveAll" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAll();" />
      <MemberSignature Language="F#" Value="abstract member RemoveAll : unit -&gt; unit&#xA;override this.RemoveAll : unit -&gt; unit" Usage="xmlNode.RemoveAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los atributos y nodos secundarios del nodo actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un atributo quitado se sabe que tiene un valor predeterminado, aparece inmediatamente un atributo que contiene el valor predeterminado y, si procede, el URI de espacio de nombres correspondiente, el nombre local y el prefijo.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente quita todos los nodos secundarios y atributos del nodo raíz.  
  
 [!code-cpp[Classic WebData XmlNode.RemoveAll Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.RemoveAll Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.RemoveAll Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.RemoveAll Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.RemoveAll Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.RemoveAll Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="RemoveAll" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="RemoveAll" /> método de la clase base.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RemoveChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode RemoveChild (System.Xml.XmlNode oldChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode RemoveChild(class System.Xml.XmlNode oldChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.RemoveChild(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveChild (oldChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ RemoveChild(System::Xml::XmlNode ^ oldChild);" />
      <MemberSignature Language="F#" Value="abstract member RemoveChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.RemoveChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.RemoveChild oldChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="oldChild">Nodo que se va a quitar.</param>
        <summary>Quita el nodo secundario especificado.</summary>
        <returns>Nodo que se quita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente quita un nodo del documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.RemoveChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.RemoveChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.RemoveChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.RemoveChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.RemoveChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.RemoveChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="oldChild" /> no es un nodo secundario de este nodo. O este nodo es de sólo lectura.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="RemoveChild" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="RemoveChild" /> método de la clase base.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ReplaceChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReplaceChild (System.Xml.XmlNode newChild, System.Xml.XmlNode oldChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReplaceChild(class System.Xml.XmlNode newChild, class System.Xml.XmlNode oldChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.ReplaceChild(System.Xml.XmlNode,System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceChild (newChild As XmlNode, oldChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReplaceChild(System::Xml::XmlNode ^ newChild, System::Xml::XmlNode ^ oldChild);" />
      <MemberSignature Language="F#" Value="abstract member ReplaceChild : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.ReplaceChild : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.ReplaceChild (newChild, oldChild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
        <Parameter Name="oldChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Nuevo nodo que se va a agregar a la lista de nodos secundarios.</param>
        <param name="oldChild">Nodo que se va a reemplazar en la lista.</param>
        <summary>Reemplaza el nodo secundario <paramref name="oldChild" /> por el nodo <paramref name="newChild" />.</summary>
        <returns>Nodo que se reemplaza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `newChild` está ya en el árbol, se quita primero.  
  
 Si el `newChild` se creó desde otro documento, puede usar <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> para importar el nodo para el documento actual. El nodo importado, a continuación, se puede pasar a la `ReplaceChild` método.  
  
   
  
## Examples  
 En el siguiente ejemplo reemplaza el elemento de título en el documento XML.  
  
 [!code-cpp[Classic WebData XmlNode.ReplaceChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.ReplaceChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.ReplaceChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.ReplaceChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.ReplaceChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.ReplaceChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Este nodo es de un tipo que no permite nodos secundarios del tipo del nodo <paramref name="newChild" />.  
  
<paramref name="newChild" /> es un nodo antecesor de este nodo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> se creó a partir de un documento diferente del que creó este nodo.  
  
Este nodo es de sólo lectura.  
  
<paramref name="oldChild" /> no es un nodo secundario de este nodo.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see langword="ReplaceChild" /> en una clase derivada, en orden para los eventos que se genere correctamente, debe llamar a la <see langword="ReplaceChild" /> método de la clase base.</para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlNode.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el conjunto de información posterior a la validación del esquema que se ha asignado a este nodo como resultado de dicha validación.</summary>
        <value>Objeto <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> que contiene el conjunto de información posterior a la validación del esquema de este nodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xml.XmlNode.SchemaInfo%2A> propiedad se establece cuando este nodo se valida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectNodes">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Selecciona una lista de nodos que coinciden con la expresión XPath.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las expresiones XPath pueden incluir espacios de nombres. La resolución de espacios de nombres es compatible con `XmlNamespaceManager`. Si la expresión XPath incluye un prefijo, el par de prefijo y espacio de nombres URI debe agregarse a la `XmlNamespaceManager`.  
  
> [!NOTE]
>  Si la expresión XPath no incluye un prefijo, se supone que el URI de espacio de nombres es el espacio de nombres vacío. Si el XML incluya un espacio de nombres predeterminado, debe agregar un prefijo y URI de espacio de nombres para el `XmlNamespaceManager`; en caso contrario, no obtendrá ningún nodo seleccionado.  
  
 Para obtener más información, consulte [seleccionar nodos de uso XPath Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md). Para obtener ejemplos de código, elija una sobrecarga de la lista de sobrecarga en la sección anterior.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">Las selecciones de XPath y funciones personalizadas etc.</related>
        <related type="ExternalDocumentation" href="http://www.w3.org/TR/xpath">Recomendación XPath 1.0 de W3C</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectNodes">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNodeList SelectNodes (string xpath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNodeList SelectNodes(string xpath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectNodes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNodes (xpath As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNodeList ^ SelectNodes(System::String ^ xpath);" />
      <MemberSignature Language="F#" Value="member this.SelectNodes : string -&gt; System.Xml.XmlNodeList" Usage="xmlNode.SelectNodes xpath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xpath">Expresión XPath.</param>
        <summary>Selecciona una lista de nodos que coinciden con la expresión XPath.</summary>
        <returns><see cref="T:System.Xml.XmlNodeList" /> que contiene una colección de nodos que coinciden con la consulta XPath.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la expresión XPath requiere la resolución de espacio de nombres, debe usar el `SelectNodes` sobrecarga que toma un <xref:System.Xml.XmlNamespaceManager> como su argumento. El `XmlNamespaceManager` se utiliza para resolver los espacios de nombres.  
  
> [!NOTE]
>  Si la expresión XPath no incluye un prefijo, se supone que el URI de espacio de nombres es el espacio de nombres vacío. Si el XML incluya un espacio de nombres predeterminado, deberá seguir usando el `XmlNamespaceManager` y agregarle un prefijo y URI de espacio de nombres; de lo contrario, no obtendrá ningún nodo seleccionado. Para obtener más información, consulte [seleccionar nodos de uso XPath Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
> [!NOTE]
>  Un problema común al formular las expresiones XPath es cómo incluir una comilla simple (') o comillas dobles (") en la expresión. Si tiene que buscar un valor que incluye una comilla simple, debe incluir la cadena de comillas dobles. Si necesita buscar un valor que incluye una comilla doble, debe incluir la cadena de comillas simples.  
  
 Por ejemplo, suponga que tiene el siguiente código XML:  
  
```xml  
<bookstore>  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 El siguiente código de Visual Basic, selecciona un elemento que contiene comillas simples:  
  
```csharp  
nodeList = root.SelectNodes("//book[contains(title,""'Emma'"")]")  
```  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 La <xref:System.Xml.XmlNodeList> objeto devuelto por este método será válido mientras el documento subyacente permanece sin cambios. Si el documento subyacente cambia, se pueden devolver resultados inesperados (no se producirá ninguna excepción).  
  
   
  
## Examples  
 El ejemplo siguiente selecciona todos los libros donde es Austen apellido del autor y, a continuación, cambia el precio de los libros.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Este ejemplo utiliza el siguiente código XML:  
  
 [!code-xml[Classic WebData XmlNode.SelectNodes Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">La expresión XPath contiene un prefijo. Vea [ejemplos de XPath](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</exception>
        <altmember cref="M:System.Xml.XmlNode.SelectSingleNode(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">Las selecciones de XPath y funciones personalizadas etc.</related>
        <related type="ExternalDocumentation" href="http://www.w3.org/TR/xpath">Recomendación XPath 1.0 de W3C</related>
      </Docs>
    </Member>
    <Member MemberName="SelectNodes">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNodeList SelectNodes (string xpath, System.Xml.XmlNamespaceManager nsmgr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNodeList SelectNodes(string xpath, class System.Xml.XmlNamespaceManager nsmgr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectNodes(System.String,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNodes (xpath As String, nsmgr As XmlNamespaceManager) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNodeList ^ SelectNodes(System::String ^ xpath, System::Xml::XmlNamespaceManager ^ nsmgr);" />
      <MemberSignature Language="F#" Value="member this.SelectNodes : string * System.Xml.XmlNamespaceManager -&gt; System.Xml.XmlNodeList" Usage="xmlNode.SelectNodes (xpath, nsmgr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" />
        <Parameter Name="nsmgr" Type="System.Xml.XmlNamespaceManager" />
      </Parameters>
      <Docs>
        <param name="xpath">Expresión XPath. Vea [ejemplos de XPath](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</param>
        <param name="nsmgr"><see cref="T:System.Xml.XmlNamespaceManager" /> que se utiliza para resolver los espacios de nombres de los prefijos de la expresión XPath.</param>
        <summary>Selecciona una lista de nodos que coinciden con la expresión XPath. Los prefijos encontrados en la expresión XPath se resuelven utilizando el <see cref="T:System.Xml.XmlNamespaceManager" /> proporcionado.</summary>
        <returns><see cref="T:System.Xml.XmlNodeList" /> que contiene una colección de nodos que coinciden con la consulta XPath.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las expresiones XPath pueden incluir espacios de nombres. La resolución de espacios de nombres es compatible con `XmlNamespaceManager`. Si la expresión XPath incluye un prefijo, el par de prefijo y espacio de nombres URI debe agregarse a la `XmlNamespaceManager`.  
  
> [!NOTE]
>  Si la expresión XPath no incluye un prefijo, se supone que el URI de espacio de nombres es el espacio de nombres vacío. Si el XML incluya un espacio de nombres predeterminado, debe agregar un prefijo y URI de espacio de nombres para el `XmlNamespaceManager`; en caso contrario, no obtendrá ningún nodo seleccionado. Para obtener más información, consulte [seleccionar nodos de uso XPath Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
 Por ejemplo, si tuviera el siguiente código XML:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
 <book>  
   <title>Pride And Prejudice</title>  
 </book>  
</bookstore>  
```  
  
 El siguiente código de C# selecciona todos los nodos de libro:  
  
```csharp  
XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com");  
XmlNodeList nodelist = doc.SelectNodes("//ab:book", nsmgr);  
```  
  
> [!NOTE]
>  Un problema común al formular las expresiones XPath es cómo incluir una comilla simple (') o comillas dobles (") en la expresión. Si tiene que buscar un valor que incluye una comilla simple, debe incluir la cadena de comillas dobles. Si necesita buscar un valor que incluye una comilla doble, debe incluir la cadena de comillas simples.  
  
 Por ejemplo, suponga que tiene el siguiente código XML:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 El siguiente código de Visual Basic, selecciona un elemento que contiene comillas simples:  
  
```vb  
Dim nsmgr As XmlNamespaceManager = New XmlNamespaceManager(doc.NameTable)  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com")  
nodeList = root.SelectNodes("//ab:book[contains(ab:title,""'Emma'"")]", nsmgr)  
```  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 La <xref:System.Xml.XmlNodeList> objeto devuelto por este método será válido mientras el documento subyacente permanece sin cambios. Si el documento subyacente cambia, se pueden devolver resultados inesperados (no se producirá ninguna excepción).  
  
   
  
## Examples  
 El ejemplo siguiente muestra los valores de cada uno de los atributos de ISBN. Este ejemplo se usa un <xref:System.Xml.XmlElement> objeto, que hereda de la <xref:System.Xml.XmlNode> clase.  
  
 [!code-cpp[XmlNode.SelectNodes1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlNode.SelectNodes1/CPP/selectnodes1.cpp#1)]
 [!code-csharp[XmlNode.SelectNodes1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlNode.SelectNodes1/CS/selectnodes1.cs#1)]
 [!code-vb[XmlNode.SelectNodes1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlNode.SelectNodes1/VB/selectnodes1.vb#1)]  
  
 En el ejemplo se utiliza el archivo `booksort.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlNode.SelectNodes Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">La expresión XPath contiene un prefijo que no está definido en <see langword="XmlNamespaceManager" />.</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">Las selecciones de XPath y funciones personalizadas etc.</related>
        <related type="ExternalDocumentation" href="http://www.w3.org/TR/xpath">Recomendación XPath 1.0 de W3C</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectSingleNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Selecciona el primer <see langword="XmlNode" /> que coincide con la expresión XPath.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las expresiones XPath pueden incluir espacios de nombres. La resolución de espacios de nombres es compatible con `XmlNamespaceManager`. Si la expresión XPath incluye un prefijo, el par de prefijo y espacio de nombres URI debe agregarse a la `XmlNamespaceManager`.  
  
> [!NOTE]
>  Si la expresión XPath no incluye un prefijo, se supone que el URI de espacio de nombres es el espacio de nombres vacío. Si el XML incluya un espacio de nombres predeterminado, debe agregar un prefijo y URI de espacio de nombres para el `XmlNamespaceManager`; en caso contrario, no obtendrá ningún nodo seleccionado. Para obtener más información, consulte [seleccionar nodos de uso XPath Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
   
  
## Examples  
 El ejemplo siguiente devuelve el primer libro con el nombre del autor correspondiente. `XmlNamespaceManager` resuelve el espacio de nombres predeterminado en la expresión XPath.  
  
 [!code-cpp[XmlNode.SelectSingleNode2#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlNode.SelectSingleNode2/CPP/XmlNode.SelectSingleNode2.cpp#1)]
 [!code-csharp[XmlNode.SelectSingleNode2#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlNode.SelectSingleNode2/CS/selectsingnode2.cs#1)]
 [!code-vb[XmlNode.SelectSingleNode2#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlNode.SelectSingleNode2/VB/selectsingnode2.vb#1)]  
  
 En el ejemplo se utiliza el archivo `newbooks.xml`como entrada.  
  
 [!code-xml[XmlNode.SelectSingleNode2#2](~/samples/snippets/xml/VS_Snippets_Data/XmlNode.SelectSingleNode2/XML/newbooks.xml#2)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">Las selecciones de XPath y funciones personalizadas etc.</related>
        <related type="ExternalDocumentation" href="http://www.w3.org/TR/xpath">Recomendación XPath 1.0 de W3C</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectSingleNode">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNode SelectSingleNode (string xpath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNode SelectSingleNode(string xpath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectSingleNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectSingleNode (xpath As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNode ^ SelectSingleNode(System::String ^ xpath);" />
      <MemberSignature Language="F#" Value="member this.SelectSingleNode : string -&gt; System.Xml.XmlNode" Usage="xmlNode.SelectSingleNode xpath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xpath">Expresión XPath. Vea [ejemplos de XPath](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</param>
        <summary>Selecciona el primer <see langword="XmlNode" /> que coincide con la expresión XPath.</summary>
        <returns>Primer <see langword="XmlNode" /> que coincide con la consulta XPath o <see langword="null" /> si no se encuentra un nodo coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la expresión XPath requiere la resolución de espacio de nombres, debe usar el `SelectSingleNode` sobrecarga que toma un <xref:System.Xml.XmlNamespaceManager> como su argumento. El `XmlNamespaceManager` se utiliza para resolver los espacios de nombres.  
  
> [!NOTE]
>  Si la expresión XPath no incluye un prefijo, se supone que el URI de espacio de nombres es el espacio de nombres vacío. Si el XML incluya un espacio de nombres predeterminado, deberá seguir usando el `XmlNamespaceManager` y agregarle un prefijo y URI de espacio de nombres; de lo contrario, no obtendrá un nodo seleccionado. Para obtener más información, consulte [seleccionar nodos de uso XPath Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
> [!NOTE]
>  Un problema común al formular las expresiones XPath es cómo incluir una comilla simple (') o comillas dobles (") en la expresión. Si tiene que buscar un valor que incluye una comilla simple, debe incluir la cadena de comillas dobles. Si necesita buscar un valor que incluye una comilla doble, debe incluir la cadena de comillas simples.  
  
 Por ejemplo, suponga que tiene el siguiente código XML:  
  
```xml  
<bookstore>  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 El siguiente código de Visual Basic, selecciona un elemento que contiene comillas simples:  
  
```  
book = root.SelectSingleNode("descendant::book[title=""'Emma'""]")  
```  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente cambia el precio del primer libro de Jane Austen.  
  
 [!code-cpp[Classic WebData XmlNode.SelectSingleNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectSingleNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectSingleNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `booksort.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlNode.SelectSingleNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">La expresión XPath contiene un prefijo.</exception>
        <altmember cref="M:System.Xml.XmlNode.SelectNodes(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">Las selecciones de XPath y funciones personalizadas etc.</related>
        <related type="ExternalDocumentation" href="http://www.w3.org/TR/xpath">Recomendación XPath 1.0 de W3C</related>
      </Docs>
    </Member>
    <Member MemberName="SelectSingleNode">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNode SelectSingleNode (string xpath, System.Xml.XmlNamespaceManager nsmgr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNode SelectSingleNode(string xpath, class System.Xml.XmlNamespaceManager nsmgr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectSingleNode(System.String,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectSingleNode (xpath As String, nsmgr As XmlNamespaceManager) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNode ^ SelectSingleNode(System::String ^ xpath, System::Xml::XmlNamespaceManager ^ nsmgr);" />
      <MemberSignature Language="F#" Value="member this.SelectSingleNode : string * System.Xml.XmlNamespaceManager -&gt; System.Xml.XmlNode" Usage="xmlNode.SelectSingleNode (xpath, nsmgr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" />
        <Parameter Name="nsmgr" Type="System.Xml.XmlNamespaceManager" />
      </Parameters>
      <Docs>
        <param name="xpath">Expresión XPath. Vea [ejemplos de XPath](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</param>
        <param name="nsmgr"><see cref="T:System.Xml.XmlNamespaceManager" /> que se utiliza para resolver los espacios de nombres de los prefijos de la expresión XPath.</param>
        <summary>Selecciona el primer <see langword="XmlNode" /> que coincide con la expresión XPath. Los prefijos encontrados en la expresión XPath se resuelven utilizando el <see cref="T:System.Xml.XmlNamespaceManager" /> proporcionado.</summary>
        <returns>Primer <see langword="XmlNode" /> que coincide con la consulta XPath o <see langword="null" /> si no se encuentra un nodo coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las expresiones XPath pueden incluir espacios de nombres. La resolución de espacios de nombres es compatible con `XmlNamespaceManager`. Si la expresión XPath incluye un prefijo, el par de prefijo y espacio de nombres URI debe agregarse a la `XmlNamespaceManager`.  
  
> [!NOTE]
>  Si la expresión XPath no incluye un prefijo, se supone que el URI de espacio de nombres es el espacio de nombres vacío. Si el XML incluya un espacio de nombres predeterminado, debe agregar un prefijo y URI de espacio de nombres para el `XmlNamespaceManager`; en caso contrario, no obtendrá ningún nodo seleccionado. Para obtener más información, consulte [seleccionar nodos de uso XPath Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
 Por ejemplo, si tuviera el siguiente código XML:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
 <book>  
   <title>Pride And Prejudice</title>  
 </book>  
</bookstore>  
```  
  
 El siguiente código de C# selecciona el primer nodo de libro:  
  
```csharp  
XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com");  
XmlNode book = doc.SelectSingleNode("//ab:book", nsmgr);  
```  
  
> [!NOTE]
>  Un problema común al formular las expresiones XPath es cómo incluir una comilla simple (') o comillas dobles (") en la expresión. Si tiene que buscar un valor que incluye una comilla simple, debe incluir la cadena de comillas dobles. Si necesita buscar un valor que incluye una comilla doble, debe incluir la cadena de comillas simples.  
  
 Por ejemplo, suponga que tiene el siguiente código XML:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 El siguiente código de Visual Basic, selecciona un elemento que contiene comillas simples:  
  
```vb  
Dim nsmgr As XmlNamespaceManager = New XmlNamespaceManager(doc.NameTable)  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com")  
book = root.SelectSingleNode("descendant::ab:book[ab:title=""'Emma'""]", nsmgr)  
```  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente selecciona el libro con el valor de ISBN coincidente.  
  
 [!code-cpp[XmlNode.SelectSingleNode1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlNode.SelectSingleNode1/CPP/selectsingnode.cpp#1)]
 [!code-csharp[XmlNode.SelectSingleNode1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlNode.SelectSingleNode1/CS/selectsingnode.cs#1)]
 [!code-vb[XmlNode.SelectSingleNode1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlNode.SelectSingleNode1/VB/selectsingnode.vb#1)]  
  
 En el ejemplo se utiliza el archivo `booksort.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlNode.SelectNodes Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">La expresión XPath contiene un prefijo que no está definido en <see langword="XmlNamespaceManager" />.</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">Las selecciones de XPath y funciones personalizadas etc.</related>
        <related type="ExternalDocumentation" href="http://www.w3.org/TR/xpath">Recomendación XPath 1.0 de W3C</related>
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (string feature, string version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(string feature, string version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.Supports(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (feature As String, version As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::String ^ feature, System::String ^ version);" />
      <MemberSignature Language="F#" Value="abstract member Supports : string * string -&gt; bool&#xA;override this.Supports : string * string -&gt; bool" Usage="xmlNode.Supports (feature, version)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="feature" Type="System.String" />
        <Parameter Name="version" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="feature">Nombre del paquete de la característica que se va a comprobar. Este nombre no distingue entre mayúsculas y minúsculas.</param>
        <param name="version">Número de versión del nombre del paquete que se va a comprobar. Si no se especifica la versión (null), la compatibilidad con cualquier versión de la característica hará que el método devuelva True.</param>
        <summary>Comprueba si la implementación de DOM incluye una característica específica.</summary>
        <returns>Es <see langword="true" /> si la característica se implementa en la versión especificada; en caso contrario, es <see langword="false" />. En la tabla siguiente se describen las combinaciones que devuelven <see langword="true" />.  
  
 <list type="table"><listheader><term> Característica 
 </term><description> Versión 
 </description></listheader><item><term> XML 
 </term><description> 1.0 
 </description></item><item><term> XML 
 </term><description> 2.0 
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.Xml.XmlNode.GetEnumerator" />.</summary>
        <returns>Devuelve un enumerador para la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Xml.XmlNode> se convierte en una interfaz <xref:System.Collections.IEnumerable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.Xml.XmlNode.Clone" />.</summary>
        <returns>Copia del nodo desde el que se llamó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Xml.XmlNode> se convierte en una interfaz <xref:System.ICloneable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public virtual string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : string with get, set" Usage="System.Xml.XmlNode.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del nodo.</summary>
        <value>El valor devuelto depende de la propiedad <see cref="P:System.Xml.XmlNode.NodeType" /> del nodo. 
 <list type="table"><listheader><term> Tipo 
 </term><description> Valor 
 </description></listheader><item><term> Atributo 
 </term><description> El valor del atributo.  
  
 </description></item><item><term> CDATASection 
 </term><description> Contenido de la sección CDATA.  
  
 </description></item><item><term> Comentario 
 </term><description> El contenido del comentario.  
  
 </description></item><item><term> Documento 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> DocumentFragment 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> DocumentType 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> Element 
 </term><description><see langword="null" />. Puede usar las propiedades <see cref="P:System.Xml.XmlElement.InnerText" /> o <see cref="P:System.Xml.XmlElement.InnerXml" /> para obtener acceso al valor del nodo element.  
  
 </description></item><item><term> Entity 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> EntityReference 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> Notation 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Todo el contenido, salvo el destino.  
  
 </description></item><item><term> Texto 
 </term><description> El contenido del nodo de texto.  
  
 </description></item><item><term> SignificantWhitespace 
 </term><description> Caracteres de espacio en blanco. El espacio en blanco puede estar formado por uno o varios caracteres de espacio, retornos de carro, saltos de línea o tabulaciones.  
  
 </description></item><item><term> Whitespace 
 </term><description> Caracteres de espacio en blanco. El espacio en blanco puede estar formado por uno o varios caracteres de espacio, retornos de carro, saltos de línea o tabulaciones.  
  
 </description></item><item><term> XmlDeclaration 
 </term><description> El contenido de la declaración (es decir, lo que aparece entre &lt;? xml y?&gt;).  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se agrega un nuevo atributo en el documento XML y establece el <xref:System.Xml.XmlNode.Value%2A> propiedad del nuevo atributo.  
  
 [!code-cpp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Establecer el valor de un nodo que es de sólo lectura.</exception>
        <exception cref="T:System.InvalidOperationException">Establecer el valor de un nodo que no debe tener un valor, por ejemplo, un nodo Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public abstract void WriteContentTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteContentTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteContentTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteContentTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlNode.WriteContentTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w"><see langword="XmlWriter" /> en el que se desea guardar.</param>
        <summary>Guarda todos los nodos secundarios del nodo en el <see cref="T:System.Xml.XmlWriter" /> especificado, cuando se reemplaza en una clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM). Es funcionalmente equivalente a la <xref:System.Xml.XmlNode.InnerXml%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el contenido del nodo raíz en la consola.  
  
 [!code-cpp[Classic WebData XmlNode.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlNode.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlNode.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w"><see langword="XmlWriter" /> en el que se desea guardar.</param>
        <summary>Guarda el nodo actual en el <see cref="T:System.Xml.XmlWriter" /> especificado, cuando se reemplaza en una clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM). Es funcionalmente equivalente a la <xref:System.Xml.XmlNode.OuterXml%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nodo raíz en la consola.  
  
 [!code-cpp[Classic WebData XmlNode.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>