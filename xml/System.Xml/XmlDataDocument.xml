<Type Name="XmlDataDocument" FullName="System.Xml.XmlDataDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="269851ce0bce3ca09412babec7031c9530854019" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36435682" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlDataDocument : System.Xml.XmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDataDocument extends System.Xml.XmlDocument" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDataDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDataDocument&#xA;Inherits XmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDataDocument : System::Xml::XmlDocument" />
  <TypeSignature Language="F#" Value="type XmlDataDocument = class&#xA;    inherit XmlDocument" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlDocument</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("XmlDataDocument class will be removed in a future release.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite que los datos estructurados se almacenen, recuperen y manipulen mediante un <see cref="T:System.Data.DataSet" /> relacional.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase extiende <xref:System.Xml.XmlDocument>. Permite cargar datos relacionales o datos XML y manipular datos con el modelo de objetos de documento (DOM) de World Wide Web Consortium (W3C). DOM presenta los datos como una jerarquía de objetos de nodo. Dado que `XmlDataDocument` implementa la <xref:System.Xml.XPath.IXPathNavigable> interfaz, también puede utilizarse como documento de origen para la <xref:System.Xml.Xsl.XslTransform> clase.  
  
 `XmlDataDocument` tiene una relación estrecha con la `DataSet` (clase), que proporciona una vista relacional de los datos XML cargados. Los cambios realizados en el `XmlDataDocument` se reflejan en el `DataSet` y viceversa.  
  
 Para cargar un `DataSet` con datos XML, utilice <xref:System.Data.DataSet.ReadXmlSchema%2A> para generar una asignación relacional. A continuación, se pueden cargar los datos XML mediante <xref:System.Xml.XmlDataDocument.Load%2A> o <xref:System.Xml.XmlDocument.LoadXml%2A>.  
  
 Para cargar datos relacionales, especifique el `DataSet` que contiene los datos relacionales como parámetro en el <xref:System.Xml.XmlDataDocument.%23ctor%2A> constructor.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlDataDocument" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlDataDocument" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vacío <xref:System.Data.DataSet> está creado y asociado con el `XmlDataDocument`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument (System.Data.DataSet dataset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataSet dataset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument(System::Data::DataSet ^ dataset);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDataDocument : System.Data.DataSet -&gt; System.Xml.XmlDataDocument" Usage="new System.Xml.XmlDataDocument dataset" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataset" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataset">
          <see langword="DataSet" /> que se va a cargar en <see langword="XmlDataDocument" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlDataDocument" /> con el objeto <see cref="T:System.Data.DataSet" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XmlDataDocument` está sincronizada con los valores especificados `DataSet`. Los datos en el `DataSet` está inmediatamente disponible a través de la `XmlDataDocument`. Los cambios en el `DataSet` se propagan en el `XmlDataDocument`. Los cambios realizados en el `XmlDataDocument`, siempre que coincidan con la `DataSet` esquema, se propagan en el `DataSet`.  
  
   
  
## Examples  
 En el ejemplo siguiente se carga una tabla de clientes en un `XmlDataDocument`.  
  
 El ejemplo utiliza la base de datos Northwind de SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.SqlClient.SqlConnection" />
        <altmember cref="T:System.Data.SqlClient.SqlDataAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDataDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">
          <see langword="true" /> para clonar de forma recursiva el subárbol del nodo especificado; <see langword="false" /> solo para clonar el nodo en sí.</param>
        <summary>Crea un duplicado del nodo actual.</summary>
        <returns>Nodo clonado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Clonación de la `XmlDataDocument` también clona el <xref:System.Data.DataSet> esquema.  
  
 Si `deep` está establecido en `false`, clonado `DataSet` tiene ningún dato; que es, no hay ninguna fila.  
  
 Si `deep` está establecido en `true`, clonado `DataSet` se configura con el esquema y, a continuación, se rellena con los datos.  
  
 Vea <xref:System.Xml.XmlNode.CloneNode%2A> en la `XmlNode` clase para ver una tabla que describe cómo se comporta este método con cada uno de los tipos de nodo.  
  
   
  
## Examples  
 En el ejemplo siguiente se carga un `DataSet` en un `XmlDataDocument` y, a continuación, crea un clon superficial de la `XmlDataDocument`.  
  
 El ejemplo utiliza la base de datos Northwind de SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo del elemento nuevo. Si es String.Empty o <see langword="null" />, no hay prefijo.</param>
        <param name="localName">Nombre local del nuevo elemento.</param>
        <param name="namespaceURI">Identificador de recursos uniforme (URI) del espacio de nombres del nuevo elemento. Si es String.Empty o <see langword="null" />, no hay URI del espacio de nombres.</param>
        <summary>Crea un elemento con los <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Un nuevo objeto <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Note to Inheritors` Si se sobrecarga esta función, no se puede usar para la extensibilidad. En su lugar, puede devolver un elemento creado por la clase base, en este caso, `XmlDataDocument`. Vea el ejemplo siguiente.  
  
```csharp  
class MyXmlDataDocument : XmlDataDocument {  
 public override XmlElement CreateElement(string prefix, string localName, string nsURI) {  
   //Ensure we are returning the base class implementation of element.  
   XmlElement e = base.CreateElement(prefix, localName, nsURI);  
   //Add additional code here.  
   return e;    //Return the element created by XmlDataDocument.  
 }      
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDataDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la referencia a entidad.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XmlEntityReference" /> con el nombre especificado.</summary>
        <returns>
          <see cref="T:System.Xml.XmlEntityReference" /> con el nombre especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlEntityReference> no se pueden crear nodos <xref:System.Xml.XmlDataDocument> objetos. Si se llama a este método, se produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Llamada a este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected override System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDataDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <see cref="T:System.Xml.XmlNode" /> en el que se desea que el explorador se sitúe inicialmente.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para navegar por este documento. <see langword="XPathNavigator" /> se sitúa en el nodo que se especifica en el parámetro <paramref name="node" />.</summary>
        <returns>Objeto <see langword="XPathNavigator" /> que se utiliza para navegar por el documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XPathNavigator` proporciona acceso aleatorio de sólo lectura a los datos. Dado que está optimizado para las transformaciones XSLT, proporciona ventajas de rendimiento cuando se usa como mecanismo de entrada para el <xref:System.Xml.Xsl.XslTransform.Transform%2A> método.  
  
   
  
## Examples  
 Para ver una transformación XSLT mediante `XmlDataDocument` y `XPathNavigator`, consulte el <xref:System.Xml.Xsl.XslTransform.Transform%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Xsl.XslTransform" />
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDataDocument.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Xml.XmlDataDocument.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un <see cref="T:System.Data.DataSet" /> que proporciona una representación relacional de los datos de <see langword="XmlDataDocument" />.</summary>
        <value>
          <see langword="DataSet" /> que se puede utilizar para tener acceso a los datos de <see langword="XmlDataDocument" /> mediante un modelo relacional.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `DataSet` podrá obtener acceso a los datos de la `XmlDataDocument` mediante un modelo relacional. Esto significa que puede controlar los datos como tablas y vistas, filas y columnas, relaciones y así sucesivamente. Los cambios realizados en el `DataSet` están visibles inmediatamente en el `XmlDataDocument`.  
  
   
  
## Examples  
 En el ejemplo siguiente se modifica el precio de un libro utilizando la `DataSet` métodos.  
  
 [!code-cpp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/VB/source.vb#1)]  
  
 El ejemplo utiliza los dos archivos siguientes como entrada.  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement GetElementById (string elemId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement GetElementById(string elemId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementById (elemId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ GetElementById(System::String ^ elemId);" />
      <MemberSignature Language="F#" Value="override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementById elemId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elemId">Identificador de atributo con el que debe haber una coincidencia.</param>
        <summary>Obtiene el <see cref="T:System.Xml.XmlElement" /> con el identificador especificado. La clase <see cref="T:System.Xml.XmlDataDocument" /> no admite este método. Si se llama a este método, se produce una excepción.</summary>
        <returns>
          <see cref="T:System.Xml.XmlElement" /> con el Id. especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.Xml.XmlDataDocument> no admite este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Llamada a este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromRow">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement GetElementFromRow (System.Data.DataRow r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement GetElementFromRow(class System.Data.DataRow r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementFromRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementFromRow (r As DataRow) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ GetElementFromRow(System::Data::DataRow ^ r);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromRow : System.Data.DataRow -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementFromRow r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="r">Objeto <see langword="DataRow" /> cuyo <see langword="XmlElement" /> asociado se desea a recuperar.</param>
        <summary>Recupera el objeto <see cref="T:System.Xml.XmlElement" /> asociado al <see cref="T:System.Data.DataRow" /> especificado.</summary>
        <returns>
          <see langword="XmlElement" /> que contiene una representación del objeto <see langword="DataRow" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se carga un `DataSet` en un `XmlDataDocument` y, a continuación, se crea un `XmlElement` que representa el primer registro del cliente.  
  
 El ejemplo utiliza la base de datos Northwind de SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDataDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo que se va a hacer coincidir. Se compara con la propiedad <see cref="P:System.Xml.XmlDocument.Name" /> del nodo coincidente. El valor especial "*" coincide con todas las etiquetas.</param>
        <summary>Devuelve un objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los elementos descendientes que coinciden con el <see cref="P:System.Xml.XmlDocument.Name" /> especificado.</summary>
        <returns>Objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los nodos coincidentes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se recomienda que use la <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> o <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> en lugar del método la <xref:System.Xml.XmlDataDocument.GetElementsByTagName%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRowFromElement">
      <MemberSignature Language="C#" Value="public System.Data.DataRow GetRowFromElement (System.Xml.XmlElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow GetRowFromElement(class System.Xml.XmlElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetRowFromElement(System.Xml.XmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRowFromElement (e As XmlElement) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ GetRowFromElement(System::Xml::XmlElement ^ e);" />
      <MemberSignature Language="F#" Value="member this.GetRowFromElement : System.Xml.XmlElement -&gt; System.Data.DataRow" Usage="xmlDataDocument.GetRowFromElement e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Xml.XmlElement" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see langword="XmlElement" /> cuyo <see langword="DataRow" /> asociado se desea a recuperar.</param>
        <summary>Recupera el objeto <see cref="T:System.Data.DataRow" /> asociado al <see cref="T:System.Xml.XmlElement" /> especificado.</summary>
        <returns>
          <see langword="DataRow" /> que contiene una representación de <see langword="XmlElement" />; <see langword="null" /> si no hay <see langword="DataRow" /> asociado a <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se modifica el precio del primer libro.  
  
 [!code-cpp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CPP/getrow.cpp#1)]
 [!code-csharp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CS/getrow.cs#1)]
 [!code-vb[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/VB/getrow.vb#1)]  
  
 El ejemplo utiliza los archivos de entrada siguientes:  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carga <see langword="XmlDataDocument" /> utilizando el origen de datos especificado y sincroniza <see cref="T:System.Data.DataSet" /> con los datos cargados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para ver los datos XML de forma relacional, debe especificar un esquema que se utilizará para la asignación de datos. Esto puede hacerse mediante una llamada a la <xref:System.Data.DataSet.ReadXmlSchema%2A> método o mediante la creación de las tablas y columnas dentro de la `DataSet` manualmente. Este paso debe realizarse antes de llamar a `Load`.  
  
 `XmlDataDocument` no admite la creación de referencias de entidad. Si los datos contienen referencias a entidades, el `Load` método resuelve y se expanden las referencias a entidades. Sin embargo, si usas el `Load` sobrecarga que toma un <xref:System.Xml.XmlReader> como un argumento, se debe especificar un `XmlReader` que pueda resolver entidades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDataDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Secuencia que contiene el documento XML que se va a cargar.</param>
        <summary>Carga el objeto <see langword="XmlDataDocument" /> desde la secuencia especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` no admite la creación de referencias de entidad. Si los datos contienen referencias a entidades, el `Load` método resuelve y se expanden las referencias a entidades.  
  
> [!NOTE]
>  Para ver los datos XML de forma relacional, debe especificar un esquema que se utilizará para la asignación de datos. Esto puede hacerse mediante una llamada a la <xref:System.Data.DataSet.ReadXmlSchema%2A> método o mediante la creación de las tablas y columnas dentro de la `DataSet` manualmente. Este paso debe realizarse antes de llamar a `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDataDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">
          <see langword="TextReader" /> que se usa para introducir los datos XML en el documento.</param>
        <summary>Carga <see langword="XmlDataDocument" /> desde el <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` no admite la creación de referencias de entidad. Si los datos contienen referencias a entidades, el `Load` método resuelve y se expanden las referencias a entidades.  
  
> [!NOTE]
>  Para ver los datos XML de forma relacional, debe especificar un esquema que se utilizará para la asignación de datos. Esto puede hacerse mediante una llamada a la <xref:System.Data.DataSet.ReadXmlSchema%2A> método o mediante la creación de las tablas y columnas dentro de la `DataSet` manualmente. Este paso debe realizarse antes de llamar a `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="override this.Load : string -&gt; unit" Usage="xmlDataDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Dirección URL del archivo que contiene el documento XML que se va a cargar.</param>
        <summary>Carga <see langword="XmlDataDocument" /> utilizando la dirección URL especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` no admite la creación de referencias de entidad. Si los datos contienen referencias a entidades, el `Load` método resuelve y se expanden las referencias a entidades.  
  
> [!NOTE]
>  Para ver los datos XML de forma relacional, debe especificar un esquema que se utilizará para la asignación de datos. Esto puede hacerse mediante una llamada a la <xref:System.Data.DataSet.ReadXmlSchema%2A> método o mediante la creación de las tablas y columnas dentro de la `DataSet` manualmente. Este paso debe realizarse antes de llamar a `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDataDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XmlReader" /> que contiene el documento XML que se va a cargar.</param>
        <summary>Carga <see langword="XmlDataDocument" /> desde el <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` no admite la creación de referencias de entidad. Si el origen de datos contiene las referencias de entidad, debe crear un <xref:System.Xml.XmlValidatingReader> con el <xref:System.Xml.XmlValidatingReader.EntityHandling%2A> propiedad establecida en EntityHandling.ExpandEntities (que es el comportamiento predeterminado) y pasar la `XmlValidatingReader` a la `Load` método. Si no usa un `XmlValidatingReader`, el `Load` método produce una excepción.  
  
 El `Load` método siempre conserva el espacio en blanco significativo. El <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propiedad determina si se conserva el espacio en blanco. El valor predeterminado es `false`, no se conserva el espacio en blanco.  
  
 Si el lector está en el estado inicial (es decir, ReadState) `Load` consume todo el contenido del lector y genera el DOM a partir de lo que encuentre.  
  
 Si el lector ya está situado en algún nodo en la profundidad "n", este método carga ese nodo y todos los nodos relacionados subsiguientes hasta la etiqueta final que cierra la profundidad "n". Esto tiene como consecuencia lo siguiente.  
  
 Si el nodo actual y sus elementos del mismo nivel un aspecto similares al siguiente:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` produce una excepción, porque un documento no puede tener dos elementos de nivel raíz. Si el nodo actual y sus elementos del mismo nivel un aspecto similares al siguiente:  
  
```xml  
<!--comment--><?process  
    instruction?><!--comment--></endtag>  
```  
  
 `Load` se realiza correctamente; Sin embargo, tendrá un árbol DOM incompleto, porque no hay ningún elemento de nivel raíz. Tiene que agregar un elemento de nivel raíz antes de guardar el documento; en caso contrario, el <xref:System.Xml.XmlDocument.Save%2A> método produce una excepción.  
  
 Si el sistema de lectura se encuentra situado en un nodo hoja que no es válido para el nivel raíz de un documento (por ejemplo, un nodo de atributos o espacios en blanco), el sistema de lectura continúa leyendo hasta estar situado en un nodo que se pueda utilizar para el nivel raíz. El documento comienza a cargarse en este punto.  
  
   
  
## Examples  
 En el ejemplo siguiente se modifica el precio de un libro utilizando la `DataSet` métodos.  
  
 [!code-cpp[XmlDataDocument.Load#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.Load/CPP/loadrdr.cpp#1)]
 [!code-csharp[XmlDataDocument.Load#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.Load/CS/loadrdr.cs#1)]
 [!code-vb[XmlDataDocument.Load#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.Load/VB/loadrdr.vb#1)]  
  
 El ejemplo utiliza los dos archivos de entrada siguientes.  
  
 `2books.xml`  
  
 [!code-xml[XmlDataDocument.Load#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/2books.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[XmlDataDocument.Load#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/test.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El documento XML que se está cargando contiene referencias a entidades y el lector no puede resolver entidades.</exception>
      </Docs>
    </Member>
  </Members>
</Type>