<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d3c1618ebd2745957f4a16a9a3d5fbe6c44b3b32" /><Meta Name="ms.sourcegitcommit" Value="2982b8c4cce02c2542285fcaf172f7544d6b80bc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/09/2019" /><Meta Name="ms.locfileid" Value="59349643" /></Metadata><TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDocument&#xA;Inherits XmlNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDocument : System::Xml::XmlNode" />
  <TypeSignature Language="F#" Value="type XmlDocument = class&#xA;    inherit XmlNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa un documento XML. Puede usar esta clase para cargar, validar, editar, agregar y posicionar el código XML en un documento.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a> La <xref:System.Xml.XmlDocument> clase es una representación en memoria de un documento XML. Implementa el W3C [Document Object Model (DOM) XML](~/docs/standard/data/xml/xml-document-object-model-dom.md) principal del nivel 1 y nivel 2 de DOM Core.  
  
 *DOM* significa *modelo de objetos de documento*. Para obtener más información, consulte [Document Object Model (DOM) XML](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 Puede cargar XML en DOM mediante el <xref:System.Xml.XmlDocument> clase y, a continuación, mediante programación leer, modificar y quitar XML en el documento.  
  
 Si desea palanca, abra el <xref:System.Xml.XmlDocument> clase y cómo se implementa, consulte el [Reference Source](https://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Tareas  
  
-   [Cargar XML en el modelo de objetos de documento](#Load)  
  
-   [Validarlo con un esquema](#Validation)  
  
-   [Navegar por el árbol de documento](#Navigate)  
  
-   [Buscar nodos](#Find)  
  
-   [Editar nodos](#Edit)  
  
-   [Agregar nodos](#Add)  
  
-   [Quitar nodos](#Remove)  
  
-   [Nodos de posición](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Cargar XML en el modelo de objetos de documento  
 Comience con un documento XML como ésta. es tan solo unos libros en una colección. Pero contener las acciones básicas que se encuentran en cualquier documento XML; un espacio de nombres, los elementos que representan los datos y atributos que describen los datos.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 A continuación, cargar estos datos en el DOM para que puede trabajar con él en la memoria. La manera más popular de hacerlo es hacer referencia a un archivo en el equipo local o en una red.  
  
 En este ejemplo se carga XML desde un archivo. Si no existe el archivo, simplemente genera algo de XML y se carga.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Más información:** [Lectura de un documento XML en DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Validarlo con un esquema  
 Comience con un esquema XML como esta. Este esquema define los tipos de datos en el archivo XML y los atributos que son necesarios.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Crear un <xref:System.Xml.XmlReader> con el esquema de objeto y, a continuación, cargar ese objeto en el DOM. Cree un controlador de eventos que se ejecuta cuando el código intenta modificar el archivo XML de maneras que infringen las reglas del esquema.  
  
 Estos bloques de código muestran métodos auxiliares que hacer todo esto.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Más información:** [Validación de un documento XML en DOM](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Navegar por el árbol de documento  
 Puede usar las propiedades para navegar por un documento XML. Pero antes de utilizar cualquiera de ellos, vamos a revisar rápidamente algunos términos. El documento se compone de nodos. Cada nodo tiene como único *primario* nodo directamente encima de él. El único nodo que no tiene un nodo primario es la raíz del documento, ya que es el nodo de nivel superior. La mayoría de los nodos puede tener *secundarios* nodos, que son nodos inmediatamente debajo de ellos. Los nodos que tienen el mismo nivel son *elementos del mismo nivel*.  
  
 Los ejemplos siguientes, se muestra cómo obtener el nodo raíz, saltar al primer nodo secundario del nodo raíz, acceder a cualquiera de sus nodos secundarios, recuperar hasta el nodo primario y, a continuación, navegue a través de los nodos del mismo nivel.  
  
 **Comience con el nodo raíz**  
  
 Este ejemplo obtiene el nodo raíz y, a continuación, utiliza ese nodo para generar el contenido del documento en la consola.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Obtener nodos secundarios**  
  
 En este ejemplo se salta hasta el primer nodo secundario del nodo raíz y, a continuación, recorre en iteración los nodos secundarios de ese nodo si existe alguno.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Volver al nodo principal**  
  
 Utilice la propiedad <xref:System.Xml.XmlDocument.ParentNode%2A>.  
  
 **Consulte en el último nodo secundario**  
  
 En este ejemplo se escribe el precio de un libro en la consola (que es el último nodo secundario de un nodo de libro).  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Navegar hacia delante a través de los elementos del mismo nivel**  
  
 En este ejemplo se mueve hacia delante desde el libro. Nodos de libro están relacionados entre sí.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Navegar hacia atrás entre elementos del mismo nivel**  
  
 Este ejemplo se mueve hacia atrás desde un libro al libro.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Buscar nodos  
 La manera más popular para buscar uno o varios nodos de datos es usar una cadena de consulta de XPath, pero también hay métodos que no requieren uno.  
  
 **Obtener un solo nodo**  
  
 En este ejemplo se busca un libro mediante el número ISBN.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 La cadena utilizada en este ejemplo es una consulta Xpath. Puede encontrar más ejemplos de ellos aquí:   [Ejemplos de XPath](https://msdn.microsoft.com/library/ms256086.aspx).  
  
 También puede usar el <xref:System.Xml.XmlDocument.GetElementById%2A> para recuperar los nodos. Para usar este enfoque, tendrá que definir identificadores en las declaraciones de definición de tipo de documento del archivo XML.  
  
 Después de obtener un nodo, obtenga el valor de atributos o nodos secundarios. Este ejemplo hace con un nodo de libro.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Obtiene una colección de nodos**  
  
 Este ejemplo selecciona todos los libros, donde es el apellido del autor **Austen**y, a continuación, cambia el precio de los libros.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 También puede obtener una colección de nodos con el nombre del nodo. Por ejemplo, en este ejemplo se obtiene una colección de todos los títulos de libros.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Más información:** [Selección de nodos con la navegación XPath](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Editar nodos  
 En este ejemplo se modifica un nodo de libro y sus atributos.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Más información:** [Modificación de nodos, contenido y valores en un documento XML](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Agregar nodos  
 Para agregar un nodo, use la <xref:System.Xml.XmlDocument.CreateElement%2A> método o la <xref:System.Xml.XmlDocument.CreateNode%2A> método.  
  
 Para agregar un nodo de datos como un libro, use el <xref:System.Xml.XmlDocument.CreateElement%2A> método.  
  
 Para cualquier otro tipo de nodo como un comentario, nodo de espacio en blanco o nodo de CDATA, uso el <xref:System.Xml.XmlDocument.CreateNode%2A> método.  
  
 En este ejemplo crea un nodo de libro, agrega atributos a ese nodo y, a continuación, agrega ese nodo al documento.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Más información:** [Inserción de nodos en un documento XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Quitar nodos  
 Para quitar un nodo, use el <xref:System.Xml.XmlNode.RemoveChild%2A> método.  
  
 En este ejemplo se quita un libro desde el documento y ningún espacio en blanco que aparece justo antes del nodo de libro.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Más información:** [Eliminación de nodos, contenido y valores de un documento XML](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Nodos de posición  
 Puede elegir dónde desea que aparece en el documento mediante el uso de un nodo del <xref:System.Xml.XmlNode.InsertBefore%2A> y <xref:System.Xml.XmlNode.InsertAfter%2A> métodos.  
  
 Este ejemplo muestra dos métodos auxiliares. Una de ellas mueve un nodo superior en una lista. El otro mueve el nodo inferior.  
  
 Estos métodos podrían usarse en una aplicación que permite a los usuarios mover los libros en pantalla hacia arriba y abajo en una lista de los libros en pantalla. Cuando un usuario elige un libro y presiona arriba o hacia abajo del botón, el código podría llamar a métodos como estos para colocar el nodo de libro correspondiente antes o después de otros nodos de libro.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Ejemplo completo:** [Manipular XML en memoria mediante la clase XmlDocument y otros tipos relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.XmlNodeChangedEventHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlDocument" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlDocument" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente es un ejemplo de validación en tiempo de carga. Una validación de definición (DTD) de tipo de documento <xref:System.Xml.XmlReader> se pasa a la <xref:System.Xml.XmlDocument.Load%2A> método y un <xref:System.Xml.Schema.ValidationEventHandler> se proporciona para notificar a los usuarios de los errores de validación. En este ejemplo se encuentra un error de validación, pero se seguirá cargando el documento. Como alternativa, puede definir una validación <xref:System.Xml.XmlReader> para producir una excepción y detener el proceso de carga cuando se encuentra un error de validación al no especificar el <xref:System.Xml.Schema.ValidationEventHandler>. Para obtener más información acerca de la validación de datos XML, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 En el ejemplo se utiliza como entrada el archivo `bookDTD.xml`.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlDocument.Load(System.String)" />
        <altmember cref="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New (imp As XmlImplementation)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; XmlDocument(System::Xml::XmlImplementation ^ imp);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlImplementation -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument imp" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">Objeto <see langword="XmlImplementation" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see langword="XmlDocument" /> con el objeto <see cref="T:System.Xml.XmlImplementation" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlNameTable -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see langword="XmlDocument" /> con el objeto <see cref="T:System.Xml.XmlNameTable" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI base del nodo actual.</summary>
        <value>Ubicación desde la que se cargó el nodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un documento XML en red se compone de fragmentos de datos agregados mediante varios mecanismos de inclusión estándar de W3C y, por tanto, contiene nodos que proceden de distintos lugares. El `BaseURI` explica procedencia de estos nodos.  
  
 Para los nodos del documento, `BaseURI` devuelve la ubicación del documento XML. Por ejemplo, si el `XmlDocument` se cargaron utilizando la siguiente llamada doc. Carga ("http://server/mydata.xml"), el `BaseURI` para el documento es el nodo http://server/mydata.xml. Sin embargo, si la <xref:System.Xml.XmlDocument.Load%2A> método se redirige al servidor a otro URI, `BaseURI` devuelve el identificador URI original pasando a la `Load` método.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM). Para obtener más información sobre `BaseURI` y cómo se comporta con otros tipos de nodo, vea <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep"><see langword="true" /> para clonar de forma recursiva el subárbol del nodo especificado; <see langword="false" /> solo para clonar el nodo en sí.</param>
        <summary>Crea un duplicado de este nodo.</summary>
        <returns>Nodo <see langword="XmlDocument" /> clonado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método actúa como un constructor de copias de los nodos. El nodo clonado no tiene ningún elemento primario (<xref:System.Xml.XmlNode.ParentNode%2A> devuelve `null`).  
  
 Si `deep` es `true`, el nodo clonado incluye todos los nodos secundarios, en caso contrario, solo el `XmlDocument` se clona el nodo. Consulte la <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> método para ver cómo se comporta este método en otros tipos de nodo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra la diferencia entre un clon superficial.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un objeto <see cref="T:System.Xml.XmlAttribute" /> con el nombre especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (name As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del atributo. Si el nombre contiene un carácter de dos puntos, la propiedad <see cref="P:System.Xml.XmlNode.Prefix" /> refleja la parte del nombre que va delante del carácter de dos puntos y la propiedad <see cref="P:System.Xml.XmlDocument.LocalName" /> refleja la parte que va detrás. El <see cref="P:System.Xml.XmlNode.NamespaceURI" /> queda vacío, a menos que el prefijo sea un prefijo integrado conocido, como xmlns. En este caso, <see langword="NamespaceURI" /> tiene un valor de http://www.w3.org/2000/xmlns/.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XmlAttribute" /> con el <see cref="P:System.Xml.XmlDocument.Name" /> especificado.</summary>
        <returns>Nuevo objeto <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XmlAttribute` pueden agregarse a un <xref:System.Xml.XmlElement> utilizando el <xref:System.Xml.XmlElement.SetAttributeNode%2A> método.  
  
   
  
## Examples  
 El siguiente crea un atributo y lo agrega a un documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (qualifiedName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Nombre completo del atributo. Si el nombre contiene un carácter de dos puntos, la propiedad <see cref="P:System.Xml.XmlNode.Prefix" /> reflejará la parte del nombre que va delante del carácter de dos puntos y la propiedad <see cref="P:System.Xml.XmlDocument.LocalName" /> reflejará la parte que va detrás.</param>
        <param name="namespaceURI">URI del espacio de nombres del atributo. Si el nombre completo incluye un prefijo de xmlns, este parámetro debe ser http://www.w3.org/2000/xmlns/.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlAttribute" /> con el nombre completo especificados y el <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nuevo objeto <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XmlAttribute` pueden agregarse a un <xref:System.Xml.XmlElement> utilizando el <xref:System.Xml.XmlElement.SetAttributeNode%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo del atributo, si lo tiene. String.Empty y <see langword="null" /> son equivalentes.</param>
        <param name="localName">Nombre local del atributo.</param>
        <param name="namespaceURI">URI del espacio de nombres del atributo, si lo tiene. String.Empty y <see langword="null" /> son equivalentes. Si <paramref name="prefix" /> es xmlns, este parámetro debe ser http://www.w3.org/2000/xmlns/; en caso contrario, se produce una excepción.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlAttribute" /> con los <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Nuevo objeto <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XmlAttribute` pueden agregarse a un <xref:System.Xml.XmlElement> utilizando el <xref:System.Xml.XmlElement.SetAttributeNode%2A> método.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateCDataSection (data As String) As XmlCDataSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlCDataSection ^ CreateCDataSection(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateCDataSection : string -&gt; System.Xml.XmlCDataSection&#xA;override this.CreateCDataSection : string -&gt; System.Xml.XmlCDataSection" Usage="xmlDocument.CreateCDataSection data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Contenido del nuevo objeto <see langword="XmlCDataSection" />.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlCDataSection" /> que contiene los datos especificados.</summary>
        <returns>Nuevo objeto <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos CDataSection se permiten dentro de los nodos de elemento y en los nodos EntityReference cuando el nodo EntityReference no es un elemento secundario de un nodo de atributo .  
  
   
  
## Examples  
 El ejemplo siguiente crea un nodo CDATA y lo agrega al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateComment (data As String) As XmlComment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlComment ^ CreateComment(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateComment : string -&gt; System.Xml.XmlComment&#xA;override this.CreateComment : string -&gt; System.Xml.XmlComment" Usage="xmlDocument.CreateComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Contenido del nuevo objeto <see langword="XmlComment" />.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlComment" /> que contiene los datos especificados.</summary>
        <returns>Nuevo objeto <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos de comentario solo se permiten en los nodos de documentos, elemento y EntityReference cuando el nodo EntityReference no es un elemento secundario de un atributo nodo.  
  
   
  
## Examples  
 El ejemplo siguiente crea un comentario y lo agrega a un documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDefaultAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XmlAttribute ^ CreateDefaultAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateDefaultAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="localName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo del atributo, si lo tiene.</param>
        <param name="localName">Nombre local del atributo.</param>
        <param name="namespaceURI">URI del espacio de nombres del atributo, si lo tiene.</param>
        <summary>Crea un atributo predeterminado con el prefijo, el nombre local y el identificador URI de espacio de nombres especificados.</summary>
        <returns>Nuevo objeto <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentFragment () As XmlDocumentFragment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentFragment ^ CreateDocumentFragment();" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment&#xA;override this.CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment" Usage="xmlDocument.CreateDocumentFragment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una interfaz <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>Nuevo objeto <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nodos DocumentFragment no pueden insertarse en un documento. Sin embargo, puede insertar a elementos secundarios del nodo DocumentFragment en un documento.  
  
   
  
## Examples  
 El ejemplo siguiente agrega nuevos nodos a un documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentType (name As String, publicId As String, systemId As String, internalSubset As String) As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentType ^ CreateDocumentType(System::String ^ name, System::String ^ publicId, System::String ^ systemId, System::String ^ internalSubset);" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType&#xA;override this.CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType" Usage="xmlDocument.CreateDocumentType (name, publicId, systemId, internalSubset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="publicId" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="systemId" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="internalSubset" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del tipo de documento.</param>
        <param name="publicId">Identificador público del tipo de documento o <see langword="null" />. Puede especificar un URI público, así como un identificador de sistema para identificar la ubicación del subconjunto DTD externo.</param>
        <param name="systemId">Identificador del sistema del tipo de documento o <see langword="null" />. Especifica la dirección URL de la ubicación del archivo para el subconjunto DTD externo.</param>
        <param name="internalSubset">Subconjunto interno de la DTD del tipo de documento o <see langword="null" />.</param>
        <summary>Devuelve un nuevo objeto <see cref="T:System.Xml.XmlDocumentType" />.</summary>
        <returns>Nuevo objeto <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nodo devuelto habrá analiza <xref:System.Xml.XmlDocumentType.Entities%2A> y <xref:System.Xml.XmlDocumentType.Notations%2A> colecciones.  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos DocumentType sólo se permiten dentro de los nodos del documento. Cada <xref:System.Xml.XmlDocument> puede tener un solo nodo DocumentType. También se debe insertar el nodo DocumentType antes del elemento raíz de la `XmlDocument` (si el documento ya tiene un elemento raíz, no se puede agregar un nodo DocumentType).  
  
 Si los parámetros pasados no se combinan para generar un válido `XmlDocumentType`, se produce una excepción.  
  
   
  
## Examples  
 El ejemplo siguiente crea un nodo DocumentType y lo agrega a un documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Este método tiene una petición de herencia. Plena confianza es necesaria para reemplazar el <see langword="CreateDocumentType" /> método.  
  
Este método es una extensión de Microsoft a Document Object Model (DOM).</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una interfaz <see cref="T:System.Xml.XmlElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del elemento. Si el nombre contiene un carácter de dos puntos, la propiedad <see cref="P:System.Xml.XmlNode.Prefix" /> refleja la parte del nombre que va delante del carácter de dos puntos y la propiedad <see cref="P:System.Xml.XmlDocument.LocalName" /> refleja la parte que va detrás. El nombre completo no puede incluir un prefijo de 'xmlns'.</param>
        <summary>Crea un elemento con el nombre especificado.</summary>
        <returns>Nuevo objeto <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que la instancia devuelta implementa la `XmlElement` interfaz, por lo que los atributos predeterminados se crearía directamente en el objeto devuelto.  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos de elemento se permiten dentro de los nodos de los documentos y elementos y en los nodos EntityReference cuando el nodo EntityReference no es un elemento secundario de un Nodo de atributo.  
  
   
  
## Examples  
 El ejemplo siguiente crea un nuevo elemento y lo agrega al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (qualifiedName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Nombre completo del elemento. Si el nombre contiene un carácter de dos puntos, la propiedad <see cref="P:System.Xml.XmlNode.Prefix" /> reflejará la parte del nombre que va delante del carácter de dos puntos y la propiedad <see cref="P:System.Xml.XmlDocument.LocalName" /> reflejará la parte que va detrás. El nombre completo no puede incluir un prefijo de 'xmlns'.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del elemento.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlElement" /> con el nombre completo y el <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nuevo objeto <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El siguiente código de C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 resultados en un elemento que es equivalente al texto XML siguiente.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos de elemento se permiten dentro de los nodos de los documentos y elementos y en los nodos EntityReference cuando el nodo EntityReference no es un elemento secundario de un Nodo de atributo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateElement : string * string * string -&gt; System.Xml.XmlElement&#xA;override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo del nuevo elemento, si lo tiene. String.Empty y <see langword="null" /> son equivalentes.</param>
        <param name="localName">Nombre local del nuevo elemento.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del nuevo elemento, si lo tiene. String.Empty y <see langword="null" /> son equivalentes.</param>
        <summary>Crea un elemento con los <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Nuevo objeto <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El siguiente código de C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 crea un elemento equivalente al texto XML siguiente:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos de elemento se permiten dentro de los nodos de los documentos y elementos y en los nodos EntityReference cuando EntityReference está fuera de un nodo de atributo.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo elemento al documento XML existente.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityReference : string -&gt; System.Xml.XmlEntityReference&#xA;override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la referencia a entidad.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XmlEntityReference" /> con el nombre especificado.</summary>
        <returns>Nuevo objeto <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se conoce la entidad que se hace referencia, la lista secundaria de la `XmlEntityReference` nodo se realiza la misma que la correspondiente <xref:System.Xml.XmlEntity> nodo.  
  
 Los espacios de nombres utilizados en el texto de reemplazo para la referencia de entidad se enlazan en el momento en que se configura el nodo primario del nodo de referencia de entidad (por ejemplo, cuando se inserta el nodo de referencia de entidad en el documento). Por ejemplo, dada la entidad siguiente:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 Si se llama a `CreateEntityReference("a")` regresar un único nodo del tipo EntityReference sin nodos secundarios. Si anexa este nodo como un elemento secundario del nodo siguiente,  
  
```  
<item xmlns="urn:1"/>  
```  
  
 a continuación, en el momento de llamar a <xref:System.Xml.XmlNode.AppendChild%2A>, se establece el elemento primario del nodo de referencia de entidad recién creada y los elementos secundarios se expanden en este contexto de espacio de nombres. El nodo de elemento secundario `b` tendrá NamespaceURI igual a `urn:1`. Los nodos secundarios de la referencia de entidad no cambian aunque mueva la referencia de entidad en un lugar en el documento que tiene un contexto de espacio de nombres predeterminado diferente. Esto no sucede con los nodos de referencia de entidad existentes cuando se quitan o insertan o se hace referencia a entidad que se clonan mediante <xref:System.Xml.XmlDocument.CloneNode%2A>. Solo se produce para las referencias de entidad recién creada.  
  
 Si la entidad correspondiente no está definida en el DocumentType cuando se agrega el nodo de referencia de entidad, porque la referencia de entidad no está definida, el único nodo secundario será un nodo de texto vacío.  
  
 También se permiten las entidades integradas amp lt, gt, apos y quot y tienen un nodo de texto secundario con el valor de carácter expandido adecuado.  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos EntityReference sólo se permiten dentro de los nodos de elemento, atributo y EntityReference.  
  
   
  
## Examples  
 El ejemplo siguiente crea dos nodos de referencia de entidad y los inserta en un documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre no es válido (por ejemplo, los nombres que empiezan por “#” no son válidos).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para navegar por este documento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para navegar por este documento.</summary>
        <returns>Un objeto <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> para obtener un ejemplo con este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.XmlNode" /> en el que se desea que el explorador se sitúe inicialmente.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para navegar por este documento colocado en <see cref="T:System.Xml.XmlNode" /> especificado.</summary>
        <returns>Un objeto <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> para obtener un ejemplo con este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una interfaz <see cref="T:System.Xml.XmlNode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (nodeTypeString As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::String ^ nodeTypeString, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (nodeTypeString, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Versión de cadena del <see cref="T:System.Xml.XmlNodeType" /> del nuevo nodo. Este parámetro debe ser uno de los valores de la tabla que figura más abajo.</param>
        <param name="name">Nombre completo del nuevo nodo. Si el nombre contiene un carácter de dos puntos, se analiza en los componentes <see cref="P:System.Xml.XmlNode.Prefix" /> y <see cref="P:System.Xml.XmlDocument.LocalName" />.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del nuevo nodo.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlNode" /> con el tipo de nodo especificado, <see cref="P:System.Xml.XmlDocument.Name" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Nuevo objeto <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `nodeTypeString` parámetro distingue mayúsculas de minúsculas y debe ser uno de los valores en la tabla siguiente.  
  
|nodeTypeString|Tipo XmlNode|  
|--------------------|-----------------|  
|Atributo|Atributo|  
|CDATASection|CDATA|  
|comentario|Comentario|  
|documento|Documento|  
|DocumentFragment|DocumentFragment|  
|DocumentType|DocumentType|  
|elemento|Elemento|  
|EntityReference|EntityReference|  
|ProcessingInstruction|ProcessingInstruction|  
|SignificantWhitespace|SignificantWhitespace|  
|texto|Texto|  
|whitespace|Whitespace|  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 La siguiente tabla muestra qué tipo de nodo [fila] se permite dentro de otro NodeType [columna de] acuerdo con la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Documento|DocumentType|XmlDeclaration|Elemento|Atributo|Texto|CDATA|marcado|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|No|No|No|No|No|No|No|No|No|  
|`DocumentType`|sí|No|No|No|No|No|No|No|No|  
|`XmlDeclaration`|Sí *|No|No|No|No|No|No|No|No|  
|`Element`|sí|No|No|sí|No|No|No|No|Sí ***|  
|`Attribute`|No|No|No|Sí ***|No|No|No|No|No|  
|`Text`|No|No|No|sí|sí|No|No|No|sí|  
|`CDATA`|No|No|No|sí|No|No|No|No|Sí ***|  
|`Markup**`|sí|No|No|sí|No|No|No|No|No|  
|`EntityReference`|No|No|No|sí|sí|No|No|No|sí|  
  
 \* El nodo XmlDeclaration debe ser el primer elemento secundario del nodo de documento.  
  
 ** Marcado incluye los nodos ProcessingInstruction y un comentario.  
  
 Nodos de elemento y CDATA sólo se permiten en los nodos EntityReference cuando el nodo EntityReference no es un elemento secundario de un nodo de atributo.  
  
 Los atributos no son elementos secundarios de un nodo de elemento. Atributos están contenidos dentro de una colección de atributos que pertenece a un nodo de elemento.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente crea un nuevo elemento y lo inserta en el documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se ha proporcionado el nombre y <see langword="XmlNodeType" /> requiere un nombre; o <paramref name="nodeTypeString" /> no es una de las cadenas enumeradas a continuación.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><see langword="XmlNodeType" /> del nuevo nodo.</param>
        <param name="name">Nombre completo del nuevo nodo. Si el nombre contiene un carácter de dos puntos, se analiza en los componentes <see cref="P:System.Xml.XmlNode.Prefix" /> y <see cref="P:System.Xml.XmlDocument.LocalName" />.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del nuevo nodo.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlNode" /> con los <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Nuevo objeto <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 La siguiente tabla muestra qué tipo de nodo [fila] se permite dentro de otro NodeType [columna de] acuerdo con la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Documento|DocumentType|XmlDeclaration|Elemento|Atributo|Texto|CDATA|marcado|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|No|No|No|No|No|No|No|No|No|  
|`DocumentType`|sí|No|No|No|No|No|No|No|No|  
|`XmlDeclaration`|Sí *|No|No|No|No|No|No|No|No|  
|`Element`|sí|No|No|sí|No|No|No|No|Sí ***|  
|`Attribute`|No|No|No|Sí ***|No|No|No|No|No|  
|`Text`|No|No|No|sí|sí|No|No|No|sí|  
|`CDATA`|No|No|No|sí|No|No|No|No|Sí ***|  
|`Markup**`|sí|No|No|sí|No|No|No|No|No|  
|`EntityReference`|No|No|No|sí|sí|No|No|No|sí|  
  
 \* El nodo XmlDeclaration debe ser el primer elemento secundario del nodo de documento.  
  
 ** Marcado incluye los nodos ProcessingInstruction y un comentario.  
  
 Nodos de elemento y CDATA sólo se permiten en los nodos EntityReference cuando el nodo EntityReference no es un elemento secundario de un nodo de atributo.  
  
 Los atributos no son elementos secundarios de un nodo de elemento. Atributos están contenidos dentro de una colección de atributos que pertenece a un nodo de elemento.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente crea un nuevo elemento y lo inserta en un documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se ha proporcionado el nombre y <see langword="XmlNodeType" /> requiere un nombre.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, prefix As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ prefix, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, prefix, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><see langword="XmlNodeType" /> del nuevo nodo.</param>
        <param name="prefix">Prefijo del nuevo nodo.</param>
        <param name="name">Nombre local del nuevo nodo.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres del nuevo nodo.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlNode" /> con los <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Nuevo objeto <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 La siguiente tabla muestra qué tipo de nodo [fila] se permite dentro de otro NodeType [columna de] acuerdo con la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Documento|DocumentType|XmlDeclaration|Elemento|Atributo|Texto|CDATA|marcado|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|No|No|No|No|No|No|No|No|No|  
|`DocumentType`|sí|No|No|No|No|No|No|No|No|  
|`XmlDeclaration`|Sí *|No|No|No|No|No|No|No|No|  
|`Element`|sí|No|No|sí|No|No|No|No|Sí ***|  
|`Attribute`|No|No|No|Sí ***|No|No|No|No|No|  
|`Text`|No|No|No|sí|sí|No|No|No|sí|  
|`CDATA`|No|No|No|sí|No|No|No|No|Sí ***|  
|`Markup**`|sí|No|No|sí|No|No|No|No|No|  
|`EntityReference`|No|No|No|sí|sí|No|No|No|sí|  
  
 \* El nodo XmlDeclaration debe ser el primer elemento secundario del nodo de documento.  
  
 ** Marcado incluye los nodos ProcessingInstruction y un comentario.  
  
 Nodos de elemento y CDATA sólo se permiten en los nodos EntityReference cuando el nodo EntityReference no es un elemento secundario de un nodo de atributo.  
  
 Los atributos no son elementos secundarios de un nodo de elemento. Atributos están contenidos dentro de una colección de atributos que pertenece al nodo de elemento.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente agrega un nuevo elemento al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se ha proporcionado el nombre y <see langword="XmlNodeType" /> requiere un nombre.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateProcessingInstruction (target As String, data As String) As XmlProcessingInstruction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlProcessingInstruction ^ CreateProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction&#xA;override this.CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction" Usage="xmlDocument.CreateProcessingInstruction (target, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Nombre de la instrucción de procesamiento.</param>
        <param name="data">Datos para la instrucción de procesamiento.</param>
        <summary>Crea un <see cref="T:System.Xml.XmlProcessingInstruction" /> con el nombre y los datos especificados.</summary>
        <returns>Nuevo objeto <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos ProcessingInstruction sólo se permiten en los nodos del documento, elemento y EntityReference, cuando el nodo EntityReference no es un elemento secundario de un nodo de atributo.  
  
   
  
## Examples  
 El ejemplo siguiente crea un nodo ProcessingInstruction y lo agrega al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSignificantWhitespace (text As String) As XmlSignificantWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlSignificantWhitespace ^ CreateSignificantWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace&#xA;override this.CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace" Usage="xmlDocument.CreateSignificantWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">La cadena debe contener solo los caracteres siguientes:&amp;#20; &amp;#10; &amp;#13; y &amp;#9;</param>
        <summary>Crea un nodo <see cref="T:System.Xml.XmlSignificantWhitespace" />.</summary>
        <returns>Nuevo nodo <see langword="XmlSignificantWhitespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM). Se usa cuando desea dar formato a su documento manualmente.  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega un espacio en blanco significativo al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTextNode (text As String) As XmlText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlText ^ CreateTextNode(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateTextNode : string -&gt; System.Xml.XmlText&#xA;override this.CreateTextNode : string -&gt; System.Xml.XmlText" Usage="xmlDocument.CreateTextNode text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Texto del nodo Text.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XmlText" />con el texto especificado.</summary>
        <returns>Nuevo nodo <see langword="XmlText" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), los nodos de texto solo se permiten dentro de los nodos de elemento, atributo y EntityReference.  
  
   
  
## Examples  
 El ejemplo siguiente crea un nuevo elemento y lo agrega al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWhitespace (text As String) As XmlWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlWhitespace ^ CreateWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateWhitespace : string -&gt; System.Xml.XmlWhitespace&#xA;override this.CreateWhitespace : string -&gt; System.Xml.XmlWhitespace" Usage="xmlDocument.CreateWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">La cadena debe contener solo los caracteres siguientes:&amp;#20; &amp;#10; &amp;#13; y &amp;#9;</param>
        <summary>Crea un nodo <see cref="T:System.Xml.XmlWhitespace" />.</summary>
        <returns>Nuevo nodo <see langword="XmlWhitespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM). Se usa cuando desea dar formato a su documento manualmente.  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
   
  
## Examples  
 El ejemplo siguiente agrega un espacio en blanco al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateXmlDeclaration (version As String, encoding As String, standalone As String) As XmlDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDeclaration ^ CreateXmlDeclaration(System::String ^ version, System::String ^ encoding, System::String ^ standalone);" />
      <MemberSignature Language="F#" Value="abstract member CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration&#xA;override this.CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration" Usage="xmlDocument.CreateXmlDeclaration (version, encoding, standalone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">La versión debe ser "1.0".</param>
        <param name="encoding">Valor del atributo de codificación. Es la codificación que se usa cuando se guarda <see cref="T:System.Xml.XmlDocument" /> en un archivo o en un flujo; por tanto, se debe establecer en una cadena admitida por la clase <see cref="T:System.Text.Encoding" /> ya que, en caso contrario, <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> produce un error. Si es <see langword="null" /> o String.Empty, el método <see langword="Save" /> no escribe un atributo de codificación en la declaración XML y, por tanto, se usa la codificación predeterminada, UTF-8.  
  
Nota: Si <see langword="XmlDocument" /> se guarda en <see cref="T:System.IO.TextWriter" /> o en <see cref="T:System.Xml.XmlTextWriter" />, se descartará este valor de codificación. En su lugar, se usa la codificación de <see langword="TextWriter" /> o de <see langword="XmlTextWriter" />. De este modo se garantiza que el fragmento XML que se escribe se puede volver a leer usando la codificación correcta.</param>
        <param name="standalone">Este valor debe ser "yes" o "no". Si es <see langword="null" /> o String.Empty, el método <see langword="Save" /> no escribe un atributo independiente en la declaración XML.</param>
        <summary>Crea un nodo <see cref="T:System.Xml.XmlDeclaration" /> con los valores especificados.</summary>
        <returns>Nuevo nodo <see langword="XmlDeclaration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los atributos se exponen como propiedades especiales en el `XmlDeclaration` nodo y no como <xref:System.Xml.XmlAttribute> nodos.  
  
 Aunque este método crea el nuevo objeto en el contexto del documento, no agregar automáticamente el nuevo objeto en el árbol del documento. Para agregar el nuevo objeto, debe llamar explícitamente a uno de los métodos de inserción de nodo.  
  
 Según la recomendación W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), el `XmlDeclaration` nodo debe ser el primer nodo en el documento.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente crea una declaración XML y lo agrega al documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Los valores de <paramref name="version" /> o <paramref name="standalone" /> son algo diferentes de los especificados anteriormente.</exception>
        <altmember cref="T:System.Xml.XmlDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentElement As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlElement ^ DocumentElement { System::Xml::XmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentElement : System.Xml.XmlElement" Usage="System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Xml.XmlElement" /> raíz del documento.</summary>
        <value><see langword="XmlElement" /> que representa la raíz del árbol del documento XML. Si no hay raíz, se devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el elemento raíz del documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Resultado:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DocumentType As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocumentType ^ DocumentType { System::Xml::XmlDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.XmlDocumentType" Usage="System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nodo que contiene la declaración DOCTYPE.</summary>
        <value><see cref="T:System.Xml.XmlNode" /> que contiene el DocumentType (declaración DOCTYPE).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un `XmlDocument` puede tener solo un elemento secundario con <xref:System.Xml.XmlNodeType> igual a DocumentType.  
  
> [!NOTE]
>  Esta propiedad es de sólo lectura. Para cambiar el nodo DocumentType, elimine el nodo existente, cree un nuevo con un el <xref:System.Xml.XmlDocument.CreateDocumentType%2A> método y agregue el nuevo nodo al documento.  
  
   
  
## Examples  
 El ejemplo siguiente se obtiene y muestra la declaración DOCTYPE del documento.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlDocumentType" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementById (elementId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ GetElementById(System::String ^ elementId);" />
      <MemberSignature Language="F#" Value="abstract member GetElementById : string -&gt; System.Xml.XmlElement&#xA;override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.GetElementById elementId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementId">Identificador de atributo con el que debe haber una coincidencia.</param>
        <summary>Obtiene el <see cref="T:System.Xml.XmlElement" /> con el identificador especificado.</summary>
        <returns><see langword="XmlElement" /> con el identificador coincidente o <see langword="null" /> si no se encuentra un elemento coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el documento tiene varios elementos con el identificador coincidente, este método devuelve el primer elemento coincidente en el documento.  
  
> [!NOTE]
>  La implementación de DOM debe tener información que define los atributos que son de tipo identificador. Aunque los atributos de tipo ID pueden definirse en esquemas XSD o DTD, esta versión del producto solo admite aquellas definidas en la DTD. Los atributos con el nombre "ID" no es de tipo ID, a menos que así se ha definido en la DTD. Las implementaciones donde se sabe si los atributos son de tipo ID se esperan que devuelvan `null`.  
  
   
  
## Examples  
 El siguiente ejemplo utiliza el método `GetElementById`.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `ids.xml`como entrada.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED>]>  
<root>  
  <Person SSN='A111' Name='Fred'/>  
  <Person SSN='A222' Name='Tom'/>  
  <Customer id='A222334444'/>  
  <Team members='A222334444 A333445555'/>  
</root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetElementsByTagName">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los elementos descendientes que coinciden con el nombre especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo que se va a hacer coincidir. Se compara con la propiedad <see langword="Name" /> del nodo coincidente. El valor especial "*" coincide con todas las etiquetas.</param>
        <summary>Devuelve un objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los elementos descendientes que coinciden con el <see cref="P:System.Xml.XmlDocument.Name" /> especificado.</summary>
        <returns>Objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los nodos coincidentes. Si ningún nodo coincide con <paramref name="name" />, se devolverá la colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nodos se colocan en el orden en que se encontrarían en el documento.  
  
> [!NOTE]
>  Se recomienda que utilice el <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> o <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> método en lugar de la <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un `XmlDocument` objeto y se usa el `GetElementsByTagName` método y resultante <xref:System.Xml.XmlNodeList> objeto para mostrar todos los títulos de libros.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza como entrada el archivo `books.xml`.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (localName As String, namespaceURI As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local que se va a hacer coincidir. El valor especial "*" coincide con todas las etiquetas.</param>
        <param name="namespaceURI">Identificador URI de espacio de nombres con el que debe haber una coincidencia.</param>
        <summary>Devuelve un objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los elementos descendientes que coinciden con el <see cref="P:System.Xml.XmlDocument.LocalName" /> y <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Objeto <see cref="T:System.Xml.XmlNodeList" /> que contiene una lista de todos los nodos coincidentes. Si ningún nodo coincide con el <paramref name="localName" /> y <paramref name="namespaceURI" /> especificados, se devolverá la colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nodos se colocan en el orden en que se encontrarían en el árbol del documento.  
  
> [!NOTE]
>  Se recomienda que utilice el <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> o <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> método en lugar de la <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Implementation As XmlImplementation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlImplementation ^ Implementation { System::Xml::XmlImplementation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Implementation : System.Xml.XmlImplementation" Usage="System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xml.XmlImplementation" /> del documento actual.</summary>
        <value>Objeto <see langword="XmlImplementation" /> del documento actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` los objetos creados desde la misma `XmlImplementation` comparten el mismo <xref:System.Xml.XmlNameTable>. Esto permite a los usuarios comparar nombres de atributos y elementos como objetos en lugar de cadenas.  
  
 Aunque el `XmlDocument` objetos comparten la misma implementación, para mover los nodos de un documento a otro, debe utilizar el <xref:System.Xml.XmlDocument.ImportNode%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo `XmlDocument` mediante la implementación de otro documento.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportNode (node As XmlNode, deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ImportNode(System::Xml::XmlNode ^ node, bool deep);" />
      <MemberSignature Language="F#" Value="abstract member ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode&#xA;override this.ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.ImportNode (node, deep)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">Nodo que se va a importar.</param>
        <param name="deep"><see langword="true" /> para producir un clon profundo; en caso contrario, <see langword="false" />.</param>
        <summary>Importa un nodo de otro documento al documento actual.</summary>
        <returns><see cref="T:System.Xml.XmlNode" /> que se importó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nodo devuelto no tiene ningún elemento primario. El nodo de origen no se modifica o se quita el documento original; `ImportNode` crea una copia del nodo de origen.  
  
 Importar un nodo, se crea un `XmlNode` que pertenecen a importar el documento, con el objeto <xref:System.Xml.XmlNode.Name%2A> y <xref:System.Xml.XmlNode.NodeType%2A> idénticos al nodo de origen. El nuevo objeto también tiene los atributos relacionados con los espacios de nombres (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>, y <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 Según el tipo de nodo del nodo importado y el valor de la `deep` parámetro, información adicional se copia según corresponda. Este método intenta reflejar el comportamiento esperado si un fragmento de origen XML o HTML se ha copiado de un documento a otro (teniendo en cuenta que, en el caso XML, los dos documentos podrían tener DTD diferentes).  
  
 En la tabla siguiente se describe el comportamiento específico para cada <xref:System.Xml.XmlNodeType>.  
  
|Tipo XmlNode|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|Atributo|El <xref:System.Xml.XmlAttribute.Specified%2A> propiedad está establecida en `true` en generado <xref:System.Xml.XmlAttribute>. Los descendientes del origen de `XmlAttribute` se importan de forma recursiva y los nodos resultantes se reensamblan para crear el subárbol correspondiente.|El `deep` parámetro no es aplicable a `XmlAttribute` nodos; siempre incluyen sus elementos secundarios con cuando se importan.|  
|CData|Copia el nodo, junto con sus datos.|Copia el nodo, junto con sus datos.|  
|Comentario|Copia el nodo, junto con sus datos.|Copia el nodo, junto con sus datos.|  
|DocumentFragment|Los descendientes del nodo de origen se importan de forma recursiva y los nodos resultantes se reensamblan para crear el subárbol correspondiente.|Un valor vacío <xref:System.Xml.XmlDocumentFragment> se genera.|  
|DocumentType|Copia el nodo, junto con sus datos.*|Copia el nodo, junto con sus datos.*|  
|Elemento|Los descendientes del elemento de origen y sus nodos de atributo especificado son importado de forma recursiva y los nodos resultantes se reensamblan para crear el subárbol correspondiente.<br /><br /> Nota: Los atributos predeterminados no se copian. Si el documento que se va a importar define atributos predeterminados para este nombre de elemento, dichos atributos se asignan.|Atributo especificado se importan los nodos del elemento de origen y el `XmlAttribute` nodos se adjuntan a generado <xref:System.Xml.XmlElement>.<br /><br /> Nota: Los atributos predeterminados no se copian. Si el documento que se va a importar define atributos predeterminados para este nombre de elemento, dichos atributos se asignan.|  
|EntityReference|Dado que los documentos de origen y de destino podrían tener las entidades definidas de forma diferente, este método solo copia la <xref:System.Xml.XmlEntityReference> nodo. El texto de sustitución no se incluye. Si el documento de destino tiene definida la entidad, se asigna su valor.|Dado que los documentos de origen y de destino podrían tener las entidades definidas de forma diferente, este método solo copia la <xref:System.Xml.XmlEntityReference> nodo. El texto de sustitución no se incluye. Si el documento de destino tiene definida la entidad, se asigna su valor.|  
|ProcessingInstruction|Copia el valor de destino y de datos del nodo importado.|Copia el valor de destino y de datos del nodo importado.|  
|Texto|Copia el nodo, junto con sus datos.|Copia el nodo, junto con sus datos.|  
|SignificantWhitespace|Copia el nodo, junto con sus datos.|Copia el nodo, junto con sus datos.|  
|Whitespace|Copia el nodo, junto con sus datos.|Copia el nodo, junto con sus datos.|  
|XmlDeclaration|Copia el valor de destino y de datos del nodo importado.|Copia el valor de destino y de datos del nodo importado.|  
|Todos los demás tipos de nodo.|Estos tipos de nodos no se pueden importar.|Estos tipos de nodos no se pueden importar.|  
  
 * Aunque se pueden importar nodos DocumentType, un documento sólo puede tener un DocumentType. Si el documento tiene actualmente un nodo DocumenType, se deben quitar antes de agregar uno nuevo.  
  
   
  
## Examples  
 El ejemplo siguiente importa un nodo de libro de un segundo documento XML en el documento XML original.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `books.xml`como entrada.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Llamar a este método en un tipo de nodo que no se pueden importar.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText {  void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string" Usage="System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Produce una <see cref="T:System.InvalidOperationException" /> en todos los casos.</summary>
        <value>Valores del nodo y de todos sus nodos secundarios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no está implementada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el marcado que representa los nodos secundarios del nodo actual.</summary>
        <value>Marcado de los nodos secundarios del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad reemplaza a los elementos secundarios del nodo con el contenido analizado de la cadena especificada. El análisis se realiza en el contexto del espacio de nombres actual.  
  
 `InnerXml` Quita las declaraciones de espacios de nombres redundantes. Como resultado, las numerosas operaciones de corte y pegado no aumentan el tamaño del documento con declaraciones de espacios de nombres redundantes. Tenga en cuenta el siguiente documento XSL:  
  
```xml  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 El `InnerXml` propiedad en el nodo de hoja de estilos devuelve la cadena siguiente:  
  
```xml  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Tenga en cuenta la declaración de espacio de nombres xmlns: xsl adicional que se utiliza para conservar la identidad del nodo. Si vuelve a insertar esta cadena XML interna, se obtendrá el documento original. En otras palabras, `InnerXml` reconoce que la declaración de espacio de nombres xmlns: XSL es redundante, dado que el elemento xsl: stylesheet primario ya tiene la declaración de espacio de nombres xmlns: xsl y, por lo tanto, quita.  
  
 Si mueve `InnerXml` desde un documento con ningún espacio de nombres predeterminado a un documento con un espacio de nombres predeterminado, el comportamiento es un poco diferente. Tenga en cuenta la siguiente cadena XML:  
  
```xml  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml` Devuelve una cadena XML sin formato sin declaraciones de espacio de nombres:  
  
```xml  
<item>123</item>  
```  
  
 Si, a continuación, inserta esta cadena en un documento que tiene un espacio de nombres predeterminado, como la siguiente:  
  
```xml  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml` analiza la cadena en contexto y los nuevos nodos recoger el espacio de nombres urn: 1. El resultado tendrá este aspecto:  
  
```xml  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Ahora, al pedir el `InnerXml` obtendrá lo siguiente:  
  
```xml  
<item xmlns="urn:1">123</item>  
```  
  
 Si se desea explícitamente el elemento insertado para conservar el hecho de que procede de un documento que no tenían ningún espacio de nombres, deberá agregar manualmente un xmlns = "" declaración e insertar la cadena resultante:  
  
```xml  
<item xmlns="">123</item>  
```  
  
 El efecto neto de todo que esto es como sigue:  
  
1.  Cortar y pegar `InnerXml` entre documentos que no usan espacios de nombres es sencilla y no crea una redundancia "xmlns" en las cadenas.  
  
2.  `InnerXml` También puede utilizarse para cortar y pegar entre documentos que tienen más de un espacio de nombres (es decir, las hojas de estilos XSL).  
  
3.  las declaraciones xmlns: xsl automáticamente aparecen en las cadenas y desaparecen en las jerarquías de nodos.  
  
4.  En el caso donde vaya a mover `InnerXml` desde un documento que no tenga ningún espacio de nombres predeterminado para un documento que tiene un espacio de nombres predeterminado, los nuevos nodos recogerá el nuevo espacio de nombres predeterminado.  
  
 Si `InnerXml` se establece con el texto que contiene referencias a entidades que no están definidas actualmente en el documento, el árbol resultante contendrá nodos EntityReference vacíos.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">El código XML especificado al establecer esta propiedad no es correcto.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el nodo actual es de solo lectura.</summary>
        <value><see langword="true" /> Si el nodo actual es de solo lectura. en caso contrario <see langword="false" />. <see langword="XmlDocument" /> siempre se devuelven nodos <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nodo de solo lectura es una cuyas propiedades, atributos o elementos secundarios no se puede cambiar. Puede quitar un nodo de solo lectura del árbol e insértelo en otro lugar.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar la propiedad `IsReadOnly`.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carga los datos XML especificados de <see cref="T:System.IO.Stream" />, una dirección URL, un <see cref="T:System.IO.TextReader" /> o un <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.Stream -&gt; unit&#xA;override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Secuencia que contiene el documento XML que se va a cargar.</param>
        <summary>Carga el documento XML desde el flujo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El `Load` método siempre conserva espacio en blanco significativo. El <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propiedad determina si los espacios en blanco insignificantes, que es un espacio en blanco en contenido de elemento, se conserva. El valor predeterminado es `false`; no se conserva el espacio en blanco en contenido del elemento.  
  
 Si desea que se produzca la validación, puede crear una validación <xref:System.Xml.XmlReader> instancia utilizando el <xref:System.Xml.XmlReaderSettings> clase y el <xref:System.Xml.XmlReader.Create%2A> método. Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 Este método detecta automáticamente el formato de cadena de la entrada XML (por ejemplo, UTF-8, ANSI y así sucesivamente). Si la aplicación necesita saber qué codificación se usa para leer la secuencia, considere el uso de un <xref:System.Xml.XmlTextReader> para leer la secuencia de objetos y, a continuación, use el <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> propiedad para determinar la codificación. Si necesita usar un <xref:System.Xml.XmlDocument> para trabajar directamente con XML, puede usar el <xref:System.Xml.XmlTextReader> objeto para crear uno. Para obtener más información, consulte [lectura de datos XML con XPathDocument y XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Hay un error de carga o de análisis en el archivo XML. En este caso, se genera una <see cref="T:System.IO.FileNotFoundException" />.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.TextReader -&gt; unit&#xA;override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader"><see langword="TextReader" /> que se usa para introducir los datos XML en el documento.</param>
        <summary>Carga el documento XML desde el <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El `Load` método siempre conserva espacio en blanco significativo. El <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propiedad determina si los espacios en blanco insignificantes, que es un espacio en blanco en contenido de elemento, se conserva. El valor predeterminado es `false`; no se conserva el espacio en blanco en contenido del elemento.  
  
 Si desea que se produzca la validación, puede crear una validación <xref:System.Xml.XmlReader> instancia utilizando el <xref:System.Xml.XmlReaderSettings> clase y el <xref:System.Xml.XmlReader.Create%2A> método. Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.StringReader> clase para cargar una cadena de datos XML en el `XmlDocument` objeto.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Hay un error de carga o de análisis en el archivo XML. En este caso, el documento permanece vacío.</exception>
        <altmember cref="T:System.IO.StreamReader" />
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; unit&#xA;override this.Load : string -&gt; unit" Usage="xmlDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filename">Dirección URL del archivo que contiene el documento XML que se va a cargar. La dirección URL puede ser un archivo local o una dirección HTTP URL (una dirección web).</param>
        <summary>Carga el documento XML desde la dirección URL especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El `Load` método siempre conserva espacio en blanco significativo. El <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propiedad determina si los espacios en blanco insignificantes, que es un espacio en blanco en contenido de elemento, se conserva. El valor predeterminado es `false`; no se conserva el espacio en blanco en contenido del elemento.  
  
 Si desea que se produzca la validación, puede crear una validación <xref:System.Xml.XmlReader> instancia utilizando el <xref:System.Xml.XmlReaderSettings> clase y el <xref:System.Xml.XmlReader.Create%2A> método. Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Hay un error de carga o de análisis en el archivo XML. En este caso, se genera una <see cref="T:System.IO.FileNotFoundException" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="filename" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="filename" /> especificó un archivo que es de solo lectura.  
  
O bien 
Esta operación no es compatible con la plataforma actual.  
  
O bien 
 <paramref name="filename" /> especificó un directorio.  
  
O bien 
El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo especificado en <paramref name="filename" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="filename" /> tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Xml.XmlReader -&gt; unit&#xA;override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="XmlReader" /> que se usa para introducir los datos XML en el documento.</param>
        <summary>Carga el documento XML desde el <see cref="T:System.Xml.XmlReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El `Load` método siempre conserva espacio en blanco significativo. El <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propiedad determina si los espacios en blanco insignificantes, que es un espacio en blanco en contenido de elemento, se conserva. El valor predeterminado es `false`; no se conserva el espacio en blanco en contenido del elemento.  
  
 Si el lector está en el estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial), `Load` consume todo el contenido del lector y genera el DOM a partir de lo que encuentre.  
  
 Si el lector está situado ya en algún nodo en profundidad "n", este método carga ese nodo y todos los nodos relacionados subsiguientes hasta la etiqueta de cierre que cierra la profundidad "n". Esto tiene los siguientes resultados.  
  
 Si el nodo actual y sus homólogos de aspecto similar al siguiente:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` produce una excepción porque un documento no puede tener dos elementos de nivel de raíz. Si el nodo actual y sus homólogos de aspecto similar al siguiente:  
  
```xml  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load` se realiza correctamente, pero tiene un árbol DOM incompleto porque no hay ningún elemento de nivel raíz. Antes de guardar el documento, debe agregar un elemento de nivel raíz, de lo contrario <xref:System.Xml.XmlDocument.Save%2A> generará una excepción.  
  
 Si el lector está situado en un nodo hoja que no es válido para el nivel raíz de un documento, por ejemplo un espacio en blanco o un nodo de atributo, continúa leyendo hasta que se coloca el lector en un nodo que se puede usar para la raíz. El documento comienza a cargarse en este punto.  
  
 Si desea que se produzca la validación, puede crear una validación <xref:System.Xml.XmlReader> instancia utilizando el <xref:System.Xml.XmlReaderSettings> clase y el <xref:System.Xml.XmlReader.Create%2A> método. Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 En el ejemplo siguiente se carga el último nodo de libro del `books.xml` archivo en el documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `books.xml`como entrada.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Hay un error de carga o de análisis en el archivo XML. En este caso, el documento permanece vacío.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadXml (xml As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadXml(System::String ^ xml);" />
      <MemberSignature Language="F#" Value="abstract member LoadXml : string -&gt; unit&#xA;override this.LoadXml : string -&gt; unit" Usage="xmlDocument.LoadXml xml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Cadena que contiene el documento XML que se va a cargar.</param>
        <summary>Carga el documento XML desde la cadena especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada el `LoadXml` método no conserva el espacio en blanco o espacio en blanco significativo.  
  
 Este método analiza las DTD, pero no realiza la validación de DTD o esquema. Si desea que se produzca la validación, puede crear una validación <xref:System.Xml.XmlReader> instancia utilizando el <xref:System.Xml.XmlReaderSettings> clase y el <xref:System.Xml.XmlReader.Create%2A> método. Para obtener más información, vea la sección Comentarios de la página de referencia de <xref:System.Xml.XmlReader>.  
  
 Si desea cargar desde un <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, o <xref:System.Xml.XmlReader>, utilice el método Load en lugar de este método.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 En el ejemplo siguiente se carga XML en un `XmlDocument` de objeto y lo guarda en un archivo.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Hay un error de carga o de análisis en el archivo XML. En este caso, el documento permanece vacío.</exception>
        <altmember cref="P:System.Xml.XmlDocument.PreserveWhitespace" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre local del nodo.</summary>
        <value>Para nodos <see langword="XmlDocument" />, el nombre local es #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre local devuelto depende de la <xref:System.Xml.XmlDocument.NodeType%2A> del nodo. Para ver una tabla que describe el nombre local devuelto para cada uno de los tipos de nodo, vea el <xref:System.Xml.XmlNode.LocalName%2A> propiedad en el <xref:System.Xml.XmlNode> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre completo del nodo.</summary>
        <value>Para nodos <see langword="XmlDocument" />, el nombre es #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre devuelto depende de la <xref:System.Xml.XmlDocument.NodeType%2A> del nodo. Para ver una tabla que describe el nombre devuelto para cada uno de los tipos de nodo, vea el <xref:System.Xml.XmlNode.Name%2A> propiedad en el <xref:System.Xml.XmlNode> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Xml.XmlNameTable" /> asociado a esta implementación.</summary>
        <value><see langword="XmlNameTable" /> que permite obtener la versión subdivida de una cadena en el documento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada `XmlDocument` objeto tiene un <xref:System.Xml.NameTable> objeto. Nombres de atributos y elementos se almacenan en el `NameTable` como cadenas subdivididas. Esto significa que incluso si se hace referencia a un nombre en el documento varias veces se almacena sólo una vez en el `NameTable`. Por ejemplo, si el documento tiene varios elementos con el nombre "Customer", `NameTable` devuelve el mismo objeto cada vez que reciba una solicitud para ese nombre. Como resultado, los usuarios pueden escribir código mediante comparaciones de estas cadenas en lugar de las comparaciones de cadenas más costosas.  
  
 Para obtener más información sobre cadenas subdivididas, vea <xref:System.Xml.XmlNameTable>.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanged As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanged;" />
      <MemberSignature Language="F#" Value="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el <see cref="P:System.Xml.XmlNode.Value" /> de un nodo que pertenece a este documento se modifica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento solo se aplica a los nodos que tienen un valor.  
  
 Todos los nodos creados por este documento, si se han insertado en el documento, se incluyen en este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanging As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanging;" />
      <MemberSignature Language="F#" Value="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el <see cref="P:System.Xml.XmlNode.Value" /> de un nodo que pertenece a este documento se va a modificar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento permite al usuario realizar comprobaciones adicionales y, si es necesario, inicie una excepción para detener la operación. Si se produce una excepción el `XmlDocument` vuelve a su estado original. Este evento solo se aplica a los nodos que tienen un valor.  
  
 Todos los nodos creados por este documento, si se han insertado en el documento, se incluyen en este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserted As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserted;" />
      <MemberSignature Language="F#" Value="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un nodo que pertenece a este documento se ha insertado en otro nodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los nodos creados por este documento, si se han insertado en el documento, se incluyen en este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserting As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserting;" />
      <MemberSignature Language="F#" Value="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un nodo que pertenece a este documento se va a insertar en otro nodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento permite al usuario realizar comprobaciones adicionales y, si es necesario, inicie una excepción para detener la operación. Si se produce una excepción el `XmlDocument` vuelve a su estado original.  
  
 Todos los nodos creados por este documento, si se han insertado en el documento, se incluyen en este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoved As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoved;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un nodo que pertenece a este documento se ha quitado de su nodo primario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los nodos creados por este documento, si se han insertado en el documento, se incluyen en este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoving As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoving;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un nodo que pertenece a este documento se va a quitar del documento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento permite al usuario realizar comprobaciones adicionales y, si es necesario, inicie una excepción para detener la operación. Si se produce una excepción el `XmlDocument` vuelve a su estado original.  
  
 Todos los nodos creados por este documento, si se han insertado en el documento, se incluyen en este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del nodo actual.</summary>
        <value>Tipo de nodo. Para los nodos <see langword="XmlDocument" />, este valor es XmlNodeType.Document.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Xml.XmlDocument" /> al que pertenece el nodo actual.</summary>
        <value>Para nodos <see langword="XmlDocument" /> (<see cref="P:System.Xml.XmlDocument.NodeType" /> equivale a XmlNodeType.Document), esta propiedad devuelve siempre <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nodo primario de este nodo, en los nodos que pueden tener nodos primarios.</summary>
        <value>Siempre devuelve <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveWhitespace : bool with get, set" Usage="System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se va a conservar el espacio en blanco del contenido del elemento.</summary>
        <value><see langword="true" /> Para conservar espacio en blanco; en caso contrario <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad determina cómo se controla el espacio en blanco durante la carga de proceso y guardar.  
  
 Si `PreserveWhitespace` es `true` antes de <xref:System.Xml.XmlDocument.Load%2A> o <xref:System.Xml.XmlDocument.LoadXml%2A> es llamado, nodos de espacio en blanco se conserva; de lo contrario, si esta propiedad es `false`, se conserva el espacio en blanco significativo, no es el espacio en blanco.  
  
 Si `PreserveWhitespace` es `true` antes <xref:System.Xml.XmlDocument.Save%2A> es llama, espacio en blanco en el documento se conserva en el resultado; en caso contrario, si esta propiedad es `false`, `XmlDocument` sangría automática la salida.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo quitar un espacio en blanco de un archivo.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `book.xml` como entrada.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadNode (reader As XmlReader) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReadNode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode&#xA;override this.ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode" Usage="xmlDocument.ReadNode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XML de origen.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XmlNode" /> tomando como base la información de <see cref="T:System.Xml.XmlReader" />. El lector debe estar situado en un nodo o en un atributo.</summary>
        <returns>Nuevo <see langword="XmlNode" /> o <see langword="null" /> si no hay más nodos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lee uno `XmlNode` desde el lector especificado y coloca el lector en el nodo siguiente. Este método crea el tipo de `XmlNode` coincidencia la <xref:System.Xml.XmlNode.NodeType%2A> en que está situado actualmente el lector. (Si el lector está en el estado inicial, `ReadNode` desplaza el lector hasta el primer nodo y, a continuación, funciona en ese nodo.)  
  
 Si el lector está situado en el inicio de un elemento `ReadNode` lee todos los atributos y los nodos secundarios, hasta e incluyendo la etiqueta de cierre del nodo actual. El `XmlNode` devuelto contiene el subárbol que representa todo lo leído. El lector está situado inmediatamente después de la etiqueta de cierre.  
  
 `ReadNode` También puede leer atributos, pero en este caso no hace avanzar el lector hasta el siguiente atributo. Esto le permite escribir el código de C# siguiente:  
  
```csharp  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode` utilizar el valor del atributo, lo que significa que después de llamar a `ReadNode` en un atributo, <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa `ReadNode` para crear un nuevo nodo y, a continuación, inserta el nuevo nodo en el documento.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `cd.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">El lector está situado en un tipo de nodo que no se traslada a un nodo DOM válido (por ejemplo, EndElement o EndEntity).</exception>
        <block subset="none" type="overrides"><para>Este método tiene una petición de herencia. Plena confianza es necesaria para reemplazar el <see langword="ReadNode" /> método.  
  
Este método es una extensión de Microsoft a Document Object Model (DOM).</para></block>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Guarda el documento XML en la ubicación especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (outStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::Stream ^ outStream);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.Stream -&gt; unit&#xA;override this.Save : System.IO.Stream -&gt; unit" Usage="xmlDocument.Save outStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">Secuencia en la que se desea guardar.</param>
        <summary>Guarda el documento XML en el flujo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espacio en blanco se conserva únicamente si <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> está establecido en `true`.  
  
 XmlDeclaration del actual `XmlDocument` objeto determina el atributo de codificación en el documento guardado. El valor del atributo de codificación se toma de la <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propiedad. Si el `XmlDocument` does no tiene una declaración XmlDeclaration, o si XmlDeclaration no tiene un atributo de codificación, el documento guardado no tendrá una bien.  
  
 Cuando se guarda el documento, se generan los atributos xmlns para conservar la identidad del nodo (nombre local y URI de espacio de nombres) correctamente. Por ejemplo, el siguiente código de C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 genera este atributo de xmls `<item xmls="urn:1"/>`.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 Tenga en cuenta que solo el <xref:System.Xml.XmlDocument.Save%2A> método impone un documento XML bien formado. Todos los demás `Save` sobrecargas sólo garantizan un fragmento correcto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">La operación no generarái un documento XML bien formado (por ejemplo, ningún documento duplicado o declaraciones XML duplicadas).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.TextWriter -&gt; unit&#xA;override this.Save : System.IO.TextWriter -&gt; unit" Usage="xmlDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see langword="TextWriter" /> en el que se desea guardar.</param>
        <summary>Guarda el documento XML en el <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codificación en la `TextWriter` determina la codificación que se escribe (la codificación del nodo XmlDeclaration se reemplaza por la codificación de la `TextWriter`). Si se ha producido ninguna codificación especificada en el `TextWriter`, el `XmlDocument` se guarda sin un atributo de codificación.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 Tenga en cuenta que solo el <xref:System.Xml.XmlDocument.Save%2A> método impone un documento XML bien formado. Todos los demás `Save` sobrecargas sólo garantizan un fragmento correcto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">La operación no generarái un documento XML bien formado (por ejemplo, ningún documento duplicado o declaraciones XML duplicadas).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Save : string -&gt; unit&#xA;override this.Save : string -&gt; unit" Usage="xmlDocument.Save filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filename">Ubicación del archivo donde se desea guardar el documento.</param>
        <summary>Guarda el documento XML en el archivo especificado. Si existe el archivo especificado, este método lo sobrescribe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espacio en blanco se conserva en la salida de archivo solo si <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> está establecido en `true`.  
  
 XmlDeclaration del actual `XmlDocument` objeto determina el atributo de codificación en el documento guardado. El valor del atributo de codificación se toma de la <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propiedad. Si el `XmlDocument` does no tiene una declaración XmlDeclaration, o si XmlDeclaration no tiene un atributo de codificación, el documento guardado no tendrá una bien.  
  
 Cuando se guarda el documento, se generan los atributos xmlns para conservar la identidad del nodo (nombre local y URI de espacio de nombres) correctamente. Por ejemplo, el siguiente código de C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 genera este atributo de xmls `<item xmls="urn:1"/>`.  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 Tenga en cuenta que solo el <xref:System.Xml.XmlDocument.Save%2A> método impone un documento XML bien formado. Todos los demás `Save` sobrecargas sólo garantizan un fragmento correcto.  
  
   
  
## Examples  
 El ejemplo siguiente carga XML en un objeto XmlDocument, lo modifica y lo guarda en un archivo denominado data.xml.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 El archivo en data.xml contendrá el siguiente código XML: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">La operación no generarái un documento XML bien formado (por ejemplo, ningún documento duplicado o declaraciones XML duplicadas).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Xml.XmlWriter -&gt; unit&#xA;override this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.Save w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w"><see langword="XmlWriter" /> en el que se desea guardar.</param>
        <summary>Guarda el documento XML en el <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espacio en blanco se conserva únicamente si <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> está establecido en `true`.  
  
 La codificación en la `XmlWriter` determina la codificación que se escribe (la codificación del nodo XmlDeclaration se reemplaza por la codificación de la `XmlWriter`). Si se ha producido ninguna codificación especificada en el `XmlWriter`, el `XmlDocument` se guarda sin un atributo de codificación.  
  
 Cuando se guarda el documento, se generan los atributos xmlns para conservar la identidad del nodo (LocalName + NamespaceURI) correctamente. Por ejemplo, el siguiente código de C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 genera este atributo XML:  
  
```xml  
<item  
    xmls="urn:1"/>  
```  
  
 Este método es una extensión de Microsoft a Document Object Model (DOM).  
  
 Tenga en cuenta que solo el <xref:System.Xml.XmlDocument.Save%2A> método impone un documento XML bien formado. Todos los demás `Save` sobrecargas sólo garantizan un fragmento correcto.  
  
   
  
## Examples  
 En el ejemplo siguiente se carga XML en un `XmlDocument` de objeto y lo guarda en un archivo.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">La operación no generarái un documento XML bien formado (por ejemplo, ningún documento duplicado o declaraciones XML duplicadas).</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el conjunto de información posterior a la validación del esquema (PSVI, Post-Schema-Validation-Infoset) del nodo.</summary>
        <value>Objeto <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> que representa el PSVI del nodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El contenido PSVI de esta propiedad se establece después de que se ha validado el nodo.  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Xml.Schema.XmlSchemaSet" /> asociado a este objeto <see cref="T:System.Xml.XmlDocument" />.</summary>
        <value>Objeto <see cref="T:System.Xml.Schema.XmlSchemaSet" /> que contiene los esquemas XSD (lenguaje de definición de esquemas XML) asociado a este <see cref="T:System.Xml.XmlDocument" />; en caso contrario, un objeto <see cref="T:System.Xml.Schema.XmlSchemaSet" /> vacío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los esquemas contenidos en un <xref:System.Xml.Schema.XmlSchemaSet> objeto asociado con un <xref:System.Xml.XmlDocument> objeto se usa para la validación cuando el <xref:System.Xml.XmlDocument.Validate%2A> método de un <xref:System.Xml.XmlDocument> se ejecuta.  
  
 Cuando un <xref:System.Xml.XmlDocument> objeto se inicializa con datos XML desde un <xref:System.Xml.XmlReader> objeto, el <xref:System.Xml.Schema.XmlSchemaSet> objeto se carga desde el <xref:System.Xml.XmlReaderSettings.Schemas%2A> propiedad de la <xref:System.Xml.XmlReader> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valida el objeto <see cref="T:System.Xml.XmlDocument" /> según los esquemas del lenguaje de definición de esquemas XML (XSD) de la propiedad <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="xmlDocument.Validate validationEventHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" /> que recibe información sobre los errores y advertencias de validación de esquemas.</param>
        <summary>Valida el objeto <see cref="T:System.Xml.XmlDocument" /> según los esquemas del lenguaje de definición de esquemas XML (XSD) de la propiedad <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xml.XmlDocument.Validate%2A> método valida los datos XML en el <xref:System.Xml.XmlDocument> según los esquemas en el <xref:System.Xml.XmlDocument.Schemas%2A> propiedad. El <xref:System.Xml.XmlDocument.Validate%2A> método realiza la ampliación de conjunto de información. En concreto, tras la validación, se aplican los valores predeterminados del esquema, los valores de texto se convierten en valores atómicos como sea necesario y se asocia con elementos de información validados información de tipo. El resultado es un anteriormente sin tipo XML subárbol en el <xref:System.Xml.XmlDocument> reemplazado por un subárbol con tipo.  
  
 Los siguientes son notas importantes a tener en cuenta cuando se usa el <xref:System.Xml.XmlDocument.Validate%2A> método.  
  
-   Sugerencias de ubicación de esquema como `xsi:schemaLocation` o `xsi:noNamespaceSchemaLocation` se omiten.  
  
-   Se omiten los esquemas en línea.  
  
-   Si se producen errores de validación de esquema durante la validación del <xref:System.Xml.XmlDocument> se valida parcialmente con algunos nodos con la información del tipo correcto y otros sin ellas.  
  
-   El proceso de validación incluye la comprobación de restricciones de exclusividad y la referencia (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, y `xs:unique`).  
  
   
  
## Examples  
 En el siguiente ejemplo, se muestra el uso del método <xref:System.Xml.XmlDocument.Validate%2A>. El ejemplo se crea un <xref:System.Xml.XmlDocument> que contiene un esquema XSD asociado usando el <xref:System.Xml.XmlReaderSettings> y <xref:System.Xml.XmlReader> objetos. El ejemplo se utiliza la <xref:System.Xml.XPath.XPathNavigator> clase modificar incorrectamente el valor con tipo de un elemento en el documento XML, generar un error de validación de esquema.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 El ejemplo se toma el `contosoBooks.xml` y `contosoBooks.xsd` archivos como entrada.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Se ha producido un evento de validación de esquema y no se ha especificado ningún objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, System::Xml::XmlNode ^ nodeToValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler * System.Xml.XmlNode -&gt; unit" Usage="xmlDocument.Validate (validationEventHandler, nodeToValidate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" /> que recibe información sobre los errores y advertencias de validación de esquemas.</param>
        <param name="nodeToValidate">Objeto <see cref="T:System.Xml.XmlNode" /> creado a partir de un <see cref="T:System.Xml.XmlDocument" /> que se va a validar.</param>
        <summary>Valida el objeto <see cref="T:System.Xml.XmlNode" /> especificado según los esquemas del lenguaje de definición de esquemas XML (XSD) de la propiedad <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xml.XmlDocument.Validate%2A> método valida los datos XML en el <xref:System.Xml.XmlNode> objeto según los esquemas en el <xref:System.Xml.XmlDocument.Schemas%2A> propiedad. El <xref:System.Xml.XmlDocument.Validate%2A> método realiza la ampliación de conjunto de información. En concreto, tras la validación, se aplican los valores predeterminados del esquema, los valores de texto se convierten en valores atómicos como sea necesario y se asocia con elementos de información validados información de tipo. El resultado es un anteriormente sin tipo XML subárbol en el <xref:System.Xml.XmlDocument> reemplazado por un subárbol con tipo.  
  
 Los siguientes son notas importantes a tener en cuenta cuando se usa el <xref:System.Xml.XmlDocument.Validate%2A> método.  
  
-   Sugerencias de ubicación de esquema como `xsi:schemaLocation` o `xsi:noNamespaceSchemaLocation` se omiten.  
  
-   Se omiten los esquemas en línea.  
  
-   Si se producen errores de validación de esquema durante la validación del <xref:System.Xml.XmlDocument> se valida parcialmente con algunos nodos con la información del tipo correcto y otros sin ellas.  
  
 Si el nodo para validar es el nodo raíz, el proceso de validación incluye la comprobación de restricciones de exclusividad y la referencia (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, y `xs:unique`); en caso contrario, referencia y unicidad se omiten las restricciones.  
  
   
  
## Examples  
 Para obtener un ejemplo de la <xref:System.Xml.XmlDocument.Validate%2A> método, consulte el <xref:System.Xml.XmlDocument.Validate%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro de objeto <see cref="T:System.Xml.XmlNode" /> no se creó a partir de un <see cref="T:System.Xml.XmlDocument" />.</exception>
        <exception cref="T:System.InvalidOperationException">El parámetro de objeto <see cref="T:System.Xml.XmlNode" /> no es un elemento, atributo, fragmento de documento ni el nodo raíz.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Se ha producido un evento de validación de esquema y no se ha especificado ningún objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteContentTo (xw As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteContentTo(System::Xml::XmlWriter ^ xw);" />
      <MemberSignature Language="F#" Value="override this.WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteContentTo xw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw"><see langword="XmlWriter" /> en el que se desea guardar.</param>
        <summary>Guarda todos los nodos secundarios del nodo <see langword="XmlDocument" /> en el <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM). Es funcionalmente equivalente a la <xref:System.Xml.XmlDocument.InnerXml%2A> propiedad.  
  
 El <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propiedad determina la codificación que se escribe. Si el `Encoding` propiedad no tiene un valor, el `XmlDocument` se escribe sin un atributo de codificación.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el documento en la pantalla.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w"><see langword="XmlWriter" /> en el que se desea guardar.</param>
        <summary>Guarda el nodo <see langword="XmlDocument" /> en el <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una extensión de Microsoft a Document Object Model (DOM). Es funcionalmente equivalente a la <xref:System.Xml.XmlNode.OuterXml%2A> propiedad.  
  
 El <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propiedad determina la codificación que se escribe. Si el `Encoding` propiedad no tiene un valor, el `XmlDocument` se escribe sin un atributo de codificación.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el documento en la pantalla.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el objeto <see cref="T:System.Xml.XmlResolver" /> para usarlo en la resolución de recursos externos.</summary>
        <value>Objeto <see langword="XmlResolver" /> que se va a usar.  
  
En la versión 1.1 de .NET Framework, el llamador debe ser de confianza para especificar un <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `XmlResolver` puede usarse para cargar la DTD o expandir referencias de entidad. Mediante el <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> propiedad, puede establecer las credenciales en el `XmlResolver` para acceder a los recursos almacenados en un recurso de red segura.  
  
-   Si el documento no se cargó mediante una <xref:System.Xml.XmlReader> (es decir, si se cargó mediante una secuencia, archivo y así sucesivamente) el `XmlResolver` en el `XmlDocument` siempre se utiliza.  
  
-   Si se ha cargado el documento con un <xref:System.Xml.XmlTextReader>, la resolución en el `XmlTextReader` se utiliza para resolver las referencias a DTD en el nodo DocumentType. La resolución en el `XmlDocument` se utiliza para expandir las referencias de entidad.  
  
-   Si se ha cargado el documento con un <xref:System.Xml.XmlValidatingReader>, la resolución en el `XmlDocument` nunca se utiliza.  
  
-   Si se ha cargado el documento con una clase que extiende `XmlReader` y `XmlReader` no puede resolver entidades (<xref:System.Xml.XmlReader.CanResolveEntity%2A> devuelve `false`), el `XmlResolver` en el `XmlDocument` se utiliza para resolver las referencias en el nodo DocumentType y para expandir las referencias de entidad.  
  
> [!NOTE]
>  Si el `XmlDocument` se carga mediante un <xref:System.Xml.XmlReader> que tenía un `XmlResolver` establecida en ella, el `XmlResolver` en el `XmlReader` no almacena en caché el `XmlDocument` después <xref:System.Xml.XmlDocument.Load%2A> se complete.  
  
 En la versión 1.1 de.NET Framework, si no se establece esta propiedad, el nivel de confianza de la aplicación determina el comportamiento predeterminado.  
  
 `Fully trusted code:` El documento utiliza el valor predeterminado es <xref:System.Xml.XmlUrlResolver> sin credenciales de usuario. Si se requiere autenticación para acceder a un recurso de red, use la `XmlResolver` propiedad para especificar un `XmlResolver` con las credenciales necesarias.  
  
 `Semi-trusted code:` La propiedad `XmlResolver` se establece en `null`. No se puede resolver recursos externos.  
  
 Para obtener más información sobre la seguridad y la `XmlResolver` propiedad, vea [resolver recursos externos](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Esta propiedad es una extensión de Microsoft para Document Object Model (DOM).  
  
   
  
## Examples  
 El ejemplo siguiente carga un documento XML que incluye una referencia a un archivo DTD. El `XmlResolver` propiedad se utiliza para establecer las credenciales necesarias para tener acceso al recurso de red.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 El ejemplo utiliza los siguientes archivos de datos como entrada.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Esta propiedad se establece en <see langword="null" /> y se encuentra una DTD o entidad externa.</exception>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
      </Docs>
    </Member>
  </Members>
</Type>