<Type Name="XmlTextReader" FullName="System.Xml.XmlTextReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4b871a9f778531e939fd55d2e78ef52d0277f3eb" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58457775" /></Metadata><TypeSignature Language="C#" Value="public class XmlTextReader : System.Xml.XmlReader, System.Xml.IXmlLineInfo, System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlTextReader extends System.Xml.XmlReader implements class System.Xml.IXmlLineInfo, class System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlTextReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlTextReader&#xA;Inherits XmlReader&#xA;Implements IXmlLineInfo, IXmlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlTextReader : System::Xml::XmlReader, System::Xml::IXmlLineInfo, System::Xml::IXmlNamespaceResolver" />
  <TypeSignature Language="F#" Value="type XmlTextReader = class&#xA;    inherit XmlReader&#xA;    interface IXmlLineInfo&#xA;    interface IXmlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlReader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlLineInfo</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.IXmlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un lector que proporciona acceso rápido a datos XML, sin almacenamiento en caché y con desplazamiento solo hacia delante.  
  
A partir de .NET Framework 2.0, se recomienda usar la clase <see cref="T:System.Xml.XmlReader" /> en su lugar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 <xref:System.Xml.XmlTextReader> proporciona acceso de solo avance y solo lectura a un flujo de datos XML. El nodo actual hace referencia al nodo en el que está situado el sistema de lectura. El lector se adelanta mediante cualquiera de los métodos de lectura y las propiedades reflejan el valor del nodo actual.  
  
 Esta clase implementa <xref:System.Xml.XmlReader> y se ajusta a los espacios de nombres en recomendaciones XML y Extensible Markup Language (XML) 1.0 del W3C. `XmlTextReader` proporciona la funcionalidad siguiente:  
  
-   Aplica las reglas de XML con formato correcto.  
  
-   `XmlTextReader` no proporciona validación de datos.  
  
-   Comprueba que `DocumentType` nodos tienen el formato correctos. `XmlTextReader` comprueba si la DTD sea correcto, pero no valida utilizando la DTD.  
  
-   Para los nodos donde <xref:System.Xml.XmlTextReader.NodeType%2A> es `XmlNodeType.EntityReference`, una sola vacía `EntityReference` se devuelve el nodo (es decir, el <xref:System.Xml.XmlTextReader.Value%2A> propiedad es `String.Empty`).  
  
> [!NOTE]
>  Las declaraciones de entidades en la DTD reales se denominan `Entity` nodos. Cuando se hace referencia a estos nodos en los datos, se denominan `EntityReference` nodos.  
  
-   No se expande los atributos predeterminados.  
  
 Dado que el `XmlTextReader` no lleva a cabo las comprobaciones adicionales necesarias para la validación de datos, proporciona un analizador rápido correcto.  
  
 Para realizar la validación de datos, use una validación <xref:System.Xml.XmlReader>.  
  
 Para leer datos XML desde un <xref:System.Xml.XmlDocument>, utilice <xref:System.Xml.XmlNodeReader>.  
  
 `XmlTextReader` se produce un <xref:System.Xml.XmlException> errores de análisis de XML. Una vez que se produce una excepción, el estado del lector no es predecible. Por ejemplo, el tipo de nodo notificado puede ser diferente que el tipo de nodo real del nodo actual. Use el <xref:System.Xml.XmlTextReader.ReadState%2A> propiedad para comprobar si un lector está en estado de error.  
  
## <a name="security-considerations"></a>Consideraciones de seguridad  
 Los siguientes son las cosas a tener en cuenta cuando se usa el <xref:System.Xml.XmlTextReader> clase.  
  
-   Las excepciones que produce el <xref:System.Xml.XmlTextReader> pueden revelar información de ruta de acceso que no desea que se ejecuta hasta la aplicación. Las aplicaciones deben detectar las excepciones y procesarlas de la manera correspondiente.  
  
-   El procesamiento de DTD está habilitado de manera predeterminada. Deshabilitar el procesamiento de DTD si le preocupan los problemas de denegación de servicio o si trabaja con orígenes de confianza. Establecer el <xref:System.Xml.XmlTextReader.DtdProcessing%2A> propiedad <xref:System.Xml.DtdProcessing.Prohibit> para deshabilitar el procesamiento de DTD.  
  
     Si tiene habilitado el procesamiento de DTD, puede utilizar <xref:System.Xml.XmlSecureResolver> para restringir los recursos a los que tiene acceso <xref:System.Xml.XmlTextReader>. También puede diseñar su aplicación para que el procesamiento XML se realice con restricciones de memoria y tiempo. Por ejemplo, puede configurar límites de tiempo de espera en la aplicación ASP.NET.  
  
-   Datos XML pueden incluir referencias a recursos externos, como un archivo DTD. De manera predeterminada, los recursos externos se resuelven utilizando un objeto <xref:System.Xml.XmlUrlResolver> sin credenciales de usuario. Puede aumentar la protección aún más realizando cualquiera de las siguientes acciones:  
  
    -   Restrinja los recursos a los que puede tener acceso <xref:System.Xml.XmlTextReader> estableciendo la propiedad <xref:System.Xml.XmlTextReader.XmlResolver%2A> en un objeto <xref:System.Xml.XmlSecureResolver>.  
  
    -   No permita que <xref:System.Xml.XmlReader> abra ningún recurso externo estableciendo la propiedad <xref:System.Xml.XmlTextReader.XmlResolver%2A> en `null`.  
  
-   Los datos XML pueden contener un gran número de atributos, declaraciones de espacios de nombres, elementos anidados, etc. cuyo procesamiento tarda una cantidad de tiempo importante. Para limitar el tamaño de la entrada que se envía a la <xref:System.Xml.XmlTextReader>, cree una implementación personalizada de IStream y proporciónele el <xref:System.Xml.XmlTextReader>.  
  
-   El <xref:System.Xml.XmlReader.ReadValueChunk%2A> método puede utilizarse para controlar grandes flujos de datos. Este método lee una pequeña cantidad de caracteres a la vez en lugar de asignar una única cadena para todo el valor.  
  
-   De manera predeterminada, las entidades generales no se expanden. Lo hacen cuando se llama al método <xref:System.Xml.XmlTextReader.ResolveEntity%2A>.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Esta clase tiene una petición de herencia. Se requiere plena confianza para heredar de <see langword="XmlTextReader" />.</para></block>
    <related type="Article" href="~/docs/standard/data/xml/index.md">Documentos y datos XML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Xml.XmlTextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de <see langword="XmlTextReader" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Flujo que contiene los datos XML que se van a leer.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el flujo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El <xref:System.Xml.XmlTextReader> descodifica el flujo mediante <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.TextReader -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input"><see langword="TextReader" /> que contiene los datos XML que se van a leer.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el objeto <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Se supone que `TextReader` ya está establecido en la codificación correcta. Esto sirve para los clientes que ya se han leído algunos aspectos de la secuencia en un escenario MIME de varias partes.  
  
   
  
## Examples  
 En el ejemplo siguiente se carga una cadena XML en el `XmlTextReader` objeto utilizando el <xref:System.IO.StringReader> clase.  
  
 [!code-cpp[XmlTextReader.cctor1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.cctor1/CPP/rdrcctor1.cpp#1)]
 [!code-csharp[XmlTextReader.cctor1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.cctor1/CS/rdrcctor1.cs#1)]
 [!code-vb[XmlTextReader.cctor1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.cctor1/VB/rdrcctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader url" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">URL del archivo que contiene los datos XML. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> se establece en este valor.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Si el archivo se encuentra en un recurso que requiere credenciales de acceso, use el <xref:System.Xml.XmlTextReader.XmlResolver%2A> propiedad para especificar las credenciales necesarias.  
  
> [!NOTE]
>  En la versión 1.1 de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], no se puede establecer el código de confianza parcial el `XmlResolver` propiedad. La solución consiste en crear un <xref:System.Xml.XmlUrlResolver> con las credenciales necesarias, pasar el identificador URI para el <xref:System.Xml.XmlUrlResolver.GetEntity%2A?displayProperty=nameWithType> método y, a continuación, construir la `XmlTextReader` mediante resultante <xref:System.IO.Stream> objeto. La solución se describe en el siguiente código de C#.  
  
```csharp  
// Create a resolver with the necessary credentials.  
XmlUrlResolver resolver = new XmlUrlResolver();  
NetworkCredential nc = new NetworkCredential(SecurelyStoredUserName, SecurelyStoredPassword, SecurelyStoredDomain);  
resolver.Credentials = nc;   
// Get a Stream object containing the XML file.  
Uri myUri = new Uri ("http://myServer/data/books.xml");  
Stream s=(Stream)resolver.GetEntity(myUri, null, typeof(Stream));  
// Construct a reader using the Stream object.  
XmlTextReader reader = new XmlTextReader(s);  
```  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `items.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo especificado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se puede encontrar parte del nombre de archivo o del directorio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="url" /> es una cadena vacía.</exception>
        <exception cref="T:System.Net.WebException">No se puede resolver el nombre de archivo remoto.  
  
O bien 
Error al procesar la solicitud.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="url" /> no es un URI válido.</exception>
        <altmember cref="P:System.Xml.XmlTextReader.XmlResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el objeto <see cref="T:System.Xml.XmlNameTable" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">Flujo que contiene los datos XML que se van a leer.</param>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el flujo especificado y <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El <xref:System.Xml.XmlTextReader> descodifica el flujo mediante <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 Si especifica una tabla de nombres, este constructor utiliza los nombres ya definidos en esa tabla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">El valor de <paramref name="input" /> o <paramref name="nt" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.TextReader * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input"><see langword="TextReader" /> que contiene los datos XML que se van a leer.</param>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con los parámetros <see cref="T:System.IO.TextReader" /> y <see cref="T:System.Xml.XmlNameTable" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Se supone que `TextReader` ya está establecido en la codificación correcta. Esto sirve para los clientes que ya se han leído algunos aspectos de la secuencia en un escenario MIME de varias partes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">El valor <paramref name="nt" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.Stream -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="url">Dirección URL que se va a usar para resolver los recursos externos. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> se establece en este valor.</param>
        <param name="input">Flujo que contiene los datos XML que se van a leer.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con la dirección URL y el flujo especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.TextReader -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="url">Dirección URL que se va a usar para resolver los recursos externos. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> se establece en este valor.</param>
        <param name="input"><see langword="TextReader" /> que contiene los datos XML que se van a leer.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con la dirección URL y el <see cref="T:System.IO.TextReader" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Se supone que `TextReader` ya está establecido en la codificación correcta. Esto sirve para los clientes que ya se han leído algunos aspectos de la secuencia en un escenario MIME de varias partes.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Dirección URL del archivo que contiene los datos XML que se van a leer.</param>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el archivo y el objeto <see cref="T:System.Xml.XmlNameTable" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">El valor <paramref name="nt" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo especificado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se puede encontrar parte del nombre de archivo o del directorio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="url" /> es una cadena vacía.</exception>
        <exception cref="T:System.Net.WebException">No se puede resolver el nombre de archivo remoto.  
  
O bien 
Error al procesar la solicitud.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="url" /> no es un URI válido.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As Stream, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream * System.Xml.XmlNodeType * System.Xml.XmlParserContext -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (xmlFragment, fragType, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.IO.Stream" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Flujo que contiene el fragmento de XML que se va a analizar.</param>
        <param name="fragType"><see cref="T:System.Xml.XmlNodeType" /> del fragmento de XML. Esto también determina lo que puede contener el fragmento. Vea la tabla que figura a continuación.</param>
        <param name="context"><see cref="T:System.Xml.XmlParserContext" /> donde se va a analizar <paramref name="xmlFragment" />. Esto incluye el objeto <see cref="T:System.Xml.XmlNameTable" /> que se va a usar, la codificación, el ámbito de espacio de nombres, el <c>xml:lang</c> actual y el ámbito de <c>xml:space</c>.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con el flujo especificado, <see cref="T:System.Xml.XmlNodeType" /> y <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este constructor analiza la cadena especificada como un fragmento de XML. Si el fragmento XML es un elemento o atributo, puede omitir las reglas del nivel raíz para documentos XML correctos.  
  
 La tabla siguiente enumeran los valores válidos para `fragType`.  
  
|Tipo XmlNode|Fragmento puede contener|  
|-----------------|--------------------------|  
|`Element`|Cualquier contenido de elemento válido (por ejemplo, cualquier combinación de elementos, comentarios, instrucciones de procesamiento, secciones CDATA, texto y las referencias de entidad).<br /><br /> También se puede suministrar una declaración XML. Esto le permite especificar la codificación para el fragmento XML, en lugar de tener que establecer esta propiedad en el <xref:System.Xml.XmlParserContext> objeto.|  
|`Attribute`|El valor de un atributo (la parte dentro de las comillas).|  
|`Document`|Contenido de un documento XML completo. Esto impone las reglas de nivel de documento.|  
  
 El lector usa lo siguiente para determinar la codificación de la secuencia.  
  
1.  Comprueba la <xref:System.Xml.XmlParserContext.Encoding%2A?displayProperty=nameWithType> propiedad para determinar la codificación.  
  
2.  Si el `Encoding` propiedad es `null`, el lector comprueba si hay una marca de orden de bytes al principio de la secuencia.  
  
3.  Si el `Encoding` propiedad es `null`y no se encuentra ninguna marca de orden de bytes, el lector se da por supuesto que la secuencia está codificada en UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><paramref name="fragType" /> no es Element, Attribute ni Document <see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlFragment" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.Stream * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Dirección URL que se va a usar para resolver los recursos externos. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> se establece en este valor. Si el valor de <paramref name="url" /> es <see langword="null" />, el valor de <see langword="BaseURI" /> se establece en <see langword="String.Empty" />.</param>
        <param name="input">Flujo que contiene los datos XML que se van a leer.</param>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con la dirección URL, el flujo y la <see cref="T:System.Xml.XmlNameTable" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">El valor de <paramref name="input" /> o <paramref name="nt" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.TextReader * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">Dirección URL que se va a usar para resolver los recursos externos. <see cref="P:System.Xml.XmlTextReader.BaseURI" /> se establece en este valor. Si el valor de <paramref name="url" /> es <see langword="null" />, el valor de <see langword="BaseURI" /> se establece en <see langword="String.Empty" />.</param>
        <param name="input"><see langword="TextReader" /> que contiene los datos XML que se van a leer.</param>
        <param name="nt">Objeto <see langword="XmlNameTable" /> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con la dirección URL y los objetos <see cref="T:System.IO.TextReader" /> y <see cref="T:System.Xml.XmlNameTable" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Se supone que `TextReader` ya está establecido en la codificación correcta. Esto sirve para los clientes que ya se han leído algunos aspectos de la secuencia en un escenario MIME de varias partes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="nt" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As String, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.Xml.XmlNodeType * System.Xml.XmlParserContext -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (xmlFragment, fragType, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.String" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Cadena que contiene el fragmento de XML que se va a analizar.</param>
        <param name="fragType"><see cref="T:System.Xml.XmlNodeType" /> del fragmento de XML. Esto también determina lo que puede contener la cadena del fragmento. Vea la tabla que figura a continuación.</param>
        <param name="context"><see cref="T:System.Xml.XmlParserContext" /> donde se va a analizar <paramref name="xmlFragment" />. Esto incluye el objeto <see cref="T:System.Xml.XmlNameTable" /> que se va a usar, la codificación, el ámbito de espacio de nombres, el <c>xml:lang</c> actual y el ámbito de <c>xml:space</c>.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.XmlTextReader" /> con la cadena y los objetos <see cref="T:System.Xml.XmlNodeType" /> y <see cref="T:System.Xml.XmlParserContext" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este constructor analiza la cadena especificada como un fragmento de XML. Si el fragmento XML es un elemento o atributo, puede omitir las reglas del nivel raíz para documentos XML correctos. Este constructor puede controlar las cadenas devueltas de <xref:System.Xml.XmlReader.ReadInnerXml%2A>.  
  
 La tabla siguiente enumeran los valores válidos para `fragType` y el modo en que el lector analiza cada uno de los tipos de nodo.  
  
|Tipo XmlNode|Fragmento puede contener|  
|-----------------|--------------------------|  
|Elemento|Cualquier contenido de elemento válido (por ejemplo, cualquier combinación de elementos, comentarios, instrucciones de procesamiento, secciones CDATA, texto y las referencias de entidad).<br /><br /> También se puede suministrar una declaración XML. Esto le permite especificar la codificación para el fragmento XML, en lugar de tener que establecer esta propiedad en el <xref:System.Xml.XmlParserContext> objeto.|  
|Atributo|El valor de un atributo (la parte dentro de las comillas).|  
|Documento|Contenido de un documento XML completo. Esto impone las reglas de nivel de documento.|  
  
   
  
## Examples  
 El ejemplo siguiente analiza un fragmento XML. Usa el `XmlParserContext` y su <xref:System.Xml.XmlNamespaceManager> para controlar la resolución de espacio de nombres.  
  
 [!code-cpp[XmlTextReader.Cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Cctor/CPP/readfrag.cpp#1)]
 [!code-csharp[XmlTextReader.Cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Cctor/CS/readfrag.cs#1)]
 [!code-vb[XmlTextReader.Cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Cctor/VB/readfrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><paramref name="fragType" /> no es <see langword="Element" />, <see langword="Attribute" /> o <see langword="Document" /><see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlFragment" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlParserContext" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public override int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlTextReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de atributos del nodo actual.</summary>
        <value>Número de atributos del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad es relevante para `Element`, `DocumentType` y `XmlDeclaration` sólo los nodos. (Otros tipos de nodos no tienen atributos).  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlTextReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI base del nodo actual.</summary>
        <value>Identificador URI base del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Un documento XML en red se compone de fragmentos de datos agregados mediante varios mecanismos de inclusión estándar de W3C y, por tanto, contiene nodos que proceden de distintos lugares. Las entidades DTD son un ejemplo de esto, pero esto no se limita a las DTD. La base de URI explica procedencia de estos nodos. Si no hay ningún URI base para los nodos que se devuelven (por ejemplo, han analizado desde una cadena en memoria), `String.Empty` se devuelve.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el identificador URI base para cada uno de los nodos.  
  
 [!code-cpp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `baseuri.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.BaseURI Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public override bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xml.XmlTextReader" /> implementa los métodos de lectura de contenido binario.</summary>
        <value>Es <see langword="true" /> si se implementan los métodos de lectura de contenido binario; en caso contrario, es <see langword="false" />. La clase <see cref="T:System.Xml.XmlTextReader" /> siempre devuelve <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Lectura de contenido binario métodos incluyen la <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlTextReader.ReadElementContentAsBase64%2A>, y <xref:System.Xml.XmlTextReader.ReadElementContentAsBinHex%2A> métodos.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public override bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xml.XmlTextReader" /> implementa el método <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Xml.XmlTextReader" /> implementa el método <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />; en caso contrario, es <see langword="false" />. La clase <see cref="T:System.Xml.XmlTextReader" /> siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El <xref:System.Xml.XmlTextReader> produce una <xref:System.NotSupportedException> si el <xref:System.Xml.XmlReader.ReadValueChunk%2A> se llama al método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public override bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este lector puede analizar y resolver entidades.</summary>
        <value>Es <see langword="true" /> si el lector puede analizar y resolver entidades; en caso contrario, es <see langword="false" />. La clase <see langword="XmlTextReader" /> siempre devuelve <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Se trata de un cambio en el [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] de versión. En versiones anteriores, el `XmlTextReader` clase no pudo resolver entidades y `CanResolveEntity` siempre devuelven `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="xmlTextReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cambia la propiedad <see cref="P:System.Xml.XmlReader.ReadState" /> a <see langword="Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método también libera los recursos utilizados durante la lectura. Si este lector se construyó mediante una secuencia, este método también llama a `Close` en la secuencia subyacente.  
  
 Si `Close` ya ha sido no llamado, se realiza ninguna acción.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlTextReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la profundidad del nodo actual en el documento XML.</summary>
        <value>Profundidad del nodo actual en el documento XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cada nodo con su profundidad, número de línea y posición de línea.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberSignature Language="F#" Value="member this.DtdProcessing : System.Xml.DtdProcessing with get, set" Usage="System.Xml.XmlTextReader.DtdProcessing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la enumeración <see cref="T:System.Xml.DtdProcessing" />.</summary>
        <value>Enumeración <see cref="T:System.Xml.DtdProcessing" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xml.DtdProcessing> enumeración contiene la <xref:System.Xml.DtdProcessing.Prohibit>, <xref:System.Xml.DtdProcessing.Ignore>, y <xref:System.Xml.DtdProcessing.Parse> enumeradores. <xref:System.Xml.DtdProcessing.Parse> es el comportamiento predeterminado. El <xref:System.Xml.XmlTextReader.DtdProcessing%2A> propiedad reemplaza la `ProhibitDTD` propiedad y agrega la capacidad de omitir el elemento DOCTYPE.  
  
> [!IMPORTANT]
>  Si el <xref:System.Xml.XmlTextReader.DtdProcessing%2A> propiedad está establecida en <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>, el <xref:System.Xml.XmlTextReader> no notificará las DTD. Esto significa que la DTD/DOCTYPE se perderá en la salida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding" Usage="System.Xml.XmlTextReader.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la codificación del documento.</summary>
        <value>Valor de codificación. Si no existe ningún atributo de codificación y no hay ninguna marca de orden de bytes, se usa el valor predeterminado UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Dado que <xref:System.Xml.XmlTextReader> usa el <xref:System.Text.Encoding?displayProperty=nameWithType> (clase), `XmlTextReader` también es compatible con todas las codificaciones admitidas por esa clase. La excepción a esto es la codificación, como UTF-7 o EBCDIC, que se asigna el `<?xml` secuencia de valores de byte diferentes a UTF-8.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityHandling">
      <MemberSignature Language="C#" Value="public System.Xml.EntityHandling EntityHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.EntityHandling EntityHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EntityHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityHandling As EntityHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::EntityHandling EntityHandling { System::Xml::EntityHandling get(); void set(System::Xml::EntityHandling value); };" />
      <MemberSignature Language="F#" Value="member this.EntityHandling : System.Xml.EntityHandling with get, set" Usage="System.Xml.XmlTextReader.EntityHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.EntityHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica cómo controla el lector las entidades.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.EntityHandling" />. Si no se especifica ningún valor para <see langword="EntityHandling" />, el valor predeterminado es <see langword="EntityHandling.ExpandCharEntities" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad se puede cambiar sobre la marcha y surte efecto después de la siguiente <xref:System.Xml.XmlTextReader.Read%2A> llamar.  
  
 Cuando `EntityHandling` está establecido en `ExpandCharEntities`, solo parcialmente se normalizan los valores de atributo. El lector normaliza cada nodo de texto individuales independientemente del contenido de los nodos de referencia de entidad adyacentes.  
  
 Para ilustrar la diferencia entre la entidad de los modos de control, tenga en cuenta el siguiente código XML:  
  
```  
<!DOCTYPE doc [<!ENTITY num "123">]>  
    <doc> &#65; &num; </doc>  
```  
  
 Cuando `EntityHandling` está establecido en `ExpandEntities` el nodo del elemento "doc" contiene un nodo de texto con el texto de la entidad expandida:  
  
|Profundidad|Tipo de nodo|nombre|Valor|  
|-----------|---------------|----------|-----------|  
|1|`Text`||A 123|  
  
 Cuando `EntityHandling` está establecido en `ExpandCharEntites`, y <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A> está establecido en `Significant` o `All`, el elemento "doc" expande la entidad de carácter y devuelve la entidad general como un nodo:  
  
|Profundidad|Tipo de nodo|nombre|Valor|  
|-----------|---------------|----------|-----------|  
|1|`Text`||A|  
|1|`EntityReference`|num||  
|1|`SignificantWhitespace`|||  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public override bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlTextReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el lector está situado al final del flujo.</summary>
        <value>Es <see langword="true" /> si el lector está situado al final del flujo; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el valor de un atributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : int -&gt; string" Usage="xmlTextReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Índice del atributo. El índice está basado en cero. El primer atributo tiene índice 0.</param>
        <summary>Obtiene el valor del atributo con el índice especificado.</summary>
        <returns>Valor del atributo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método no desplaza el lector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="i" /> es menor que cero o mayor o igual que <see cref="P:System.Xml.XmlTextReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : string -&gt; string" Usage="xmlTextReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del atributo.</param>
        <summary>Obtiene el valor del atributo con el nombre especificado.</summary>
        <returns>Valor del atributo especificado. Si no se encuentra el atributo, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método no desplaza el lector.  
  
 Si el lector está situado en un `DocumentType` nodo, este método puede usarse para obtener los literales PUBLIC y SYSTEM, por ejemplo, `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 El ejemplo siguiente obtiene el valor del atributo ISBN.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `attrs.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.GetAttribute1 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : string * string -&gt; string" Usage="xmlTextReader.GetAttribute (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del atributo.</param>
        <param name="namespaceURI">URI de espacio de nombres del atributo.</param>
        <summary>Obtiene el valor del atributo con el nombre local y el identificador URI de espacio de nombres que se hayan especificado.</summary>
        <returns>Valor del atributo especificado. Si no se encuentra el atributo, se devuelve <see langword="null" />. Este método no desplaza el lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El siguiente código XML contiene un atributo en un espacio de nombres específico:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Para buscar el `dt:type` atributo mediante un argumento (prefijo y nombre local) o dos argumentos (nombre local y URI de espacio de nombres):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Para buscar el `xmlns:dt` atributo, utilice uno de los argumentos siguientes:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 También puede obtener esta información mediante el <xref:System.Xml.XmlTextReader.Prefix%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetNamespacesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GetNamespacesInScope(System::Xml::XmlNamespaceScope scope);" />
      <MemberSignature Language="F#" Value="member this.GetNamespacesInScope : System.Xml.XmlNamespaceScope -&gt; System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="xmlTextReader.GetNamespacesInScope scope" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="scope">Valor <see cref="T:System.Xml.XmlNamespaceScope" /> que especifica el tipo de nodos de espacio de nombres que se va a devolver.</param>
        <summary>Obtiene una colección que contiene todos los espacios de nombres que hay actualmente en el ámbito.</summary>
        <returns>Objeto <see cref="T:System.Collections.IDictionary" /> que contiene todos los espacios de nombres que hay actualmente en el ámbito. Si el lector no se coloca en un elemento, se devuelve un diccionario vacío (sin ningún espacio de nombres).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El diccionario consta de una colección de espacios de nombres con clave de prefijo. Puede usar para enumerar los espacios de nombres en el ámbito. El diccionario es una copia desconectada de la lista de espacio de nombres del lector. Permanece sin cambios como la posición del lector, lista de espacio de nombres en el ámbito actual, los cambios.  
  
 La tabla siguiente describe cómo el <xref:System.Xml.XmlNamespaceScope> afecta al valor de enumeración si o no los espacios de nombres predeterminados e integrados son devueltos por <xref:System.Xml.XmlTextReader.GetNamespacesInScope%2A>.  
  
|Valor de XmlNamespaceScope|xmlns:xml|xmlns:xmlns|xmlns=""|  
|-----------------------------|---------------|-----------------|---------------|  
|`All`|sí|No|No|  
|`ExcludeXml`|No|No|No|  
|`Local`|No|No|sí|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetRemainder">
      <MemberSignature Language="C#" Value="public System.IO.TextReader GetRemainder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.TextReader GetRemainder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetRemainder" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRemainder () As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::TextReader ^ GetRemainder();" />
      <MemberSignature Language="F#" Value="member this.GetRemainder : unit -&gt; System.IO.TextReader" Usage="xmlTextReader.GetRemainder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el resto de XML con búfer.</summary>
        <returns><see cref="T:System.IO.TextReader" /> que contiene el resto del código XML almacenado en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Dado que <xref:System.Xml.XmlTextReader> un búfer `Read`, debe ser capaz de devolver el resto del búfer no utilizado para que se pierda ningún dato. Esto permite protocolos (por ejemplo, varias partes MIME) para el paquete XML en la misma secuencia que otras cosas.  
  
 Después de llamar a este método, <xref:System.Xml.XmlTextReader.EOF%2A> está establecido en `true`.  
  
   
  
## Examples  
 El ejemplo siguiente se lee la primera parte de un documento XML y, a continuación, utiliza `GetRemainder` para completar la lectura del documento mediante un segundo lector.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo de entrada `tworeads.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.GetRemainder Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasLineInfo">
      <MemberSignature Language="C#" Value="public bool HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function HasLineInfo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasLineInfo();" />
      <MemberSignature Language="F#" Value="abstract member HasLineInfo : unit -&gt; bool&#xA;override this.HasLineInfo : unit -&gt; bool" Usage="xmlTextReader.HasLineInfo " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si la clase puede devolver información de línea.</summary>
        <returns>Es <see langword="true" /> si la clase puede devolver información de línea; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public override bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlTextReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el nodo actual puede tener una propiedad <see cref="P:System.Xml.XmlTextReader.Value" /> con un valor distinto de <see langword="String.Empty" />.</summary>
        <value>Es <see langword="true" /> si el nodo en el que está situado actualmente el lector puede tener un <see langword="Value" />; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 En la siguiente tabla se recogen los tipos de nodo que tienen un valor para devolver.  
  
|Tipo de nodo|Valor|  
|---------------|-----------|  
|`Attribute`|El valor del atributo.|  
|`CDATA`|Contenido de la sección CDATA.|  
|`Comment`|El contenido del comentario.|  
|`DocumentType`|El subconjunto interno.|  
|`ProcessingInstruction`|El contenido completo, sin incluir el destino.|  
|`SignificantWhitespace`|Espacio en blanco entre marcas en un modelo de contenido mixto.|  
|`Text`|El contenido del nodo de texto.|  
|`Whitespace`|El espacio en blanco entre marcado.|  
|`XmlDeclaration`|El contenido de la declaración.|  
  
   
  
## Examples  
 El ejemplo siguiente muestra el valor para cada nodo que puede tener un valor.  
  
 [!code-cpp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `book1.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.HasValue Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public override bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlTextReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el nodo actual es un atributo que se ha generado a partir del valor predeterminado definido en la DTD o esquema.</summary>
        <value>Esta propiedad devuelve siempre <see langword="false" />. (<see cref="T:System.Xml.XmlTextReader" /> no expande los atributos predeterminados).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad solo se aplica a los nodos de atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public override bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el nodo actual es un elemento vacío (por ejemplo, <c>&lt;MyElement/&gt;</c>).</summary>
        <value><see langword="true" /> Si el nodo actual es un elemento (<see cref="P:System.Xml.XmlTextReader.NodeType" /> es igual a <see langword="XmlNodeType.Element" />) que termina en <c>/ &gt;</c>; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad le permite determinar la diferencia entre lo siguiente:  
  
 `<item num="123"/>` (`IsEmptyElement` es `true`).  
  
 `<item num="123">` (`IsEmptyElement` es `false`, aunque el contenido del elemento está vacío).  
  
 Correspondiente `EndElement` nodo no se genera para elementos vacíos.  
  
 `IsEmptyElement` simplemente indica si el elemento del documento de origen tenía una etiqueta de elemento de cierre o no.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el contenido de texto de cada elemento.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `elems.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlTextReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="i">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlTextReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="namespaceURI">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumber { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int" Usage="System.Xml.XmlTextReader.LineNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LineNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de línea actual.</summary>
        <value>Número de línea actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad se usa normalmente para los informes de errores, pero se puede llamar en cualquier momento. El valor inicial de esta propiedad es `1`.  
  
 Combinado con <xref:System.Xml.XmlTextReader.LinePosition%2A>, un valor de `1,1` indica el inicio del documento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cada nodo con su profundidad, número de línea y posición de línea.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LinePosition">
      <MemberSignature Language="C#" Value="public int LinePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePosition" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LinePosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LinePosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LinePosition : int" Usage="System.Xml.XmlTextReader.LinePosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LinePosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la posición de línea actual.</summary>
        <value>Posición de línea actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad se usa normalmente para los informes de errores, pero se puede llamar en cualquier momento. Valor inicial de la propiedad es `1`.  
  
 La posición indicada es el primer carácter del texto en el marcado.  
  
```  
<root>  
abc<tag/>  
</root>  
```  
  
 En la primera línea del texto XML anterior, un `LinePosition` de `2` correspondiente al carácter `r`; en la segunda línea, un `LinePosition` de `5` correspondiente al carácter `t`; y en la tercera línea, un `LinePosition` de `3` correspondiente al carácter `r`.  
  
 Combinado con <xref:System.Xml.XmlTextReader.LineNumber%2A>, un valor de `1,1` indica el inicio del documento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cada nodo con su profundidad, número de línea y posición de línea.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlTextReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre local del nodo actual.</summary>
        <value>Nombre del nodo actual sin prefijo. Por ejemplo, <see langword="LocalName" /> es <see langword="book" /> para el elemento <c>&lt;bk: book&gt;</c>.  
  
Para los tipos de nodo sin nombre (por ejemplo, <see langword="Text" />, <see langword="Comment" />, etc.), esta propiedad devuelve <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre local de cada nodo, y, si existen, el prefijo y URI de espacio de nombres.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `book2.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public override string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="override this.LookupNamespace : string -&gt; string" Usage="xmlTextReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo cuyo identificador URI de espacio de nombres se desea resolver. Para hacer coincidir el espacio de nombres predeterminado, pase una cadena vacía. Esta cadena no necesita subdividirse.</param>
        <summary>Resuelve un prefijo de espacio de nombres en el ámbito del elemento actual.</summary>
        <returns>Identificador URI de espacio de nombres al que se asigna el prefijo o <see langword="null" /> si no se encuentra ningún prefijo coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 En el siguiente XML, si el lector está situado en la `href` atributo, el prefijo `a` se resuelve mediante una llamada a `reader.LookupNamespace("a")`. La cadena devuelta es `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
 <item>  
 <ref href="a:b"/>  
 </item>  
</root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.Xml.XmlTextReader.Namespaces" /> se establece en <see langword="true" /> y el valor de <paramref name="prefix" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se mueve al atributo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : int -&gt; unit" Usage="xmlTextReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Índice del atributo.</param>
        <summary>Se desplaza hasta el atributo con el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="i" /> es menor que cero o mayor o igual que <see cref="P:System.Xml.XmlReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : string -&gt; bool" Usage="xmlTextReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre completo del atributo.</param>
        <summary>Se desplaza hasta el atributo con el nombre especificado.</summary>
        <returns>Es <see langword="true" /> si se encuentra el atributo; en caso contrario, es <see langword="false" />. Si es <see langword="false" />, no cambia la posición del lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Después de llamar a `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, y <xref:System.Xml.XmlTextReader.Prefix%2A> propiedades refleja las propiedades de ese atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : string * string -&gt; bool" Usage="xmlTextReader.MoveToAttribute (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nombre local del atributo.</param>
        <param name="namespaceURI">URI de espacio de nombres del atributo.</param>
        <summary>Se desplaza hasta el atributo con el nombre local y el URI de espacio de nombres que se hayan especificado.</summary>
        <returns>Es <see langword="true" /> si se encuentra el atributo; en caso contrario, es <see langword="false" />. Si es <see langword="false" />, no cambia la posición del lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Después de llamar a `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, y <xref:System.Xml.XmlTextReader.Prefix%2A> propiedades refleja las propiedades de ese atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public override bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToElement();" />
      <MemberSignature Language="F#" Value="override this.MoveToElement : unit -&gt; bool" Usage="xmlTextReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se desplaza hasta el elemento que contiene el nodo de atributo actual.</summary>
        <returns>Es <see langword="true" /> si el lector está situado en un atributo (el lector se desplaza hasta el elemento que posee el atributo); es <see langword="false" /> si el lector no está situado en un atributo (no cambia la posición del lector).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Utilice este método para devolver a un elemento después de navegar a través de sus atributos. Este método mueve el lector a uno de los siguientes tipos de nodo: `Element`, `DocumentType`, o `XmlDeclaration`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="override this.MoveToFirstAttribute : unit -&gt; bool" Usage="xmlTextReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se mueve al primer atributo.</summary>
        <returns>Es <see langword="true" /> si existe un atributo (el lector se desplaza hasta el primer atributo); en caso contrario, es <see langword="false" /> (no cambia la posición del lector).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene el valor del primer atributo del nodo raíz.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `attrs.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.MoveToFirstAttribute Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="override this.MoveToNextAttribute : unit -&gt; bool" Usage="xmlTextReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se mueve al siguiente atributo.</summary>
        <returns>Es <see langword="true" /> si hay siguiente atributo; es <see langword="false" /> si no hay más atributos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Si el nodo actual es un nodo de elemento, este método es equivalente a <xref:System.Xml.XmlTextReader.MoveToFirstAttribute%2A>. Si `MoveToNextAttribute` devuelve `true`, el lector se desplaza hasta el siguiente atributo; en caso contrario, no cambia la posición del lector.  
  
   
  
## Examples  
 El ejemplo siguiente muestra todos los atributos en el nodo actual.  
  
 [!code-cpp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlTextReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre completo del nodo actual.</summary>
        <value>Nombre completo del nodo actual. Por ejemplo, <see langword="Name" /> es <see langword="bk:book" /> para el elemento <c>&lt;bk: book&gt;</c>.  
  
El nombre devuelto depende de la propiedad <see cref="P:System.Xml.XmlTextReader.NodeType" /> del nodo:  Los siguientes tipos de nodo devuelven los valores que figuran en la lista. Todos los demás tipos de nodo devuelven una cadena vacía.  
  
 <list type="table"><listheader><term> Tipo de nodo 
 </term><description> nombre 
 </description></listheader><item><term><see langword="Attribute" /></term><description> El nombre del atributo.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Nombre del tipo de documento.  
  
 </description></item><item><term><see langword="Element" /></term><description> Nombre de la etiqueta.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Nombre de la entidad a la que se hace referencia.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Destino de la instrucción de procesamiento.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Cadena literal <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Namespaces">
      <MemberSignature Language="C#" Value="public bool Namespaces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Namespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Namespaces" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Namespaces { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Namespaces : bool with get, set" Usage="System.Xml.XmlTextReader.Namespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se ha de aplicar la compatibilidad de espacio de nombres.</summary>
        <value>Es <see langword="true" /> si se debe aplicar la compatibilidad de espacio de nombres; en caso contrario, es <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad determina si el lector admite los espacios de nombres de W3C en la recomendación de XML que se encuentra en www.w3.org/TR/REC-xml-names.  
  
 El `Namespaces` no se puede establecer la propiedad después de que se ha producido una operación de lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha establecido esta propiedad después de producirse una operación de lectura (<see cref="P:System.Xml.XmlTextReader.ReadState" /> no es <see langword="ReadState.Initial" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public override string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlTextReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el URI de espacio de nombres (según se define en la especificación relativa a espacios de nombres del Consorcio W3C) del nodo en el que está situado el lector.</summary>
        <value>URI de espacio de nombres del nodo actual; en caso contrario, una cadena vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad es relevante para `Element` y `Attribute` sólo los nodos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre local de cada nodo, y, si existen, el prefijo y URI de espacio de nombres.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `book2.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlTextReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Xml.XmlNameTable" /> asociado a esta implementación.</summary>
        <value><see langword="XmlNameTable" /> que permite obtener la versión subdividida de una cadena en el nodo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Devuelven todos los nombres de nodo y de atributo de <xref:System.Xml.XmlTextReader> se subdividen mediante el `NameTable`. Cuando se devuelve varias veces el mismo nombre (por ejemplo, `Customer`), a continuación, en el mismo `String` se devuelve el objeto de ese nombre. Esto permite escribir código eficiente que comparaciones de objetos en estas cadenas en lugar de costosas comparaciones de cadenas.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlTextReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del nodo actual.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.XmlNodeType" /> que representa el tipo del nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad nunca devuelve los siguientes `XmlNodeType` tipos: `Document`, `DocumentFragment`, `Entity`, `EndEntity`, o `Notation`.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada uno de los nodos.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Normalization">
      <MemberSignature Language="C#" Value="public bool Normalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Normalization" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Normalization" />
      <MemberSignature Language="VB.NET" Value="Public Property Normalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Normalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Normalization : bool with get, set" Usage="System.Xml.XmlTextReader.Normalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben normalizar los valores de atributo y de espacio en blanco.</summary>
        <value><see langword="true" /> si se deben normalizar; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad se puede cambiar en cualquier momento y surte efecto en la siguiente operación de lectura.  
  
> [!NOTE]
>  Si el <xref:System.Xml.XmlTextReader> se usa para construir un <xref:System.Xml.XmlValidatingReader>para normalizar los valores de atributo, `Normalization` debe establecerse en `true`.  
  
 Si `Normalization` está establecido en `false`, esto también deshabilita la comprobación para las entidades numéricas del intervalo de caracteres. Como resultado, entidades de caracteres, como `&#0;`, se permiten.  
  
 A continuación describe la normalización del valor de atributo:  
  
-   Para una referencia a carácter, adjunte al valor de atributo el carácter al que se hace referencia.  
  
-   Para una referencia a entidad, procese de manera recursiva el texto de reemplazo de la entidad.  
  
-   Para un carácter de espacio en blanco (#x20, #xD, #xA y #x9) que anexar #x20 al valor normalizado. (Solo un único carácter #x20 se adjunta para una secuencia "#xD #xA" que es parte de una entidad externa analizada o el valor de la entidad literal de una entidad interna analizada).  
  
-   Para procesar otros caracteres, adjúntelos al valor normalizado.  
  
-   Si el valor declarado no es CDATA, descartar los caracteres de espacio (#x20) iniciales y finales y reemplazar las secuencias de caracteres de espacio (#x20) con un carácter de espacio (#x20).  
  
 El `XmlTextReader` solo realiza el atributo o la normalización de CDATA. No hace normalización específica de la DTD, a menos que se ajusta dentro de un `XmlValidatingReader`.  
  
 Consulte la recomendación W3C XML 1.0 para obtener más información sobre la normalización.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el comportamiento del lector con normalización activada y, a continuación, se ha desactivado.  
  
 [!code-cpp[XmlTextReader.Normalization#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Normalization/CPP/readnormal.cpp#1)]
 [!code-csharp[XmlTextReader.Normalization#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Normalization/CS/readnormal.cs#1)]
 [!code-vb[XmlTextReader.Normalization#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Normalization/VB/readnormal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se establece cuando el lector está cerrado (<see cref="P:System.Xml.XmlTextReader.ReadState" /> es <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public override string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlTextReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el prefijo de espacio de nombres asociado al nodo actual.</summary>
        <value>Prefijo de espacio de nombres asociado al nodo actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre local de cada nodo, y, si existen, el prefijo y URI de espacio de nombres.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `book2.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProhibitDtd : bool with get, set" Usage="System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe permitir el procesamiento de DTD. Esta propiedad ha quedado obsoleta. Utilice <see cref="P:System.Xml.XmlTextReader.DtdProcessing" /> en su lugar.</summary>
        <value>Es <see langword="true" /> para no permitir el procesamiento de DTD; en caso contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El procesamiento de DTD está habilitado con versiones anteriores de forma predeterminada para la compatibilidad. Sin embargo, a menos que su aplicación necesita procesamiento de DTD, debe deshabilitar a esta configuración. Puede ser útil deshabilitar el procesamiento DTD para prevenir determinados ataques de denegación de servicio. Si establece en `true`, el lector produce una <xref:System.Xml.XmlException> cuando se encuentra contenido DTD.  
  
 Si tiene habilitado el procesamiento de DTD, deberá tener en cuenta, incluidos las DTD de orígenes de confianza y posibles ataques de denegación de servicio. Use la <xref:System.Xml.XmlSecureResolver> para restringir los recursos que la <xref:System.Xml.XmlTextReader> puede tener acceso. También puede diseñar su aplicación para que el procesamiento XML se realice con restricciones de memoria y tiempo. Por ejemplo, configurar los límites de tiempo de espera en la aplicación ASP.NET  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public override char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlTextReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el carácter de comillas entre las que se encierra el valor de un nodo de atributo.</summary>
        <value>Carácter de comillas (" o ') entre las que se encierra el valor de un nodo de atributo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad solo se aplica a un nodo de atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="xmlTextReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el siguiente nodo del flujo.</summary>
        <returns>Es <see langword="true" /> si se lee correctamente el siguiente nodo; es <see langword="false" /> si no hay más nodos que leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Cuando un lector primero se crea e inicializa, hay ninguna información. Debe llamar a `Read` para leer el primer nodo.  
  
 Este método requiere al menos cuatro bytes desde el flujo de datos para poder empezar a analizar. Si se devuelven menos de cuatro bytes y no hay ningún dato más en la secuencia, se producirá un error en el método. Si hay más datos en la secuencia, el método bloqueará hasta que se reciba el cuarto byte de análisis.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada nodo.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se ha producido un error al analizar el fragmento de XML.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public override bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="override this.ReadAttributeValue : unit -&gt; bool" Usage="xmlTextReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analiza el valor de atributo en uno o varios nodos <see langword="Text" />, <see langword="EntityReference" /> o <see langword="EndEntity" />.</summary>
        <returns><see langword="true" /> si hay nodos para devolver.  
  
 <see langword="false" /> si el lector no está situado en un nodo de atributo cuando se realiza la llamada inicial o si se leyeron todos los valores de atributo.  
  
Un atributo vacío, como <c>misc=""</c>, devuelve <see langword="true" /> con un solo nodo cuyo valor es <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Utilice este método después de llamar a `MoveToAttribute` para leer los nodos de referencia de texto o una entidad que constituyen el valor del atributo. El <xref:System.Xml.XmlReader.Depth%2A> de los nodos de valor de atributo es uno más la profundidad del nodo de atributo; aumenta y disminuye en uno al entrar y salir de las referencias de entidad general.  
  
   
  
## Examples  
 El ejemplo siguiente lee un atributo con nodos de texto y de entidad.  
  
 [!code-cpp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CPP/readattrval.cpp#1)]
 [!code-csharp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CS/readattrval.cs#1)]
 [!code-vb[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/VB/readattrval.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBase64">
      <MemberSignature Language="C#" Value="public int ReadBase64 (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBase64(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBase64 (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBase64(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberSignature Language="F#" Value="member this.ReadBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadBase64 (array, offset, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz de caracteres que sirve como búfer en el que se escribe el contenido de texto.</param>
        <param name="offset">Índice de base cero de la matriz que especifica dónde el método puede comenzar a escribir en el búfer.</param>
        <param name="len">Número de bytes que se van a escribir en el búfer.</param>
        <summary>Descodifica Base64 y devuelve los bytes binarios descodificados.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Al igual que <xref:System.Xml.XmlTextReader.ReadChars%2A>, este método se puede llamar sucesivamente para leer grandes flujos de texto incrustado. Descodifica el contenido en Base64 y devuelve los bytes binarios descodificados (por ejemplo, una línea Base64 codificada en formato GIF) en el búfer. Consulte el documento RFC 1521. (Puede obtener RFC del [sitio Web de comentarios de solicitud de](https://www.rfc-editor.org).)  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo que contenga datos Base64 y BinHex.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">La secuencia Base64 no es válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> &lt; 0, o <paramref name="len" /> &lt; 0, o <paramref name="len" /> &gt; <paramref name="array" />.Length- <paramref name="offset" />.</exception>
        <altmember cref="M:System.Xml.XmlTextWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBinHex">
      <MemberSignature Language="C#" Value="public int ReadBinHex (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBinHex(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBinHex (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBinHex(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberSignature Language="F#" Value="member this.ReadBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadBinHex (array, offset, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz de bytes que sirve como búfer en el que se escriben los bytes binarios descodificados.</param>
        <param name="offset">Índice de base cero de la matriz que especifica dónde el método puede comenzar a escribir en el búfer.</param>
        <param name="len">Número de bytes que se van a escribir en el búfer.</param>
        <summary>Descodifica <see langword="BinHex" /> y devuelve los bytes binarios descodificados.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Al igual que <xref:System.Xml.XmlTextReader.ReadChars%2A>, este método se puede llamar sucesivamente para leer grandes flujos de texto incrustado. Descodifica `BinHex` de contenido y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `BinHex` codificado en formato GIF) en el búfer.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo que contiene `Base64` y `BinHex` datos.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">La secuencia <see langword="BinHex" /> no es válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> &lt; 0, o <paramref name="len" /> &lt; 0, o <paramref name="len" /> &gt; <paramref name="array" />.Length- <paramref name="offset" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public int ReadChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChars (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadChars : char[] * int * int -&gt; int" Usage="xmlTextReader.ReadChars (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres que sirve como búfer en el que se escribe el contenido de texto.</param>
        <param name="index">Posición dentro de <paramref name="buffer" /> donde el método puede comenzar a escribir contenido de texto.</param>
        <param name="count">Número de caracteres que se van a escribir en el <paramref name="buffer" />.</param>
        <summary>Lee el contenido de texto de un elemento en un búfer de caracteres. Este método se ha diseñado para leer grandes flujos de texto incrustado llamando sucesivamente al método.</summary>
        <returns>Número de caracteres que se han leído. Puede ser <see langword="0" /> si el lector no está situado en un elemento o si no hay más contenido de texto para devolver en el contexto actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Se trata de la manera más eficaz para procesar secuencias muy grandes de texto incrustados en un documento XML. En lugar de asignar objetos de cadena grande, `ReadChars` devuelve un búfer de contenido de texto a la vez. Este método está diseñado para funcionar solo en los nodos de elemento. Tipos de otro nodo hacen `ReadChars` para devolver `0`.  
  
 En el siguiente XML, si el lector está situado en la etiqueta de apertura, `ReadChars` devuelve `test` y coloca el lector después de la etiqueta de cierre.  
  
```xml  
<Item>test</Item>  
```  
  
 `ReadChars` tiene la siguiente funcionalidad:  
  
-   Este método está diseñado para trabajar en sólo los nodos de elemento. Tipos de otro nodo hacen `ReadChars` devuelva 0.  
  
-   Este método devuelve el contenido real de caracteres. No hay ningún intento para resolver entidades, CDATA o cualquier otro marcado encontrado. `ReadChars` Devuelve todo el contenido entre la etiqueta de apertura y la etiqueta de cierre, incluido el marcado.  
  
-   `ReadChars` omite el marcado XML que no es correcto. Por ejemplo, al leer la siguiente cadena XML `<A>1<A>2</A>`, `ReadChars` devuelve `1<A>2</A>`. (Devuelve el marcado de par de elementos coincidentes y omite los demás).  
  
-   Este método no realiza ninguna normalización.  
  
-   Cuando `ReadChars` ha llegado al final de la secuencia de caracteres, devuelve el valor 0 y el lector está situado después de la etiqueta de cierre.  
  
-   Los métodos no están disponibles durante el uso de lectura de atributos `ReadChars`.  
  
 Por ejemplo, mediante el siguiente código XML:  
  
```xml  
<thing>  
 some text  
</thing>  
<item>  
</item>  
```  
  
 El lector está situado en la `<item>` elemento al final de while en bucle.  
  
```csharp  
if (XmlNodeType.Element == reader.NodeType && "thing" == reader.Name)  
{  
 while(0 != reader.ReadChars(buffer, 0, 1)  
 {  
 // Do something.  
 // Attribute values are not available at this point.  
 }  
}  
```  
  
   
  
## Examples  
 El ejemplo siguiente se lee en XML mediante `ReadChars`.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza como entrada el archivo `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="count" /> es mayor que el espacio especificado en <paramref name="buffer" /> (tamaño de búfer - <paramref name="index" />).</exception>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
          <see langword="&lt; 0" /> o <paramref name="count" /><see langword="&lt; 0" />.</exception>
        <altmember cref="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el contenido y devuelve los bytes binarios descodificados de <see langword="Base64" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método envía el contenido, descodifica el `Base64` de contenido y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `Base64`-codificado en formato GIF) en el búfer. Puede llamar sucesivamente a este método para leer grandes flujos de texto incrustado. Para obtener más información, vea RFC 1521, "MIME (Multipurpose Internet Mail Extensions) parte uno: Mecanismos para especificar y describir el formato de los cuerpos de mensaje de Internet". Puede obtener RFC del [sitio Web de comentarios de solicitud de](https://www.rfc-editor.org).  
  
> [!NOTE]
>  Debe tener acceso a cualquiera de las propiedades del lector entre las llamadas a no la <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> método hasta que el método devuelve el valor 0.  
  
 Este método tiene el siguiente comportamiento:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> Devuelve el valor 0 cuando ha llegado al final de la secuencia de bytes que estaba operando. El lector está situado en el primer nodo sin contenido.  
  
-   Si solicita un número menor, o el número exacto de bytes que quedan en la secuencia, el lector permanece en su posición actual.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> no se admite en los siguientes tipos de nodo XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">En el nodo actual, no se admite el método <see cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el contenido y devuelve los bytes binarios descodificados de <see langword="BinHex" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método envía el contenido, descodifica el `BinHex` de contenido y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `BinHex` codificado en formato GIF) en el búfer. Puede llamar sucesivamente a este método para leer grandes flujos de texto incrustado.  
  
> [!NOTE]
>  Debe tener acceso a cualquiera de las propiedades del lector entre las llamadas a no la <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> método hasta que el método devuelve el valor 0.  
  
 Este método tiene el siguiente comportamiento:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> Devuelve el valor 0 cuando ha llegado al final de la secuencia de bytes que estaba operando. El lector está situado en el primer nodo sin contenido.  
  
-   Si solicita un número menor, o el número exacto de bytes que quedan en la secuencia, el lector permanece en su posición actual.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> no se admite en los siguientes tipos de nodo XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El método <see cref="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> no es compatible con el nodo actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlTextReader" /> no admite este método.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el elemento y descodifica el contenido de Base64.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método lee el contenido del elemento, descodifica mediante la codificación Base64 y devuelve los bytes binarios descodificados (por ejemplo, una línea Base64 codificada en formato GIF) en el búfer. Para obtener más información, vea RFC 1521, "MIME (Multipurpose Internet Mail Extensions) parte uno: Mecanismos para especificar y describir el formato de los cuerpos de mensaje de Internet". Puede obtener RFC del [sitio Web de comentarios de solicitud de](https://www.rfc-editor.org).  
  
 Este método solo puede leer elementos de contenido simple. El elemento puede contener texto, espacios en blanco, espacio en blanco significativo, secciones CDATA, comentarios y las instrucciones de procesamiento. También puede contener referencias de entidad, que se expanden automáticamente. El elemento no puede tener elementos secundarios.  
  
 Este método es muy similar a la <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> método excepto en que sólo se puede llamar en tipos de nodo de elemento.  
  
 Si el `count` valor es mayor que el número de bytes en el documento, o si es igual al número de bytes en el documento, el <xref:System.Xml.XmlTextReader> lee todos los bytes restantes en el documento y devuelve el número de bytes leídos. La siguiente <xref:System.Xml.XmlTextReader> llamada al método devuelve un cero y desplaza el lector al siguiente nodo del <xref:System.Xml.XmlNodeType.EndElement>.  
  
 Si se llama a <xref:System.Xml.XmlTextReader.Read%2A> antes de que se consuma todo el contenido del elemento, el lector puede comportarse como si se consumió el primer contenido y, a continuación, el <xref:System.Xml.XmlTextReader.Read%2A> se llamó al método. Esto significa que el lector lee todo el texto hasta que se encuentra el elemento final. A continuación, lee el nodo de la etiqueta de cierre, lee el nodo siguiente y, a continuación, se coloca en el siguiente nodo.  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A?displayProperty=nameWithType> para ver un ejemplo de cómo utilizar este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El nodo actual no es un nodo de elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlTextReader" /> no admite este método.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento contiene un contenido mixto.</exception>
        <exception cref="T:System.FormatException">El contenido no puede convertirse en el tipo solicitado.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer donde se va a copiar el texto resultante. Este valor no puede ser <see langword="null" />.</param>
        <param name="index">Posición de desplazamiento en el búfer donde debe comenzar la copia del resultado.</param>
        <param name="count">Número máximo de bytes que se van a copiar en el búfer. El número real de bytes copiados se devuelve a partir de este método.</param>
        <summary>Lee el elemento y descodifica el contenido de <see langword="BinHex" />.</summary>
        <returns>Número de bytes escritos en el búfer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método lee el contenido del elemento, se descodifica mediante `BinHex` codificación y devuelve los bytes binarios descodificados (por ejemplo, un elemento incorporado `BinHex` codificado en formato GIF) en el búfer.  
  
 Este método solo puede leer elementos de contenido simple. El elemento puede contener texto, espacios en blanco, espacio en blanco significativo, secciones CDATA, comentarios y las instrucciones de procesamiento. También puede contener referencias de entidad, que se expanden automáticamente. El elemento no puede tener elementos secundarios.  
  
 Este método es muy similar a la <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> método excepto en que sólo se puede llamar en tipos de nodo de elemento.  
  
 Si el `count` valor es mayor que el número de bytes en el documento, o si es igual al número de bytes en el documento, el <xref:System.Xml.XmlTextReader> lee todos los bytes restantes en el documento y devuelve el número de bytes leídos. La siguiente <xref:System.Xml.XmlTextReader> llamada al método devuelve un cero y desplaza el lector al siguiente nodo del <xref:System.Xml.XmlNodeType.EndElement>.  
  
 Si se llama a <xref:System.Xml.XmlTextReader.Read%2A> antes de que se consuma todo el contenido del elemento, el lector puede comportarse como si se consumió el primer contenido y, a continuación, el <xref:System.Xml.XmlTextReader.Read%2A> se llamó al método. Esto significa que el lector lee todo el texto hasta que se encuentra el elemento final. A continuación, lee el nodo de la etiqueta de cierre, lee el nodo siguiente y, a continuación, se coloca en el siguiente nodo.  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A?displayProperty=nameWithType> para ver un ejemplo de cómo utilizar este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El nodo actual no es un nodo de elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice del búfer (index) o la suma del índice y el recuento (index + count) es mayor que el tamaño de búfer asignado.</exception>
        <exception cref="T:System.NotSupportedException">La implementación de <see cref="T:System.Xml.XmlReader" /> no admite este método.</exception>
        <exception cref="T:System.Xml.XmlException">El elemento contiene un contenido mixto.</exception>
        <exception cref="T:System.FormatException">El contenido no puede convertirse en el tipo solicitado.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public override System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlTextReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado del lector.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.ReadState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public override string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="override this.ReadString : unit -&gt; string" Usage="xmlTextReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el contenido de un nodo de texto o un elemento como cadena.</summary>
        <returns>Contenido del nodo de elemento o de texto. Puede ser una cadena vacía si el lector está situado en un nodo que no sea de elemento ni de texto, o si no hay más contenido de texto para devolver en el contexto actual.  
  
 <see langword="Note:" /> El nodo de texto puede ser un nodo de texto de elemento o de atributo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Si se coloca en un elemento, `ReadString` concatena todo texto, espacios en blanco significativos, espacios en blanco, y `CData` juntos los tipos de nodo de sección y devuelve los datos concatenados como el contenido del elemento. Se detiene cuando se encuentra cualquier marcado, incluidos los comentarios y las instrucciones de procesamiento. Esto se podría producir en un modelo de contenido mixto o cuando se lee una etiqueta de fin de elemento.  
  
 Si se coloca en un nodo de texto, `ReadString` realiza la misma concatenación desde el nodo de texto hasta la etiqueta de cierre del elemento. Si el sistema de lectura está situado en un nodo de texto de atributos, `ReadString` tiene la misma funcionalidad que si el sistema de lectura estuviera situado en la etiqueta de inicio de elemento. Devuelve todos los nodos de texto de elementos concatenados.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el contenido de texto de cada elemento.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 En el ejemplo se utiliza el archivo `elems.xml`como entrada.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se ha producido un error al analizar el fragmento de XML.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha intentado realizar una operación no válida.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public void ResetState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResetState" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetState();" />
      <MemberSignature Language="F#" Value="member this.ResetState : unit -&gt; unit" Usage="xmlTextReader.ResetState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el estado del lector en ReadState.Initial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Este método le permite analizar varios documentos XML en una sola secuencia. Cuando se alcanza el final de un documento XML, puede llamar a `ResetState` para restablecer el estado del lector como preparación para el siguiente documento XML.  
  
> [!IMPORTANT]
>  Los documentos de la secuencia deben compartir la misma codificación. Si esto no es así, cuando `ResetState` se denomina un <xref:System.Xml.XmlException> se produce. (Esto es un cambio de comportamiento de .NET Framework versión 1.1 y anterior).  
  
 Las siguientes propiedades no se ven afectadas por `ResetState`.  
  
-   <xref:System.Xml.XmlTextReader.Normalization%2A>  
  
-   <xref:System.Xml.XmlTextReader.Namespaces%2A>  
  
-   <xref:System.Xml.XmlTextReader.XmlResolver%2A>  
  
-   <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A>  
  
   
  
## Examples  
 El ejemplo siguiente analiza dos documentos XML en un solo flujo.  
  
 [!code-cpp[XmlTextReader.ResetState#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ResetState/CPP/resetstate.cpp#1)]
 [!code-csharp[XmlTextReader.ResetState#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ResetState/CS/resetstate.cs#1)]
 [!code-vb[XmlTextReader.ResetState#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ResetState/VB/resetstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama a <see langword="ResetState" /> si el lector se construyó mediante <see cref="T:System.Xml.XmlParserContext" />.</exception>
        <exception cref="T:System.Xml.XmlException">Los documentos de una sola secuencia no comparten la misma codificación.</exception>
        <altmember cref="T:System.Xml.ReadState" />
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public override void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResolveEntity();" />
      <MemberSignature Language="F#" Value="override this.ResolveEntity : unit -&gt; unit" Usage="xmlTextReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resuelve la referencia a entidad de los nodos <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Si el lector está situado en un `EntityReference` nodo (`XmlNodeType.EntityReference`), si <xref:System.Xml.XmlTextReader.Read%2A> se llama después de llamar a este método, el texto de reemplazo de entidad se analiza. Cuando finalice el texto de reemplazo de entidad, un `EndEntity` nodo se devuelve al cerrar el ámbito de referencia de entidad.  
  
> [!NOTE]
>  Después de llamar a este método, si la entidad forma parte de un valor de atributo, debe llamar a <xref:System.Xml.XmlTextReader.ReadAttributeValue%2A> para ir a la entidad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlTextReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xml.XmlReaderSettings" /> que se usa para crear esta instancia de <see cref="T:System.Xml.XmlTextReader" />.</summary>
        <value>Objeto <see cref="T:System.Xml.XmlReaderSettings" /> usado para crear esta instancia de <see cref="T:System.Xml.XmlTextReader" />; es <see langword="null" /> si el lector no se creó mediante el método <see cref="Overload:System.Xml.XmlReader.Create" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> En [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], la práctica recomendada es crear instancias <xref:System.Xml.XmlReader> mediante la clase <xref:System.Xml.XmlReaderSettings> y el método <xref:System.Xml.XmlReader.Create%2A>. Esto le permite sacar el máximo provecho de todas las nuevas características introducidas en [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Para obtener más información, vea la sección Comentarios de la <xref:System.Xml.XmlReader> página de referencia.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public override void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Skip();" />
      <MemberSignature Language="F#" Value="override this.Skip : unit -&gt; unit" Usage="xmlTextReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Omite los nodos secundarios del nodo actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 En el siguiente código XML de entrada si el lector está situado en la `<a>` nodo o cualquiera de sus atributos, una llamada a `Skip` coloca el lector a la `<b>` nodo.  
  
 Si el lector ya está situado en un nodo hoja (como el `<x>` nodo o el nodo de texto `abc`), al llamar a `Skip` es igual que llamar a <xref:System.Xml.XmlTextReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
  <x/>abc<y/>  
</a>  
<b>  
 ...  
</b>  
```  
  
 Este método comprueba XML bien formado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlLineInfo.HasLineInfo">
      <MemberSignature Language="C#" Value="bool IXmlLineInfo.HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Xml.IXmlLineInfo.HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlLineInfo#HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Function HasLineInfo () As Boolean Implements IXmlLineInfo.HasLineInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Xml.IXmlLineInfo.HasLineInfo() = System::Xml::IXmlLineInfo::HasLineInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.Xml.IXmlLineInfo.HasLineInfo" />.</summary>
        <returns>Es <see langword="true" /> si se pueden proporcionar <see cref="P:System.Xml.IXmlLineInfo.LineNumber" /> y <see cref="P:System.Xml.IXmlLineInfo.LinePosition" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Xml.XmlTextReader> se convierte en una interfaz <xref:System.Xml.IXmlLineInfo>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.GetNamespacesInScope">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IDictionary&lt;string,string&gt; IXmlNamespaceResolver.GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String) Implements IXmlNamespaceResolver.GetNamespacesInScope" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System::Xml::XmlNamespaceScope scope) = System::Xml::IXmlNamespaceResolver::GetNamespacesInScope;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="scope">Valor <see cref="T:System.Xml.XmlNamespaceScope" /> que especifica el tipo de nodos de espacio de nombres que se va a devolver.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />.</summary>
        <returns><see cref="T:System.Collections.IDictionary" /> que contiene los espacios de nombres que hay actualmente en el ámbito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Xml.XmlTextReader> se convierte en una interfaz <xref:System.Xml.IXmlNamespaceResolver>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupNamespace">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupNamespace (prefix As String) As String Implements IXmlNamespaceResolver.LookupNamespace" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupNamespace(System::String ^ prefix) = System::Xml::IXmlNamespaceResolver::LookupNamespace;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo cuyo URI de espacio de nombres se desea buscar.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)" />.</summary>
        <returns>Identificador URI del espacio de nombres que está asignado al prefijo; es <see langword="null" /> si el prefijo no está asignado a ningún URI de espacio de nombres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Xml.XmlTextReader> se convierte en una interfaz <xref:System.Xml.IXmlNamespaceResolver>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupPrefix">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupPrefix (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupPrefix (namespaceName As String) As String Implements IXmlNamespaceResolver.LookupPrefix" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupPrefix(System::String ^ namespaceName) = System::Xml::IXmlNamespaceResolver::LookupPrefix;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="namespaceName">URI de espacio de nombres cuyo prefijo se desea buscar.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)" />.</summary>
        <returns>Prefijo asignado al URI del espacio de nombres; es <see langword="null" /> si este URI no está asignado a ningún prefijo.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public override string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlTextReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de texto del nodo actual.</summary>
        <value>El valor devuelto depende de la propiedad <see cref="P:System.Xml.XmlTextReader.NodeType" /> del nodo:  En la siguiente tabla se recogen los tipos de nodo que tienen un valor para devolver. Todos los demás tipos de nodo devuelven <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Tipo de nodo 
 </term><description> Valor 
 </description></listheader><item><term><see langword="Attribute" /></term><description> El valor del atributo.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Contenido de la sección CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> El contenido del comentario.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> El subconjunto interno.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> El contenido completo, sin incluir el destino.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> El espacio en blanco que se encuentra en el ámbito de <see langword="xml:space" />= 'preserve'.  
  
 </description></item><item><term><see langword="Text" /></term><description> El contenido del nodo de texto.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> El espacio en blanco entre marcado.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> El contenido de la declaración.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo XML y muestra cada nodo.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 El ejemplo usa el archivo `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="WhitespaceHandling">
      <MemberSignature Language="C#" Value="public System.Xml.WhitespaceHandling WhitespaceHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WhitespaceHandling WhitespaceHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property WhitespaceHandling As WhitespaceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::WhitespaceHandling WhitespaceHandling { System::Xml::WhitespaceHandling get(); void set(System::Xml::WhitespaceHandling value); };" />
      <MemberSignature Language="F#" Value="member this.WhitespaceHandling : System.Xml.WhitespaceHandling with get, set" Usage="System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WhitespaceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica cómo se controla el espacio en blanco.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.WhitespaceHandling" />. El valor predeterminado es <see langword="WhitespaceHandling.All" /> (devuelve los nodos <see langword="Whitespace" /> y <see langword="SignificantWhitespace" />).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad se puede cambiar en cualquier momento y surte efecto en la siguiente operación de lectura.  
  
 Dado que el `XmlTextReader` no tiene información DTD disponible, `SignificantWhitepsace` sólo se devuelven nodos dentro de un `xml:space='preserve'` ámbito.  
  
   
  
## Examples  
 El ejemplo siguiente lee un fragmento de XML.  
  
 [!code-cpp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se ha especificado un valor no válido.</exception>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se establece cuando el lector está cerrado (<see cref="P:System.Xml.XmlTextReader.ReadState" /> es <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlTextReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el ámbito de <see langword="xml:lang" /> actual.</summary>
        <value>Ámbito de <see langword="xml:lang" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 Esta propiedad representa el `xml:lang` definir el ámbito en que reside el nodo actual. Por ejemplo, este es un fragmento XML con `xml:lang` establecido en inglés de Estados Unidos en el elemento raíz:  
  
 \<root xml:lang="en-us">  
  
 \<name>Fred\</name>  
  
 \</root>  
  
 Cuando el lector está situado en la `name` elemento, puede utilizar esta propiedad para saber que está en el ámbito de un inglés de Estados Unidos `xml:lang` atributo.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el `xml:lang` valor para cada uno de los nodos.  
  
 [!code-cpp[XmlTextReader.XmlLang#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlLang/CPP/readlang.cpp#1)]
 [!code-csharp[XmlTextReader.XmlLang#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlLang/CS/readlang.cs#1)]
 [!code-vb[XmlTextReader.XmlLang#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlLang/VB/readlang.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlTextReader.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece el objeto <see cref="T:System.Xml.XmlResolver" /> que se usa para resolver las referencias a DTD.</summary>
        <value>Objeto <see langword="XmlResolver" /> que se va a usar. Si se establece en <see langword="null" />, los recursos externos no se resuelven.  
  
En la versión 1.1 de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], el llamador debe ser de plena confianza para poder especificar un objeto <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
 El lector utiliza `XmlResolver` para resolver la ubicación del archivo cargado en el lector y también para resolver las referencias a DTD. Por ejemplo, si el XML incluye la declaración DOCTYPE, `<!DOCTYPE book SYSTEM book.dtd>` el lector resuelve este archivo externo y asegura que la DTD sea correcto. El lector no utiliza la DTP para validación.  
  
 Esta propiedad se puede cambiar en cualquier momento y surte efecto en la siguiente operación de lectura. Si esta propiedad se establece en `null`, no se resuelven las referencias DTD externas detectadas por el lector.  
  
 En la versión 1.1 de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], si no se establece esta propiedad, el nivel de confianza de la aplicación determina el comportamiento predeterminado.  
  
 `Fully trusted code:` El lector usa un valor predeterminado <xref:System.Xml.XmlUrlResolver> sin credenciales de usuario. Si se requiere autenticación para acceder a un recurso de red, use la `XmlResolver` propiedad para especificar un `XmlResolver` con las credenciales necesarias.  
  
 `Semi-trusted code:` El `XmlResolver` propiedad está establecida en `null`. No se puede resolver recursos externos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `XmlResolver` propiedad para especificar las credenciales necesarias para tener acceso al archivo en red.  
  
 [!code-cpp[XmlTextReader.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlResolver/CPP/rdr_resolver.cpp#1)]
 [!code-csharp[XmlTextReader.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlResolver/CS/rdr_resolver.cs#1)]
 [!code-vb[XmlTextReader.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlResolver/VB/rdr_resolver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlTextReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el ámbito de <see langword="xml:space" /> actual.</summary>
        <value>Uno de los valores de <see cref="T:System.Xml.XmlSpace" />. Si no existe ningún ámbito de <see langword="xml:space" />, el valor predeterminado de esta propiedad será <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de .NET Framework 2.0, se recomienda crear <xref:System.Xml.XmlReader> instancias utilizando el <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> método para aprovechar las ventajas de la nueva funcionalidad.  
  
   
  
## Examples  
 El ejemplo siguiente se analiza un archivo y devuelve el espacio en blanco significativo si un `xml:space='preserve'` ámbito se encuentra.  
  
 [!code-cpp[XmlTextReader.XmlSpace#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlSpace/CPP/readspace.cpp#1)]
 [!code-csharp[XmlTextReader.XmlSpace#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlSpace/CS/readspace.cs#1)]
 [!code-vb[XmlTextReader.XmlSpace#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlSpace/VB/readspace.vb#1)]  
  
 En el ejemplo se utiliza el archivo `authors.xml`como entrada.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
  </Members>
</Type>