<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3d082dd7c9628002f1da7a6e1f97b52c5dbf6533" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694154" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contiene métodos, propiedades y eventos compatibles con la navegación.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> Encapsula la capacidad de descargar contenido en el contexto de una navegación de tipo explorador.  
  
 El contenido puede ser cualquier tipo de objeto de .NET Framework y los archivos HTML. En general, sin embargo, las páginas son la manera preferida de empaquetar el contenido para la navegación (vea <xref:System.Windows.Controls.Page>).  
  
 Contenido se puede navegar a proporcionar una instancia de un objeto y llamando a una sobrecarga de la <xref:System.Windows.Navigation.NavigationService.Navigate%2A> método que acepta un objeto:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 Como alternativa, se puede navegar contenido pasando un URI relativo o absoluto a uno de los <xref:System.Windows.Navigation.NavigationService.Navigate%2A> sobrecargas del método que acepta un URI:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 Cuando se navega al contenido mediante URI, <xref:System.Windows.Navigation.NavigationService> devolverá un objeto que contiene el contenido.  
  
 Puede realizar el seguimiento de la duración de una navegación a través de los siguientes eventos:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>.  
  
 No todos los eventos se generan cada vez que tenga lugar la navegación; el conjunto de eventos que se produzcan se determina por el tipo de navegación que se produce (contenido o fragmento del contenido) y cómo se completa la navegación (cancelada, detenido o con errores).  
  
 La ilustración siguiente muestra la secuencia en que se producen estos eventos:  
  
 ![Diagrama de flujo de navegación de página](~/add/media/navigationoverviewfigure11.png "diagrama de flujo de navegación de página")  
  
 Durante o después de una exploración, <xref:System.Windows.Navigation.NavigationService> proporciona información acerca del contenido que se navega, incluido el identificador URI del contenido que se navega (<xref:System.Windows.Navigation.NavigationService.Source%2A>), el URI del contenido actual (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>) y un objeto que contiene el contenido que se navegó (<xref:System.Windows.Navigation.NavigationService.Content%2A>).  
  
 Cuando se navega al, contenido <xref:System.Windows.Navigation.NavigationService> graba la navegación como una entrada en el historial de navegación. Se agrega una entrada al historial de navegación de retroceso cuando se produce una nueva navegación, mediante una llamada a la <xref:System.Windows.Navigation.NavigationService.Navigate%2A> método, o yendo a una entrada en el historial de navegación hacia atrás, mediante una llamada a <xref:System.Windows.Navigation.NavigationService.GoForward%2A>. Se agrega una entrada en el historial de navegación hacia atrás, vaya a una entrada en la parte posterior historial de navegación, mediante una llamada a <xref:System.Windows.Navigation.NavigationService.GoBack%2A>. <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> y <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> notificar si hay entradas en la parte posterior y el historial de navegación hacia atrás, respectivamente. Además, la entrada más reciente en la parte posterior se puede quitar el historial de navegación mediante una llamada a <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>.  
  
 De forma predeterminada, <xref:System.Windows.Navigation.NavigationService> no almacena una instancia de un objeto contenido en el historial de navegación. En su lugar, <xref:System.Windows.Navigation.NavigationService> crea una nueva instancia del objeto de contenido cada vez que se navega mediante el historial de navegación. Este comportamiento está diseñado para evitar el consumo excesivo de memoria cuando se navegue a números grandes y grandes fragmentos de contenido. Por lo tanto, no se recuerda el estado del contenido en un panel de navegación a la siguiente. Sin embargo, WPF proporciona varias técnicas que puede almacenar una parte de estado para una parte del contenido en el historial de navegación.  
  
 Usar <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, también puede recordar varios conjuntos de estado para una instancia de página única.  
  
 <xref:System.Windows.Navigation.NavigationService> es un `sealed` clase y, por tanto, no pueden crearse instancias; en su lugar, <xref:System.Windows.Navigation.NavigationService> navegadores sirve para habilitar la exploración. En WPF, hay dos exploradores: <xref:System.Windows.Navigation.NavigationWindow> y <xref:System.Windows.Controls.Frame>.  
  
 Visualmente, [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] usar [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] como un explorador, para proporcionar una experiencia de usuario integrada. Físicamente, sin embargo, [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] utilizar realmente <xref:System.Windows.Navigation.NavigationWindow> como el navegador; la <xref:System.Windows.Application.MainWindow%2A> propiedad de un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] ejecuta en [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] devolverá una referencia a la <xref:System.Windows.Navigation.NavigationWindow>y el historial de navegación que está administrado por el <xref:System.Windows.Navigation.NavigationWindow> se integra con el historial de navegación que está administrado por [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] de las maneras siguientes:  
  
-   Cuando se navega al contenido mediante una llamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, y <xref:System.Windows.Navigation.NavigationService.GoForward%2A> desde una [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] también se agregan las entradas del historial de navegación pertinentes a [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] historial de navegación.  
  
-   Cuando las entradas de la [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] navegación [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] están seleccionadas, [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] hace <xref:System.Windows.Navigation.NavigationService> para ir atrás o hacia delante al contenido que está asociado con esas entradas.  
  
> [!NOTE]
>  Un <xref:System.Windows.Controls.Frame> puede proporcionar su propio historial de navegación, o utilizar el historial de navegación del navegador que lo hospeda. Si <xref:System.Windows.Controls.Frame> proporciona su propio historial de navegación, puede mostrar su propia navegación [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] para navegar por las entradas en el historial de navegación; no se agregan las entradas en el historial de navegación del navegador host (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) y, por lo tanto, no se abrirá en el panel de navegación [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de cada uno de ellos (consulte <xref:System.Windows.Controls.Frame.JournalOwnership%2A>).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">Objeto <see cref="T:System.Windows.Navigation.CustomContentState" /> que representa el estado definido por la aplicación asociado a una parte concreta del contenido.</param>
        <summary>Agrega una entrada al historial de retroceso de navegación que contiene un objeto <see cref="T:System.Windows.Navigation.CustomContentState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, <xref:System.Windows.Navigation.CustomContentState>, y <xref:System.Windows.Navigation.IProvideCustomContentState> se usan para ayudar a recordar varios conjuntos de estado para el contenido actual.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" /> es <see langword="null" /> y no se devuelve ningún objeto del objeto <see cref="T:System.Windows.Navigation.CustomContentState" /> desde <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" />.</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si hay al menos una entrada en el historial de retroceso de navegación.</summary>
        <value>
          Es <see langword="true" /> si hay al menos una entrada en el historial de retroceso de navegación; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> para determinar si hay al menos una entrada en el historial de navegación hacia atrás. Esta propiedad se debe inspeccionar antes de llamar a <xref:System.Windows.Navigation.NavigationService.GoBack%2A>; si <xref:System.Windows.Navigation.NavigationService.GoBack%2A> se llama y no hay entradas en el historial de navegación hacia atrás, un <xref:System.InvalidOperationException> se produce.  
  
> [!NOTE]
>  que si varios navegadores comparten el historial de navegación (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), la mayoría entrada reciente en la parte posterior historial de navegación puede no haberse agregado por la <xref:System.Windows.Navigation.NavigationService> para el explorador actual.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si hay al menos una entrada en el historial de avance de navegación.</summary>
        <value>
          Es <see langword="true" /> si hay al menos una entrada en el historial de avance de navegación; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> para determinar si hay al menos una entrada en el historial de navegación hacia atrás. Esta propiedad se debe inspeccionar antes de llamar a <xref:System.Windows.Navigation.NavigationService.GoForward%2A>; si <xref:System.Windows.Navigation.NavigationService.GoForward%2A> se llama y no hay entradas en el historial de navegación hacia atrás, un <xref:System.InvalidOperationException> se produce.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una referencia al objeto que contiene el contenido actual.</summary>
        <value>Objeto que es una referencia al objeto que incluye el contenido actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contenido se puede establecer en uno de dos maneras:  
  
-   Directamente, si se establece en una referencia a un objeto.  
  
-   De forma indirecta, mediante una llamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, o <xref:System.Windows.Navigation.NavigationService.GoForward%2A>.  
  
 Establecer <xref:System.Windows.Navigation.NavigationService> inicia una nueva navegación; puesto que la navegación es asincrónica, <xref:System.Windows.Navigation.NavigationService.Content%2A> no devuelve ningún valor si se inspecciona inmediatamente después de que se va a establecer.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el URI del contenido al que se navegó por última vez.</summary>
        <value>A <see cref="T:System.Uri" /> para el contenido que se navegó en último lugar, si navegado a utilizando un URI; en caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> no se cambia la propiedad hasta que se ha completado correctamente la navegación a un URI diferente.  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> se puede establecer con un solo fragmento de URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se genera cuando comienza la navegación a un fragmento del contenido, lo que ocurre de inmediato, si el fragmento deseado está en el contenido actual, o una vez cargado el contenido de [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] de origen, si el fragmento deseado está en un contenido diferente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, un fragmento de contenido es contenido que es contenidos en un conjunto con nombre <xref:System.Windows.UIElement>, que es un <xref:System.Windows.UIElement> cuyo <xref:System.Windows.FrameworkElement.Name%2A> atributo está establecido, p. ej.:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 Navegue hasta una [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] fragmento proporcionando un URI con un sufijo en el formato siguiente:  
  
 \#*NombreDeFragmento*  
  
 A continuación muestra un ejemplo de un URI que hace referencia a un fragmento de contenido:  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 Una vez cargada la página de origen (después de <xref:System.Windows.Navigation.NavigationService.LoadCompleted> evento se desencadena), comienza la navegación del fragmento y el <xref:System.Windows.Navigation.NavigationService> intenta localizar el [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fragmento. Si el [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fragmento se encuentra, <xref:System.Windows.Navigation.NavigationService> indica al explorador de contenido (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) para mostrar el fragmento. Si necesita cambiar este comportamiento, puede controlar <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para proporcionar su propio comportamiento de navegación del fragmento. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> se pasa un <xref:System.Windows.Navigation.FragmentNavigationEventArgs> parámetro que expone propiedades que son útiles para este propósito, incluyendo:  
  
-   El navegador que posee este servicio de navegación (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   El nombre del fragmento.  
  
 Puede controlar <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para invalidar la implementación de fragmento WPF predeterminado con su propia implementación personalizada. Si lo hace, debe establecer <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> a `true`; en caso contrario, se aplica el fragmento WPF predeterminado comportamiento del procesamiento.  
  
 No se deben iniciar directamente la navegación desde un <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> controlador de eventos. Puesto que <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> se produce durante una navegación existente, iniciar una nueva navegación de un <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> controlador de eventos crea una navegación anidada que puede causar la <xref:System.ExecutionEngineException> que se produzca. En su lugar, puede iniciar indirectamente la navegación mediante la creación de un trabajo asincrónico elemento mediante el <xref:System.Windows.Threading.Dispatcher>.  
  
> [!NOTE]
>  Cuando <xref:System.Windows.Navigation.NavigationService> genera <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>, también provoca <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> evento en el <xref:System.Windows.Application> objeto.  
  
> [!IMPORTANT]
>  Navegación del fragmento no es compatible con suelto [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] páginas (sólo marcado [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] archivos con `Page` como el elemento raíz) en los casos siguientes:  
>   
>  • Al navegar a un fragmento de un flexible [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página.  
>   
>  • Al navegar desde un malas [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página a un fragmento de otra [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página.  
>   
>  Sin embargo, un malas [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página puede navegar a sus propios fragmentos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para proporcionar un comportamiento de navegación del fragmento personalizado. En este caso, el ejemplo abre un error [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] página si el fragmento en el origen de [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] no se encuentra la página.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objeto <see cref="T:System.Windows.DependencyObject" /> del contenido que hospeda un navegador.</param>
        <summary>Obtiene una referencia al objeto <see cref="T:System.Windows.Navigation.NavigationService" /> del navegador cuyo contenido incluye el objeto <see cref="T:System.Windows.DependencyObject" /> especificado.</summary>
        <returns>Referencia al objeto <see cref="T:System.Windows.Navigation.NavigationService" /> del navegador cuyo contenido contiene el objeto <see cref="T:System.Windows.DependencyObject" /> especificado; puede ser <see langword="null" /> en algunos casos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un explorador tiene un <xref:System.Windows.Navigation.NavigationService> que controla la navegación de contenido. WPF tiene dos exploradores: <xref:System.Windows.Navigation.NavigationWindow> y <xref:System.Windows.Controls.Frame>. Para procesar las solicitudes de navegación y administrar la duración de la navegación, un navegador usa el servicio de navegación de WPF, que se implementa como la <xref:System.Windows.Navigation.NavigationService> clase. Contenido que se hospeda en un navegador puede obtener una referencia para el navegador <xref:System.Windows.Navigation.NavigationService> mediante una llamada a la <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> método.  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> Devuelve `null` cuando el `dependencyObject`:  
  
-   Es una <xref:System.Windows.Navigation.NavigationWindow>.  
  
-   Es un <xref:System.Windows.Controls.Frame> que:  
  
    1.  Está hospedado en otro navegador.  
  
    2.  Tiene su <xref:System.Windows.Controls.Frame.JournalOwnership%2A> propiedad establecida en <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>.  
  
-   No es parte del contenido que se hospeda en un explorador.  
  
 WPF proporciona dos accesos directos para adquirir una referencia a la <xref:System.Windows.Navigation.NavigationService>:  
  
-   El <xref:System.Windows.Navigation.NavigationService> que procesó la navegación a un <xref:System.Windows.Controls.Page> puede tener acceso desde el <xref:System.Windows.Controls.Page> propio obteniendo el valor de su <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> propiedad.  
  
-   El <xref:System.Windows.Navigation.NavigationService> utilizado por un <xref:System.Windows.Controls.Frame> procesar la navegación puede obtenerse obteniendo el valor de la <xref:System.Windows.Controls.Frame.NavigationService%2A> propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo se muestra cómo un <xref:System.Windows.Controls.UserControl> puede recuperar un servicio en la navegación mediante una llamada a <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>.  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="dependencyObject" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navega hasta la entrada más reciente del historial de retroceso de navegación, si lo hay.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de llamar a <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, el <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> propiedad se puede inspeccionar para determinar si hay entradas en el historial de navegación hacia atrás.  
  
   
  
## Examples  
 En el ejemplo siguiente se navega a la entrada más reciente en la parte posterior historial de navegación, si lo hay.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Se llama a <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> cuando no hay ninguna entrada en el historial de navegación hacia atrás.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navegue hasta la entrada más reciente del historial de avance de navegación, si lo hay.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de llamar a <xref:System.Windows.Navigation.NavigationService.GoForward%2A>, el <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> propiedad se puede inspeccionar para determinar si hay entradas en el historial de navegación hacia atrás.  
  
   
  
## Examples  
 En el ejemplo siguiente se navega a la entrada más reciente en el historial de navegación hacia atrás, si existe alguno.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Se llama a <see cref="M:System.Windows.Navigation.NavigationService.GoForward" /> cuando no hay ninguna entrada en el historial de avance de navegación.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se ha cargado, analizado y comenzado a representar el contenido al que se navegó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlar <xref:System.Windows.Navigation.NavigationService.LoadCompleted> si necesita detectar la información pertinente en relación con la solicitud de navegación al finalizar la carga. Esta información está disponible desde el <xref:System.Windows.Navigation.NavigationEventArgs> objeto que se pasa a la <xref:System.Windows.Navigation.NavigationService.LoadCompleted> controlador de eventos e incluye:  
  
-   El contenido y su URI.  
  
-   El navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Datos adicionales, si el panel de navegación fue iniciado por una llamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A> o <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Detalles de la respuesta (mediante un <xref:System.Net.WebResponse> objeto).  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> no se produce cuando la página de origen no se pudo encontrar o cargar, en cuyo caso <xref:System.Windows.Navigation.NavigationService.NavigationFailed> se genera.  
  
> [!NOTE]
>  Cuando <xref:System.Windows.Navigation.NavigationService> genera <xref:System.Windows.Navigation.NavigationService.LoadCompleted>, también provoca <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> evento en el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.LoadCompleted>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navegue asincrónicamente al contenido de origen especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">Objeto que contiene el contenido al que navegar.</param>
        <summary>Navegue asincrónicamente al contenido incluido en un objeto.</summary>
        <returns>
          Es <see langword="true" /> si no se cancela ninguna navegación; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> se le remitirá a la <xref:System.Object> especificado por `root` si se cumplen las condiciones siguientes:  
  
-   El <xref:System.Windows.Navigation.NavigationService.Navigating> no se cancela el evento.  
  
-   Una solicitud web (vea <xref:System.Windows.Navigation.NavigationService.Navigating>) se pueden crear.  
  
 Si `root` es `null`, el contenido existente (<xref:System.Windows.Navigation.NavigationService.Content%2A>) está desactivada.  
  
> [!NOTE]
>  Al descargar contenido Web, recibirá una excepción Web (por ejemplo, 404: archivo no encontrado). Puede controlar dichas excepciones desde <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo navegar hasta una <xref:System.Windows.Controls.Page> objeto que contiene el árbol de contenido de origen.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Objeto <see cref="T:System.Uri" /> inicializado con el URI del contenido deseado.</param>
        <summary>Navegue asincrónicamente a un contenido especificado por un URI.</summary>
        <returns>
          Es <see langword="true" /> si no se cancela ninguna navegación; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de `source` puede ser un servidor Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] o un URI de paquete válido (vea [Pack URI en WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> se le remitirá al URI especificado por `source` si se cumplen las condiciones siguientes:  
  
-   El <xref:System.Windows.Navigation.NavigationService.Navigating> no se cancela el evento.  
  
-   Una solicitud web (vea <xref:System.Windows.Navigation.NavigationService.Navigating>) se pueden crear.  
  
 Si `source` es `null`, el contenido existente (<xref:System.Windows.Navigation.NavigationService.Content%2A>) está desactivada.  
  
> [!NOTE]
>  Al descargar contenido Web, recibirá una excepción Web (por ejemplo, 404: archivo no encontrado). Puede controlar dichas excepciones desde <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 Puede usar <xref:System.Windows.Navigation.NavigationService.Navigate%2A> para navegar a un fragmento de contenido. Si el contenido identificado por el URI es el contenido actual, no se descarga de nuevo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo navegar a un URI.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">Objeto que contiene el contenido al que navegar.</param>
        <param name="navigationState">Objeto que contiene los datos que se van a usar para el procesamiento durante la navegación.</param>
        <summary>Navegue asincrónicamente al contenido incluido en un objeto y pase un objeto con los datos que se van a usar para el procesamiento durante la navegación.</summary>
        <returns>
          Es <see langword="true" /> si no se cancela ninguna navegación; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método tiene el mismo comportamiento que <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, aunque se pasa un objeto en lugar de un identificador URI.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo navegar hasta una <xref:System.Windows.Controls.Page> del objeto que contiene el contenido de origen y pasar el estado de navegación.  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Objeto <see cref="T:System.Uri" /> inicializado con el URI del contenido deseado.</param>
        <param name="navigationState">Objeto que contiene los datos que se van a usar para el procesamiento durante la navegación.</param>
        <summary>Navegue asincrónicamente al contenido de origen que se encuentra en el URI y pase un objeto que contenga los datos que se van a usar para el procesamiento durante la navegación.</summary>
        <returns>
          Es <see langword="true" /> si no se cancela ninguna navegación; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puesto que navegaciones son asincrónicas, es posible que varias navegaciones estén en curso al mismo tiempo. Por ejemplo, si hay dos marcos secundarios en una sola página, pueden navegar ambos marcos. En este caso, los distintos eventos de navegación que se genera mediante <xref:System.Windows.Navigation.NavigationService> puede ser genera varias veces, uno para cada parte del contenido que se abrirá y no necesariamente para que se solicitaron la navegación. Por lo tanto, si una solicitud de navegación concreta debe procesar datos que es específicos de la solicitud individual, no puede utilizar los datos que está disponibles para todas las solicitudes de navegación. En su lugar, puede usar `navigationState` para pasar datos de navegación de procesamiento que es específico para una solicitud de navegación.  
  
 Los siguientes argumentos de evento proporcionan acceso al estado de exploración:  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (pasa a la <xref:System.Windows.Navigation.NavigationService.Navigating> evento).  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (pasa a la <xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted> controladores de eventos).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo navegar a un URI y pasando el estado de navegación.  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Objeto <see cref="T:System.Uri" /> inicializado con el URI del contenido deseado.</param>
        <param name="navigationState">Objeto que contiene los datos que se van a usar para el procesamiento durante la navegación.</param>
        <param name="sandboxExternalContent">Descargue el contenido en un recinto de seguridad de confiable parcial (con el conjunto de zonas de Internet predeterminado de permisos, si es <see langword="true" />. El valor predeterminado es <see langword="false" />.</param>
        <summary>Navegue asincrónicamente al contenido de origen que se encuentra en el URI y pase un objeto que contenga el estado de navegación de procesamiento durante la navegación e incluya el contenido en el espacio aislado.</summary>
        <returns>
          Es <see langword="true" /> si no se cancela ninguna navegación; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es solo para las aplicaciones independientes y [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] contenido.  
  
 Este método muestra el mismo comportamiento que <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, lo extiende asegurándose de que el contenido que se descarga se coloca en un recinto de seguridad de confianza parcial (con el conjunto de zonas de Internet predeterminado de permisos - vea [seguridad de confianza parcial de WPF](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se ha encontrado el contenido al que se navega y ese contenido está disponible en la propiedad <see cref="P:System.Windows.Navigation.NavigationService.Content" />, aunque no haya terminado de cargarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlar <xref:System.Windows.Navigation.NavigationService.Navigated> si necesita detectar la información pertinente en relación con la solicitud de navegación al iniciarse la descarga. Esta información está disponible desde el <xref:System.Windows.Navigation.NavigationEventArgs> objeto que se pasa a la <xref:System.Windows.Navigation.NavigationService.Navigated> controlador de eventos e incluye:  
  
-   La página de origen. Cuando <xref:System.Windows.Navigation.NavigationService.Navigated> se genera, al menos una parte de la página de origen [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] árbol se ha analizado y asociado al control de contenido de destino.  
  
-   El URI solicitado.  
  
-   El navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Datos adicionales, si el panel de navegación fue iniciado por una llamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A> o <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Detalles de la respuesta (mediante un <xref:System.Net.WebResponse> objeto).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> no se produce cuando la página de origen no se pudo encontrar o cargar, en cuyo caso <xref:System.Windows.Navigation.NavigationService.NavigationFailed> se genera.  
  
> [!NOTE]
>  Cuando <xref:System.Windows.Navigation.NavigationService> genera <xref:System.Windows.Navigation.NavigationService.NavigationFailed>, también provoca <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> evento en el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.Navigated>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se solicita una nueva navegación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> se produce cuando se solicita una nueva navegación, pero antes de la fuente se solicita contenido, incluyendo cuándo:  
  
-   Se llama a <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> o <xref:System.Windows.Navigation.NavigationService.GoForward%2A> se denomina (o se selecciona una entrada en un panel de navegación [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]).  
  
-   Se abrirá un fragmento de contenido.  
  
 Controlar <xref:System.Windows.Navigation.NavigationService.Navigating> si necesita detectar la información pertinente en relación con la solicitud de navegación antes de iniciarse la navegación. Esta información está disponible desde el <xref:System.Windows.Navigation.NavigatingCancelEventArgs> objeto que se pasa a la <xref:System.Windows.Navigation.NavigationService.Navigating> controlador de eventos.  
  
 A <xref:System.Net.WebRequest> objeto para el panel de navegación se haya creado y disponible desde el <xref:System.Windows.Navigation.NavigatingCancelEventArgs> parámetro; porque la solicitud real no se ha hecho en este momento, puede volver a configurar la <xref:System.Net.WebRequest> del objeto, si es necesario.  
  
 El usuario controle también <xref:System.Windows.Navigation.NavigatingCancelEventArgs> para cancelar la navegación, si fuese necesario, estableciendo <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> en true. Si cancela la navegación, no se produce ningún otro evento de navegación.  
  
> [!NOTE]
>  Si la aplicación se hospeda en el explorador, no se puede evitar que el usuario navegue fuera de su aplicación Cancelando el <xref:System.Windows.Navigation.NavigationService.Navigating> eventos.  
  
 Después de la primera parte del contenido se navega a un navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), cada fragmento de contenido que se navega fuera de se agrega al historial de navegación. Si tiene que guardar la información de estado sobre el contenido está navegando fuera de, puede agregar el estado de la entrada de diario para que el contenido estableciendo <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> con un <xref:System.Windows.Navigation.CustomContentState> objeto.  
  
> [!NOTE]
>  Cuando <xref:System.Windows.Navigation.NavigationService> genera <xref:System.Windows.Navigation.NavigationService.Navigating>, también provoca <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> evento en el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.Navigating> para detectar si se ha realizado una solicitud para actualizar el contenido estático y, si es así, cancelar la solicitud.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando surge un error al navegar al contenido solicitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando ya sea un <xref:System.Net.WebException> o un <xref:System.IO.IOException> se produce durante una navegación la <xref:System.Windows.Navigation.NavigationService.NavigationFailed> evento se desencadena. <xref:System.Windows.Navigation.NavigationService.NavigationFailed> se pasa un <xref:System.Windows.Navigation.NavigationFailedEventArgs> que encapsula la información sobre la excepción y los detalles de la navegación que produjo la excepción.  
  
 Cuando una excepción resultante de una navegación fallida y no está controlada, se generan los siguientes eventos en el orden indicado:  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> o <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 Si un navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) hospedada por uno o varios navegadores, `NavigationFailed` no se produce en cualquiera de ellos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce periódicamente durante una descarga y ofrece información sobre el progreso de la exploración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> se pasa un <xref:System.Windows.Navigation.NavigationProgressEventArgs> que expone la siguiente información de progreso:  
  
-   Número de bytes descargados hasta el momento (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>).  
  
-   Número total de bytes para descargar (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>).  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> se produce una vez por cada 1024 bytes del contenido descargado y una vez más si el número de bytes restantes es nunca inferior a 1024 bytes. Por esta razón, control <xref:System.Windows.Navigation.NavigationService.NavigationProgress> proporciona una forma útil de realizar un seguimiento y mostrar el progreso de una descarga actual.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> no se provocará en algunos casos, como cuando se navega en el mismo elemento de contenido o cuando un fragmento de contenido se abrirá en el contenido que está cargada actualmente (es decir, el valor de la <xref:System.Windows.Navigation.NavigationService.Content%2A> propiedad).  
  
 Al navegar a un recurso XAML compilado, la última <xref:System.Windows.Navigation.NavigationService.NavigationProgress> no se puede generar el evento. Esto significa que al final de la descarga, el último notificado <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> valor no puede igualar la <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> valor. Controlar la <xref:System.Windows.Navigation.NavigationService.LoadCompleted> eventos para recibir una notificación cuando haya terminado el panel de navegación.  
  
> [!NOTE]
>  Cuando <xref:System.Windows.Navigation.NavigationService> genera <xref:System.Windows.Navigation.NavigationService.NavigationProgress>, también provoca <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> evento en el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.NavigationProgress>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se llama al método <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> o cuando se solicita una nueva navegación mientras hay una navegación en curso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlar <xref:System.Windows.Navigation.NavigationService.NavigationStopped> si debe detectar la información pertinente en relación con la solicitud de navegación al detenerse la descarga. Esta información está disponible desde el <xref:System.Windows.Navigation.NavigationEventArgs> objeto que se pasa a la <xref:System.Windows.Navigation.NavigationService.NavigationStopped> controlador de eventos e incluye:  
  
-   El URI solicitado.  
  
-   El navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Datos adicionales, si el panel de navegación fue iniciado por una llamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> o <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Cuando <xref:System.Windows.Navigation.NavigationService> genera <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, también provoca <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> evento en el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar <xref:System.Windows.Navigation.NavigationService.NavigationStopped>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recarga el contenido actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el contenido actual (especificado por el valor de la <xref:System.Windows.Navigation.NavigationService.Source%2A> propiedad) se abrirá de nuevo, <xref:System.Windows.Navigation.NavigationService> descargar el contenido nuevo. Para forzar <xref:System.Windows.Navigation.NavigationService> para volver a navegar al contenido, llame a <xref:System.Windows.Navigation.NavigationService.Refresh%2A>.  
  
 Tenga en cuenta que si el contenido actual se abrirá de nuevo, ya sea llamando a <xref:System.Windows.Navigation.NavigationService.Navigate%2A> o <xref:System.Windows.Navigation.NavigationService.Refresh%2A>, no se agrega una nueva entrada en el historial de navegación.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita la entrada más reciente del diario del historial de retroceso de navegación.</summary>
        <returns>El objeto <see cref="T:System.Windows.Navigation.JournalEntry" /> más reciente del historial de retroceso de navegación, si lo hay.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si dos o varios navegadores (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) comparten el mismo historial de navegación, puede usar un navegador <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> para recuperar la entrada del historial de navegación hacia atrás para una navegación que tuvieron lugar en otro navegador.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el URI del contenido actual o el del nuevo contenido al que se está navegando actualmente.</summary>
        <value>Un <see cref="T:System.Uri" /> que contiene el URI para el contenido actual o el contenido que se navega actualmente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si establece esta propiedad en un URI diferente de la que se muestra actualmente, el navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) navega al URI especificado.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> se establece en el contenido que se carga desde el URI que se abrirá, a menos que se cancele la navegación.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> se puede establecer con un solo fragmento de URI y se puede establecer en `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detiene la descarga de contenido para la solicitud de navegación actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> se puede llamar en cuanto <xref:System.Windows.Navigation.NavigationService.Navigate%2A> devuelve y deja de navegación que está en curso en marcos secundarios.  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 Llamar a la <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> método genera el <xref:System.Windows.Navigation.NavigationService.NavigationStopped> eventos.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> se debe llamar en el mismo subproceso que inició la navegación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo detener la carga.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>