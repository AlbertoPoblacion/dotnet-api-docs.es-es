<Type Name="CodeGroup" FullName="System.Security.Policy.CodeGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ed7902f2adebda5a22b06a65e6b163e182e032e4" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500799" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeGroup" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeGroup extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Policy.CodeGroup" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeGroup" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeGroup abstract" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa la clase base abstracta de la que deben derivarse todas las implementaciones de grupos de código.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grupos de código son los bloques de creación de directiva de seguridad de acceso de código. Cada nivel de directiva consta de un grupo de código raíz que puede tener grupos de código secundarios. Cada grupo de código secundario puede tener sus propios grupos de código secundarios; Este comportamiento se extiende a cualquier número de niveles, que forman un árbol. Cada grupo de código tiene una condición de pertenencia que determina si un ensamblado dado pertenece a él basándose en la evidencia de ese ensamblado.  
  
 Se aplicará sólo a los grupos de código cuyas condiciones de pertenencia coincide con la evidencia de un ensamblado determinado. Si un grupo de código coincidente tiene grupos de código secundarios, del mismo modo se aplicarán esos elementos secundarios cuyas condiciones de pertenencia también coincide con la evidencia proporcionada.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeGroup (System.Security.Policy.IMembershipCondition membershipCondition, System.Security.Policy.PolicyStatement policy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Security.Policy.IMembershipCondition membershipCondition, class System.Security.Policy.PolicyStatement policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.#ctor(System.Security.Policy.IMembershipCondition,System.Security.Policy.PolicyStatement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (membershipCondition As IMembershipCondition, policy As PolicyStatement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeGroup(System::Security::Policy::IMembershipCondition ^ membershipCondition, System::Security::Policy::PolicyStatement ^ policy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="membershipCondition" Type="System.Security.Policy.IMembershipCondition" />
        <Parameter Name="policy" Type="System.Security.Policy.PolicyStatement" />
      </Parameters>
      <Docs>
        <param name="membershipCondition">Condición de pertenencia que comprueba la evidencia para determinar si este grupo de código aplica la directiva.</param>
        <param name="policy">Instrucción de directiva del grupo de código en forma de conjunto de permisos y atributos que se conceden al código que cumple la condición de pertenencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Policy.CodeGroup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un grupo de código básico y se debe llamar desde los constructores de grupos de código personalizado. Puede agregar grupos de código secundarios mediante la <xref:System.Security.Policy.CodeGroup.AddChild%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="membershipCondition" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El tipo del parámetro <paramref name="membershipCondition" /> no es válido.  
  
 O bien  
  
 El tipo del parámetro <paramref name="policy" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChild">
      <MemberSignature Language="C#" Value="public void AddChild (System.Security.Policy.CodeGroup group);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddChild(class System.Security.Policy.CodeGroup group) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.AddChild(System.Security.Policy.CodeGroup)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddChild (group As CodeGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddChild(System::Security::Policy::CodeGroup ^ group);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="group" Type="System.Security.Policy.CodeGroup" />
      </Parameters>
      <Docs>
        <param name="group">El grupo de código que se va a agregar como grupo secundario. Este nuevo grupo de código secundario se agrega al final de la lista.</param>
        <summary>Agrega un grupo de código secundario al grupo de código actual.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="group" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="group" /> no es un grupo de código válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="AttributeString">
      <MemberSignature Language="C#" Value="public virtual string AttributeString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AttributeString" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.AttributeString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AttributeString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AttributeString { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una representación en forma de cadena de los atributos de la instrucción de directiva del grupo de código.</summary>
        <value>Representación en forma de cadena de los atributos de la instrucción de directiva del grupo de código.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se encuentra la representación de cadena.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Collections.IList Children { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Children" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.Children" />
      <MemberSignature Language="VB.NET" Value="Public Property Children As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Children { System::Collections::IList ^ get(); void set(System::Collections::IList ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una lista ordenada de los grupos de código secundarios de un grupo de código.</summary>
        <value>Lista de grupos de código secundarios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden de los grupos de código secundarios es significativo para determinados grupos de código.  
  
> [!NOTE]
>  El valor devuelto es una copia de la lista de códigos secundarios. No utilice la lista devuelta para agregar un grupo de código secundario; en su lugar, use la <xref:System.Security.Policy.CodeGroup.AddChild%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer esta propiedad en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se ha intentado establecer esta propiedad con una lista de elementos secundarios que no son objetos <see cref="T:System.Security.Policy.CodeGroup" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.Policy.CodeGroup Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.CodeGroup Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As CodeGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Policy::CodeGroup ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, realiza una copia profunda del grupo de código actual.</summary>
        <returns>Una copia equivalente del grupo de código actual que incluye sus condiciones de pertenencia y los grupos de código secundarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una copia en profundidad del grupo de código, por lo que también se realizan copias de todos los objetos que contiene el grupo de código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXml">
      <MemberSignature Language="C#" Value="protected virtual void CreateXml (System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateXml(class System.Security.SecurityElement element, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateXml (element As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateXml(System::Security::SecurityElement ^ element, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="element">La codificación XML a la que se agrega la serialización.</param>
        <param name="level">Nivel de directiva donde está incluido el grupo de código.</param>
        <summary>Cuando se reemplaza en una clase derivada, serializa las propiedades y el estado interno específico de un grupo de código derivado y agrega la serialización al <see cref="T:System.Security.SecurityElement" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Policy.CodeGroup.ToXml%2A> no se puede invalidar. Si necesita serializar miembros específicos de una implementación concreta de <xref:System.Security.Policy.CodeGroup>, debe invalidar <xref:System.Security.Policy.CodeGroup.CreateXml%2A> y serializar allí sus miembros. Cuando se serializa el grupo de código, <xref:System.Security.Policy.CodeGroup.ToXml%2A> llamadas <xref:System.Security.Policy.CodeGroup.CreateXml%2A> y agrega la serialización para el <xref:System.Security.SecurityElement> creado por <xref:System.Security.Policy.CodeGroup.ToXml%2A>.  
  
 El XML creado mediante este método se deserializa el <xref:System.Security.Policy.CodeGroup.ParseXml%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si implementa este método, debe implementar la <see cref="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> método así.</para>
        </block>
        <altmember cref="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public string Description { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Description" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.Description" />
      <MemberSignature Language="VB.NET" Value="Public Property Description As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Description { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la descripción del grupo de código.</summary>
        <value>La descripción del grupo de código.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si dos grupos de código son equivalentes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Grupo de código que se va a comparar con el grupo de código actual.</param>
        <summary>Determina si el grupo de código especificado es equivalente al grupo de código actual.</summary>
        <returns>
          <see langword="true" /> si el grupo de código especificado es equivalente al grupo de código actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos grupos de código son equivalentes si tienen el mismo <xref:System.Security.Policy.CodeGroup.Name%2A>, <xref:System.Security.Policy.CodeGroup.Description%2A>, y <xref:System.Security.Policy.CodeGroup.MembershipCondition%2A>.  
  
 Este método comprueba el grupo de código de nivel superior únicamente, no sus grupos de código secundarios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Security.Policy.CodeGroup cg, bool compareChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Security.Policy.CodeGroup cg, bool compareChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.Equals(System.Security.Policy.CodeGroup,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (cg As CodeGroup, compareChildren As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Security::Policy::CodeGroup ^ cg, bool compareChildren);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cg" Type="System.Security.Policy.CodeGroup" />
        <Parameter Name="compareChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cg">Grupo de código que se va a comparar con el grupo de código actual.</param>
        <param name="compareChildren">
          <see langword="true" /> si se comparan los grupos de código secundarios; en caso contrario, <see langword="false" />.</param>
        <summary>Determina si el grupo de código especificado es equivalente al grupo de código actual, comprobando también los grupos de código secundarios, si se especifican.</summary>
        <returns>
          <see langword="true" /> si el grupo de código especificado es equivalente al grupo de código actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos grupos de código son equivalentes si tienen el mismo <xref:System.Security.Policy.CodeGroup.Name%2A>, <xref:System.Security.Policy.CodeGroup.Description%2A>, y <xref:System.Security.Policy.CodeGroup.MembershipCondition%2A>.  
  
 Si el `compareChildren` parámetro es `true`, este método solo devolverá `true` si el grupo de código actual y todos sus grupos de código secundarios son equivalentes al grupo de código especificado y todos sus grupos de código secundarios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromXml">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reconstruye un objeto de seguridad con un estado dado a partir de codificación XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public void FromXml (System.Security.SecurityElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FromXml(class System.Security.SecurityElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXml (e As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FromXml(System::Security::SecurityElement ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="e">Codificación XML que se usará para reconstruir el objeto de seguridad.</param>
        <summary>Reconstruye un objeto de seguridad con un estado dado a partir de codificación XML.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="e" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Security.Policy.CodeGroup.FromXml(System.Security.SecurityElement)" /> y <see cref="M:System.Security.Policy.CodeGroup.ToXml" /> no se puede invalidar. Si necesita cambiar la forma en que la implementación del grupo de código maneja el código XML, invalide el <see cref="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> y <see cref="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> métodos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public void FromXml (System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FromXml(class System.Security.SecurityElement e, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.FromXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXml (e As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FromXml(System::Security::SecurityElement ^ e, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="e">Codificación XML que se usará para reconstruir el objeto de seguridad.</param>
        <param name="level">Nivel de directiva donde está incluido el grupo de código.</param>
        <summary>Reconstruye un objeto de seguridad con un estado y un nivel de directiva dados a partir de codificación XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se proporciona el contexto de nivel de directiva para la resolución de conjuntos de permisos con nombre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="e" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Security.Policy.CodeGroup.FromXml(System.Security.SecurityElement)" /> y <see cref="M:System.Security.Policy.CodeGroup.ToXml" /> no se puede invalidar. Si necesita cambiar la forma en que la implementación del grupo de código maneja el código XML, invalide el <see cref="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> y <see cref="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> métodos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el código hash del grupo de código actual.</summary>
        <returns>Código hash del grupo de código actual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MembershipCondition">
      <MemberSignature Language="C#" Value="public System.Security.Policy.IMembershipCondition MembershipCondition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.IMembershipCondition MembershipCondition" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.MembershipCondition" />
      <MemberSignature Language="VB.NET" Value="Public Property MembershipCondition As IMembershipCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::IMembershipCondition ^ MembershipCondition { System::Security::Policy::IMembershipCondition ^ get(); void set(System::Security::Policy::IMembershipCondition ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.IMembershipCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la condición de pertenencia del grupo de código.</summary>
        <value>Condición de pertenencia que determina a qué evidencia se aplica el grupo de código.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una condición de pertenencia comprueba la evidencia y devuelve un valor booleano que indica si se encuentra una coincidencia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se ha intentado establecer este parámetro en <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeLogic">
      <MemberSignature Language="C#" Value="public abstract string MergeLogic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MergeLogic" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.MergeLogic" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MergeLogic As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ MergeLogic { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la lógica de combinación del grupo de código.</summary>
        <value>Una descripción de la lógica de combinación del grupo de código.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Esta propiedad es una cadena de descripción de la lógica de combinación utilizada por el grupo de código para resolver los permisos concedidos por sus grupos de código secundarios. Está diseñado para ayudar a los administradores que usan el grupo de código, pero no se utiliza el sistema de la directiva.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del grupo de código.</summary>
        <value>Nombre del grupo de código.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseXml">
      <MemberSignature Language="C#" Value="protected virtual void ParseXml (System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ParseXml(class System.Security.SecurityElement e, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ParseXml (e As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ParseXml(System::Security::SecurityElement ^ e, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="e">Codificación XML que se usará para reconstruir el objeto de seguridad.</param>
        <param name="level">Nivel de directiva donde está incluido el grupo de código.</param>
        <summary>Cuando se reemplaza en una clase derivada, reconstruye las propiedades y el estado interno específico de un grupo de código derivado del <see cref="T:System.Security.SecurityElement" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Policy.CodeGroup.FromXml%2A> no se puede invalidar. Si necesita deserializar miembros específicos de una implementación concreta de <xref:System.Security.Policy.CodeGroup>, debe invalidar <xref:System.Security.Policy.CodeGroup.ParseXml%2A> y deserializar allí sus miembros. Cuando se deserializa el grupo de código, <xref:System.Security.Policy.CodeGroup.FromXml%2A> llamadas <xref:System.Security.Policy.CodeGroup.ParseXml%2A> y reconstruye los miembros de la <xref:System.Security.SecurityElement>.  
  
 Este método deserializa el código XML creado mediante <xref:System.Security.Policy.CodeGroup.CreateXml%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si implementa este método, debe implementar la <see cref="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> método así.</para>
        </block>
        <altmember cref="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      </Docs>
    </Member>
    <Member MemberName="PermissionSetName">
      <MemberSignature Language="C#" Value="public virtual string PermissionSetName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PermissionSetName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.PermissionSetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ PermissionSetName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del conjunto de permisos con nombre del grupo de código.</summary>
        <value>El nombre de un conjunto de permisos con nombre del nivel de directiva.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad puede ser `null` si el grupo de código contiene un conjunto de permisos sin nombre.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PolicyStatement">
      <MemberSignature Language="C#" Value="public System.Security.Policy.PolicyStatement PolicyStatement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyStatement PolicyStatement" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.CodeGroup.PolicyStatement" />
      <MemberSignature Language="VB.NET" Value="Public Property PolicyStatement As PolicyStatement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::PolicyStatement ^ PolicyStatement { System::Security::Policy::PolicyStatement ^ get(); void set(System::Security::Policy::PolicyStatement ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyStatement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la instrucción de directiva asociada al grupo de código.</summary>
        <value>La instrucción de directiva del grupo de código.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La instrucción de directiva se aplica a código en los ensamblados cuando la evidencia cumple la condición de pertenencia.  
  
 Esta propiedad puede establecerse también pasando una instrucción de directiva al constructor.  
  
   
  
## Examples  
 El ejemplo siguiente se establece el <xref:System.Security.Policy.PolicyStatement> para un grupo de código.  
  
 [!code-cpp[Classic CodeGroup.PolicyStatement Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic CodeGroup.PolicyStatement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CodeGroup.PolicyStatement Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic CodeGroup.PolicyStatement Example/CS/source.cs#1)]
 [!code-vb[Classic CodeGroup.PolicyStatement Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic CodeGroup.PolicyStatement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveChild">
      <MemberSignature Language="C#" Value="public void RemoveChild (System.Security.Policy.CodeGroup group);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveChild(class System.Security.Policy.CodeGroup group) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.RemoveChild(System.Security.Policy.CodeGroup)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveChild (group As CodeGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveChild(System::Security::Policy::CodeGroup ^ group);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="group" Type="System.Security.Policy.CodeGroup" />
      </Parameters>
      <Docs>
        <param name="group">Grupo de código que se va a quitar como grupo secundario.</param>
        <summary>Quita el grupo de código secundario especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con este método se pueden quitar solo los grupos de código secundarios inmediatos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="group" /> no es un grupo de código secundario inmediato del grupo de código actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public abstract System.Security.Policy.PolicyStatement Resolve (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.PolicyStatement Resolve(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.Resolve(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Policy::PolicyStatement ^ Resolve(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyStatement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Prueba del ensamblado.</param>
        <summary>Cuando se reemplaza en una clase derivada, resuelve la directiva del grupo de código y sus descendientes para un conjunto de evidencias.</summary>
        <returns>Una instrucción de directiva que contiene los permisos concedidos por el grupo de código con atributos opcionales, o <see langword="null" /> si el grupo de código no se aplica (la evidencia especificada no cumple la condición de pertenencia).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada la evidencia de un ensamblado que se va a cargar, este método se evalúa como el grupo de código mediante la comprobación de la condición de pertenencia con la evidencia especificada. Si se encuentra una coincidencia, este método devuelve una instrucción de directiva para el grupo de código, incluida la evaluación de los grupos de código secundarios.  
  
 Para una <xref:System.Security.Policy.UnionCodeGroup>, todos los grupos de código secundarios cuya condición de pertenencia coincide con la evidencia especificada también se resuelven, y todas las instrucciones de directiva resultantes se combinan con la instrucción de directiva del grupo de código de unión primario. Cada tipo de grupo de código secundario determina cómo se aplican todos sus grupos secundarios, según cómo <xref:System.Security.Policy.CodeGroup.Resolve%2A> funcionen métodos de estos grupos secundarios.  
  
 El sistema de seguridad de .NET Framework usa <xref:System.Security.Policy.CodeGroup.Resolve%2A> en los niveles de directiva para determinar qué permisos se conceden al código cargado desde el código y las instrucciones de directiva resultante de solicitud en el ensamblado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveMatchingCodeGroups">
      <MemberSignature Language="C#" Value="public abstract System.Security.Policy.CodeGroup ResolveMatchingCodeGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.ResolveMatchingCodeGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Policy::CodeGroup ^ ResolveMatchingCodeGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Prueba del ensamblado.</param>
        <summary>Cuando se reemplaza en una clase derivada, resuelve los grupos de código coincidentes.</summary>
        <returns>Un objeto <see cref="T:System.Security.Policy.CodeGroup" /> que es el nodo raíz del árbol de grupos de código coincidentes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método tiene las mismas características de evaluación que <xref:System.Security.Policy.CodeGroup.Resolve%2A>. El grupo de código devuelto contiene grupos de código secundarios, lo que a su vez pueden tener grupos de código secundarios según sea necesario para representar el conjunto completo de grupos de código que se corresponden con la evidencia proporcionada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToXml">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una codificación XML del objeto de seguridad y su estado actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una codificación XML del objeto de seguridad y su estado actual.</summary>
        <returns>Codificación XML del objeto de seguridad, incluida cualquier información de estado.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Security.Policy.CodeGroup.FromXml(System.Security.SecurityElement)" /> y <see cref="M:System.Security.Policy.CodeGroup.ToXml" /> no se puede invalidar. Si necesita cambiar la forma en que la implementación del grupo de código maneja el código XML, invalide el <see cref="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> y <see cref="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> métodos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public System.Security.SecurityElement ToXml (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecurityElement ToXml(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.CodeGroup.ToXml(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml (level As PolicyLevel) As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecurityElement ^ ToXml(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">Nivel de directiva donde está incluido el grupo de código.</param>
        <summary>Crea una codificación XML del objeto de seguridad, de su estado actual y del nivel de directiva donde está incluido el código.</summary>
        <returns>Codificación XML del objeto de seguridad, incluida cualquier información de estado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se proporciona el contexto de nivel de directiva para la resolución de conjuntos de permisos con nombre.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Security.Policy.CodeGroup.FromXml(System.Security.SecurityElement)" /> y <see cref="M:System.Security.Policy.CodeGroup.ToXml" /> no se puede invalidar. Si necesita cambiar la forma en que la implementación del grupo de código maneja el código XML, invalide el <see cref="M:System.Security.Policy.CodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> y <see cref="M:System.Security.Policy.CodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" /> métodos.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>