<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XNode.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5f001654247344cf25b9ac07d23e7fb08ac4c201a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f001654247344cf25b9ac07d23e7fb08ac4c201a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</source>
          <target state="translated">Representa el concepto abstracto de un nodo (elemento, comentario, tipo de documento, instrucción de procesamiento o nodo de texto) del árbol XML.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> is an abstract common base class for the following types:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> es una clase base común abstracta para los siguientes tipos:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> is an abstract common base class for the following types:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> es una clase base común abstracta para los siguientes tipos:</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Objects of classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> can contain child nodes.</source>
          <target state="translated">Objetos de las clases que derivan de <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> puede contener nodos secundarios.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> is not an <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> no es un <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Attributes are maintained as a list of name/value pairs on an element.</source>
          <target state="translated">Los atributos se mantienen como una lista de pares de nombre/valor en un elemento.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</source>
          <target state="translated">Si está escribiendo una aplicación XML compleja, como un editor XML o un procesador de textos que almacena el contenido como XML, a menudo funcionará en el nivel de nodo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</source>
          <target state="translated">Las actividades típicas al trabajar en el nivel de nodo incluyen agregar nodos, eliminar nodos, transformar nodos y recorrer en iteración los ejes que devuelven colecciones de nodos.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">Agrega el contenido especificado inmediatamente a continuación de este nodo.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">En el ejemplo siguiente se usa una consulta LINQ para crear un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, que, a continuación, pasa a este método.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Esto agrega los resultados de una consulta al árbol en la ubicación deseada.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>A content object that contains simple content or a collection of content objects to be added after this node.</source>
          <target state="translated">Objeto de contenido que incluye contenido simple o una colección de objetos de contenido que se van a agregar a continuación de este nodo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">Agrega el contenido especificado inmediatamente a continuación de este nodo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Eventos <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>The following example uses this method to add an element into the tree.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para agregar un elemento en el árbol.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del elemento primario es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">Lista de parámetros de objetos de contenido.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">Agrega el contenido especificado inmediatamente a continuación de este nodo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">En el ejemplo siguiente se usa una consulta LINQ para crear un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, que, a continuación, pasa a este método.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Esto agrega los resultados de una consulta al árbol en la ubicación deseada.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del elemento primario es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">Agrega el contenido especificado inmediatamente antes de este nodo.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child notes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus notas secundarias como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Therefore, using this method might  affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">En el ejemplo siguiente se usa una consulta LINQ para crear un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, que, a continuación, pasa a este método.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Esto agrega los resultados de una consulta al árbol en la ubicación deseada.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>A content object that contains simple content or a collection of content objects to be added before this node.</source>
          <target state="translated">Un objeto de contenido que incluye contenido simple o una colección de objetos de contenido que se van a agregar antes de este nodo.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">Agrega el contenido especificado inmediatamente antes de este nodo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>Therefore, using this method might  affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The following example uses this method to add an element into the tree.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para agregar un elemento en el árbol.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del elemento primario es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">Lista de parámetros de objetos de contenido.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">Agrega el contenido especificado inmediatamente antes de este nodo.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>Therefore, using this function might affect your performance.</source>
          <target state="translated">Por lo tanto, con esta función puede afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">En el ejemplo siguiente se usa una consulta LINQ para crear un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, que, a continuación, pasa a este método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Esto agrega los resultados de una consulta al árbol en la ubicación deseada.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del elemento primario es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the ancestor elements of this node.</source>
          <target state="translated">Devuelve una colección de los elementos antecesores de este nodo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Optionally a node name can be specified to filter for ancestor elements with a specific name.</source>
          <target state="translated">Opcionalmente, puede especificarse un nombre de nodo para filtrar los elementos antecesores con un nombre específico.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">Los nodos de la colección devuelta están en el orden del documento inverso.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>Returns a collection of the ancestor elements of this node.</source>
          <target state="translated">Devuelve una colección de los elementos antecesores de este nodo.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the ancestor elements of this node.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> de los elementos antecesores de este nodo.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This method does not return itself in the results.</source>
          <target state="translated">Este método no se devuelve en los resultados.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">Los nodos de la colección devuelta están en el orden del documento inverso.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>The following example uses this method to enumerate the ancestors of a node.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para enumerar a los antecesores de un nodo.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the ancestor elements of this node.</source>
          <target state="translated">Devuelve una colección filtrada de los elementos antecesores de este nodo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">En la colección sólo se incluyen los elementos que tienen un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> coincidente.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the ancestor elements of this node.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> de los elementos antecesores de este nodo.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">En la colección sólo se incluyen los elementos que tienen un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> coincidente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">Los nodos de la colección devuelta están en el orden del documento inverso.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This method will not return itself in the results.</source>
          <target state="translated">Este método no devolverá propio en los resultados.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The following example uses this method.</source>
          <target state="translated">En el ejemplo siguiente se usa este método.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>First <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Primera <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Segunda <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Compares two nodes to determine their relative XML document order.</source>
          <target state="translated">Compara dos nodos para determinar el orden relativo de sus documentos XML.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>An <ph id="ph1">&lt;see langword="int" /&gt;</ph> containing 0 if the nodes are equal; -1 if <ph id="ph2">&lt;paramref name="n1" /&gt;</ph> is before <ph id="ph3">&lt;paramref name="n2" /&gt;</ph>; 1 if <ph id="ph4">&lt;paramref name="n1" /&gt;</ph> is after <ph id="ph5">&lt;paramref name="n2" /&gt;</ph>.</source>
          <target state="translated">Valor de tipo <ph id="ph1">&lt;see langword="int" /&gt;</ph> que contiene 0 si los nodos son iguales; -1 si <ph id="ph2">&lt;paramref name="n1" /&gt;</ph> está antes de <ph id="ph3">&lt;paramref name="n2" /&gt;</ph>; 1 si <ph id="ph4">&lt;paramref name="n1" /&gt;</ph> está después de <ph id="ph5">&lt;paramref name="n2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> método debe recorrer los antecesores de los dos nodos que se están comparados hasta que encuentra el elemento primario común.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">A continuación, debe recorrer la lista de nodos de elemento secundario del elemento primario común para determinar el orden de los dos nodos que se están comparando.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">En el ejemplo siguiente se usa este método.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The two nodes do not share a common ancestor.</source>
          <target state="translated">Los dos nodos no comparten un antecesor común.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this node.</source>
          <target state="translated">Crea un objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> para este nodo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this node.</source>
          <target state="translated">Crea un objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> para este nodo.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that can be used to read this node and its descendants.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> que se puede usar para leer este nodo y sus descendientes.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>You typically use this method when you have to supply another component with an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Este método utiliza normalmente cuando se debe proporcionar otro componente con un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>For example, you can create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from a <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> tree, and then pass that reader to <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>.</source>
          <target state="translated">Por ejemplo, puede crear un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> desde una <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> del árbol y, a continuación, pasar ese lector para <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>All of the readers returned by <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> are normalizing readers.</source>
          <target state="translated">Todos los lectores devueltos por <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> son los lectores de normalización.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>They always perform line break normalization and full normalization of attributes.</source>
          <target state="translated">Siempre realizan la normalización de saltos de línea y la normalización completa de atributos.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> is not a normalizing reader.</source>
          <target state="translated">En cambio, el <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> devuelto por <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> no es un lector de normalización.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>It does not transform any white space.</source>
          <target state="translated">No se transforma los espacios en blanco.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>It also returns attributes in the order that they were added, not in attribute name order.</source>
          <target state="translated">También devuelve los atributos en el orden que se agregaron, no en el orden del nombre de atributo.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> does not keep information about whether attributes are default attributes.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> no se mantiene la información sobre si los atributos son atributos predeterminados.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> will always return false regardless of whether the attribute was populated from a default value or not.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> siempre devolverá false, independientemente de si el atributo se rellena un valor predeterminado o no.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The <ph id="ph1">`PUBLIC`</ph> and <ph id="ph2">`SYSTEM`</ph> pseudo attributes on <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> are not available through the <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">`PUBLIC`</ph> y <ph id="ph2">`SYSTEM`</ph> pseudo atributos en <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> no están disponibles a través de la <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>They are only available through the <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> method that takes the qualified name of the attribute as a parameter.</source>
          <target state="translated">Solo están disponibles a través de la <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> método que toma el nombre completo del atributo como un parámetro.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>If you have to retrieve the <ph id="ph1">`PUBLIC`</ph> or <ph id="ph2">`SYSTEM`</ph> attributes, you should use the <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si tiene que recuperar el <ph id="ph1">`PUBLIC`</ph> o <ph id="ph2">`SYSTEM`</ph> atributos, debe usar el <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Base64 and BinHex data are not supported.</source>
          <target state="translated">No se admiten datos Base64 y BinHex.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>If you attempt to retrieve these types of data (for example, by calling <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), the reader will throw <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si intenta recuperar estos tipos de datos (por ejemplo, mediante una llamada a <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), se iniciará el lector <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The <ph id="ph1">`xml`</ph> declaration is not surfaced by the reader.</source>
          <target state="translated">El <ph id="ph1">`xml`</ph> declaración no aparece por el lector.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>While reading, you will not encounter a node of type <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>.</source>
          <target state="translated">Durante la lectura, no se encontrará con un nodo de tipo <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The following example creates an XML tree, creates an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> method, and creates an <ph id="ph3">&lt;xref:System.Xml.XmlDocument&gt;</ph> by using the reader.</source>
          <target state="translated">En el ejemplo siguiente se crea un árbol XML, crea un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> mediante el uso de la <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> método y crea un <ph id="ph3">&lt;xref:System.Xml.XmlDocument&gt;</ph> mediante el lector.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Another use for this method is to do an XSLT transformation.</source>
          <target state="translated">Otro uso de este método es realizar una transformación XSLT.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>You can create an XML tree, create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from the XML tree, create a new document, and create an <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> that will write into the new document.</source>
          <target state="translated">Puede crear un árbol XML, crear un objeto <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> desde el árbol XML, crear un nuevo documento y crear un objeto <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> que escribirá en el nuevo documento.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Then, you can invoke the XSLT transformation, passing the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> to the transformation.</source>
          <target state="translated">A continuación, puede invocar la transformación XSLT y pasar <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> a la transformación.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>After the transformation successfully completes, the new XML tree is populated with the results of the transform.</source>
          <target state="translated">Después de que se complete correctamente la transformación, se rellenará el nuevo árbol XML con los resultados de la transformación.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.ReaderOptions" /&gt;</ph> object that specifies whether to omit duplicate namespaces.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.ReaderOptions" /&gt;</ph> que especifica si se van a omitir los espacios de nombres duplicados.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> with the options specified by the <ph id="ph2">&lt;paramref name="readerOptions" /&gt;</ph> parameter.</source>
          <target state="translated">Crea una clase <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> con las opciones especificadas por el parámetro <ph id="ph2">&lt;paramref name="readerOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> object.</source>
          <target state="translated">Un objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Primer objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Segundo objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Compares the values of two nodes, including the values of all descendant nodes.</source>
          <target state="translated">Compara los valores de dos nodos, incluidos los valores de todos los nodos descendientes.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the nodes are equal; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si los nodos son iguales; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following criteria determine whether two nodes are equal:</source>
          <target state="translated">Los siguientes criterios determinan si dos nodos son iguales:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>A <ph id="ph1">`null`</ph> node is equal to another <ph id="ph2">`null`</ph> node but unequal to a non-<ph id="ph3">`null`</ph> node.</source>
          <target state="translated">A <ph id="ph1">`null`</ph> es igual a otro nodo <ph id="ph2">`null`</ph> nodo pero diferente de no<ph id="ph3">`null`</ph> nodo.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects of different types are never equal.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos de diferentes tipos nunca son iguales.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> nodes are equal if they contain the same text.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> nodos son iguales si contienen el mismo texto.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> nodos son iguales si tienen el mismo nombre de etiqueta, el mismo conjunto de atributos con los mismos valores y (omitiendo los comentarios y las instrucciones de procesamiento) contienen dos secuencias de igual longitud de nodos de contenido iguales.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> nodes are equal if their root nodes are equal.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> nodos son iguales si sus nodos raíz son iguales.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> nodes are equal if they contain the same comment text.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> nodos son iguales si contienen el mismo texto del comentario.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> nodes are equal if they have the same target and data.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> nodos son iguales si tienen el mismo objetivo y datos.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> nodes are equal if the have the same name, public ID, system ID, and internal subset.</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> nodos son iguales si los tiene el mismo nombre, el identificador público, el Id. del sistema y el subconjunto interno.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following example uses this method to compare two XML trees.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para comparar dos árboles XML.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>Gets a comparer that can compare the relative position of two nodes.</source>
          <target state="translated">Obtiene un comparador que compara la posición relativa de dos nodos.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /&gt;</ph> that can compare the relative position of two nodes.</source>
          <target state="translated">Clase <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /&gt;</ph> que puede comparar la posición relativa de dos nodos.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>This property is primarily used internally for implementing the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> extension method.</source>
          <target state="translated">Esta propiedad se usa principalmente para implementar el <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> método de extensión.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>The recommended approach is to use that extension method instead of using this property directly.</source>
          <target state="translated">El enfoque recomendado es usar ese método de extensión en lugar de usar esta propiedad directamente.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>The following example creates an XML tree with some elements.</source>
          <target state="translated">En el ejemplo siguiente se crea un árbol XML con algunos elementos.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>It then creates a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> that contains some elements from the XML tree at random.</source>
          <target state="translated">A continuación, se crea un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> que contiene algunos elementos del árbol XML de forma aleatoria.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>It sorts the list, using this property to retrieve a <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeDocumentOrderComparer&gt;</ph>, which implements the <ph id="ph2">&lt;xref:System.Collections.IComparer?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</source>
          <target state="translated">Ordena la lista, utilizando esta propiedad para recuperar un <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeDocumentOrderComparer&gt;</ph>, que implementa el <ph id="ph2">&lt;xref:System.Collections.IComparer?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
          <target state="translated">Devuelve una colección de los elementos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
          <target state="translated">Devuelve una colección de los elementos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements after this node, in document order.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> de los elementos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Este método sólo incluye elementos del mismo nivel en la colección devuelta.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>It does not include descendants.</source>
          <target state="translated">No incluye a descendientes.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>The following example creates an element with some complex content.</source>
          <target state="translated">En el ejemplo siguiente se crea un elemento con algún contenido complejo.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>It then uses this method to retrieve the nodes in document order.</source>
          <target state="translated">A continuación, se usa este método para recuperar los nodos en orden del documento.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the sibling elements after this node, in document order.</source>
          <target state="translated">Devuelve una colección filtrada de los elementos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">En la colección sólo se incluyen los elementos que tienen un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> coincidente.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements after this node, in document order.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> de los elementos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">En la colección sólo se incluyen los elementos que tienen un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> coincidente.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Este método sólo incluye elementos del mismo nivel en la colección devuelta.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>It does not include descendants.</source>
          <target state="translated">No incluye a descendientes.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>The following example creates an element with some complex content.</source>
          <target state="translated">En el ejemplo siguiente se crea un elemento con algún contenido complejo.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>It then uses this method to retrieve the sibling elements, in document order.</source>
          <target state="translated">A continuación, se usa este método para recuperar los elementos del mismo nivel, en orden del documento.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
          <target state="translated">Devuelve una colección de los elementos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
          <target state="translated">Devuelve una colección de los elementos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements before this node, in document order.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> de los elementos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Este método sólo incluye elementos del mismo nivel en la colección devuelta.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>It does not include descendants.</source>
          <target state="translated">No incluye a descendientes.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>The following example uses this axis method.</source>
          <target state="translated">En el ejemplo siguiente se usa este método de eje.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> que se va a comparar.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the sibling elements before this node, in document order.</source>
          <target state="translated">Devuelve una colección filtrada de los elementos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">En la colección sólo se incluyen los elementos que tienen un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> coincidente.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements before this node, in document order.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> de los elementos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">En la colección sólo se incluyen los elementos que tienen un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> coincidente.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Este método sólo incluye elementos del mismo nivel en la colección devuelta.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>It does not include descendants.</source>
          <target state="translated">No incluye a descendientes.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>The following example uses this method.</source>
          <target state="translated">En el ejemplo siguiente se usa este método.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>Gets a comparer that can compare two nodes for value equality.</source>
          <target state="translated">Obtiene un comparador que comprueba si los valores de dos nodos son iguales.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeEqualityComparer" /&gt;</ph> that can compare two nodes for value equality.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeEqualityComparer" /&gt;</ph> que compara si los valores de dos nodos son iguales.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>The following example uses this property to retrieve an <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeEqualityComparer&gt;</ph>, which implements the <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</source>
          <target state="translated">En el ejemplo siguiente se utiliza esta propiedad para recuperar un <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeEqualityComparer&gt;</ph>, que implementa el <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>It creates a dictionary that uses this property.</source>
          <target state="translated">Crea un diccionario que usa esta propiedad.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare for document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que se va a comparar respecto al orden del documento.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Determines if the current node appears after a specified node in terms of document order.</source>
          <target state="translated">Determina si el nodo actual aparece después de un nodo especificado respecto al orden del documento.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this node appears after the specified node; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este nodo aparece después del nodo especificado; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> método debe recorrer los antecesores de los dos nodos que se están comparados hasta que encuentra el elemento primario común.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">A continuación, debe recorrer la lista de nodos de elemento secundario del elemento primario común para determinar el orden de los dos nodos que se están comparando.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">En el ejemplo siguiente se usa este método.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare for document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que se va a comparar respecto al orden del documento.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Determines if the current node appears before a specified node in terms of document order.</source>
          <target state="translated">Determina si el nodo actual aparece antes de un nodo especificado respecto al orden del documento.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this node appears before the specified node; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este nodo aparece antes del nodo especificado; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> método debe recorrer los antecesores de los dos nodos que se están comparados hasta que encuentra el elemento primario común.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">A continuación, debe recorrer la lista de nodos de elemento secundario del elemento primario común para determinar el orden de los dos nodos que se están comparando.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">En el ejemplo siguiente se usa este método.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>Gets the next sibling node of this node.</source>
          <target state="translated">Obtiene el siguiente nodo relacionado de este nodo.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the next sibling node.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que contiene el nodo relacionado siguiente.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no next node, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si este <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does no tiene un elemento primario, o si no hay ningún nodo siguiente, esta propiedad devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>The following example uses this property to loop through nodes.</source>
          <target state="translated">En el ejemplo siguiente se usa esta propiedad para recorrer los nodos.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>Returns a collection of the sibling nodes after this node, in document order.</source>
          <target state="translated">Devuelve una colección de los nodos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> of the sibling nodes after this node, in document order.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> de los nodos relacionados situados detrás de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Este método sólo incluye elementos del mismo nivel en la colección devuelta.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>It does not include descendants.</source>
          <target state="translated">No incluye a descendientes.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>The following example creates an XML tree, and then queries the tree using this axis method.</source>
          <target state="translated">En el ejemplo siguiente se crea un árbol XML y, a continuación, consulta el árbol mediante este método de eje.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>Returns a collection of the sibling nodes before this node, in document order.</source>
          <target state="translated">Devuelve una colección de los nodos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> of the sibling nodes before this node, in document order.</source>
          <target state="translated">Interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> de los nodos relacionados situados antes de este nodo en el orden del documento.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Este método sólo incluye elementos del mismo nivel en la colección devuelta.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>It does not include descendants.</source>
          <target state="translated">No incluye a descendientes.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Este método usa la ejecución diferida.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>The following example creates an XML tree, and then queries the tree using this axis method.</source>
          <target state="translated">En el ejemplo siguiente se crea un árbol XML y, a continuación, consulta el árbol mediante este método de eje.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>Gets the previous sibling node of this node.</source>
          <target state="translated">Obtiene el anterior nodo relacionado de este nodo.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the previous sibling node.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que contiene el nodo relacionado anterior.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no previous node, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si este <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does no tiene un elemento primario, o si no hay ningún nodo anterior, esta propiedad devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> property must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> propiedad debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>Therefore, using this property might affect your performance.</source>
          <target state="translated">Por lo tanto, uso de esta propiedad podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The following example uses this property to loop through nodes.</source>
          <target state="translated">En el ejemplo siguiente se usa esta propiedad para recorrer los nodos.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> positioned at the node to read into this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> situado en el nodo para leer <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> from an <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Crea un objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> a partir de un objeto <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the node and its descendant nodes that were read from the reader.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> que contiene el nodo y sus nodos descendientes que se leyeron desde el lector.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The runtime type of the node is determined by the node type (<ph id="ph1">&lt;see cref="P:System.Xml.Linq.XObject.NodeType" /&gt;</ph>) of the first node encountered in the reader.</source>
          <target state="translated">El tipo de nodo (<ph id="ph1">&lt;see cref="P:System.Xml.Linq.XObject.NodeType" /&gt;</ph>) del primer nodo situado en el lector determina el tipo del nodo en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</source>
          <target state="translated">Puede usar este método para escribir un método que devuelve una colección de nodos, lo que produce cada nodo tal y como se lee el nodo desde el lector.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This method enables you to process arbitrarily large XML files with a very small memory footprint.</source>
          <target state="translated">Este método permite procesar archivos XML de arbitrariamente grandes con una superficie de memoria muy pequeña.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The reader that you pass to this method might throw exceptions.</source>
          <target state="translated">El lector que se pasa a este método podría producir excepciones.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> no se detectan todas las excepciones iniciadas por el lector; las excepciones no controladas ascienden a código que llamó a <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>In particular, your code should be prepared to handle <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>.</source>
          <target state="translated">En concreto, el código debe estar preparado para afrontar <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>For an example of how to stream a more complex document, see <bpt id="p1">[</bpt>How to: Stream XML Fragments with Access to Header Information<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>.</source>
          <target state="translated">Para obtener un ejemplo de cómo transmitir por secuencias un documento más complejo, consulte <bpt id="p1">[</bpt>Cómo: transmitir por secuencias fragmentos de XML con acceso a la información de encabezado<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Certain standard query operators, such as <ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</source>
          <target state="translated">Ciertos operadores de consulta estándar, como <ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>, recorren en iteración su origen, recaban todos los datos, los ordenan y finalmente producen el primer elemento de la secuencia.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</source>
          <target state="translated">Si usa un operador de consulta que materializa su origen antes de producir el primer elemento, no retendrá una superficie de memoria pequeña.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>For an example of using <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> to transform extremely large XML documents while maintaining a small memory footprint, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
          <target state="translated">Para obtener un ejemplo del uso de <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> para transformar documentos XML sumamente grandes manteniendo una superficie de memoria pequeña, vea <bpt id="p1">[</bpt>Cómo: realizar una transformación de transmisión por secuencias de documentos XML grandes<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example uses the following XML file, named Source.xml:</source>
          <target state="translated">En este ejemplo se utiliza el siguiente archivo XML, denominado Source.xml:</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example creates a custom axis method that uses <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
          <target state="translated">Este ejemplo crea un método de eje personalizado que utiliza <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>You can query the custom axis by using a LINQ query.</source>
          <target state="translated">Puede consultar el eje personalizado mediante una consulta LINQ.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The following example uses the yield return construct of C#.</source>
          <target state="translated">En el ejemplo siguiente se utiliza la construcción de valor devuelto de rendimiento de C#.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Because there is no equivalent feature in <ph id="ph1">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph>, this example is provided only in C#.</source>
          <target state="translated">Puesto que no hay ninguna característica equivalente en <ph id="ph1">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph>, este ejemplo sólo se proporciona en C#.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example produces the following output.</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> is not positioned on a recognized node type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> no se coloca en un tipo de nodo reconocido.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The underlying <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> throws an exception.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> subyacente produce una excepción.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Removes this node from its parent.</source>
          <target state="translated">Quita este nodo de su elemento primario.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>In <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</source>
          <target state="translated">En <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> de programación, no debe manipular o modificar un conjunto de nodos mientras esté consultando los nodos de ese conjunto.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>In practical terms, this means that you should not iterate over a set of nodes and remove them.</source>
          <target state="translated">En la práctica, esto significa que no debe recorrer en iteración un conjunto de nodos y quitarlos.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Instead, you should materialize them into a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> extension method.</source>
          <target state="translated">En su lugar, debe materializarlos en un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> utilizando el <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> método de extensión.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Then, you can iterate over the list to remove the nodes.</source>
          <target state="translated">A continuación, puede recorrer en iteración la lista para quitar los nodos.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>For more information, see <bpt id="p1">[</bpt>Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>mixto declarativa/errores de código imperativo (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Alternatively, if you want to remove a set of nodes, it is recommended that you use the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">O bien, si desea quitar un conjunto de nodos, se recomienda que utilice la <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This method copies the nodes to a list, and then iterates over the list to remove the nodes.</source>
          <target state="translated">Este método copia los nodos en una lista y, a continuación, recorre en iteración la lista para quitar los nodos.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The following example removes a node from its parent.</source>
          <target state="translated">En el ejemplo siguiente se quita un nodo de su elemento primario.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor del elemento primario es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">Reemplaza este nodo por el contenido especificado.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must  traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses this method to replace the contents of a node with different content.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para reemplazar el contenido de un nodo con contenido diferente.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Content that replaces this node.</source>
          <target state="translated">Contenido que reemplaza este nodo.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">Reemplaza este nodo por el contenido especificado.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
          <target state="translated">Este método quita primero el nodo de su elemento primario y, a continuación, agrega el contenido especificado al elemento primario de este nodo, en lugar de este nodo.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>The following example uses this method to replace the contents of a node with different content.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para reemplazar el contenido de un nodo con contenido diferente.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>A parameter list of the new content.</source>
          <target state="translated">Lista de parámetros del nuevo contenido.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">Reemplaza este nodo por el contenido especificado.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
          <target state="translated">Este método quita primero el nodo de su elemento primario y, a continuación, agrega el contenido especificado al elemento primario de este nodo, en lugar de este nodo.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> almacena sus nodos secundarios como una lista vinculada individualmente de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Esto significa que el <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> método debe recorrer la lista de nodos secundarios directos en el contenedor primario.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Por lo tanto, con este método podría afectar a su rendimiento.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Para obtener más información sobre el contenido válido que se puede pasar a este método, consulte <bpt id="p1">[</bpt>válido contenido de objetos XElement y XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Este método producirá la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> y <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>The following example shows using the results of a <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> query as the input to this method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de los resultados de una <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> consulta como entrada a este método.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
          <target state="translated">Devuelve el XML de este nodo y, opcionalmente, deshabilita el formato.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString">
          <source>Returns the indented XML for this node.</source>
          <target state="translated">Devuelve el XML con sangría para este nodo.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the indented XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene el XML con sangría.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString">
          <source>The following example uses this method to retrieve indented XML.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para recuperar datos XML con sangría.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> that specifies formatting behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> que especifica el comportamiento de formato.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
          <target state="translated">Devuelve el XML de este nodo y, opcionalmente, deshabilita el formato.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene el XML.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>The following example uses this method to retrieve unformatted and formatted XML.</source>
          <target state="translated">En el ejemplo siguiente se usa este método para recuperar el XML sin formato y con formato.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> into which this method will write.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> en el que escribirá este método.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>Writes this node to an <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Escribe este nodo en un objeto <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>You can use this method to write code that does a streaming transform of a very large document.</source>
          <target state="translated">Puede usar este método para escribir código que realiza una transformación de transmisión por secuencias de un documento muy grande.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Cómo: realizar una transformación de transmisión por secuencias de documentos XML grandes<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.XmlWriter&gt;</ph> that writes to a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Xml.XmlWriter&gt;</ph> que escribe en un <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>It then uses this method to write two XML trees to the writer.</source>
          <target state="translated">A continuación, se usa este método para escribir dos árboles XML en el sistema de escritura.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>This example produces the following output:</source>
          <target state="translated">Este ejemplo produce el siguiente resultado:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>